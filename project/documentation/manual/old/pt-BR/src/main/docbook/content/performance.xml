<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="performance">
    <title>Aumentando a performance</title>

    <sect1 id="performance-fetching" revision="2">
        <title>Estratégias de Fetching</title>

        <para>
            Uma <emphasis>estratégia de fetching</emphasis> é a estratégia que o Hibernate 
            irá usar para buscar objetos associados se a aplicação precisar navegar pela associação. 
            Estratégias de Fetch podem ser declaradas nos metadados de mapeamento O/R, ou sobrescritos 
            por uma query HQL ou query com <literal>Criteria</literal>.
        </para>

        <para>
            Hibernate3 define as seguintes estratégias de fetching:
        </para>

        <itemizedlist>
             <listitem>
                <para>
                    <emphasis>Join fetching</emphasis> - o Hibernate busca o objeto 
                    ou coleção associada no mesmo <literal>SELECT</literal>, usando um 
                    <literal>OUTER JOIN</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>Select fetching</emphasis> - um segundo <literal>SELECT</literal> é 
                    usado para buscar a entidade ou coleção associada. A menos que você desabilite 
                    lazy fetching especificando <literal>lazy="false"</literal>, esse segundo SELECT 
                    será executado apenas quando você acessar a associação.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>Subselect fetching</emphasis> - um segundo <literal>SELECT</literal> será 
                    usado para buscar as coleções associadas de todas as entidades buscadas na query ou 
                    fetch anterior. A menos que você desabilite lazy fetching especificando 
                    <literal>lazy="false"</literal>, esse segundo SELECT será executado apenas quando 
                    você acessar a associação.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>Batch fetching</emphasis> - uma opção de otimização para o Select 
                    Fetching – O Hibernate busca um lote de instâncias ou entidades usando um único 
                    <literal>SELECT</literal>, especificando uma lista de chaves primárias ou chaves 
                    estrangeiras.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>
            O Hibernate distingue também entre:
        </para>

        <itemizedlist>
             <listitem>
                <para>
                    <emphasis>Immediate fetching</emphasis> - uma associação, coleção ou atributo é buscado 
		                como ela é carregada (Qual SQL é usado). Não se confuda com eles! Nós usamos fetch para melhorar a performance. Nós podemos usar lazy para definir um contrato para qual dado é sempre disponível em qualquer instância desanexada de uma classe qualquer.
		                imediatamente, quando o pai é carregado.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>Lazy collection fetching</emphasis> - a coleção é buscada quando a 
                    aplicação invoca uma operação sobre aquela coleção (Esse é o padrão para coleções)
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>"Extra-lazy" collection fetching</emphasis> - elementos individuais de uma 
                    coleção são acessados do banco de dados quando preciso. O Hibernate tenta não buscar 
                    a coleção inteira dentro da memória ao menos que seja absolutamente preciso. 
                    (indicado para coleções muito grandes)
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>Proxy fetching</emphasis> - uma associação de um valor é carregada quando um método 
                    diferente do getter do identificador é invocado sobre o objeto associado.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>"No-proxy" fetching</emphasis> -  uma associação de um valor é carregada quando 
                    a variável da instância é carregada. Comparada com a proxy fetching, esse método é menos 
                    preguiçoso (lazy)(a associação é carregada somente quando o identificador é acessada) 
                    mas é mais transparente, já que não há proxies visíveis para a aplicação. 
                    Esse método requer instrumentação de bytecodes em build-time e é raramente necessário.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>Lazy attribute fetching</emphasis> - um atributo ou associação de um valor é 
                    carregada quanto a varíavel da instância é acessada. Esse método requer instrumentação 
                    de bytecodes em build-time e é raramente necessário.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>
            Nós temos aqui duas noções ortogonais: <emphasis>quando</emphasis> a associação é carregada e 
            <emphasis>como </emphasis> ela é carregada (Qual SQL é usado). Não se confuda com eles! Nós 
            usamos <literal>fetch</literal> para melhorar a performance. Nós podemos usar lazy para 
            definir um contrato para qual dado é sempre disponível em qualquer instância desconectada
            de uma classe qualquer.
        </para>
 
        <sect2 id="performance-fetching-lazy">
            <title>Inicializando coleções e proxies</title>
            
            <para>
                Por padrão, o Hibernate3 usa busca preguiçosa para coleções e busca preguiçosa 
                com proxy para associações de um valor. Esses padrões fazem sentido para quase 
                todas as associações em quase todas a aplicações.
            </para>
            
            <para>
                <emphasis>Veja:</emphasis> se voce setar 
                <literal>hibernate.default_batch_fetch_size</literal>, O Hibernate irá usar otimização
                de carregamento em lote para o carregamento preguiçoso(Essa otimização pode ser também 
                habilitada em um nível mais fino).
            </para>
            
            <para>
                Porém, a busca preguiçosa tem um problema que você precisar saber. Acesso a associações 
                preguiçosas fora do contexto de uma sessão aberta do Hibernate irá resultar numa exceção. 
                Por exemplo:
            </para>
        
            <programlisting><![CDATA[s = sessions.openSession();
Transaction tx = s.beginTransaction();
            
User u = (User) s.createQuery("from User u where u.name=:userName")
    .setString("userName", userName).uniqueResult();
Map permissions = u.getPermissions();

tx.commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!]]></programlisting>

            <para>
                Como a coleção de permissões não foi inicializada quando a <literal>Session</literal> 
                foi fechada, a coleção não poderá carregar o seu estado. O Hibernate não suporta 
                inicialização preguiçosa para objetos desconectados. Para consertar isso, é necessário 
                mover o código que carrega a coleção para antes da transação ser comitada.
            </para>
    
            <para>
                Alternativamente, nós podemos usar uma coleção ou associação não preguiçosa, 
                especificando <literal>lazy="false"</literal> para o mapeamento da associação. 
                Porém, é pretendido que a inicialização preguiçosa seja usada por quase todas as 
                coleções e associações. Se você definir muitas associações não preguiçosas em seu 
                modelo de objetos, o Hibernate irá precisar carregar o banco de dados inteiro na memória 
                em cada transação!
            </para>
    
            <para>
                Por outro lado, nós geralmente escolhemos join fetching (que é não preguiçosa por natureza) 
                ao invés de select fetching em uma transação particular. Nós iremos ver como customizar 
                a estratégoa de busca. No Hibernate3, os mecanismos para escolher a estratégia de fetching 
                são identicos para as associações simples e para coleções.
            </para>
        
        </sect2>
        
        <sect2 id="performance-fetching-custom" revision="4">
            <title>Personalizando as estratégias de busca</title>
            
            <para>
                O select fetching (o padrão) é extremamente vunerável para N+1 problemas em select, 
                então nós iremos querer habilitar o join fetching no documento de mapeamento:
            </para>
            
            <programlisting><![CDATA[<set name="permissions" 
            fetch="join">
    <key column="userId"/>
    <one-to-many class="Permission"/>
</set]]></programlisting>

           <programlisting><![CDATA[<many-to-one name="mother" class="Cat" fetch="join"/>]]></programlisting>

            <para>
                A estratégia de <literal>fetch</literal> definida no documento de mapeamento afeta:
            </para>
            
        <itemizedlist>
             <listitem>
                <para>
                    recupera via <literal>get()</literal> ou <literal>load()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    Recuperações  que acontecem implicitamente quando navegamos por uma associação
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>Criteria</literal> queries
                </para>
            </listitem>
            <listitem>
                <para>
                    buscas por HQL se buscar por <literal>subselect</literal> for usado
                </para>
            </listitem>
        </itemizedlist>

            <para>
                Independentemente da estratégia de busca que você usar, o grafo não preguiçoso definido 
                será garantidamente carregado na memória. Note que isso irá resultar em diversos selects 
                imediatos sendo usados em um HQL em particular.
            </para>

            <para>
                Usualmente não usamos documentos de mapeamento para customizar as buscas. Ao invés disso, 
                nós deixamos o comportamento padrão e sobrescrevemos isso em uma transação em particular, 
                usando <literal>left join fetch</literal> no HQL. Isso diz ao Hibernate para buscar a associação 
                inteira no primeiro select, usando um outer join. Na API de busca <literal>Criteria</literal>, 
                você irá usar <literal>setFetchMode(FetchMode.JOIN)</literal>.
            </para>
            
            <para>
                Se você quiser mudar a estratégia de busca usada pelo <literal>get()</literal> 
                ou <literal>load()</literal>, simplesmente use uma query <literal>Criteria</literal>, 
                por exemplo:
            </para>
            
            <programlisting><![CDATA[User user = (User) session.createCriteria(User.class)
                .setFetchMode("permissions", FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();]]></programlisting>
                
            <para>
                (Isto é o  equivalente do Hibernate para o que algumas soluções ORM chamam de "plano de busca")
            </para>

            <para>
                Um meio totalmente diferente de evitar problemas com selects N+1 é usar um cache de segundo nível.
            </para>

        </sect2>

        <sect2 id="performance-fetching-proxies" revision="2">
            <title>Proxies de associação single-ended</title>

            <para>
                A recuperação preguiçosa para coleções é implementada usando uma implementação 
                própria do Hibernate para coleções persistentes. Porém, um mecanismo diferente é 
                necessário para comportamento preguiçoso para associações de um lado só. A entidade 
                alvo da associação precisa usar um proxy. O Hibernate implementa proxies para inicialização 
                preguiçosa em objetos persistentes usando manipulação de bytecode 
                (via a excelente biblioteca CGLIB).
            </para>

            <para>
                Por padrão, o Hibernate3 gera proxies (na inicialização) para todas as classes 
                persistentes que usem eles para habilitar recuperaçãopreguiçosa de associações 
                <literal>many-to-one</literal> e <literal>one-to-one</literal>.
            </para>

            <para>
                O arquivo de mapeamento deve declaram uma interface para usar como interface de proxy 
                para aquela classe, com o atributo <literal>proxy</literal>. Por padrão, o Hibernate usa 
                uma subclasse dessa classe. <emphasis>Note que a classe a ser usada via proxy precisa 
                implementar o construtor padrão com pelo menos visibilidade de package. Nós recomendamos 
                esse construtor para todas as classes persistentes!</emphasis>
            </para>

            <para>
                Existe alguns truques que você deve saber quando extender esse comportamento para classes 
                polimórficas, dessa maneira:
            </para>

            <programlisting><![CDATA[<class name="Cat" proxy="Cat">
    ......
    <subclass name="DomesticCat">
        .....
    </subclass>
</class>]]></programlisting>

            <para>
                Primeiramente, instâncias de  <literal>Cat</literal> nunca seráo convertidas 
                para <literal>DomesticCat</literal>, mesmo que a instância em questão seja uma 
                estância de <literal>DomesticCat</literal>:
            </para>

            <programlisting><![CDATA[Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}]]></programlisting>

            <para>
                É possível quebrar o proxy <literal>==</literal>.
            </para>

            <programlisting><![CDATA[Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!
System.out.println(cat==dc);                            // false]]></programlisting>

            <para>
                Porém a situação não é tão ruim como parece. Mesmo quando temos duas referências para 
                objetos proxies diferentes, a instância deles será o mesmo objeto
            </para>

            <programlisting><![CDATA[cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0]]></programlisting>

            <para>
                Terceiro, Você não pode usar um proxy CGLIB em uma classe <literal>final</literal>
                ou com qualquer método <literal>final</literal>.
            </para>

            <para>
                Finalmente, se o seu objeto persistente adquirir qualquer recursto durante a instanciação 
                (em inicializadores ou construtor padrão), então esses recursos serão adquiridos pelo proxy 
                também. A classe de proxy é uma subclasse da classe persistente.
            </para>

            <para>
                Esses problemas são todos devido a limitação fundamental do modelo de herança simples do Java. 
                Se você quiser evitar esse problemas em suas classes persistentes você deve imeplementar uma 
                interface que declare seus métodos de negócio. Você deve especificar essas interfaces no arquivo 
                de mapeamento. Ex:
            </para>

            <programlisting><![CDATA[<class name="CatImpl" proxy="Cat">
    ......
    <subclass name="DomesticCatImpl" proxy="DomesticCat">
        .....
    </subclass>
</class>]]></programlisting>

            <para>
                onde <literal>CatImpl</literal> implementa a interface <literal>Cat</literal> e 
                <literal>DomesticCatImpl</literal> implementa a interface <literal>DomesticCat</literal>. 
                Então proxies para instâncias de <literal>Cat</literal> e <literal>DomesticCat</literal> 
                serão retornadas por <literal>load()</literal> ou <literal>iterate()</literal>. 
                (Note que <literal>list()</literal> geralmente não retorna proxies).
            </para>

            <programlisting><![CDATA[Cat cat = (Cat) session.load(CatImpl.class, catid);
Iterator iter = session.createQuery("from CatImpl as cat where cat.name='fritz'").iterate();
Cat fritz = (Cat) iter.next();]]></programlisting>

            <para>
                Relacionamentos são também carregados preguiçosamente. Isso significa que você precisa declarar 
                qualquer propriedade como sendo do tipo <literal>Cat</literal>, e não <literal>CatImpl</literal>.
            </para>

            <para>
                Algumas operações <emphasis>não</emphasis> requerem inicialização por proxy:
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>equals()</literal>, se a classe persistente não sobrescrever 
                        <literal>equals()</literal>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>hashCode()</literal>, se a classe persistente não sobrescrever 
                        <literal>hashCode()</literal>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        O método getter do identificador
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                O Hibernate irá detectar classes persistentes que sobrescrevem 
                <literal>equals()</literal> ou <literal>hashCode()</literal>.
            </para>
            
            <para>
                Escolhendo <literal>lazy="no-proxy"</literal> ao invés do padrão 
                <literal>lazy="proxy"</literal>, podemos evitar problemas associados com typecasting.
                Porém, iremos precisar de instrumentação de bytecode em tempo de compilação e todas 
                as operações irão resultar em iniciazações de proxy imediatas.
	            </para>

        </sect2>

        <sect2 id="performance-fetching-initialization" revision="1">
            <title>Inicializando coleções e proxies</title>

            <para>
                Será lançada uma <literal>LazyInitializationException</literal>  se uma coleção não inicializada 
                ou proxy é acessado fora do escopo da <literal>Session</literal>, isto é, quando a entidade que 
                contém a coleção ou tem a referência ao proxy estiver no estado destachado.
            </para>

            <para>
                Algumas vezes precisamos garantir qie o proxy ou coleção é inicializado antes de se fechar a 
                <literal>Session</literal>. Claro que sempre podemos forçar a inicialização chamando 
                <literal>cat.getSex()</literal> ou <literal>cat.getKittens().size()</literal>, por exemplo. 
                Mas isto parece confuso para quem lê o código e não é conveniente para códigos genéricos.
            </para>

            <para>
                Os métodos estáticos <literal>Hibernate.initialize()</literal> e <literal>Hibernate.isInitialized()</literal> 
                possibilitam a aplicação uma maneira conveniente de trabalhar com coleções inicializadas preguiçosamente e 
                proxies. <literal>Hibernate.initialize(cat)</literal> irá forçar a inicialização de um proxy, 
                <literal>cat</literal>, contanto que a <literal>Session</literal> esteja ainda aberta. 
                <literal>Hibernate.initialize( cat.getKittens() )</literal> tem um efeito similar para a coleção de 
                kittens.
            </para>

            <para>
                Outra opção é manter a <literal>Session</literal> aberta até que todas as coleções e 
                proxies necessários sejam  carregados. Em algumas arquiteturas de aplicações, particularmente 
                onde o código que acessa os dados usando Hibernate e o código que usa os dados estão em diferentes 
                camadas da aplicação ou diferentes processos físicos, será um problema garantir que a 
                <literal>Session</literal> esteja aberta quando uma coleção for inicializada. Existem dois 
                caminhos básicos para lidar com esse problema:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        Em aplicações web, um filtro servlet pode ser usado para fechar a 
                        <literal>Session</literal> somente no final da requisição do usuário, já que a 
                        renderização da visão estará completa (o pattern <emphasis>Open Session In View</emphasis>). 
                        Claro, que isto cria a necessidade de um correto manuseio de exceções na infraestrutura 
                        de sua aplicação. É vitalmente importante que a <literal>Session</literal> esteja fechada 
                        e a transação terminada antes de retornar para o usuário, mesmo que uma exceção ocorra 
                        durante a renderização da view. Veja o Wiki do Hibernate para exemplos do pattern 
                        "Open Session In View"
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Em uma aplicação com uma camada de negócios separada, a lógica de negócios deve 
                        "preparar" todas as coleções que serão usadas pela camada web antes de retornar. 
                        Isto sgnifica que a camada de negócios deve carregar todos os dados e retorná-los 
                        já inicializados para a camada de apresentação. Usualmente a aplicação chama 
                        <literal>Hibernate.initialize()</literal> para cada coleção que será usada pela 
                        camada web (essa chamada de método deve ocorrer antes da sessão ser fechada ou 
                        retornar a coleção usando uma consulta Hibernate com uma cláusula <literal>FETCH</literal>
                        ou um <literal>FetchMode.JOIN</literal> na <literal>Criteria</literal>. Fica muito 
                        mais fácil se você adotar o pattern <emphasis>Command</emphasis> ao invés do 
                        <emphasis>Session Facade</emphasis>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Você também pode anexar um objeto prevaimente carregado em uma nova 
                        <literal>Session</literal> <literal>merge()</literal> or <literal>lock()</literal> 
                        antes de acessar coleções não inicializadas (ou outros proxies). O Hibernate não faz 
                        e certamente <literal>não deve</literal> isso automaticamente pois isso introduziria
                        semantica em transações ad hoc.
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                As vezes você não quer inicializar uma coleção muito grande, mas precisa de algumas 
                informações (como o tamanho) ou alguns de seus dados.
            </para>

            <para>
                Você pode usar um filtro de coleção para saber seu tamanho sem a inicializar:
            </para>

            <programlisting><![CDATA[( (Integer) s.createFilter( collection, "select count(*)" ).list().get(0) ).intValue()]]></programlisting>

            <para>
                O método <literal>createFilter()</literal> é usado também para retornar algus dados de uma
                coleção eficientemente sem precisar inicializar a coleção inteira:
            </para>

            <programlisting><![CDATA[s.createFilter( lazyCollection, "").setFirstResult(0).setMaxResults(10).list();]]></programlisting>

        </sect2>

        <sect2 id="performance-fetching-batch">
            <title>Usando busca em lote</title>

            <para>
                O Hibernate pode fazer uso eficiente de busca em lote, isto é, o Hibernate pode carregar diversos 
                proxies não inicializados se um proxy é acessado (ou coleções. A busca em lote é uma otimização da 
                estratégia de select fetching). Existe duas maneiras em que você pode usar busca em lote: no nível 
                da classe ou no nível da coleção.
            </para>

            <para>
                A recuperação em lote para classes/entidades é mais fácil de entender. Imagine que você tem a seguinte 
                situação em tempo de execução: Você tem 25 instâncias de <literal>Cat</literal> carregadas em uma 
                <literal>Session</literal>, cada <literal>Cat</literal> tem uma referência ao seu <literal>owner</literal>,
                que é da classe <literal>Person</literal>. A classe <literal>Person</literal> é mapeada com um proxy, 
                <literal>lazy="true"</literal>. Se você iterar sobre todos os Cat's e chamar <literal>getOwner()</literal>
                em cada, o Hibernate irá por padrão executar 25 comandos <literal>SELECT()</literal>, para buscar os 
                proxies de owners. Você pode melhorar esse comportamento especificando um <literal>batch-size</literal>
                no mapeamento da classe <literal>Person</literal>:
            </para>

            <programlisting><![CDATA[<class name="Person" batch-size="10">...</class>]]></programlisting>

            <para>
                O Hibernate irá executar agora apenas três consultas, buscando por vez, 10, 10 e 5 Person.
            </para>

            <para>
                Você também pode habilitar busca em lote de uma coleção. Por exemplo, se cada <literal>Person</literal> 
                tem uma coleção preguiçosa de <literal>Cat</literal>s, e 10 pessoas estão já carregados em uma 
                <literal>Sesssion</literal>, serão gerados 10 <literal>SELECT</literal>s ao se iterar todas as 
                pessoas, um para cada chamada de <literal>getCats()</literal>.. Se você habilitar busca em lote 
                para a coleção de <literal>cats</literal> no mapeamento da classe <literal>Person</literal>, 
                o Hibernate pode fazer uma pré carga das coleções:
            </para>

            <programlisting><![CDATA[<class name="Person">
    <set name="cats" batch-size="3">
        ...
    </set>
</class>]]></programlisting>

            <para>
                Com um <literal>batch-size</literal> de 3, o Hibernate irá carregar 3, 3, 3, 1 coleções em 4 
                <literal>SELECT</literal>s. Novamente, o valor do atributo depende do número esperado de coleções 
                não inicialiadas em determinada <literal>Session</literal>.
            </para>

            <para>
                A busca em lote de coleções é particularmente útil quando você tem uma árvore encadeada de 
                items, ex. o típico padrão bill-of-materials (Se bem que um <emphasis>conjunto encadeado</emphasis> 
                ou <emphasis>caminho materializado </emphasis> pode ser uma opção melhor para árvores com mais
                leitura)
            </para>

        </sect2>

        <sect2 id="performance-fetching-subselect">
            <title>Usando subselect fetching</title>

            <para>
                Se uma coleção ou proxy simples precisa ser recuperado, o Hibernate carrega todos eles 
                rodando novamente a query original em um subselect. Isso funciona da mesma maneira que busca 
                em lote, sem carregar tanto.
            </para>
            
            <!-- TODO: Write more about this -->

        </sect2>
        
        <sect2 id="performance-fetching-lazyproperties">
            <title>Usando busca preguiçosa de propriedade</title>

            <para>
                O Hibernate3 suporta a carga posterior de propriedades individuais. Essa técnica de otimização 
                também conhecida como  <emphasis>fetch groups</emphasis>. Veja que isso é mais uma funcionalidade 
                de marketing já que na prática, é mais importante otimização nas leituras dos registros do 
                que na leitura das colunas. Porém, carregar apenas algumas propriedades de uma classe pode 
                ser útil em casos extremos, onde tabelas legadas podem ter centenas de colunas e o modelo 
                de dados não pode ser melhorado.
            </para>

            <para>
                Para habilitar a carga posterior de propriedade, é preciso setar o atributo 
                <literal>lazy</literal> no seu mapeamento de propriedade:
            </para>

            <programlisting><![CDATA[<class name="Document">
       <id name="id">
        <generator class="native"/>
    </id>
    <property name="name" not-null="true" length="50"/>
    <property name="summary" not-null="true" length="200" lazy="true"/>
    <property name="text" not-null="true" length="2000" lazy="true"/>
</class>]]></programlisting>

            <para>
                A carga posterior de propriedades requer instrumentação de bytecode! Se suas classes 
                persistentes não forem melhoradas, o Hibernate irá ignorar silenciosamente essa 
                configuração e usará busca imediatamente.
            </para>

            <para>
                Para instrumentação de bytecode, use a seguinte tarefa do Ant:
            </para>

            <programlisting><![CDATA[<target name="instrument" depends="compile">
    <taskdef name="instrument" classname="org.hibernate.tool.instrument.InstrumentTask">
        <classpath path="${jar.path}"/>
        <classpath path="${classes.dir}"/>
        <classpath refid="lib.class.path"/>
    </taskdef>

    <instrument verbose="true">
        <fileset dir="${testclasses.dir}/org/hibernate/auction/model">
            <include name="*.class"/>
        </fileset>
    </instrument>
</target>]]></programlisting>

            <para>
                A different (better?) way to avoid unnecessary column reads, at least for
                read-only transactions is to use the projection features of HQL or Criteria
                queries. This avoids the need for buildtime bytecode processing and is
                certainly a prefered solution.
            </para>
            
            <para>
                You may force the usual eager fetching of properties using <literal>fetch all
                properties</literal> in HQL.
            </para>

        </sect2>

    </sect1>

    <sect1 id="performance-cache" revision="1">
        <title>The Second Level Cache</title>

        <para>
            A Hibernate <literal>Session</literal> is a transaction-level cache of persistent data. It is
            possible to configure a cluster or JVM-level (<literal>SessionFactory</literal>-level) cache on 
            a class-by-class and collection-by-collection basis. You may even plug in a clustered cache. Be 
            careful. Caches are never aware of changes made to the persistent store by another application 
            (though they may be configured to regularly expire cached data).
        </para>
        
        <para revision="1">
            You have the option to tell Hibernate which caching implementation to use by
            specifying the name of a class that implements <literal>org.hibernate.cache.CacheProvider</literal>
            using the property <literal>hibernate.cache.provider_class</literal>.  Hibernate
            comes bundled with a number of built-in integrations with open-source cache providers
            (listed below); additionally, you could implement your own and plug it in as
            outlined above.  Note that versions prior to 3.2 defaulted to use EhCache as the
            default cache provider; that is no longer the case as of 3.2.
        </para>

        <table frame="topbot" id="cacheproviders" revision="1">
            <title>Cache Providers</title>
            <tgroup cols='5' align='left' colsep='1' rowsep='1'>
            <colspec colname='c1' colwidth="1*"/>
            <colspec colname='c2' colwidth="3*"/>
            <colspec colname='c3' colwidth="1*"/>
            <colspec colname='c4' colwidth="1*"/>
            <colspec colname='c5' colwidth="1*"/>
            <thead>
            <row>
              <entry>Cache</entry>
              <entry>Provider class</entry>
              <entry>Type</entry>
              <entry>Cluster Safe</entry>
              <entry>Query Cache Supported</entry>
            </row>
            </thead>
            <tbody>
            <row>
                <entry>Hashtable (not intended for production use)</entry>
                <entry><literal>org.hibernate.cache.HashtableCacheProvider</literal></entry>
                <entry>memory</entry>
                <entry></entry>
                <entry>yes</entry>
            </row>
            <row>
                <entry>EHCache</entry>
                <entry><literal>org.hibernate.cache.EhCacheProvider</literal></entry>
                <entry>memory, disk</entry>
                <entry></entry>
                <entry>yes</entry>
            </row>
            <row>
                <entry>OSCache</entry>
                <entry><literal>org.hibernate.cache.OSCacheProvider</literal></entry>
                <entry>memory, disk</entry>
                <entry></entry>
                <entry>yes</entry>
            </row>
            <row>
                <entry>SwarmCache</entry>
                <entry><literal>org.hibernate.cache.SwarmCacheProvider</literal></entry>
                <entry>clustered (ip multicast)</entry>
                <entry>yes (clustered invalidation)</entry>
                <entry></entry>
            </row>
            <row>
                <entry>JBoss TreeCache</entry>
                <entry><literal>org.hibernate.cache.TreeCacheProvider</literal></entry>
                <entry>clustered (ip multicast), transactional</entry>
                <entry>yes (replication)</entry>
                <entry>yes (clock sync req.)</entry>
            </row>
            </tbody>
            </tgroup>
        </table>

        <sect2 id="performance-cache-mapping" revision="2">
            <title>Cache mappings</title>

            <para>
                The <literal>&lt;cache&gt;</literal> element of a class or collection mapping has the
                following form:
            </para>

            <programlistingco>
                <areaspec>
                    <area id="cache1" coords="2 70"/>
                    <area id="cache2" coords="3 70"/>
                    <area id="cache3" coords="4 70"/>
                </areaspec>
                <programlisting><![CDATA[<cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"
    region="RegionName"
    include="all|non-lazy"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="cache1">
                        <para>
                            <literal>usage</literal> (required) specifies the caching strategy:
                            <literal>transactional</literal>,
                            <literal>read-write</literal>,
                            <literal>nonstrict-read-write</literal> or
                            <literal>read-only</literal>
                        </para>
                    </callout>                   
                    <callout arearefs="cache2">
                        <para>
                            <literal>region</literal> (optional, defaults to the class or
                            collection role name) specifies the name of the second level cache 
                            region
                        </para>
                    </callout>                   
                    <callout arearefs="cache3">
                        <para>
                            <literal>include</literal> (optional, defaults to <literal>all</literal>) 
                            <literal>non-lazy</literal> specifies that properties of the entity mapped
                            with <literal>lazy="true"</literal> may not be cached when attribute-level
                            lazy fetching is enabled
                        </para>
                    </callout>                   
                </calloutlist>
            </programlistingco>
            
            <para>
                Alternatively (preferrably?), you may specify <literal>&lt;class-cache&gt;</literal> and 
                <literal>&lt;collection-cache&gt;</literal> elements in <literal>hibernate.cfg.xml</literal>.
            </para>
            
            <para>
                The <literal>usage</literal> attribute specifies a <emphasis>cache concurrency strategy</emphasis>.
            </para>

        </sect2>

        <sect2 id="performance-cache-readonly">
            <title>Strategy: read only</title>

            <para>
                If your application needs to read but never modify instances of a persistent class, a 
                <literal>read-only</literal> cache may be used. This is the simplest and best performing
                strategy. It's even perfectly safe for use in a cluster.
            </para>

            <programlisting><![CDATA[<class name="eg.Immutable" mutable="false">
    <cache usage="read-only"/>
    ....
</class>]]></programlisting>

        </sect2>


        <sect2 id="performance-cache-readwrite">
            <title>Strategy: read/write</title>

            <para>
                If the application needs to update data, a <literal>read-write</literal> cache might be appropriate. 
                This cache strategy should never be used if serializable transaction isolation level is required. 
                If the cache is used in a JTA environment, you must specify the property 
                <literal>hibernate.transaction.manager_lookup_class</literal>, naming a strategy for obtaining the 
                JTA <literal>TransactionManager</literal>. In other environments, you should ensure that the transaction 
                is completed when <literal>Session.close()</literal> or <literal>Session.disconnect()</literal> is called. 
                If you wish to use this strategy in a cluster, you should ensure that the underlying cache implementation 
                supports locking. The built-in cache providers do <emphasis>not</emphasis>.
            </para>

            <programlisting><![CDATA[<class name="eg.Cat" .... >
    <cache usage="read-write"/>
    ....
    <set name="kittens" ... >
        <cache usage="read-write"/>
        ....
    </set>
</class>]]></programlisting>

        </sect2>

        <sect2 id="performance-cache-nonstrict">
            <title>Strategy: nonstrict read/write</title>

            <para>
                If the application only occasionally needs to update data (ie. if it is extremely unlikely that two 
                transactions would try to update the same item simultaneously) and strict transaction isolation is
                not required, a <literal>nonstrict-read-write</literal> cache might be appropriate. If the cache is 
                used in a JTA environment, you must specify <literal>hibernate.transaction.manager_lookup_class</literal>. 
                In other environments, you should ensure that the transaction is completed when 
                <literal>Session.close()</literal> or <literal>Session.disconnect()</literal> is called.
            </para>

        </sect2>

        <sect2 id="performance-cache-transactional">
            <title>Strategy: transactional</title>

            <para>
                The <literal>transactional</literal> cache strategy provides support for fully transactional cache
                providers such as JBoss TreeCache. Such a cache may only be used in a JTA environment and you must 
                specify <literal>hibernate.transaction.manager_lookup_class</literal>. 
            </para>

        </sect2>
        
        <para>
            None of the cache providers support all of the cache concurrency strategies. The following table shows
            which providers are compatible with which concurrency strategies.
        </para>

        <table frame="topbot">
            <title>Cache Concurrency Strategy Support</title>
            <tgroup cols='5' align='left' colsep='1' rowsep='1'>
            <colspec colname='c1' colwidth="1*"/>
            <colspec colname='c2' colwidth="1*"/>
            <colspec colname='c3' colwidth="1*"/>
            <colspec colname='c4' colwidth="1*"/>
            <colspec colname='c5' colwidth="1*"/>
            <thead>
            <row>
              <entry>Cache</entry>
              <entry>read-only</entry>
              <entry>nonstrict-read-write</entry>
              <entry>read-write</entry>
              <entry>transactional</entry>
            </row>
            </thead>
            <tbody>
            <row>
                <entry>Hashtable (not intended for production use)</entry>
                <entry>yes</entry>
                <entry>yes</entry>
                <entry>yes</entry>
                <entry></entry>
            </row>
            <row>
                <entry>EHCache</entry>
                <entry>yes</entry>
                <entry>yes</entry>
                <entry>yes</entry>
                <entry></entry>
            </row>
            <row>
                <entry>OSCache</entry>
                <entry>yes</entry>
                <entry>yes</entry>
                <entry>yes</entry>
                <entry></entry>
            </row>
            <row>
                <entry>SwarmCache</entry>
                <entry>yes</entry>
                <entry>yes</entry>
                <entry></entry>
                <entry></entry>
            </row>
            <row>
                <entry>JBoss TreeCache</entry>
                <entry>yes</entry>
                <entry></entry>
                <entry></entry>
                <entry>yes</entry>
            </row>
            </tbody>
            </tgroup>
        </table>

    </sect1>

    <sect1 id="performance-sessioncache" revision="2">
        <title>Managing the caches</title>

        <para>
            Whenever you pass an object to <literal>save()</literal>, <literal>update()</literal>
            or <literal>saveOrUpdate()</literal> and whenever you retrieve an object using 
            <literal>load()</literal>, <literal>get()</literal>, <literal>list()</literal>, 
            <literal>iterate()</literal> or <literal>scroll()</literal>, that object is added 
            to the internal cache of the <literal>Session</literal>. 
        </para>
        <para>
            When <literal>flush()</literal> is subsequently called, the state of that object will 
            be synchronized with the database. If you do not want this synchronization to occur or 
            if you are processing a huge number of objects and need to manage memory efficiently, 
            the <literal>evict()</literal> method may be used to remove the object and its collections 
            from the first-level cache.
        </para>
        
        <programlisting><![CDATA[ScrollableResult cats = sess.createQuery("from Cat as cat").scroll(); //a huge result set
while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0);
    doSomethingWithACat(cat);
    sess.evict(cat);
}]]></programlisting>
        
        <para>
            The <literal>Session</literal> also provides a <literal>contains()</literal> method to determine 
            if an instance belongs to the session cache.
        </para>
        
        <para>
            To completely evict all objects from the session cache, call <literal>Session.clear()</literal>
        </para>
        
        <para>
            For the second-level cache, there are methods defined on <literal>SessionFactory</literal> for 
            evicting the cached state of an instance, entire class, collection instance or entire collection 
            role.
        </para>
        
        <programlisting><![CDATA[sessionFactory.evict(Cat.class, catId); //evict a particular Cat
sessionFactory.evict(Cat.class);  //evict all Cats
sessionFactory.evictCollection("Cat.kittens", catId); //evict a particular collection of kittens
sessionFactory.evictCollection("Cat.kittens"); //evict all kitten collections]]></programlisting>

        <para>
            The <literal>CacheMode</literal> controls how a particular session interacts with the second-level
            cache.
        </para>
        
        <itemizedlist>
        <listitem>
        <para>
            <literal>CacheMode.NORMAL</literal> - read items from and write items to the second-level cache
        </para>
        </listitem>
        <listitem>
        <para>
            <literal>CacheMode.GET</literal> - read items from the second-level cache, but don't write to
            the second-level cache except when updating data
        </para>
        </listitem>
        <listitem>
        <para>
            <literal>CacheMode.PUT</literal> - write items to the second-level cache, but don't read from
            the second-level cache
        </para>
        </listitem>
        <listitem>
        <para>
            <literal>CacheMode.REFRESH</literal> - write items to the second-level cache, but don't read from
            the second-level cache, bypass the effect of <literal>hibernate.cache.use_minimal_puts</literal>, forcing
            a refresh of the second-level cache for all items read from the database
        </para>
        </listitem>
        </itemizedlist>
        
        <para>
            To browse the contents of a second-level or query cache region, use the <literal>Statistics</literal>
            API:
        </para>
        
        <programlisting><![CDATA[Map cacheEntries = sessionFactory.getStatistics()
        .getSecondLevelCacheStatistics(regionName)
        .getEntries();]]></programlisting>
        
        <para>
            You'll need to enable statistics, and, optionally, force Hibernate to keep the cache entries in a
            more human-understandable format:
        </para>
        
        <programlisting><![CDATA[hibernate.generate_statistics true
hibernate.cache.use_structured_entries true]]></programlisting>       
                
    </sect1>
    
    <sect1 id="performance-querycache" revision="1">
        <title>The Query Cache</title>

        <para>
            Query result sets may also be cached. This is only useful for queries that are run
            frequently with the same parameters. To use the query cache you must first enable it:
        </para>

        <programlisting><![CDATA[hibernate.cache.use_query_cache true]]></programlisting>       
        
        <para>
            This setting causes the creation of two new cache regions - one holding cached query 
            result sets (<literal>org.hibernate.cache.StandardQueryCache</literal>), the other 
            holding timestamps of the most recent updates to queryable tables 
            (<literal>org.hibernate.cache.UpdateTimestampsCache</literal>). Note that the query
            cache does not cache the state of the actual entities in the result set; it caches 
            only identifier values and results of value type. So the query cache should always be
            used in conjunction with the second-level cache.
        </para>
        
        <para>
            Most queries do not benefit from caching, so by default queries are not cached. To
            enable caching, call <literal>Query.setCacheable(true)</literal>. This call allows
            the query to look for existing cache results or add its results to the cache when
            it is executed.
        </para>
        
        <para>
            If you require fine-grained control over query cache expiration policies, you may
            specify a named cache region for a particular query by calling 
            <literal>Query.setCacheRegion()</literal>.
        </para>
        
        <programlisting><![CDATA[List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();]]></programlisting>

        <para>
            If the query should force a refresh of its query cache region, you should call
            <literal>Query.setCacheMode(CacheMode.REFRESH)</literal>. This is particularly useful 
            in cases where underlying data may have been updated via a separate process (i.e., 
            not modified through Hibernate) and allows the application to selectively refresh 
            particular query result sets. This is a more efficient alternative to eviction of 
            a query cache region via <literal>SessionFactory.evictQueries()</literal>.
        </para>

    </sect1>

    <sect1 id="performance-collections">
        <title>Understanding Collection performance</title>

        <para>
            We've already spent quite some time talking about collections.
            In this section we will highlight a couple more issues about
            how collections behave at runtime.
        </para>

        <sect2 id="performance-collections-taxonomy">
            <title>Taxonomy</title>

            <para>Hibernate defines three basic kinds of collections:</para>

            <itemizedlist>
            <listitem>
                <para>collections of values</para>
            </listitem>
            <listitem>
                <para>one to many associations</para>
            </listitem>
            <listitem>
                <para>many to many associations</para>
            </listitem>
            </itemizedlist>

            <para>
                This classification distinguishes the various table and foreign key
                relationships but does not tell us quite everything we need to know
                about the relational model. To fully understand the relational structure
                and performance characteristics, we must also consider the structure of
                the primary key that is used by Hibernate to update or delete collection
                rows. This suggests the following classification:
            </para>

            <itemizedlist>
            <listitem>
                <para>indexed collections</para>
            </listitem>
            <listitem>
                <para>sets</para>
            </listitem>
            <listitem>
                <para>bags</para>
            </listitem>
            </itemizedlist>

            <para>
                All indexed collections (maps, lists, arrays) have a primary key consisting
                of the <literal>&lt;key&gt;</literal> and <literal>&lt;index&gt;</literal>
                columns. In this case collection updates are usually extremely efficient -
                the primary key may be efficiently indexed and a particular row may be efficiently
                located when Hibernate tries to update or delete it.
            </para>
                        
            <para>
                Sets have a primary key consisting of <literal>&lt;key&gt;</literal> and element
                columns. This may be less efficient for some types of collection element, particularly
                composite elements or large text or binary fields; the database may not be able to index
                a complex primary key as efficently.  On the other hand, for one to many or many to many
                associations, particularly in the case of synthetic identifiers, it is likely to be just
                as efficient. (Side-note: if you want <literal>SchemaExport</literal> to actually create
                the primary key of a <literal>&lt;set&gt;</literal> for you, you must declare all columns
                as <literal>not-null="true"</literal>.)
            </para>

            <para>
                <literal>&lt;idbag&gt;</literal> mappings define a surrogate key, so they are
                always very efficient to update. In fact, they are the best case.
            </para>
            
            <para>
                Bags are the worst case. Since a bag permits duplicate element values and has no
                index column, no primary key may be defined. Hibernate has no way of distinguishing
                between duplicate rows. Hibernate resolves this problem by completely removing
                (in a single <literal>DELETE</literal>) and recreating the collection whenever it
                changes. This might be very inefficient.
            </para>

            <para>
                Note that for a one-to-many association, the "primary key" may not be the physical
                primary key of the database table - but even in this case, the above classification
                is still useful. (It still reflects how Hibernate "locates" individual rows of the
                collection.)
            </para>

        </sect2>

        <sect2 id="performance-collections-mostefficientupdate">
            <title>Lists, maps, idbags and sets are the most efficient collections to update</title>

            <para>
                From the discussion above, it should be clear that indexed collections
                and (usually) sets allow the most efficient operation in terms of adding,
                removing and updating elements.
            </para>

            <para>
                There is, arguably, one more advantage that indexed collections have over sets for
                many to many associations or collections of values. Because of the structure of a
                <literal>Set</literal>, Hibernate doesn't ever <literal>UPDATE</literal> a row when
                an element is "changed". Changes to a <literal>Set</literal> always work via
                <literal>INSERT</literal> and <literal>DELETE</literal> (of individual rows). Once
                again, this consideration does not apply to one to many associations.
            </para>

            <para>
                After observing that arrays cannot be lazy, we would conclude that lists, maps and 
                idbags are the most performant (non-inverse) collection types, with sets not far 
                behind. Sets are expected to be the most common kind of collection in Hibernate 
                applications. This is because the "set" semantics are most natural in the relational
                model.
            </para>

            <para>
                However, in well-designed Hibernate domain models, we usually see that most collections
                are in fact one-to-many associations with <literal>inverse="true"</literal>. For these
                associations, the update is handled by the many-to-one end of the association, and so
                considerations of collection update performance simply do not apply.
            </para>

        </sect2>

        <sect2 id="performance-collections-mostefficentinverse">
            <title>Bags and lists are the most efficient inverse collections</title>

            <para>
                Just before you ditch bags forever, there is a particular case in which bags (and also lists)
                are much more performant than sets. For a collection with <literal>inverse="true"</literal>
                (the standard bidirectional one-to-many relationship idiom, for example) we can add elements
                to a bag or list without needing to initialize (fetch) the bag elements! This is because
                <literal>Collection.add()</literal> or <literal>Collection.addAll()</literal> must always
                return true for a bag or <literal>List</literal> (unlike a <literal>Set</literal>). This can
                make the following common code much faster.
            </para>

            <programlisting><![CDATA[Parent p = (Parent) sess.load(Parent.class, id);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);  //no need to fetch the collection!
sess.flush();]]></programlisting>

        </sect2>

        <sect2 id="performance-collections-oneshotdelete">
            <title>One shot delete</title>

            <para>
                Occasionally, deleting collection elements one by one can be extremely inefficient. Hibernate
                isn't completely stupid, so it knows not to do that in the case of an newly-empty collection
                (if you called <literal>list.clear()</literal>, for example). In this case, Hibernate will
                issue a single <literal>DELETE</literal> and we are done!
            </para>

            <para>
                Suppose we add a single element to a collection of size twenty and then remove two elements.
                Hibernate will issue one <literal>INSERT</literal> statement and two <literal>DELETE</literal>
                statements (unless the collection is a bag). This is certainly desirable.
            </para>

            <para>
                However, suppose that we remove eighteen elements, leaving two and then add thee new elements.
                There are two possible ways to proceed
            </para>

            <itemizedlist>
            <listitem>
                <para>delete eighteen rows one by one and then insert three rows</para>
            </listitem>
            <listitem>
                <para>remove the whole collection (in one SQL <literal>DELETE</literal>) and insert
                all five current elements (one by one)</para>
            </listitem>
            </itemizedlist>

            <para>
                Hibernate isn't smart enough to know that the second option is probably quicker in this case.
                (And it would probably be undesirable for Hibernate to be that smart; such behaviour might
                confuse database triggers, etc.)
            </para>

            <para>
                Fortunately, you can force this behaviour (ie. the second strategy) at any time by discarding
                (ie. dereferencing) the original collection and returning a newly instantiated collection with
                all the current elements. This can be very useful and powerful from time to time.
            </para>
            
            <para>
                Of course, one-shot-delete does not apply to collections mapped <literal>inverse="true"</literal>.
            </para>

        </sect2>

    </sect1>

    <sect1 id="performance-monitoring" revision="1">
        <title>Monitoring performance</title>

        <para>
            Optimization is not much use without monitoring and access to performance numbers.
            Hibernate provides a full range of figures about its internal operations.
            Statistics in Hibernate are available per <literal>SessionFactory</literal>.
        </para>

        <sect2 id="performance-monitoring-sf" revision="2">
            <title>Monitoring a SessionFactory</title>

            <para>
                You can access <literal>SessionFactory</literal> metrics in two ways.
                Your first option is to call <literal>sessionFactory.getStatistics()</literal> and
                read or display the <literal>Statistics</literal> yourself.
            </para>

            <para>
                Hibernate can also use JMX to publish metrics if you enable the
                <literal>StatisticsService</literal> MBean. You may enable a single MBean for all your
                <literal>SessionFactory</literal> or one per factory. See the following code for
                minimalistic configuration examples:
            </para>

            <programlisting><![CDATA[// MBean service registration for a specific SessionFactory
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "myFinancialApp");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory
server.registerMBean(stats, on); // Register the Mbean on the server]]></programlisting>


<programlisting><![CDATA[// MBean service registration for all SessionFactory's
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "all");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
server.registerMBean(stats, on); // Register the MBean on the server]]></programlisting>

            <para>
                TODO: This doesn't make sense: In the first case, we retrieve and use the MBean directly. In the second one, we must give
                the JNDI name in which the session factory is held before using it. Use
                <literal>hibernateStatsBean.setSessionFactoryJNDIName("my/JNDI/Name")</literal>
            </para>
            <para>
                You can (de)activate the monitoring for a <literal>SessionFactory</literal>
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        at configuration time, set <literal>hibernate.generate_statistics</literal> to <literal>false</literal>
                    </para>
                </listitem>
            </itemizedlist>
            <itemizedlist>
                <listitem>
                    <para>
                        at runtime: <literal>sf.getStatistics().setStatisticsEnabled(true)</literal>
                        or <literal>hibernateStatsBean.setStatisticsEnabled(true)</literal>
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Statistics can be reset programatically using the <literal>clear()</literal> method.
                A summary can be sent to a logger (info level) using the <literal>logSummary()</literal>
                method.
            </para>

        </sect2>

        <sect2 id="performance-monitoring-metrics" revision="1">
            <title>Metrics</title>

            <para>
                Hibernate provides a number of metrics, from very basic to the specialized information
                only relevant in certain scenarios. All available counters are described in the
                <literal>Statistics</literal> interface API, in three categories:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Metrics related to the general <literal>Session</literal> usage, such as
                        number of open sessions, retrieved JDBC connections, etc.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Metrics related to he entities, collections, queries, and caches as a
                        whole (aka global metrics),
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Detailed metrics related to a particular entity, collection, query or
                        cache region.
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                For exampl,e you can check the cache hit, miss, and put ratio of entities, collections
                and queries, and the average time a query needs. Beware that the number of milliseconds
                is subject to approximation in Java. Hibernate is tied to the JVM precision, on some
                platforms this might even only be accurate to 10 seconds.
            </para>

            <para>
                Simple getters are used to access the global metrics (i.e. not tied to a particular entity,
                collection, cache region, etc.). You can access the metrics of a particular entity, collection
                or cache region through its name, and through its HQL or SQL representation for queries. Please
                refer to the <literal>Statistics</literal>, <literal>EntityStatistics</literal>,
                <literal>CollectionStatistics</literal>, <literal>SecondLevelCacheStatistics</literal>,
                and <literal>QueryStatistics</literal> API Javadoc for more information. The following
                code shows a simple example:
            </para>

            <programlisting><![CDATA[Statistics stats = HibernateUtil.sessionFactory.getStatistics();

double queryCacheHitCount  = stats.getQueryCacheHitCount();
double queryCacheMissCount = stats.getQueryCacheMissCount();
double queryCacheHitRatio =
  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);

log.info("Query Hit ratio:" + queryCacheHitRatio);

EntityStatistics entityStats =
  stats.getEntityStatistics( Cat.class.getName() );
long changes =
        entityStats.getInsertCount()
        + entityStats.getUpdateCount()
        + entityStats.getDeleteCount();
log.info(Cat.class.getName() + " changed " + changes + "times"  );]]></programlisting>

            <para>
                To work on all entities, collections, queries and region caches, you can retrieve
                the list of names of entities, collections, queries and region caches with the
                following methods: <literal>getQueries()</literal>, <literal>getEntityNames()</literal>,
                <literal>getCollectionRoleNames()</literal>, and
                <literal>getSecondLevelCacheRegionNames()</literal>.
            </para>

        </sect2>

    </sect1>

</chapter>
