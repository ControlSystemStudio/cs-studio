<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="objectstate">
    <title>Trabalhando com objetos</title>

    <para>
        O Hibernate é uma solução completa de mapeamento objeto/relacional que não apenas 
        poupa o desenvolvedor dos detalhes de baixo nível do sistema de gerenciamento do 
        banco de dados, mas também oferece um <emphasis>gerenciamento de estado </emphasis>
        para objetos. Isto é, ao contrário do gerenciamento de  <literal>instruções </literal>
        SQL em camadas de persistência JDBC/SQL comuns, uma visão natural da persistência 
        orientada a objetos em aplicações Java.
    </para>

    <para>
        Em outras palavras, desenvolvedores de aplicações Hibernate podem sempre pensar em 
        relação ao <emphasis>estado</emphasis> de seus objetos, e não necessariamente em 
        relação a execução de instruções SQL. Este parte é responsabilidade do Hibernate e 
        é relevante aos desenvolvedores de aplicações apenas quando estão ajustando 
        a performance do sistema.
    </para>

    <sect1 id="objectstate-overview">
        <title>Estado dos objetos no Hibernate</title>

        <para>
            O Hibernate define e suporta os seguintes estados de um objetos:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <emphasis>Transient</emphasis> - um objeto é transiente se ele foi instanciando 
                    usando apenas o operador <literal>new</literal>, e não foi associado com uma 
                    <literal>Session</literal> do Hibernate. Ele não terá uma representação 
                    persistente no banco de dados e nenhum identificador será atribuído para ele. 
                    Instâncias transientes serão destruídas pelo coletor de lixo se a aplicação 
                    não manter sua referência. Use uma <literal>Session</literal> do Hibernate 
                    para tornar o objeto persistente ( e deixe o Hibernate gerenciar as 
                    instruções SQL que serão necessárias para executar esta transição).
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>Persistent</emphasis> -– uma instância persistente possui uma 
                    representação no banco de dados e um identificador. Ele pode ter sido salvo 
                    ou carregado, assim, ele está por definição no escopo de uma 
                    <literal>Session</literal>. O Hibernate irá detectar qualquer mudança feita a 
                    um objeto persistente e sincronizar o seu estado com o banco de dados quando 
                    completar a unidade de trabalho. Desenvolvedores não executam instruções manuais 
                    de <literal>UPDATE</literal>, ou instruções de  <literal>DELETE</literal> 
                    quando o objeto deve ser passado para transiente.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>Detached</emphasis> – uma instância desaclopada é um objeto que 
                    foi persistido, mas sua <literal>Session</literal> foi fechada. A referência 
                    ao objeto continua válida, é claro, e  a instância destacada desaclopada pode 
                    ser acoplada a uma nova <literal>Session</literal> no futuro, fazendo-o 
                    ( e todas as modificações sofridas) persistente novamente. Essa característica 
                    possibilita um modelo de programação para unidades de trabalho que rodam 
                    durante muito tempo que requer um pensamento por tempo do usuário. Podemos 
                    chamar-las de <emphasis>transações da aplicação</emphasis>, i.e. uma unidade 
                    de trabalho do ponto de vista do usuário.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Agora iremos discutir os estados e suas transições ( e os métodos do Hibernate que 
            disparam uma transição) em mais detalhes.
        </para>

    </sect1>

    <sect1 id="objectstate-makingpersistent" revision="1">
        <title>Tornando os objetos persistentes</title>

        <para>
            Instâncias recentemente instanciadas de uma classe persistente são 
            consideradas <emphasis>transientes </emphasis> pelo Hibernate.
            Podemos tornar uma instância transiente em  <emphasis>persistente</emphasis>
            associando-a a uma sessão:            
        </para>

        <programlisting><![CDATA[DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);]]></programlisting>

        <para>
            Se <literal>Cat</literal> possui um identificador gerado, o identificador 
            é gerado e atribuído a <literal>cat</literal> quando <literal>save()</literal> 
            for chamada. Se <literal>Cat</literal> possuir um identificador 
            <literal>Associado</literal>, ou uma chave composta, o identificador deve ser 
            atribuído à instância de <literal>cat</literal> antes que <literal>save()</literal> 
            seja chamado. Pode-se usar também  <literal>persist()</literal> ao invés de 
             <literal>save()</literal>, com a semântica definada no novo esboço do EJB3.
        </para>
        
	<itemizedlist spacing="compact">
		<listitem>
			<para>
				<literal>persist()</literal> makes a transient instance persistent. 
				However, it doesn't guarantee that the identifier value will be assigned to 
				the persistent instance immediately, the assignment might happen at flush time. 
				<literal>persist()</literal> also guarantees that it will not execute an 
				<literal>INSERT</literal> statement if it is called outside of transaction 
				boundaries. This is useful in long-running conversations with an extended 
				Session/persistence context.
			</para>
		</listitem>
		<listitem>
			<para>
				<literal>save()</literal> does guarantee to return an identifier. If an INSERT 
				has to be executed to get the identifier ( e.g. "identity" generator, not 
				"sequence"), this INSERT happens immediately, no matter if you are inside or 
				outside of a transaction. This is problematic in a long-running conversation  
				with an extended Session/persistence context.
			</para>
		</listitem>
        </itemizedlist>        	
        <para>
            Alternativamente, pode-se atribuir o identificador usando uma versão 
            sobrecarregada de <literal>save()</literal>.
        </para>

<programlisting><![CDATA[DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );]]></programlisting>
        
        <para>
            Se o objeto persistido possuir objetos associados (e.g. a coleção 
            <literal>kittens</literal> no exemplo anterior), esses objetos podem ser 
            tornar persistente em qualquer ordem que se queira ao menos que se tenha uma 
            restrição <literal>NOT NULL</literal> em uma coluna de chave estrangeira. 
            Nunca há risco de violação de restrições de chave estrangeira. Assim, 
            pode-se violar uma restrição <literal>NOT NULL</literal> se 
            <literal>save()</literal> for usada nos objetos em uma ordem errada.
        </para>
        
        <para>
            Geralmente você não deve se importar com esses detalhes, muito provavelmente se 
            usará a característica de <emphasis>persistência transitiva </emphasis> do Hibernate 
            para salvar os objetos associados automaticamente. Então, enquanto uma restrição 
            <literal>NOT NULL</literal> não ocorrer – Hibernate tomará conta de tudo. 
            Persistência transitiva será discutida futuramente nesse capítulo.
        </para>
        
    </sect1>

    <sect1 id="objectstate-loading">
        <title>Carregando o objetos</title>

        <para>
            O método <literal>load()</literal> de uma <literal> Session</literal> nos 
            fornece um meio para recuperar uma instância persistente se o identificador 
            for conhecido. <literal>load()</literal> recebe uma classe do objeto e carregará
            o estado em uma instância mais recente dessa classe, no estado persistente.             
        </para>

        <programlisting><![CDATA[Cat fritz = (Cat) sess.load(Cat.class, generatedId);]]></programlisting>

<programlisting><![CDATA[// you need to wrap primitive identifiers
long id = 1234;
DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );]]></programlisting>

        <para>
            Alternatively, you can load state into a given instance:
Alternativamente, pode-se carregar um estado em uma instância dada:
        </para>

<programlisting><![CDATA[Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();]]></programlisting>

        <para>
            Repare que <literal>load()</literal> irá lançar uma exceção irrecuperável 
            se não houver na tabela no banco de dados um registro que combine. 
            Se a classe for mapeada com um proxy, <literal>load()</literal> 
            simplesmente retorna um proxy não inicializado e realmente não chamará 
            o banco de dados até que um método do proxy seja invocado. 
            Esse comportamento é muito útil se deseja-se criar uma associação 
            com um objeto sem que realmente o carregue do bando de dados. 
            Isto também permite que sejam carregadas múltiplas instâncias como um 
            grupo se <literal>batch-size</literal> estiver para o mapeamento da 
            classe.
        </para>
        
        <para>
            Se você não tiver certeza da existencia do registro no banco, você deve
            usar o metodo <literal>get()</literal>, que consulta o banco 
            imediantamente e retorna um null se não existir o registro.
        </para>
        
        <programlisting><![CDATA[Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;]]></programlisting>

        <para>
            Também pode-se carregar um objeto usando <literal>SELECT ... FOR UPDATE</literal>, 
            usando um <literal>LockMode</literal>. Veja a documentação da API para maiores 
            informações.
        </para>

        <programlisting><![CDATA[Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);]]></programlisting>
        
        <para>
            Note that any associated instances or contained collections are 
            <emphasis>not</emphasis> selected <literal>FOR UPDATE</literal>, unless you decide
            to specify <literal>lock</literal> or <literal>all</literal> as a
            cascade style for the association.
       </para>
        
        <para>
            O recarregamento de um objeto e todas as suas coleções é possível a qualquer momento, 
            usando o método <literal>refresh()</literal>. Util quando as triggers do banco de 
            dados  são usados para inicializar algumas propriedades do objeto.
        </para>
        
        <programlisting><![CDATA[sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)]]></programlisting>

        <para>
            Uma importante questão geralmente aparece neste ponto: O quanto Hibernate carrega 
            do banco de dados e quantos SQL  <literal>SELECT</literal> ele irá usar? Isto 
            depende da estratégia de <emphasis>recuperação</emphasis>usada e explicada na 
            <xref linkend="performance-fetching"/>.
        </para>

    </sect1>

    <sect1 id="objectstate-querying" revision="1">
        <title>Consultando</title>

        <para>
            Se o identificador do objeto que se está buscando não for conhecido, 
            uma consulta será necessária. O Hibernate suporta uma linguagem de consulta 
            (HQL) orientada a objetos fácil mas poderosa. Para criação via programação 
            de consultas, o Hibernate suporta características sofisticadas de consulta 
            por Critério e Exemplo (QBCe QBE). Pode-se também expressar a consulta 
            por meio de SQL nativa do banco de dados, com suporte opcional do Hibernate 
            para conversão do conjunto de reultados em objetos.
        </para>

        <sect2 id="objectstate-querying-executing" revision="1">
            <title>Executando consultas</title>

            <para>
                Consultas HQL e SQL nativa são representadas por uma instância de <literal>org.hibernate.Query</literal>.
                Esta interface oferece métodos para associação de parâmetros, tratamento de conjunto de resultados, 
                e para a execução de consultas reais. Você pode obter uma <literal>Query</literal> usando a 
                <literal>Session</literal> atual:
            </para>

        <programlisting><![CDATA[List cats = session.createQuery(
    "from Cat as cat where cat.birthdate < ?")
    .setDate(0, date)
    .list();

List mothers = session.createQuery(
    "select mother from Cat as cat join cat.mother as mother where cat.name = ?")
    .setString(0, name)
    .list();

List kittens = session.createQuery(
    "from Cat as cat where cat.mother = ?")
    .setEntity(0, pk)
    .list();

Cat mother = (Cat) session.createQuery(
    "select cat.mother from Cat as cat where cat = ?")
    .setEntity(0, izi)
    .uniqueResult();]]

Query mothersWithKittens = (Cat) session.createQuery(
    "select mother from Cat as mother left join fetch mother.kittens");
Set uniqueMothers = new HashSet(mothersWithKittens.list());]]></programlisting>

            <para>
                Geralmente uma consulta é executada ao invocar <literal>list()</literal>, 
                o resultado da consulta será carregado completamente em uma coleção na memória. 
                Instâncias de entidades recuperadas por uma consulta estão no estado persistente. 
                O <literal>uniqueResult()</literal> oferece um atalho se você souber de 
                previamente que a consulta retornará apenas um único objeto. Repare que consultas 
                que fazem uso de buscas de coleções de forma ansiosa (eager) geralmente retornam 
                duplicatas dos objetos raiz ( mas com suas coleções inicializadas ). Pode-se 
                filtrar estas duplicatas através de um simples <literal>Set</literal>.
            </para>

            <sect3 id="objectstate-querying-executing-iterate">
                <title>Interagindo com resultados</title>

                <para>
                    Ocasionalmente, deves-se ser capaz de atingir performances melhores com 
                    a execução de consultas usando o método <literal>iterate()</literal>. 
                    Geralmente isso será o caso esperado apenas se as instâncias dos entidades 
                    reais retornadas pela consulta já estiverem na sessão ou no caché de segundo 
                    nível. Caso elas ainda não tenham sido armazenadas,  <literal>iterate()</literal> 
                    será mais devagar do que <literal>list()</literal> e pode ser necessário vários 
                    acessos ao banco de dados para um simples consulta, geralmente  <emphasis>1</emphasis>
                    para a seleção inicial que retorna apenas identificadores, e <emphasis>n</emphasis>
                    consultas adicionais para inicializar as instâncias reais.
                </para>

                <programlisting><![CDATA[// fetch ids
Iterator iter = sess.createQuery("from eg.Qux q order by q.likeliness").iterate();
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // fetch the object
    // something we couldnt express in the query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // delete the current instance
        iter.remove();
        // dont need to process the rest
        break;
    }
}]]></programlisting>
            </sect3>
            
            <sect3 id="objectstate-querying-executing-tuples">
                <title>Consultas que retornam tuplas</title>

                <para>
                    Algumas vezes as consultas do Hibernate retornam tuplas de objetos, nesse caso 
                    cada tupla é retornada como um array:                    
                </para>

                <programlisting><![CDATA[Iterator kittensAndMothers = sess.createQuery(
            "select kitten, mother from Cat kitten join kitten.mother mother")
            .list()
            .iterator();

while ( kittensAndMothers.hasNext() ) {
    Object[] tuple = (Object[]) kittensAndMothers.next();
    Cat kitten = (Cat) tuple[0];
    Cat mother = (Cat) tuple[1];
    ....
}]]></programlisting>

            </sect3>

            <sect3 id="objectstate-querying-executing-scalar" revision="1">
                <title>Resultados escalares</title>

                <para>
                    Consultas devem especificar uma propriedade da classe na clausula 
                    <literal>select</literal>. Elas também podem chamar funções SQL  de agregaçãos. 
                    Propriedades ou agregações são considerados resultados agregados 
                    ( e não entidades no estado persistente).
                </para>

                <programlisting><![CDATA[Iterator results = sess.createQuery(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color")
        .list()
        .iterator();

while ( results.hasNext() ) {
    Object[] row = (Object[]) results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}]]></programlisting>

            </sect3>

            <sect3 id="objectstate-querying-executing-parameters">
                <title>Bind parameters</title>

                <para>
                    Methods on <literal>Query</literal> are provided for binding values to
                    named parameters or JDBC-style <literal>?</literal> parameters. 
                    <emphasis>Contrary to JDBC, Hibernate numbers parameters from zero.</emphasis>
                    Named parameters are identifiers of the form <literal>:name</literal> in 
                    the query string. The advantages of named parameters are:
                </para>

                <itemizedlist spacing="compact">
                    <listitem>
                        <para>
                            named parameters are insensitive to the order they occur in the
                            query string
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            they may occur multiple times in the same query
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            they are self-documenting
                        </para>
                    </listitem>
                </itemizedlist>

                <programlisting><![CDATA[//named parameter (preferred)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();]]></programlisting>

                <programlisting><![CDATA[//positional parameter
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();]]></programlisting>

                <programlisting><![CDATA[//named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();]]></programlisting>

            </sect3>

            <sect3 id="objectstate-querying-executing-pagination">
                <title>Pagination</title>

                <para>
                    If you need to specify bounds upon your result set (the maximum number of rows
                    you want to retrieve and / or the first row you want to retrieve) you should
                    use methods of the <literal>Query</literal> interface:
                </para>

                <programlisting><![CDATA[Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();]]></programlisting>

                <para>
                    Hibernate knows how to translate this limit query into the native
                    SQL of your DBMS.
                </para>

            </sect3>

            <sect3 id="objectstate-querying-executing-scrolling">
                <title>Scrollable iteration</title>

                <para>
                    If your JDBC driver supports scrollable <literal>ResultSet</literal>s, the
                    <literal>Query</literal> interface may be used to obtain a
                    <literal>ScrollableResults</literal> object, which allows flexible
                    navigation of the query results.
                </para>

                <programlisting><![CDATA[Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // find the first name on each page of an alphabetical list of cats by name
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Now get the first page of cats
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE > i++ ) && cats.next() ) pageOfCats.add( cats.get(1) );

}
cats.close()]]></programlisting>

                <para>
                    Note that an open database connection (and cursor) is required for this
                    functionality, use <literal>setMaxResult()</literal>/<literal>setFirstResult()</literal>
                    if you need offline pagination functionality.
                </para>

            </sect3>

            <sect3 id="objectstate-querying-executing-named" revision="1">
                <title>Externalizing named queries</title>

                <para>
                    You may also define named queries in the mapping document. (Remember to use a
                    <literal>CDATA</literal> section if your query contains characters that could
                    be interpreted as markup.)
                </para>

                <programlisting><![CDATA[<query name="ByNameAndMaximumWeight"><![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight > ?
] ]></query>]]></programlisting>

                <para>
                    Parameter binding and executing is done programatically:
                </para>

                <programlisting><![CDATA[Query q = sess.getNamedQuery("ByNameAndMaximumWeight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();]]></programlisting>

                <para>
                    Note that the actual program code is independent of the query language that
                    is used, you may also define native SQL queries in metadata, or migrate
                    existing queries to Hibernate by placing them in mapping files.
                </para>

                <para>
                    Also note that a query declaration inside a <literal>&lt;hibernate-mapping&gt;</literal>
                    element requires a global unique name for the query, while a query declaration inside a
                    <literal>&lt;class&gt;</literal> element is made unique automatically by prepending the
                    fully qualified name of the class, for example
                    <literal>eg.Cat.ByNameAndMaximumWeight</literal>.
                </para>

            </sect3>

        </sect2>

        <sect2 id="objectstate-filtering" revision="1">
            <title>Filtering collections</title>
            <para>
                A collection <emphasis>filter</emphasis> is a special type of query that may be applied to
                a persistent collection or array. The query string may refer to <literal>this</literal>,
                meaning the current collection element.
            </para>

            <programlisting><![CDATA[Collection blackKittens = session.createFilter(
    pk.getKittens(), 
    "where this.color = ?")
    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )
    .list()
);]]></programlisting>
        
            <para>
                The returned collection is considered a bag, and it's a copy of the given
                collection. The original collection is not modified (this is contrary to
                the implication of the name "filter", but consistent with expected behavior).
            </para>

            <para>
                Observe that filters do not require a <literal>from</literal> clause (though they may have
                one if required). Filters are not limited to returning the collection elements themselves.
            </para>

            <programlisting><![CDATA[Collection blackKittenMates = session.createFilter(
    pk.getKittens(), 
    "select this.mate where this.color = eg.Color.BLACK.intValue")
    .list();]]></programlisting>

            <para>
                Even an empty filter query is useful, e.g. to load a subset of elements in a
                huge collection:
            </para>

            <programlisting><![CDATA[Collection tenKittens = session.createFilter(
    mother.getKittens(), "")
    .setFirstResult(0).setMaxResults(10)
    .list();]]></programlisting>

        </sect2>

        <sect2 id="objecstate-querying-criteria" revision="1">
           <title>Criteria queries</title>

            <para>
                HQL is extremely powerful but some developers prefer to build queries dynamically,
                using an object-oriented API, rather than building query strings. Hibernate provides
                an intuitive <literal>Criteria</literal> query API for these cases:
            </para>

            <programlisting><![CDATA[Criteria crit = session.createCriteria(Cat.class);
crit.add( Restrictions.eq( "color", eg.Color.BLACK ) );
crit.setMaxResults(10);
List cats = crit.list();]]></programlisting>
    
            <para>
                The <literal>Criteria</literal> and the associated <literal>Example</literal>
                API are discussed in more detail in <xref linkend="querycriteria"/>.
            </para>

        </sect2>

        <sect2 id="objectstate-querying-nativesql" revision="2">
            <title>Queries in native SQL</title>

            <para>
                You may express a query in SQL, using <literal>createSQLQuery()</literal> and
                let Hibernate take care of the mapping from result sets to objects. Note
                that you may at any time call <literal>session.connection()</literal> and
                use the JDBC <literal>Connection</literal> directly. If you chose to use the
                Hibernate API, you must enclose SQL aliases in braces:
            </para>

            <programlisting><![CDATA[List cats = session.createSQLQuery("SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM<10")
    .addEntity("cat", Cat.class)
.list();]]></programlisting>
                
            <programlisting><![CDATA[List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM<10")
    .addEntity("cat", Cat.class)
.list()]]></programlisting>

            <para>
                SQL queries may contain named and positional parameters, just like Hibernate queries.
                More information about native SQL queries in Hibernate can be found in
                <xref linkend="querysql"/>.
            </para>

        </sect2>

    </sect1>

    <sect1 id="objectstate-modifying" revision="1">
        <title>Modifying persistent objects</title>

        <para>
            <emphasis>Transactional persistent instances</emphasis> (ie. objects loaded, saved, created or
            queried by the <literal>Session</literal>) may be manipulated by the application
            and any changes to persistent state will be persisted when the <literal>Session</literal>
            is <emphasis>flushed</emphasis> (discussed later in this chapter). There is no need
            to call a particular method (like <literal>update()</literal>, which has a different
            purpose) to make your modifications persistent. So the most straightforward way to update
            the state of an object is to <literal>load()</literal> it,
            and then manipulate it directly, while the <literal>Session</literal> is open:
        </para>

        <programlisting><![CDATA[DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // changes to cat are automatically detected and persisted]]></programlisting>

        <para>
            Sometimes this programming model is inefficient since it would require both an SQL
            <literal>SELECT</literal> (to load an object) and an SQL <literal>UPDATE</literal>
            (to persist its updated state) in the same session. Therefore Hibernate offers an
            alternate approach, using detached instances.
        </para>

        <para>
            <emphasis>Note that Hibernate does not offer its own API for direct execution of
            <literal>UPDATE</literal> or <literal>DELETE</literal> statements. Hibernate is a
            <emphasis>state management</emphasis> service, you don't have to think in
            <emphasis>statements</emphasis> to use it. JDBC is a perfect API for executing
            SQL statements, you can get a JDBC <literal>Connection</literal> at any time
            by calling <literal>session.connection()</literal>. Furthermore, the notion
            of mass operations conflicts with object/relational mapping for online
            transaction processing-oriented applications. Future versions of Hibernate
            may however provide special mass operation functions. See <xref linkend="batch"/>
            for some possible batch operation tricks.</emphasis>
        </para>

    </sect1>

    <sect1 id="objectstate-detached" revision="2">
        <title>Modifying detached objects</title>

        <para>
            Many applications need to retrieve an object in one transaction, send it to the
            UI layer for manipulation, then save the changes in a new transaction.
            Applications that use this kind of approach in a high-concurrency environment
            usually use versioned  data to ensure isolation for the "long" unit of work.
        </para>

        <para>
            Hibernate supports this model by providing for reattachment of detached instances
            using the <literal>Session.update()</literal> or <literal>Session.merge()</literal>
            methods:
        </para>

        <programlisting><![CDATA[// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in a higher layer of the application
cat.setMate(potentialMate);

// later, in a new session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate]]></programlisting>

        <para>
            If the <literal>Cat</literal> with identifier <literal>catId</literal> had already
            been loaded  by <literal>secondSession</literal> when the application tried to
            reattach it, an exception would have been thrown.
        </para>

        <para>
            Use <literal>update()</literal> if you are sure that the session does
            not contain an already persistent instance with the same identifier, and
            <literal>merge()</literal> if you want to merge your modifications at any time
            without consideration of the state of the session. In other words, <literal>update()</literal>
            is usually the first method you would call in a fresh session, ensuring that
            reattachment of your detached instances is the first operation that is executed.
        </para>

        <para>
            The application should individually <literal>update()</literal> detached instances
            reachable from the given detached instance if and <emphasis>only</emphasis> if it wants
            their state also updated. This can be automated of course, using <emphasis>transitive
            persistence</emphasis>, see <xref linkend="objectstate-transitive"/>.
        </para>

        <para>
            The <literal>lock()</literal> method also allows an application to reassociate
            an object with a new session. However, the detached instance has to be unmodified!
        </para>

        <programlisting><![CDATA[//just reassociate:
sess.lock(fritz, LockMode.NONE);
//do a version check, then reassociate:
sess.lock(izi, LockMode.READ);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.lock(pk, LockMode.UPGRADE);]]></programlisting>

        <para>
            Note that <literal>lock()</literal> can be used with various
            <literal>LockMode</literal>s, see the API documentation and the
            chapter on transaction handling for more information. Reattachment is not
            the only usecase for <literal>lock()</literal>.
        </para>

        <para>
            Other models for long units of work are discussed in <xref linkend="transactions-optimistic"/>.
        </para>

    </sect1>

    <sect1 id="objectstate-saveorupdate">
        <title>Automatic state detection</title>

        <para>
            Hibernate users have requested a general purpose method that either saves a
            transient instance by generating a new identifier or updates/reattaches
            the detached instances associated with its current identifier.
            The <literal>saveOrUpdate()</literal> method implements this functionality.
        </para>

        <programlisting><![CDATA[// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.setMate(mate);

// later, in a new session
secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)]]></programlisting>

        <para>
            The usage and semantics of <literal>saveOrUpdate()</literal> seems to be confusing
            for new users. Firstly, so long as you are not trying to use instances from one session
            in another new session, you should not need to use <literal>update()</literal>,
            <literal>saveOrUpdate()</literal>, or <literal>merge()</literal>. Some whole
            applications will never use either of these methods.
        </para>

        <para>
            Usually <literal>update()</literal> or <literal>saveOrUpdate()</literal> are used in
            the following scenario:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    the application loads an object in the first session
                </para>
            </listitem>
            <listitem>
                <para>
                    the object is passed up to the UI tier
                </para>
            </listitem>
            <listitem>
                <para>
                    some modifications are made to the object
                </para>
            </listitem>
            <listitem>
                <para>
                    the object is passed back down to the business logic tier
                </para>
            </listitem>
            <listitem>
                <para>
                    the application persists these modifications by calling
                    <literal>update()</literal> in a second session
                </para>
            </listitem>
        </itemizedlist>

        <para>
            <literal>saveOrUpdate()</literal> does the following:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    if the object is already persistent in this session, do nothing
                </para>
            </listitem>
            <listitem>
                <para>
                    if another object associated with the session has the same identifier, 
                    throw an exception
                </para>
            </listitem>
            <listitem>
                <para>
                    if the object has no identifier property, <literal>save()</literal> it
                </para>
            </listitem>
            <listitem>
                <para>
                    if the object's identifier has the value assigned to a newly instantiated
                    object, <literal>save()</literal> it
                </para>
            </listitem>
            <listitem>
                <para>
                    if the object is versioned (by a <literal>&lt;version&gt;</literal> or
                    <literal>&lt;timestamp&gt;</literal>), and the version property value
                    is the same value assigned to a newly instantiated object, 
                    <literal>save()</literal> it
                </para>
            </listitem>
            <listitem>
                <para>
                    otherwise <literal>update()</literal> the object
                </para>
            </listitem>
        </itemizedlist>

        <para>
            and <literal>merge()</literal> is very different:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    if there is a persistent instance with the same identifier currently 
                    associated with the session, copy the state of the given object onto 
                    the persistent instance
                </para>
            </listitem>
            <listitem>
                <para>
                    if there is no persistent instance currently associated with the session, 
                    try to load it from the database, or create a new persistent instance
                </para>
            </listitem>
            <listitem>
                <para>
                    the persistent instance is returned
                </para>
            </listitem>
            <listitem>
                <para>
                    the given instance does not become associated with the session, it
                    remains detached
                </para>
            </listitem>
        </itemizedlist>

    </sect1>

    <sect1 id="objectstate-deleting" revision="1">
        <title>Deleting persistent objects</title>

        <para>
            <literal>Session.delete()</literal> will remove an object's state from the database.
            Of course, your application might still hold a reference to a deleted object.
            It's best to think of <literal>delete()</literal> as making a persistent instance
            transient.
        </para>

        <programlisting><![CDATA[sess.delete(cat);]]></programlisting>

        <para>
            You may delete objects in any order you like, without risk of foreign key
            constraint violations. It is still possible to violate a <literal>NOT
            NULL</literal> constraint on a foreign key column by deleting objects in
            the wrong order, e.g. if you delete the parent, but forget to delete the
            children.
        </para>

    </sect1>
    
    <sect1 id="objectstate-replicating" revision="1">
    	<title>Replicating object between two different datastores</title>
    	
    	<para>
    	    It is occasionally useful to be able to take a graph of persistent instances
    	    and make them persistent in a different datastore, without regenerating identifier
    	    values.
    	</para>
    	
        <programlisting><![CDATA[//retrieve a cat from one database
Session session1 = factory1.openSession();
Transaction tx1 = session1.beginTransaction();
Cat cat = session1.get(Cat.class, catId);
tx1.commit();
session1.close();

//reconcile with a second database
Session session2 = factory2.openSession();
Transaction tx2 = session2.beginTransaction();
session2.replicate(cat, ReplicationMode.LATEST_VERSION);
tx2.commit();
session2.close();]]></programlisting>

        <para>
            The <literal>ReplicationMode</literal> determines how <literal>replicate()</literal>
            will deal with conflicts with existing rows in the database.
        </para>
        
        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>ReplicationMode.IGNORE</literal> - ignore the object when there is
                    an existing database row with the same identifier
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>ReplicationMode.OVERWRITE</literal> - overwrite any existing database 
                    row with the same identifier
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>ReplicationMode.EXCEPTION</literal> - throw an exception if there is
                    an existing database row with the same identifier
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>ReplicationMode.LATEST_VERSION</literal> - overwrite the row if its
                    version number is earlier than the version number of the object, or ignore
                    the object otherwise
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Usecases for this feature include reconciling data entered into different database
            instances, upgrading system configuration information during product upgrades,
            rolling back changes made during non-ACID transactions and more.
        </para>
    	
    </sect1>

    <sect1 id="objectstate-flushing">
        <title>Flushing the Session</title>

        <para>
            From time to time the <literal>Session</literal> will execute the SQL statements 
            needed to synchronize the JDBC connection's state with the state of objects held in 
            memory. This process, <emphasis>flush</emphasis>, occurs by default at the following 
            points
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    before some query executions
                </para>
            </listitem>
            <listitem>
                <para>
                    from <literal>org.hibernate.Transaction.commit()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    from <literal>Session.flush()</literal>
                </para>
            </listitem>
        </itemizedlist>

        <para>
            The SQL statements are issued in the following order
        </para>

        <orderedlist spacing="compact">
            <listitem>
                <para>
                    all entity insertions, in the same order the corresponding objects
                    were saved using <literal>Session.save()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    all entity updates
                </para>
            </listitem>
            <listitem>
                <para>
                    all collection deletions
                </para>
            </listitem>
            <listitem>
                <para>
                    all collection element deletions, updates and insertions
                </para>
            </listitem>
            <listitem>
                <para>
                    all collection insertions
                </para>
            </listitem>
            <listitem>
                <para>
                    all entity deletions, in the same order the corresponding objects
                    were deleted using <literal>Session.delete()</literal>
                </para>
            </listitem>
        </orderedlist>

        <para>
            (An exception is that objects using <literal>native</literal> ID generation are 
            inserted when they are saved.)
        </para>

        <para>
            Except when you explicity <literal>flush()</literal>, there are absolutely no 
            guarantees about <emphasis>when</emphasis> the <literal>Session</literal> executes 
            the JDBC calls, only the <emphasis>order</emphasis> in which they are executed.
            However, Hibernate does guarantee that the <literal>Query.list(..)</literal> 
            will never return stale data; nor will they return the wrong data.
        </para>

        <para>
            It is possible to change the default behavior so that flush occurs less frequently.
            The <literal>FlushMode</literal> class defines three different modes: only flush
            at commit time (and only when the Hibernate <literal>Transaction</literal> API
            is used), flush automatically using the explained routine, or never flush unless
            <literal>flush()</literal> is called explicitly. The last mode is useful for long running
            units of work, where a <literal>Session</literal> is kept open and disconnected for
            a long time (see <xref linkend="transactions-optimistic-longsession"/>).
        </para>

        <programlisting><![CDATA[sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state

Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);

// might return stale data
sess.find("from Cat as cat left outer join cat.kittens kitten");

// change to izi is not flushed!
...
tx.commit(); // flush occurs
sess.close();]]></programlisting>

        <para>
            During flush, an exception might occur (e.g. if a DML operation violates a constraint).
            Since handling exceptions involves some understanding of Hibernate's transactional 
            behavior, we discuss it in <xref linkend="transactions"/>.
        </para>

    </sect1>

    <sect1 id="objectstate-transitive" revision="1">
        <title>Transitive persistence</title>

        <para>
            It is quite cumbersome to save, delete, or reattach individual objects,
            especially if you deal with a graph of associated objects. A common case is
            a parent/child relationship. Consider the following example:
        </para>

        <para>
            If the children in a parent/child relationship would be value typed (e.g. a collection
            of addresses or strings), their life cycle would depend on the parent and no
            further action would be required for convenient "cascading" of state changes.
            When the parent is saved, the value-typed child objects are saved as
            well, when the parent is deleted, the children will be deleted, etc. This
            even works for operations such as the removal of a child from the collection;
            Hibernate will detect this and, since value-typed objects can't have shared
            references, delete the child from the database.
        </para>

        <para>
            Now consider the same scenario with parent and child objects being entities,
            not value-types (e.g. categories and items, or parent and child cats). Entities
            have their own life cycle, support shared references (so removing an entity from
            the collection does not mean it can be deleted), and there is by default no
            cascading of state from one entity to any other associated entities. Hibernate
            does not implement <emphasis>persistence by reachability</emphasis> by default.
        </para>

        <para>
            For each basic operation of the Hibernate session - including <literal>persist(), merge(),
            saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</literal> - there is a 
            corresponding cascade style. Respectively, the cascade styles are named <literal>create, 
            merge, save-update, delete, lock, refresh, evict, replicate</literal>. If you want an 
            operation to be cascaded along an association, you must indicate that in the mapping
            document. For example:
        </para>
        
        <programlisting><![CDATA[<one-to-one name="person" cascade="persist"/>]]></programlisting>
        
        <para>
            Cascade styles my be combined:
        </para>
        
        <programlisting><![CDATA[<one-to-one name="person" cascade="persist,delete,lock"/>]]></programlisting>
        
        <para>
            You may even use <literal>cascade="all"</literal> to specify that <emphasis>all</emphasis>
            operations should be cascaded along the association. The default <literal>cascade="none"</literal>
            specifies that no operations are to be cascaded.
        </para>
        
        <para>
            A special cascade style, <literal>delete-orphan</literal>, applies only to one-to-many
            associations, and indicates that the <literal>delete()</literal> operation should
            be applied to any child object that is removed from the association.
        </para>


        <para>
            Recommendations:
        </para>

       <itemizedlist spacing="compact">
            <listitem>
                <para>
                    It doesn't usually make sense to enable cascade on a <literal>&lt;many-to-one&gt;</literal>
                    or <literal>&lt;many-to-many&gt;</literal> association. Cascade is often useful for 
                    <literal>&lt;one-to-one&gt;</literal> and <literal>&lt;one-to-many&gt;</literal>
                    associations.
                </para>
            </listitem>
            <listitem>
                <para>
                    If the child object's lifespan is bounded by the lifespan of the parent
                    object, make it a <emphasis>life cycle object</emphasis> by specifying
                    <literal>cascade="all,delete-orphan"</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Otherwise, you might not need cascade at all. But if you think that you will often be
                    working with the parent and children together in the same transaction, and you want to save 
                    yourself some typing, consider using <literal>cascade="persist,merge,save-update"</literal>.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Mapping an association (either a single valued association, or a collection) with 
            <literal>cascade="all"</literal> marks the association as a 
            <emphasis>parent/child</emphasis> style relationship where save/update/delete of the 
            parent results in save/update/delete of the child or children.
        </para>
        <para>
            Futhermore, a mere reference to a child from a persistent parent will result in 
            save/update of the child. This metaphor is incomplete, however. A child which becomes 
            unreferenced by its parent is <emphasis>not</emphasis> automatically deleted, except 
            in the case of a <literal>&lt;one-to-many&gt;</literal> association mapped with
            <literal>cascade="delete-orphan"</literal>. The precise semantics of cascading 
            operations for a parent/child relationship are as follows:
        </para>

       <itemizedlist spacing="compact">
            <listitem>
                <para>
                    If a parent is passed to <literal>persist()</literal>, all children are passed to 
                    <literal>persist()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    If a parent is passed to <literal>merge()</literal>, all children are passed to 
                    <literal>merge()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    If a parent is passed to <literal>save()</literal>, <literal>update()</literal> or 
                    <literal>saveOrUpdate()</literal>, all children are passed to <literal>saveOrUpdate()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    If a transient or detached child becomes referenced by a persistent parent, 
                    it is passed to <literal>saveOrUpdate()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    If a parent is deleted, all children are passed to <literal>delete()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    If a child is dereferenced by a persistent parent, <emphasis>nothing
                    special happens</emphasis> - the application should explicitly delete 
                    the child if necessary - unless <literal>cascade="delete-orphan"</literal>, 
                    in which case the "orphaned" child is deleted.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Finally, note that cascading of operations can be applied to an object graph at
            <emphasis>call time</emphasis> or at <emphasis>flush time</emphasis>. All operations,
            if enabled, are cascaded to associated entities reachable when the operation is
            executed. However, <literal>save-upate</literal> and <literal>delete-orphan</literal>
            are transitive for all associated entities reachable during flush of the
            <literal>Session</literal>.
        </para>

    </sect1>

    <sect1 id="objectstate-metadata">
        <title>Usando metadados</title>

        <para>
            O Hibernate requer um modelo muito rico a nível de metadados de todas as entidades e tipos de 
            valores. De tempos em tempos, este modelo é muito útil à própria aplicação. Por exemplo, a 
            aplicação pode usar o metadados do Hibernate que executa um algoritmo "inteligente" que 
            compreende quais objetos podem ser copiados (por exemplo, tipos de valores mutáveis) ou 
            não (por exemplo, tipos de valores imutáveis e, possivelmente, entidades associadas).            
        </para>
        <para>
            O Hibernate expõe o metadados via interfaces <literal>ClassMetadata</literal>
            e <literal>CollectionMetadata</literal> e pela hierarquia <literal>Type</literal>. 
            Instâncias das interfaces de metadados podem ser obtidas a partir do 
            <literal>SessionFactory</literal>.
        </para>

        <programlisting><![CDATA[Cat fritz = ......;
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);

Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();

// get a Map of all properties which are not collections or associations
Map namedValues = new HashMap();
for ( int i=0; i<propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() && !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}]]></programlisting>
        
    </sect1>

</chapter>

