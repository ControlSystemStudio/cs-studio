<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="transactions" revision="2">
    <title>トランザクションと並行性</title>

    <para>
        Hibernateと同時実行制御について最も重要な点は、容易に理解できることです。
        Hibernateは新たなロックの振る舞いを追加しておらず、直接JDBCコネクションとJTAリソースを使用します。
        JDBC、ANSI、およびデータベース管理システム（DBMS）のトランザクション分離の仕様を
        少し時間をかけて勉強することを強く推奨します。
    </para>

    <para>
        Hibernateはメモリ内のオブジェクトをロックしません。
        アプリケーションは、データベーストランザクションの分離レベルで
        定義した振る舞いを期待できます。
        トランザクションスコープのキャッシュでもある <literal>Session</literal> のお陰で、
        識別子やクエリにより検索したエンティティはリピータブルリードになります
        （スカラー値を返すようなレポートクエリは違います）。
    </para>

    <para>
        バージョニングによる自動的な楽観的同時実行制御に加えて、
        <literal>SELECT FOR UPDATE</literal> 文を使用して、
        行を悲観的ロックするための（マイナーな）APIも提供します。
        楽観的同時実行制御とこのAPIについては、この章の後のほうで議論します。
    </para>

    <para>
        データベーストランザクションや長い対話（conversation、ロングトランザクション）だけでなく、
        <literal>Configuration</literal>、<literal>SessionFactory</literal>、および
        <literal>Session</literal>
        という粒度でHibernateが行う同時実行制御の議論を始めます。
    </para>

    <sect1 id="transactions-basics" revision="1">
        <title>sessionスコープとtransactionスコープ</title>

        <para>
            <literal>SessionFactory</literal> は生成することが高価で、
            スレッドセーフなオブジェクトです。
            よって、アプリケーションのすべてのスレッドで共有すべきです。
            通常、アプリケーションの起動時に、
            <literal>Configuration</literal> インスタンスから１度だけ生成します。
        </para>

        <para>
            <literal>Session</literal> は高価ではなく、スレッドセーフなオブジェクトでもありません。
            よって、１つの要求や１つの対話、１つの作業単位（unit of work）に対して１度だけ使い、
            その後で捨てるべきです。
            <literal>Session</literal> は必要になるまで、
            JDBC <literal>Connection</literal>（もしくは <literal>DataSource</literal>）を獲得しません。
            ゆえに、実際に使用するときまでリソースを消費しません。
        </para>

        <para>
            この状況を完了させるために、 データベーストランザクションについても考えなければなりません。
            データベース内のロックの競合を少なくするために、
            データベーストランザクションは可能な限り短くするべきです。
            長いデータベーストランザクションは、アプリケーションの高い並列実行性を阻害します。
            ゆえに、ユーザーが考えている間（作業単位が完了するまで）データベーストランザクションを
            開いたままにするのは、たいていの場合よい設計とはいえません。
        </para>

        <para>
            作業単位というスコープとは何でしょうか？
            １つのHibernate <literal>Session</literal> は、
            いくつかのデータベーストランザクションをまたがることができるでしょうか？
            または、スコープと一対一の関係でしょうか？
            いつ <literal>Session</literal> を開き、閉じるべきでしょうか？
            そして、データベーストランザクション境界をどのように分けるのでしょうか？
        </para>

        <sect2 id="transactions-basics-uow" revision="1">
            <title>作業単位（Unit of work）</title>

            <para>
                １つ目は、<emphasis>session-per-operation</emphasis> アンチパターンを使ってはいけません。
                すなわち、１つのスレッドの中で、単純なデータベース呼び出しのたびに
                <literal>Session</literal> を開いて、閉じてはいけません！
                もちろん、データベーストランザクションについても同様です。
                アプリケーション中のデータベース呼び出しは、
                計画されたシーケンス（planned sequence）を使い、
                アトミックな作業単位に分類されます。
                （１つのSQL文ごとにコミットする自動コミットが、
                使われないという意味でもあることに注意してください。
                自動コミットは、SQLコンソールでアドホックな作業をする際に使うものです。
                Hibernateは直ちに自動コミットモードを無効にします。
                もしくは、アプリケーションサーバーが無効化することを期待します。）
                データベーストランザクションはオプションではありません。
                データベースとのすべての通信は、データの読み込みであっても、書き込みであっても、
                トランザクションの中で行わなければなりません。
                説明すると、データ読み込みに対して、自動コミットは避けるべきです。
                なぜなら、多数の小さなトランザクションは、明確に定義された１つの作業単位と比べて、
                パフォーマンスがよくなることはありません。
                後者は保守性や拡張性もよりすぐれています。
            </para>

            <para>
                マルチユーザーのクライアント／サーバーアプリケーションの中で、
                最もよく使われるパターンは、<emphasis>session-per-request</emphasis> です。
                このモデルの中では、
                クライアントから（Hibernate永続化層が動作する）サーバーへリクエストが送られ、
                新しいHibernate <literal>Session</literal> が開かれます。
                そして、この作業単位の中ですべてのデータベース処理が実行されます。
                作業が完了した（そして、クライアントへのレスポンスが準備できた）時点で、
                session をフラッシュし、閉じます。
                クライアントの要求を処理するために、１つのデータベーストランザクションを使用するでしょう。
                <literal>Session</literal> を開き、閉じる際に、
                データベーストランザクションを開始し、コミットします。
                二つの関係は一対一です。
                このモデルは多くのアプリケーションに完全に適合します。
            </para>



            <para>
                以降の実装にチャレンジしてください。
                Hibernateは単純なこのパターンのために、予め組み込まれた
                「current session」の管理を提供します。
                サーバーリクエストを処理する際はトランザクションを開始しなければなりません。
                そして、レスポンスをクライアントに送信する前にトランザクションを終わらせます。
                好きな方法で実現できます。一般的な解決策は <literal>ServletFilter</literal> や
                サービスメソッドをポイントカットしてAOPインターセプター、
                proxy/interception コンテナです。
                EJBコンテナはEJBセッションビーンをトランザクション境界として
                アスペクトをクロスカットする実装の標準的な方法です（CMTによる宣言的）。
                プログラムによるトランザクション境界を使うと決めた場合、
                簡単に使うため、互換性のあるコードにするために、
                この章の後のほうにあるHibernate <literal>Transaction</literal> APIのほうがよいです。
            </para>

            <para>
                アプリケーションのコードは、必要なときにどこでも、何回でも、
                単に <literal>sessionFactory.getCurrentSession()</literal> を呼び出すだけで
                「現在のセッション」にアクセスできます。
                現在のデータベーストランザクションへの <literal>セッション</literal> を常に取得します。
                リソース・ローカルな環境、もしくはJTA環境を構成しなければなりません
                （<xref linkend="architecture-current-session"/> を参照してください）。
            </para>

            <para>
                ときどき、「ビューを描画する」まで <literal>セッション</literal>
                とデータベーストランザクションのスコープを拡張すると便利なことがあります。
                これは、要求の処理と描画のフェーズを分けている
                サーブレットアプリケーションにおいて特に役立ちます。
                独自のインターセプタを実装すれば、
                ビューを描画するまでデータベーストランザクションを拡張するのは簡単です。
                しかし、コンテナ管理トランザクションのEJBに頼る場合は、簡単にはできません。
                なぜなら、ビューの描画を開始する前に、EJBのメソッドがリターンした際に、
                トランザクションが完了するためです。
                この <emphasis>Open Session in View</emphasis> パターンに関連するヒントと例については、
                HibernateのWebサイトやフォーラムを参照してください。
             </para>

        </sect2>

        <sect2 id="transactions-basics-apptx" revision="1">
            <title>長い対話</title>

            <para>
                session-per-requestパターンは、作業単位を設計する際に役立つ考えというだけではありません。
                多くのビジネスプロセスは、ユーザーとの一連の相互作用全体を要求します。
                その相互作用には、データベースアクセスが含まれます。
                
                Webとエンタープライズアプリケーションでは、データベーストランザクションが
                ユーザとの相互作用にまで渡ることは許されません。
                
                次の例をよく考えてみてください。
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        ダイアログの最初の画面が開き、個々の <literal>Session</literal>
                        とデータベーストランザクションの中でロードされたデータをユーザーに見せます。
                        ユーザーはオブジェクトを自由に修正できます。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        5分後にユーザーは「Save」をクリックし、修正が永続化されるのを期待します。
                        また、この情報を編集したのは自分１人だけで、
                        修正のコンフリクトは発生しないと期待します。
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                この作業単位を（ユーザーの視点で）長期の <emphasis>対話</emphasis>
                （もしくは、<emphasis>アプリケーショントランザクション</emphasis> ）と呼びます。
                アプリケーションにこれを実装する方法はたくさんあります。
            </para>

            <para>
                最初に思いつく実装は、ユーザーが考えている間、<literal>Session</literal>
                とデータベーストランザクションを開いたままにしておくことです。
                同時に修正されず、分離と原子性が保証されるように、
                データベース内のロックは保持したままにします。
                もちろん、これはアンチパターンです。
                なぜなら、ロックの競合が発生すると、
                アプリケーションが同時ユーザー数に応じてスケールアップできなくなるからです。
            </para>

            <para>
                明らかに、対話を実装するためには、
                いくつかのデータベーストランザクションを使用するべきです。
                この場合、ビジネスプロセスの分離を維持することは、
                アプリケーション層の責務の１つになります。
                １つの対話は、
                通常いくつかのデータベーストランザクションに及びます。
                データベーストランザクションの１つのみ（最後の１つ）が更新したデータを保存し、
                他はデータを読むだけであれば、それはアトミックです
                （例えば、いくつかの要求／応答を繰り返すウィザード形式のダイアログ）。
                これは聞くより、実装したほうが簡単です。
                Hibernateの機能を使うのであれば、特に簡単です。
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>自動バージョニング</emphasis>
                        - Hibernateは自動的に楽観的同時実行制御ができます。
                        ユーザーが考えている間に同時に修正がおきた場合、自動的に検出できます。
                        通常、対話の終了時にチェックするだけです。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>分離（Detached）オブジェクト</emphasis> - すでに議論した
                        <emphasis>session-per-request</emphasis> パターンを使うと決定した場合、
                        ロードされたすべてのインスタンスは、ユーザが考えている間は、
                        セッションから分離された状態になります。
                        オブジェクトをセッションに再追加し、修正を永続化できます。
                        これを <emphasis>session-per-request-with-detached-objects</emphasis>
                        パターンと呼びます。
                        自動バージョニングを使うことで、同時に行われる修正を分離できます。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>拡張（もしくは、長い）セッション</emphasis>
                        - Hibernateの <literal>Session</literal> は、
                        データベーストランザクションをコミットした後、
                        裏で結びついているJDBCコネクションを切断できます。
                        そして、クライアントからの新しい要求が発生した際に、再接続できます。
                        このパターンは、<emphasis>session-per-conversation</emphasis>
                        という名で知られており、オブジェクトをセッションへ再追加することさえ不要にします。
                        自動バージョニングを使うことで、同時に行われる修正を分離できます。
                        
                        通常 <literal>Session</literal> を自動的にフラッシュさせず、
                        明示的にフラッシュします。
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                <emphasis>session-per-request-with-detached-objects</emphasis> と
                <emphasis>session-per-conversation</emphasis> の２つは、
                利点と欠点を持っています。
                これについては、この章の後のほうで、楽観的同時実行制御の文脈の中で議論します。
            </para>

        </sect2>

        <sect2 id="transactions-basics-identity">
            <title>オブジェクト識別子を考える</title>

            <para>
                アプリケーションは、２つの異なる <literal>Session</literal> から
                同じ永続状態に同時にアクセスできます。
                しかし、２つの <literal>Session</literal> インスタンスが
                永続性クラスの１つのインスタンスを共有することはできません。
                ゆえに、識別子には２つの異なる概念があるということになります。
            </para>

            <variablelist spacing="compact">
                <varlistentry>
                    <term>データベース識別子</term>
                    <listitem>
                        <para>
                            <literal>foo.getId().equals( bar.getId() )</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>JVM識別子</term>
                    <listitem>
                        <para>
                            <literal>foo==bar</literal>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                <emphasis>個々の</emphasis> <literal>Session</literal> に追加されたオブジェクトにとって
                （すなわち、１つの <literal>Session</literal> のスコープの中では）、２つの概念は同じです。
                データベース同一性とJVM同一性が一致することを、Hibernateが保証します。
                しかし、アプリケーションが２つの異なるセッションから
                「同じ」（永続性識別子の）ビジネスオブジェクトに同時にアクセスする限り、
                ２つのインスタンスは実際に（JVM識別子が）「異なり」ます。
                楽観的アプローチによって、（自動バージョニングの）フラッシュ／コミット時に
                コンフリクトが解決されます。
            </para>

            <para>
                このアプローチでは、Hibernateとデータベースに同時実行についての心配が残ります。
                一方で、最高のスケーラビリティが提供されます。
                なぜなら、１スレッドの作業単位の中で一意性が保証されれば、
                高価なロックや同期化が不要になるためです。
                <literal>Session</literal> ごとに１つのスレッドを貼り付ける限り、
                アプリケーションはビジネスオブジェクトをsynchronizeする必要はありません。
                <literal>Session</literal> 内では、アプリケーションはオブジェクトを比較するために、
                <literal>==</literal> を安全に使用できます。
            </para>

            <para>
                けれども、<literal>Session</literal> の外で <literal>==</literal>
                を使うアプリケーションは、予期しない結果に遭遇します。
                これは予期しない場所で起こりえます。
                例えば、２つの分離インスタンスを同じ <literal>Set</literal> に
                putしたときなどです。
                両方とも同じデータベース識別子を持ちます（すなわち、同じ行を表します）。
                しかし、分離状態のインスタンスのJVM識別子は当然保証されません。
                開発者は、永続性クラスの <literal>equals()</literal> と <literal>hashCode()</literal>
                メソッドをオーバーライドし、オブジェクト等価性の概念を実装すべきです。
                警告が１つあります。等価性の実装にデータベース識別子を使わないでください。
                ユニークな（普通は不変の）属性の組み合わせであるビジネスキーを使ってください。
                もし、一時オブジェクトが永続化された場合、データベース識別子が変わります。
                一時オブジェクトを（通常分離インスタンスと共に） <literal>Set</literal>
                に保持する場合、ハッシュコードが変わるということは、<literal>Set</literal>
                の契約を破るということです。
                ビジネスキーのための属性は、データベースの主キーほど安定すべきではないです。
                オブジェクトが同じ <literal>Set</literal> の中にいる間だけ、安定を保証すべきです。
                この問題のより徹底的な議論は、HibernateのWebサイトを参照してください。
                また、これはHibernateの問題ではなく、単にJavaオブジェクトの識別子や等価性を
                どのように実装すべきかということです。
            </para>

        </sect2>

        <sect2 id="transactions-basics-issues">
            <title>一般的な問題</title>

             <para>
                 <emphasis>session-per-user-session</emphasis> と
                 <emphasis>session-per-application</emphasis> アンチパターン
                 は使ってはいけません（もちろん、まれに例外があります）。
                 注意：下記の問題のいくつかは、推奨されるパターンとしても出現します。
                 設計を決定する前に、裏の意味を理解するようにしてください。
             </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <literal>Session</literal> はスレッドセーフではありません。
                        HTTPリクエスト、セッションBean、Swingワーカーのように、
                        同時実行が可能なものが <literal>Session</literal> インスタンスを共有すると、
                        競合状態を引き起こします。
                        （後で議論する）<literal>HttpSession</literal> の中で
                        Hibernate <literal>Session</literal> を保持する場合、
                        HttpSessionへのアクセスを同期化することを考慮すべきです。
                        さもなければ、ユーザーが十分早くリロードをクリックすると、
                        同時に走る２つのスレッドの中で、同じ <literal>Session</literal> が使われます。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Hibernateが例外を投げた場合は、データベーストランザクションをロールバックし、
                        直ちに <literal>Session</literal> を閉じるべきです（詳細を後で議論します）。
                        <literal>Session</literal> がアプリケーションに結び付けられているのであれば、
                        アプリケーションを停止すべきです。
                        データベーストランザクションをロールバックしても、ビジネスオブジェクトは
                        トランザクションを開始したときの状態に戻りません。
                        これは、データベースの状態とビジネスオブジェクトは同期していないことを意味します。
                        通常これは問題になりません。
                        なぜなら、例外は回復できないからです。
                        とにかくロールバックした後にやり直すべきです。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>Session</literal> は永続（persistent）状態のすべてのオブジェクトを
                        キャッシュします（Hibernateは監視し、ダーティ状態かチェックします）。
                        これは、長い間セッションを開いたままにするか、
                        非常に多くのデータをロードし続けるかした場合は、
                        OutOfMemoryExceptionが発生するまで無限に大きくなることを意味します。
                        解決策の１つは、<literal>Session</literal> キャッシュを管理するために、
                        <literal>clear()</literal> か <literal>evict()</literal> を呼ぶことです。
                        しかし、大きなデータを処理する必要があるなら、
                        たぶんストアドプロシージャを考慮するべきでしょう。
                        いくつかの解決策は、<xref linkend="batch"/> で紹介されています。
                        ユーザーセッションの間、<literal>Session</literal> を開いたままにするということは、
                        データが新鮮でなくなる確率が高くなることを意味します。
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

    </sect1>

    <sect1 id="transactions-demarcation">
        <title>データベーストランザクション境界</title>

        <para>
            データベース（もしくはシステム）トランザクションの境界は、常に必要です。
            データベーストランザクションの外で、データベースとの通信は起きません
            （これは自動コミットモードに慣れている多くの開発者を混乱させるかもしれません）。
            読み込むだけの操作にでも、いつも明確なトランザクション境界を使用してください。
            分離レベルとデータベースの能力次第で、これは必要ないかもしれませんが、
            常にトランザクション境界を明示的に指定しても、マイナス面は全くありません。
            
            確かに、１つのデータベーストランザクションは多数の小さなトランザクションより
            （データの読み込みであっても）パフォーマンスがすぐれています。
        </para>

        <para>
            J2EE環境に管理されていない状態
            （すなわち、スタンドアロン、単純なWebやSwingアプリケーション）でも、
            管理された状態でも、Hibernateアプリケーションを実行できます。
            管理されていない環境では、Hiberanteがデータベースのコネクションプールを提供します。
            アプリケーション開発者は、トランザクション境界を手動で設定しなければなりません。
            言い換えると、データベーストランザクションの開始、コミット、ロールバックを
            開発者自身が設定する必要があるということです。
            
            通常、管理された環境では、コンテナ管理によるトランザクション（CMT）が提供されます。
            例えば、セッションBeanのデプロイメントディスクリプタで宣言的に定義し、
            トランザクションを組み立てます。
            プログラムによるトランザクション境界はもう必要ありません。
        </para>

        <para>
            しかしながら、管理されていないリソース・ローカルな環境と
            JTAに依存したシステム（CMTではなくBMT）の両方に、
            永続化層をポータブルに保つのは、しばしば望ましいことです。
            
            デプロイ環境のネイティブのトランザクションシステムを呼び出す
            <literal>Transaction</literal> というラッパーAPIをHibernateが提供します。
            このAPIを使うかは任意ですが、CMTのセッションBeanを使わないのであれば、使うことを強く推奨します。
        </para>

        <para>
            通常、<literal>Session</literal> 終了は、４つの異なるフェーズを含みます。
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    セッションのフラッシュ
                </para>
            </listitem>
            <listitem>
                <para>
                    トランザクションのコミット
                </para>
            </listitem>
            <listitem>
                <para>
                    セッションのクローズ
                </para>
            </listitem>
            <listitem>
                <para>
                    例外のハンドリング
                </para>
            </listitem>
        </itemizedlist>

        <para>
            セッションのフラッシュについては、前のほうですでに議論しました。
            管理された環境と管理されていない環境の両方について、
            トランザクション境界と例外ハンドリングをもっと詳しく見ていきましょう。
        </para>


        <sect2 id="transactions-demarcation-nonmanaged" revision="2">
            <title>管理されていない環境</title>

            <para>
                Hibernate永続化層を管理されていない環境で実装する場合は、
                
                通常単純なコネクションプール（すなわちDataSourceではない）によって、
                データベースコネクションを制御します。
                Hibernateはそのコネクションプールから必要なコネクションを取得します。
                
                セッション／トランザクション制御のイディオムは次のようになります。
            </para>

            <programlisting><![CDATA[// Non-managed environment idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}]]></programlisting>

            <para>
                明示的に <literal>Session</literal> の <literal>flush()</literal> を呼び出すべきではなく、
                <literal>commit()</literal> を呼び出すことにより、自動的に同期化処理が実行されます
                （セッションの <xref linkend="objectstate-flushing">FlushMode</xref> に依存している）。
                
                <literal>close()</literal> を呼び出すことにより、セッションの終わりを明確にします。
                <literal>close()</literal> が暗黙的に行う主なことは、
                セッションがJDBCコネクションを開放することです。
                
                上記のJavaコードはポータブルであり、管理されていない環境とJTA環境の両方で実行できます。
            </para>

           <para>
                より適応性のある解決策は、Hibernateに予め組み込まれている
                「current session」コンテキスト管理です。
                言葉で説明するより下記を見たほうが速いでしょう。
            </para>

            <programlisting><![CDATA[// Non-managed environment idiom with getCurrentSession()
try {
    factory.getCurrentSession().beginTransaction();

    // do some work
    ...

    factory.getCurrentSession().getTransaction().commit();
}
catch (RuntimeException e) {
    factory.getCurrentSession().getTransaction().rollback();
    throw e; // or display error message
}]]></programlisting>

            <para>
                正規のアプリケーションの中では、このようなコードの切れ端を決して見ないでしょう。
                致命的な（システム）例外は、常に「最上位」でキャッチすべきです。
                言い換えれば、（永続化層で）Hibernate呼び出しを実行するコードと、
                <literal>RuntimeException</literal> を制御する
                （通常はクリーンアップと終了のみ行うことができる）コードは、別々の層の中にあります。
                Hibernateによるカレントコンテキスト管理は、この設計をかなり単純にします。
                必要なのは、<literal>SessionFactory</literal> にアクセスすることだけです。
                例外処理は、この章の後のほうで議論します。
            </para>

           <para>
                注意：（デフォルトですが）
                <literal>org.hibernate.transaction.JDBCTransactionFactory</literal>
                を選択するべきです。
                第2の用例としては、
                <literal>hibernate.current_session_context_class</literal> を
                <literal>"thread"</literal> とするとよいでしょう。
            </para>
            
        </sect2>

        <sect2 id="transactions-demarcation-jta" revision="3">
            <title>JTAを使用する</title>

            <para>
                永続化層をアプリケーションサーバー（例えば、EJBセッションBeanの背後）で実行する場合、
                Hibernateから取得するすべてのデータソースコネクションは、
                自動的にグローバルJTAトランザクションの一部になります。
                
                EJBを使わずに、スタンドアロンのJTA実装を導入することもできます。
                JTA統合のために、Hibernateは２つの戦略を提供します。
            </para>

            <para>
                Bean管理トランザクション（BMT）を使い、<literal>Transaction</literal> APIを使う場合、
                HibernateはアプリケーションサーバーにBMTトランザクションの開始と終わりを告げます。
                すなわち、トランザクション管理のコードは、管理されない環境と同じになります。
            </para>
            
           <programlisting><![CDATA[// BMT idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}]]></programlisting>

           <para>
               トランザクション境界として <literal>Session</literal> を使いたい場合、
               簡単にコンテキストを伝播する機能である <literal>getCurrentSession()</literal> があるので、
               JTAの <literal>UserTransaction</literal> APIを直接使用すべきでしょう。
            </para>

            <programlisting><![CDATA[// BMT idiom with getCurrentSession()
try {
    UserTransaction tx = (UserTransaction)new InitialContext()
                            .lookup("java:comp/UserTransaction");

    tx.begin();

    // Do some work on Session bound to transaction
    factory.getCurrentSession().load(...);
    factory.getCurrentSession().persist(...);

    tx.commit();
}
catch (RuntimeException e) {
    tx.rollback();
    throw e; // or display error message
}]]></programlisting>

            <para>
                CMTでは、トランザクション境界をセッションBeanのデプロイメントディスクリプタで定義し、
                プログラムでは行いません。
                ゆえに、コードは次のように少なくなります。
            </para>

            <programlisting><![CDATA[// CMT idiom
 Session sess = factory.getCurrentSession();

 // do some work
 ...
]]></programlisting>

            <para>
                CMT/EJBの中では、常にロールバックが自動的に実施されます。
                なぜなら、セッションビーンのメソッドにより投げられた制御されていない
                <literal>RuntimeException</literal> は、グローバルトランザクションを
                ロールバックするようにコンテナに伝えるためです。
                <emphasis>これは、BMTもしくはCMTといっしょにHibernate <literal>Transaction</literal>
                APIを使う必要は少しもないという意味です。</emphasis>
            </para>

            <para>
                Hibernateのトランザクションファクトリを設定する際に、
                JTAを直接使う（BMTの）場合は <literal>org.hibernate.transaction.JTATransactionFactory</literal> を、
                CMTセッションビーンの中では <literal>org.hibernate.transaction.CMTTransactionFactory</literal> を
                選択すべきだということに注意してください。
                <literal>hibernate.transaction.manager_lookup_class</literal>
                をセットすることも思い出してください。
                なお、<literal>hibernate.current_session_context_class</literal> は、
                セットしないか（後方互換）、<literal>"jta"</literal> をセットしてください。
            </para>
            
            <para>
                <literal>getCurrentSession()</literal> オペレーションは、JTA環境では１つの欠点を持ちます。
                
                デフォルトで使われる <literal>after_statement</literal> コネクションリリースモードを使用する上で、
                警告が１つあります。
                
                JTA仕様の愚かな制約のために、
                <literal>scroll()</literal> または <literal>iterate()</literal> が返した、
                閉じられていない <literal>ScrollableResults</literal> または <literal>Iterator</literal>
                インスタンスをHibernateが自動的にクリーンアップすることはできません。
                
                <literal>finally</literal> ブロックの中で、
                <literal>ScrollableResults.close()</literal> または
                <literal>Hibernate.close(Iterator)</literal> を明示的に呼び出して、
                裏に潜んだデータベースカーソルを解放 <emphasis>しなければなりません</emphasis>。
                
                （もちろん、多くのアプリケーションでは、JTAかCMTコードで <literal>scroll()</literal>
                や <literal>iterate()</literal> の使用を避けるのは容易です。）
            </para>

        </sect2>

        <sect2 id="transactions-demarcation-exceptions">
            <title>例外ハンドリング</title>

            <para>
                <literal>Session</literal> が例外（<literal>SQLException</literal>を含む）を投げた場合、
                直ちに、データベーストランザクションをロールバックし、<literal>Session.close()</literal>
                を呼び、<literal>Session</literal> インスタンスを破棄すべきです。
                <literal>Session</literal> のいくつかのメソッドは、
                セッションの状態を <emphasis>矛盾したまま</emphasis> にします。
                Hibernateが投げた例外を、回復できるものとして扱うことはできません。
                <literal>finally</literal> ブロックの中で <literal>close()</literal> を呼んで、
                <literal>Session</literal> を確実に閉じてください。
            </para>

            <para>
                <literal>HibernateException</literal> は、Hibernate永続化層の中で発生する多くのエラーを
                ラップする、検査されない例外です（Hibernateの古いバージョンは違いました）。
                私たちの意見は、アプリケーション開発者に回復不可能な例外を
                下層でキャッチすることを強要すべきではないということです。
                多くのシステムでは、検査されない例外と致命的な例外は、
                コールスタックの最初のフレームの１つ（例えば、最上位の層で）でハンドリングし、
                エラーメッセージをアプリケーションユーザーに表示します
                （もしくは、他の適切な処理を実施します）。
                Hibernateは、<literal>HibernateException</literal> 以外の検査されない例外も
                投げることに注意してください。
                これらもまた、回復不可能であり、適切な処理を実施すべきです。
            </para>

            <para>
                Hibernateは、データベースとの対話中に投げられた <literal>SQLException</literal> を
                <literal>JDBCException</literal> でラップします。
                実は、例外をより意味のある <literal>JDBCException</literal> のサブクラスに
                変換しようと試みます。
                元の <literal>SQLException</literal> は、<literal>JDBCException.getCause()</literal>
                によりいつでも得られます。
                Hibernateは、<literal>SessionFactory</literal> に追加されている
                <literal>SQLExceptionConverter</literal> を使い、<literal>SQLException</literal> を
                適当な <literal>JDBCException</literal> サブクラスに変換します。
                デフォルトでは、<literal>SQLExceptionConverter</literal> は設定されているSQL方言により
                定義されます。
                一方で、独自の実装に差し替えることもできます
                （詳細は、<literal>SQLExceptionConverterFactory</literal> クラスのJavadocを参照してください）。
                標準的な <literal>JDBCException</literal> のサブタイプを下記に示します。
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>JDBCConnectionException</literal> -
                        基礎となるJDBC通信のエラーを表します。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>SQLGrammarException</literal> -
                        発行するSQLの文法もしくは構文の問題を表します。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>ConstraintViolationException</literal> -
                        何らかの形式の完全性制約違反を表します。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>LockAcquisitionException</literal> -
                        要求された操作を実施するのに必要なロックレベルを得る際のエラーを表します。
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>GenericJDBCException</literal> -
                        他のカテゴリに一致しなかった一般的な例外です。
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

        <sect2 id="transactions-demarcation-timeout">
            <title>トランザクションのタイムアウト</title>

            <para>
                EJBのような管理された環境が提供するきわめて重要な特徴の１つは、
                トランザクションのタイムアウトです。
                これは管理されていないコードには提供できません。
                トランザクションタイムアウトは、不品行なトランザクションが
                ユーザーにレスポンスを返さないまま、無期限にリソースを使い続けない
                ことを保障します。
                管理された環境（JTA）の外では、Hibernateはこの機能をフルに提供できません。
                しかしながら、Hibernateは次のようなデータアクセス操作の制御くらいはできます。
                データベースレベルのデッドロックや大きなリザルトセットを返すクエリを
                定義されたタイムアウトによって確実に制限します。
                管理された環境では、HibernateはトランザクションタイムアウトをJTAに委譲します。
                この機能は、Hibernateの <literal>Transaction</literal> オブジェクトに
                よって抽象化されています。
            </para>
            
            <programlisting><![CDATA[
Session sess = factory.openSession();
try {
    //set transaction timeout to 3 seconds
    sess.getTransaction().setTimeout(3);
    sess.getTransaction().begin();

    // do some work
    ...

    sess.getTransaction().commit()
}
catch (RuntimeException e) {
    sess.getTransaction().rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}]]></programlisting>

            <para>
                CMTビーンの中では <literal>setTimeout()</literal> を
                呼び出せないことに注意してください。
                トランザクションタイムアウトは宣言的に定義されるべきです。
            </para>
            
        </sect2>

    </sect1>

    <sect1 id="transactions-optimistic">
        <title>楽観的同時実行制御</title>

        <para>
            高い並列性と高いスケーラビリティの両方を実現するアプローチは、
            バージョニングを使った楽観的同時実行制御のみです。
            更新の衝突を見つけるために（および、更新が失われるのを防ぐために）、
            バージョン番号もしくはタイムスタンプを使って、バージョンをチェックします。
            Hibernateは、楽観的同時実行を行うアプリケーションコードを書くための
            アプローチを３つ提供します。
            私たちが見せるユースケースは、長い対話を持ちますが、
            バージョンチェックはまだ１つのデータベーストランザクションの中で更新を失うことを防ぐ
            利点も持っています。
        </para>

        <sect2 id="transactions-optimistic-manual">
            <title>アプリケーションによるバージョンチェック</title>

            <para>
                Hibernateにほとんど助けてもらわずに実装するケースです。
                データベースとのやり取りは、それぞれ新しい <literal>Session</literal> の中で起こります。
                開発者は、すべての永続性インスタンスを操作する前に、
                データベースから再読み込みする責務があります。
                このアプローチでは、対話トランザクションの分離を守るために、
                アプリケーション自身がバージョンチェックを行う必要があります。
                このアプローチは、データベースアクセスの中では、最も非効率です。
                エンティティEJBと最も似ているアプローチです。
            </para>

            <programlisting><![CDATA[// foo is an instance loaded by a previous Session
session = factory.openSession();
Transaction t = session.beginTransaction();

int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() ); // load the current state
if ( oldVersion != foo.getVersion() ) throw new StaleObjectStateException();
foo.setProperty("bar");

t.commit();
session.close();]]></programlisting>

            <para>
                <literal>&lt;version&gt;</literal> を使って、<literal>version</literal>
                プロパティをマッピングします。
                Hibernateは、エンティティがダーティである場合、フラッシュし、
                その間に <literal>version</literal> プロパティを自動的にインクリメントします。
            </para>

            <para>
                もちろん、データの並列性が低い環境で運用しており、バージョンチェックが不要なら、
                このアプローチを使い、バージョンチェックをスキップするだけです。
                その場合は、長い対話には、
                <emphasis>「最後にコミットしたものが勝つ」</emphasis> がデフォルトの戦略でしょう。
                このアプローチは、アプリケーションのユーザーを混乱させるかもしれないことを
                心に留めて置いてください。それは、エラーメッセージや競合した変更をマージする機会が
                ないまま、更新を失う経験をするためです。
            </para>

            <para>
                確かに、マニュアルによるバージョンチェックは、些細な儀式だけで実行できますが、
                多くのアプリケーションにとって実用的ではありません。
                しばしば、１つのインスタンスだけでなく、
                修正されたオブジェクトの完全なグラフをチェックしなければなりません。
                Hibernateは、設計パラダイムとして、拡張 <literal>Session</literal> か
                分離されたインスタンスを自動的にバージョンチェックします。
            </para>

        </sect2>

        <sect2 id="transactions-optimistic-longsession">
            <title>拡張セッションと自動バージョニング</title>

            <para>
                １つの <literal>Session</literal> インスタンスとその永続性インスタンスは、
                <emphasis>session-per-conversation</emphasis> として知られる、
                対話全体で使われます。
                Hibernateはフラッシュする際に、インスタンスのバージョンをチェックします。
                同時に修正されたことを検出すると、例外を投げます。
                この例外をキャッチして扱うのは、開発者の責任です
                （一般的な選択肢は、変更をマージするか古くないデータでビジネス対話を
                再スタートする機会をユーザーに提供することです）。
            </para>

            <para>
                ユーザーの対話を待っているときは、
                <literal>Session</literal> を基礎となるJDBCコネクションから切り離します。
                このアプローチは、データベースアクセスの中では、最も効率的です。
                アプリケーションは、バージョンチェックや分離されたインスタンスを再追加すること
                に関心を持つ必要はありません。また、あらゆるデータベーストランザクションの中で
                インスタンスを再読み込みする必要はありません。
            </para>

            <programlisting><![CDATA[// foo is an instance loaded earlier by the old session
Transaction t = session.beginTransaction(); // Obtain a new JDBC connection, start transaction

foo.setProperty("bar");

session.flush();    // Only for last transaction in conversation
t.commit();         // Also return JDBC connection
session.close();    // Only for last transaction in conversation]]></programlisting>

            <para>
                <literal>foo</literal> オブジェクトは、自分をロードした <literal>Session</literal>
                をまだ知っています。
                古いセッションの上で新しいデータベーストランザクションを開始することで、
                新しいコネクションを取得し、そのセッションが再開されます。
                データベーストランザクションをコミットすることで、
                セッションからJDBCコネクションを切断し、コネクションをプールに返します。
                再接続した後、更新していないデータのバージョンチェックを強制するために、
                他のトランザクションにより更新されているかもしれないオブジェクトに関して、
                <literal>LockMode.READ</literal> をつけて <literal>Session.lock()</literal>
                を呼び出すことができます。
                更新して <emphasis>いる</emphasis> データをロックする必要はありません。
                
                通常、拡張 <literal>Session</literal> に <literal>FlushMode.MANUAL</literal>
                をセットします。
                最後のデータベーストランザクションの周期でのみ、
                対話の中で変更されたすべてを実際に永続化させるためです。
                ゆえに、最後のデータベーストランザクションのみ <literal>flush()</literal>
                オペレーションを含みます。そして、対話を終わらせるために、
                セッションも <literal>close()</literal> します。
            </para>

            <para>
                ユーザーが考慮中に、格納することができないくらい <literal>Session</literal>
                が大きいのであれば、このパターンは問題があります。
                例えば、<literal>HttpSession</literal> は可能な限り小さく保つべきです。
                <literal>Session</literal> は（強制的に）１次キャッシュでもあり、
                ロードしたオブジェクトをすべて保持します。
                おそらく、リクエスト／レスポンスのサイクルが数回であれば、この戦略が使えます。
                
                １つの対話のためだけに <literal>Session</literal> を使うべきです。
                なぜなら、すぐに新鮮でないデータを持つためです。
            </para>

            <para>
                （Hibernateの以前のバージョンは、明示的な <literal>Session</literal> の
                切断と再接続が必要だったことに注意してください。
                これらのメソッドは非推奨になりました。
                なぜなら、トランザクションの開始と終了は同じ効果があるためです。）
            </para>

            <para>
                切断した <literal>Session</literal> を永続化層の近くで保持すべきであることに
                注意してください。
                言い換えると、３層環境の中で <literal>Session</literal> を保持するために、
                EJBステートフルセッションBeanを使ってください。
                <literal>HttpSession</literal> に格納するために、Web層に転送しないでください
                （別の層へのシリアライズもしないでください）。
            </para>

            <para>
                拡張セッションパターン（もしくは、<emphasis>session-per-conversation</emphasis>）は、
                自動的なカレントセッションコンテキスト管理を実施するより難しい。
                このために、あなたは <literal>CurrentSessionContext</literal> の実装を供給する必要があります。
                Hibernate Wikiにある例を参照してください。
            </para>

        </sect2>

        <sect2 id="transactions-optimistic-detached">
            <title>デタッチされたオブジェクトと自動バージョニング</title>

            <para>
                新しい <literal>Session</literal>により、永続化ストア（訳注：ＤＢ）との対話が発生します。
                また一方、同じ永続性インスタンスが、データベースとの対話ごとに再利用されます。
                アプリケーションは、元々は他の <literal>Session</literal> でロードされ、
                デタッチされたインスタンスの状態を操作します。
                そして、<literal>Session.update()</literal> もしくは、<literal>Session.saveOrUpdate()</literal>、
                <literal>Session.merge()</literal> を使って、それらのインスタンスを再追加します。
            </para>

            <programlisting><![CDATA[// foo is an instance loaded by a previous Session
foo.setProperty("bar");
session = factory.openSession();
Transaction t = session.beginTransaction();
session.saveOrUpdate(foo); // Use merge() if "foo" might have been loaded already
t.commit();
session.close();]]></programlisting>

            <para>
                この場合もやはり、Hibernateはフラッシュする際に、インスタンスのバージョンをチェックします。
                更新の競合が発生した場合には、例外を投げます。
            </para>

            <para>
                オブジェクトが修正されていないことを確信している場合は、
                <literal>update()</literal> の代わりに、<literal>LockMode.READ</literal> を使って、
                <literal>lock()</literal> を呼び出すこともできます
                （すべてのキャッシュを迂回し、バージョンチェックを実施します）。
            </para>

        </sect2>

        <sect2 id="transactions-optimistic-customizing">
            <title>自動バージョニングのカスタマイズ</title>

            <para>
                マッピングの <literal>optimistic-lock</literal> 属性に <literal>false</literal>
                を設定することにより、特定のプロパティやコレクションのために
                自動バージョンインクリメントを無効にできます。
                プロパティがダーティであっても、バージョンをインクリメントしません。
            </para>

            <para>
                レガシーのデータベーススキーマは、しばしば固定的であり、変更できません。
                または、他のアプリケーションが同じデータベースにアクセスしなければならず、
                そのアプリケーションはバージョン番号やタイムスタンプさえ操作する方法を知りません。
                どちらの場合も、テーブルの特定のカラムを当てにして、バージョニングを行えません。
                バージョンやタイムスタンプのプロパティをマッピングせずに、バージョンチェックさせるために、
                <literal>&lt;class&gt;</literal> マッピングに <literal>optimistic-lock="all"</literal> を
                指定してください。
                行のすべてのフィールドの状態を比較するようになります。
                これは、Hibernateが古い状態と新しい状態を比較できる場合に、
                理論的に動作するだけであることに注意してください。
                例えば、session-per-request-with-detached-objects ではなく、
                １つの長い <literal>Session</literal> を使う場合です。
            </para>

            <para>
                ときどき、行われた変更が重ならない限り、同時に行われた変更を受け入れることができます。
                <literal>&lt;class&gt;</literal> マッピングに <literal>optimistic-lock="dirty"</literal>
                を設定した場合、フラッシュする際に、Hibernateはダーティフィールドのみを比較します。
            </para>

            <para>
                専用のバージョン／タイムスタンプのカラムを使う場合、
                もしくはすべて／ダーティのフィールドを比較する場合どちらであっても、
                Hibernateはエンティティごとに1つの <literal>UPDATE</literal> 文を
                （適切な <literal>WHERE</literal> 節と共に）使い、
                バージョンチェックと情報の更新を行います。
                関連するエンティティの再追加をカスケードするために、
                連鎖的な永続化を使用した場合、不必要な更新を実行するかもしれません。
                これは通常問題になりません。
                しかし、分離したインスタンスを変更していなくとも、
                データベースの <emphasis>on update</emphasis> トリガーが実行されるかもしれません。
                <literal>&lt;class&gt;</literal> マッピングに
                <literal>select-before-update="true"</literal> を設定することによって、
                この振る舞いをカスタマイズできます。
                確実に変更されたかを確認するために、行を更新する前に、
                必ずインスタンスを <literal>SELECT</literal> します。
            </para>

        </sect2>

    </sect1>

    <sect1 id="transactions-locking">
        <title>悲観的ロック</title>

        <para>
            ユーザがロック戦略に悩むのに多くの時間を費やすことを意図していません。
            通常は、JDBCコネクションに分離レベルを指定し、
            単にデータベースにすべての仕事をさせれば十分です。
            しかしながら、高度なユーザは、排他的な悲観的ロックを獲得することか、
            新しいトランザクションが開始される際にロックを再獲得することを
            ときどき望むかもしれません。
        </para>

        <para>
            Hibernateはいつもデータベースのロックの仕組みを使います。
            メモリ内のオブジェクトを決してロックしません！
        </para>

        <para>
            <literal>LockMode</literal> クラスは、Hibernateが獲得できる異なるロックレベルを定義します。
            以下の仕組みにより、ロックを獲得できます。
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>LockMode.WRITE</literal> は、
                    Hibernateが行を更新もしくは挿入する際に自動的に得られます。
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>LockMode.UPGRADE</literal> は、
                    データベースでサポートされている文法 <literal>SELECT ... FOR UPDATE</literal>
                    を使った、明示的なユーザー要求により得られるかもしれません。
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>LockMode.UPGRADE_NOWAIT</literal> は、
                    Oracle で <literal>SELECT ... FOR UPDATE NOWAIT</literal> を使った、
                    明示的なユーザー要求により得られるかもしれません。
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>LockMode.READ</literal> は、
                    Repeatable ReadもしくはSerializableの分離レベルで、データを読んだ際に自動的に得られます。
                    おそらく、明示的なユーザー要求により、再取得されます。
                </para>
            </listitem>
        <listitem>
        <para>
            <literal>LockMode.NONE</literal> は、ロックしないことを表します。
            <literal>Transaction</literal> の終わりに、
            すべてのオブジェクトはこのロックモードに切り替わります。
            <literal>update()</literal> や <literal>saveOrUpdate()</literal> を呼び出すことによって、
            セッションに関連付けられたオブジェクトも、このロックモードで出発します。
        </para>
        </listitem>
        </itemizedlist>

        <para>
            「明示的なユーザー要求」とは、下記の方法の１つで言い表せます。
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>LockMode</literal> を指定した <literal>Session.load()</literal> の呼び出し。
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>Session.lock()</literal> の呼び出し。
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>Query.setLockMode()</literal> の呼び出し。
                </para>
            </listitem>
        </itemizedlist>

        <para>
            <literal>UPGRADE</literal> もしくは <literal>UPGRADE_NOWAIT</literal> が指定された
            <literal>Session.load()</literal> が呼び出され、
            かつ要求されたオブジェクトがセッションによってまだロードされていなかった場合は、
            <literal>SELECT ... FOR UPDATE</literal> を使って、オブジェクトがロードされます。
            <literal>load()</literal> で呼び出されたオブジェクトが、
            要求されているより制限が少ないロックですでにロードされていた場合は、
            Hibernateはそのオブジェクトのために、<literal>lock()</literal> を呼び出します。
        </para>

        <para>
            指定されたロックモードが <literal>READ</literal> もしくは、<literal>UPGRADE</literal>、
            <literal>UPGRADE_NOWAIT</literal> だった場合、<literal>Session.lock()</literal>
            は、バージョン番号のチェックを実施します。
            （<literal>UPGRADE</literal> もしくは <literal>UPGRADE_NOWAIT</literal> の場合、
            <literal>SELECT ... FOR UPDATE</literal> が使われます。）
        </para>

        <para>
            データベースが要求されたロックモードをサポートしていない場合、
            Hibernateは（例外を投げる代わりに、）適切な代わりのモードを使います。
            これは、アプリケーションがポータブルであることを保証します。
        </para>

    </sect1>

    <sect1 id="transactions-connection-release">
        <title>コネクション開放モード</title>

        <para>
            Hibernateのレガシー（2.x）のJDBCコネクション管理に関する振る舞いは、
            最初に必要とした際に <literal>Session</literal> がコネクションを得るというものでした。
            そして、セッションが閉じられるまで、そのコネクションを保持しました。
            Hibernate 3.xは、セッションにJDBCコネクションをどのように制御するかを伝える
            コネクション開放モードという概念を導入しました。
            以降の議論は、構成された <literal>ConnectionProvider</literal> を通して提供される
            コネクションに適切であることに注意してください。
            異なる開放モードは、<literal>org.hibernate.ConnectionReleaseMode</literal> に
            列挙された値により確認されます。
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>ON_CLOSE</literal> - 本質的に上記で述べたレガシーの振る舞いです。
                    Hibernateセッションは最初にJDBCアクセスを実行する必要がある際にコネクションを得ます。
                    そして、セッションが閉じられるまで、コネクションを保持します。
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>AFTER_TRANSACTION</literal> - 
                    <literal>org.hibernate.Transaction</literal> が完了した後、
                    コネクションを開放します。
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>AFTER_STATEMENT</literal> （積極的な開放とも呼ばれる） -
                    すべてのステートメントがそれぞれ実行された後、コネクションが開放されます。
                    ステートメントがセッションに関連するリソースを開いたままにする場合は、
                    この積極的な開放はスキップされます。
                    今のところ、これが起こるのは <literal>org.hibernate.ScrollableResults</literal>
                    が使われる場合のみです。
                </para>
            </listitem>
        </itemizedlist>

        <para>
            コンフィグレーションパラメータの <literal>hibernate.connection.release_mode</literal>
            は、使用する開放モードを指定するために使います。
            指定できる値は次の通りです。
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>auto</literal> （デフォルト） - これを選択すると
                    <literal>org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</literal>
                    メソッドによって返される開放モードに委譲されます。
                    このメソッドは、
                    JTATransactionFactoryにはConnectionReleaseMode.AFTER_STATEMENTを返し、
                    JDBCTransactionFactoryにはConnectionReleaseMode.AFTER_TRANSACTIONを返します。
                    このデフォルトの振る舞いを変えてうまくいった試しがありません。
                    それは、この設定値が原因で起こる障害は、
                    ユーザコードの中でバグや間違った条件になりやすいからです。
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>on_close</literal> - ConnectionReleaseMode.ON_CLOSEを使います。
                    この設定は後方互換のために残されていますが、使わないことを強く勧めます。
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>after_transaction</literal> - ConnectionReleaseMode.AFTER_TRANSACTIONを使います。
                    この設定はJTA環境の中では使うべきではありません。
                    ConnectionReleaseMode.AFTER_TRANSACTIONを指定し、自動コミットモードの中では、
                    開放モードがAFTER_STATEMENTであるかのように、コネクションは開放されることに注意してください。
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>after_statement</literal> - ConnectionReleaseMode.AFTER_STATEMENTを使います。
                    さらに、設定された <literal>ConnectionProvider</literal> は、
                    この設定 (<literal>supportsAggressiveRelease()</literal>) をサポートするかどうか
                    を調べるために使用します。
                    もしそうでない場合、開放モードはConnectionReleaseMode.AFTER_TRANSACTION
                    にリセットされます。
                    この設定は次の環境でのみ安全です。
                    それは、<literal>ConnectionProvider.getConnection()</literal> を呼び出すたびに
                    基盤となるJDBCコネクションが同じものを取得できるか、
                    同じコネクションが得られることが問題とならない自動コミット環境の中です。
                </para>
            </listitem>
        </itemizedlist>

    </sect1>

</chapter>
