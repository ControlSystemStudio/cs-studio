# translation of query_hql.po to French
# Myriam Malga <mmalga@redhat.com>, 2007.
# Xi HUANG <xhuang@redhat.com>, 2007.
# Corina Roe <croe@redhat.com>, 2009, 2010.
# translation of Collection_Mapping.po to
msgid ""
msgstr ""
"Project-Id-Version: query_hql\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:15\n"
"PO-Revision-Date: 2010-01-05 09:46+1000\n"
"Last-Translator: Corina Roe <croe@redhat.com>\n"
"Language-Team: French <i18@redhat.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "HQL: The Hibernate Query Language"
msgstr "HQL : langage d'interrogation d'Hibernate"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate uses a powerful query language (HQL) that is similar in appearance "
"to SQL. Compared with SQL, however, HQL is fully object-oriented and "
"understands notions like inheritance, polymorphism and association."
msgstr ""
"Hibernate fournit un langage d'interrogation extrêmement puissant qui "
"ressemble (et c'est voulu) au SQL. Mais ne soyez pas dupe de la syntaxe ; "
"HQL est totalement orienté objet, cernant des notions comme l'héritage, le "
"polymorphisme et les associations. "

#. Tag: title
#, no-c-format
msgid "Case Sensitivity"
msgstr "Sensibilité à la casse"

#. Tag: para
#, no-c-format
msgid ""
"With the exception of names of Java classes and properties, queries are case-"
"insensitive. So <literal>SeLeCT</literal> is the same as <literal>sELEct</"
"literal> is the same as <literal>SELECT</literal>, but <literal>org."
"hibernate.eg.FOO</literal> is not <literal>org.hibernate.eg.Foo</literal>, "
"and <literal>foo.barSet</literal> is not <literal>foo.BARSET</literal>."
msgstr ""
"Les requêtes sont insensibles à la casse, à l'exception des noms de classes "
"Java et des propriétés. Ainsi, <literal>SeLeCT</literal> est identique à "
"<literal>sELEct</literal> et à <literal>SELECT</literal> mais <literal>net."
"sf.hibernate.eg.FOO</literal> n'est pas identique <literal>net.sf.hibernate."
"eg.Foo</literal> et <literal>foo.barSet</literal> n'est pas identique à "
"<literal>foo.BARSET</literal>. "

#. Tag: para
#, no-c-format
msgid ""
"This manual uses lowercase HQL keywords. Some users find queries with "
"uppercase keywords more readable, but this convention is unsuitable for "
"queries embedded in Java code."
msgstr ""
"Ce guide utilise les mots clés HQL en minuscules. Certains utilisateurs "
"trouvent les requêtes écrites avec les mots clés en majuscules plus "
"lisibles, mais nous trouvons cette convention pénible lorsqu'elle est lue "
"dans du code Java. "

#. Tag: title
#, no-c-format
msgid "The from clause"
msgstr "La clause from"

#. Tag: para
#, no-c-format
msgid "The simplest possible Hibernate query is of the form:"
msgstr "La requête Hibernate la plus simple est de la forme :"

#. Tag: para
#, no-c-format
msgid ""
"This returns all instances of the class <literal>eg.Cat</literal>. You do "
"not usually need to qualify the class name, since <literal>auto-import</"
"literal> is the default. For example:"
msgstr ""
"Retourne toutes les instances de la classe <literal>eg.Cat</literal>. Nous "
"n'avons pas besoin de qualifier le nom de la classe, puisque <literal>auto-"
"import</literal> est la valeur par défaut. Donc nous écrivons presque "
"toujours :"

#. Tag: para
#, no-c-format
msgid ""
"In order to refer to the <literal>Cat</literal> in other parts of the query, "
"you will need to assign an <emphasis>alias</emphasis>. For example:"
msgstr ""
"Pour pouvoir nous référer à <literal>Cat</literal> dans des autres parties "
"de la requête, vous aurez besoin d'y assigner un <emphasis>alias</emphasis>. "
"Ainsi :"

#. Tag: para
#, no-c-format
msgid ""
"This query assigns the alias <literal>cat</literal> to <literal>Cat</"
"literal> instances, so you can use that alias later in the query. The "
"<literal>as</literal> keyword is optional. You could also write:"
msgstr ""
"Cette requête assigne l'alias <literal>cat</literal> à l'instance "
"<literal>Cat</literal>, nous pouvons donc utiliser cet alias ailleurs dans "
"la requête. Le mot clé <literal>as</literal> est optionnel. Nous aurions pu "
"écrire :"

#. Tag: para
#, no-c-format
msgid ""
"Multiple classes can appear, resulting in a cartesian product or \"cross\" "
"join."
msgstr ""
"Plusieurs classes peuvent apparaître, ce qui conduira à un produit cartésien "
"(encore appelé jointures croisées). "

#. Tag: para
#, no-c-format
msgid ""
"It is good practice to name query aliases using an initial lowercase as this "
"is consistent with Java naming standards for local variables (e.g. "
"<literal>domesticCat</literal>)."
msgstr ""
"C'est une bonne pratique que de nommer les alias dans les requêtes en "
"utilisant l'initiale en miniscule, ce qui correspond aux standards de "
"nommage Java pour les variables locales (par ex. <literal>domesticCat</"
"literal>)."

#. Tag: title
#, no-c-format
msgid "Associations and joins"
msgstr "Associations et jointures"

#. Tag: para
#, no-c-format
msgid ""
"You can also assign aliases to associated entities or to elements of a "
"collection of values using a <literal>join</literal>. For example:"
msgstr ""
"On peut aussi assigner des alias à des entités associées, ou même aux "
"éléments d'une collection de valeurs, en utilisant un <literal>join</"
"literal> (jointure). Par exemple :"

#. Tag: para
#, no-c-format
msgid "The supported join types are borrowed from ANSI SQL:"
msgstr "Les types de jointures supportées sont empruntées de ANSI SQL :"

#. Tag: para
#, no-c-format
msgid "<literal>inner join</literal>"
msgstr "<literal>inner join</literal> (jointure interne)"

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>left outer join</literal>"
msgstr "<literal>inner join</literal> (jointure interne)"

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>right outer join</literal>"
msgstr "<literal>inner join</literal> (jointure interne)"

#. Tag: para
#, no-c-format
msgid "<literal>full join</literal> (not usually useful)"
msgstr ""
"<literal>full join</literal> (jointure ouverte totalement - généralement "
"inutile)"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>inner join</literal>, <literal>left outer join</literal> and "
"<literal>right outer join</literal> constructs may be abbreviated."
msgstr ""
"Les constructions des jointures <literal>inner join</literal>, <literal>left "
"outer join</literal> et <literal>right outer join</literal> peuvent être "
"abrégées."

#. Tag: para
#, no-c-format
msgid ""
"You may supply extra join conditions using the HQL <literal>with</literal> "
"keyword."
msgstr ""
"Nous pouvons soumettre des conditions de jointure supplémentaires en "
"utilisant le mot-clef HQL <literal>with</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A \"fetch\" join allows associations or collections of values to be "
"initialized along with their parent objects using a single select. This is "
"particularly useful in the case of a collection. It effectively overrides "
"the outer join and lazy declarations of the mapping file for associations "
"and collections. See <xref linkend=\"performance-fetching\" /> for more "
"information."
msgstr ""
"Par ailleurs, une jointure \"fetch\" (rapportée) permet d'initialiser les "
"associations ou collections de valeurs en même temps que leurs objets "
"parents, en utilisant qu'un seul Select. Ceci est particulièrement utile "
"dans le cas des collections. Ce système permet de surcharger les "
"déclarations \"lazy\" et \"outer-join\" des fichiers de mapping pour les "
"associations et collections. Consultez <xref linkend=\"performance-fetching"
"\" /> pour plus d'informations."

#. Tag: para
#, no-c-format
msgid ""
"A fetch join does not usually need to assign an alias, because the "
"associated objects should not be used in the <literal>where</literal> clause "
"(or any other clause). The associated objects are also not returned directly "
"in the query results. Instead, they may be accessed via the parent object. "
"The only reason you might need an alias is if you are recursively join "
"fetching a further collection:"
msgstr ""
"Une jointure \"fetch\" (rapportée) n'a généralement pas besoin de se voir "
"assigner un alias puisque les objets associés ne doivent pas être utilisés "
"dans la clause <literal>where</literal> ou toute autre clause. Notez aussi "
"que les objets associés ne sont pas retournés directement dans le résultat "
"de la requête mais l'on peut y accéder via l'objet parent. La seule raison "
"pour laquelle nous pourrions avoir besoin d'un alias est si nous récupérons "
"récursivement une collection supplémentaire :"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>fetch</literal> construct cannot be used in queries called "
"using <literal>iterate()</literal> (though <literal>scroll()</literal> can "
"be used). <literal>Fetch</literal> should be used together with "
"<literal>setMaxResults()</literal> or <literal>setFirstResult()</literal>, "
"as these operations are based on the result rows which usually contain "
"duplicates for eager collection fetching, hence, the number of rows is not "
"what you would expect. <literal>Fetch</literal> should also not be used "
"together with impromptu <literal>with</literal> condition. It is possible to "
"create a cartesian product by join fetching more than one collection in a "
"query, so take care in this case. Join fetching multiple collection roles "
"can produce unexpected results for bag mappings, so user discretion is "
"advised when formulating queries in this case. Finally, note that "
"<literal>full join fetch</literal> and <literal>right join fetch</literal> "
"are not meaningful."
msgstr ""
"Notez que la construction de <literal>fetch</literal> ne peut pas être "
"utilisée dans les requêtes appelées par <literal>scroll()</literal> ou "
"<literal>iterate()</literal>. De même <literal>Fetch</literal> ne devrait "
"pas être utilisé avec <literal>setMaxResults()</literal> ou "
"<literal>setFirstResult()</literal>, ces opérations étant basées sur le "
"nombre de résultats contenant généralement des doublons dès que des "
"collections sont chargées agressivement, par conséquent le nombre de lignes "
"est imprévisible. <literal>Fetch</literal> ne peut pas non plus être utilisé "
"avec une condition <literal>with</literal> ad hoc. Il est possible de créer "
"un produit cartésien par jointure en récupérant plus d'une collection dans "
"une requête, donc faites attention dans ce cas. Récupérer par jointure de "
"multiples collections donne aussi parfois des résultats inattendus pour des "
"mappages de sac, donc soyez prudent lorsque vous formulez vos requêtes dans "
"de tels cas. Finalement, notez que <literal>full join fetch</literal> et "
"<literal>right join fetch</literal> ne sont pas utiles en général."

#. Tag: para
#, no-c-format
msgid ""
"If you are using property-level lazy fetching (with bytecode "
"instrumentation), it is possible to force Hibernate to fetch the lazy "
"properties in the first query immediately using <literal>fetch all "
"properties</literal>."
msgstr ""
"Si vous utilisez un chargement retardé pour les propriétés (avec une "
"instrumentation par bytecode), il est possible de forcer Hibernate à "
"récupérer les propriétés non encore chargées immédiatement (dans la première "
"requête) en utilisant <literal>fetch all properties</literal>. "

#. Tag: title
#, no-c-format
msgid "Forms of join syntax"
msgstr "Formes de syntaxes pour les jointures"

#. Tag: para
#, no-c-format
msgid ""
"HQL supports two forms of association joining: <literal>implicit</literal> "
"and <literal>explicit</literal>."
msgstr ""
"HQL supporte deux formes pour joindre les associations : <literal>implicit</"
"literal> et <literal>explicit</literal>."

#. Tag: para
#, no-c-format
msgid ""
"The queries shown in the previous section all use the <literal>explicit</"
"literal> form, that is, where the join keyword is explicitly used in the "
"from clause. This is the recommended form."
msgstr ""
"Les requêtes présentes dans la section précédente utilisent la forme "
"<literal>explicit</literal> où le mot clé join est explicitement utilisé "
"dans la clause from. C'est la forme recommandée. "

#. Tag: para
#, no-c-format
msgid ""
"The <literal>implicit</literal> form does not use the join keyword. Instead, "
"the associations are \"dereferenced\" using dot-notation. <literal>implicit</"
"literal> joins can appear in any of the HQL clauses. <literal>implicit</"
"literal> join result in inner joins in the resulting SQL statement."
msgstr ""
"La forme <literal>implicit</literal> n'utilise pas le mot clé join. En "
"revanche, les associations sont \"déréférencées\" en utilisant la notation. "
"Ces jointures <literal>implicit</literal> peuvent apparaître dans toutes les "
"clauses HQL. Les jointures <literal>implicit</literal> résultent en des "
"jointures internes dans le SQL généré."

#. Tag: title
#, no-c-format
msgid "Referring to identifier property"
msgstr "Faire référence à la propriété identifiant "

#. Tag: para
#, no-c-format
msgid "There are 2 ways to refer to an entity's identifier property:"
msgstr ""
"Il y a en général deux façons de faire référence à une propriété "
"d'identifiant d'une entité :"

#. Tag: para
#, no-c-format
msgid ""
"The special property (lowercase) <literal>id</literal> may be used to "
"reference the identifier property of an entity <emphasis>provided that the "
"entity does not define a non-identifier property named id</emphasis>."
msgstr ""
"La propriété particulière (minuscule) <literal>id</literal> peut être "
"utilisée pour référencer la propriété d'identifiant d'une entité "
"<emphasis>du moment que l'entité ne définisse pas une propriété de non-"
"identifiant appelée id</emphasis>."

#. Tag: para
#, no-c-format
msgid ""
"If the entity defines a named identifier property, you can use that property "
"name."
msgstr ""
"Si l'identité définit une propriété d'identifiant nommée, vous pouvez "
"utiliser ce nom de propriété."

#. Tag: para
#, no-c-format
msgid ""
"References to composite identifier properties follow the same naming rules. "
"If the entity has a non-identifier property named id, the composite "
"identifier property can only be referenced by its defined named. Otherwise, "
"the special <literal>id</literal> property can be used to reference the "
"identifier property."
msgstr ""
"Les références aux propriétés d'identifiant composites suivent les mêmes "
"règles de nommage. Si l'entité a une propriété de non-identifiant appelée "
"id, la propriété d'identifiant composite ne peut être référencée que par son "
"nom défini ; sinon la propriété spéciale <literal>id</literal> peut être "
"utilisée pour référencer la propriété d'identifiant. "

#. Tag: para
#, no-c-format
msgid ""
"Please note that, starting in version 3.2.2, this has changed significantly. "
"In previous versions, <literal>id</literal> <emphasis>always</emphasis> "
"referred to the identifier property regardless of its actual name. A "
"ramification of that decision was that non-identifier properties named "
"<literal>id</literal> could never be referenced in Hibernate queries."
msgstr ""
"Note : cela a changé de façon significative depuis la version 3.2.2. Dans "
"les versions précédentes, <literal>id</literal> référait <emphasis>toujours</"
"emphasis> à la propriété identifiant quel que soit son nom réel. Une des "
"conséquences de cette décision fut que les propriétés de non-identifiant "
"appelées <literal>id</literal> ne pouvaient jamais être référencées dans les "
"requêtes Hibernate."

#. Tag: title
#, no-c-format
msgid "The select clause"
msgstr "La clause select"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>select</literal> clause picks which objects and properties to "
"return in the query result set. Consider the following:"
msgstr ""
"La clause <literal>select</literal> sélectionne les objets et propriétés qui "
"doivent être retournés dans le résultat de la requête. Soit : "

#. Tag: para
#, no-c-format
msgid ""
"The query will select <literal>mate</literal>s of other <literal>Cat</"
"literal>s. You can express this query more compactly as:"
msgstr ""
"La requête recherchera les <literal>mate</literal> s liés aux <literal>Cat</"
"literal> s. Vous pouvez exprimer cette requête de manière plus compacte : "

#. Tag: para
#, no-c-format
msgid ""
"Queries can return properties of any value type including properties of "
"component type:"
msgstr ""
"Les requêtes peuvent retourner des propriétés de n'importe quel type de "
"valeur, même celles de type composant : "

#. Tag: para
#, no-c-format
msgid ""
"Queries can return multiple objects and/or properties as an array of type "
"<literal>Object[]</literal>:"
msgstr ""
"Les requêtes peuvent retourner de multiples objets et/ou propriétés sous la "
"forme d'un tableau du type <literal>Object[]</literal> :"

#. Tag: para
#, no-c-format
msgid "Or as a <literal>List</literal>:"
msgstr "Ou sous la forme d'une <literal>List</literal> :"

#. Tag: para
#, no-c-format
msgid ""
"Or - assuming that the class <literal>Family</literal> has an appropriate "
"constructor - as an actual typesafe Java object:"
msgstr ""
"Ou bien - à condition que la classe <literal>Family</literal> possède le "
"constructeur approprié - en tant qu'objet typesafe Java :"

#. Tag: para
#, no-c-format
msgid ""
"You can assign aliases to selected expressions using <literal>as</literal>:"
msgstr ""
"Vous pouvez assigner des alias aux expressions sélectionnées en utilisant "
"<literal>as</literal> : "

#. Tag: para
#, no-c-format
msgid ""
"This is most useful when used together with <literal>select new map</"
"literal>:"
msgstr ""
"C'est surtout utile lorsque c'est utilisé avec <literal>select new map</"
"literal> :"

#. Tag: para
#, no-c-format
msgid ""
"This query returns a <literal>Map</literal> from aliases to selected values."
msgstr ""
"Cette requête retourne une <literal>Map</literal> à partir des alias vers "
"les valeurs sélectionnées."

#. Tag: title
#, no-c-format
msgid "Aggregate functions"
msgstr "Fonctions d'agrégation"

#. Tag: para
#, no-c-format
msgid ""
"HQL queries can even return the results of aggregate functions on properties:"
msgstr ""
"Les requêtes HQL peuvent aussi retourner les résultats de fonctions "
"d'agrégation sur les propriétés : "

#. Tag: para
#, no-c-format
msgid "The supported aggregate functions are:"
msgstr "Les fonctions d'agrégation supportées sont :"

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>avg(...), sum(...), min(...), max(...)</literal>"
msgstr "<literal>avg(...), sum(...), min(...), max(...)</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>count(*)</literal>"
msgstr "<literal>count(*)</literal>"

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>count(...), count(distinct ...), count(all...)</literal>"
msgstr "<literal>count(...), count(distinct ...), count(all...)</literal>"

#. Tag: para
#, no-c-format
msgid ""
"You can use arithmetic operators, concatenation, and recognized SQL "
"functions in the select clause:"
msgstr ""
"Vous pouvez utiliser des opérateurs arithmétiques, la concaténation, et des "
"fonctions SQL reconnues dans la clause select : "

#. Tag: para
#, no-c-format
msgid ""
"The <literal>distinct</literal> and <literal>all</literal> keywords can be "
"used and have the same semantics as in SQL."
msgstr ""
"Les mots clé <literal>distinct</literal> et <literal>all</literal> peuvent "
"être utilisés et ont la même sémantique qu'en SQL. "

#. Tag: title
#, no-c-format
msgid "Polymorphic queries"
msgstr "Requêtes polymorphiques"

#. Tag: para
#, no-c-format
msgid "A query like:"
msgstr "Une requête comme :"

#. Tag: para
#, no-c-format
msgid ""
"returns instances not only of <literal>Cat</literal>, but also of subclasses "
"like <literal>DomesticCat</literal>. Hibernate queries can name "
"<emphasis>any</emphasis> Java class or interface in the <literal>from</"
"literal> clause. The query will return instances of all persistent classes "
"that extend that class or implement the interface. The following query would "
"return all persistent objects:"
msgstr ""
"retourne non seulement les instances de <literal>Cat</literal>, mais aussi "
"celles des sous classes comme <literal>DomesticCat</literal>. Les requêtes "
"Hibernate peuvent nommer n'importe quelle classe ou interface Java dans la "
"clause <literal>from</literal>. La requête retournera les instances de "
"toutes les classes persistantes qui étendent cette classe ou implémente "
"cette interface. La requête suivante retournera tous les objets "
"persistants : "

#. Tag: para
#, no-c-format
msgid ""
"The interface <literal>Named</literal> might be implemented by various "
"persistent classes:"
msgstr ""
"L'interface <literal>Named</literal> peut être implémentée par plusieurs "
"classes persistantes :"

#. Tag: para
#, no-c-format
msgid ""
"These last two queries will require more than one SQL <literal>SELECT</"
"literal>. This means that the <literal>order by</literal> clause does not "
"correctly order the whole result set. It also means you cannot call these "
"queries using <literal>Query.scroll()</literal>."
msgstr ""
"Notez que ces deux dernières requêtes nécessitent plus d'un SQL "
"<literal>SELECT</literal>. Ce qui signifie que la clause <literal>order by</"
"literal> ne trie pas correctement la totalité des résultats (cela signifie "
"aussi que vous ne pouvez exécuter ces requêtes en appelant <literal>Query."
"scroll()</literal>). "

#. Tag: title
#, no-c-format
msgid "The where clause"
msgstr "La clause where"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>where</literal> clause allows you to refine the list of "
"instances returned. If no alias exists, you can refer to properties by name:"
msgstr ""
"La clause <literal>where</literal> vous permet de réduire la liste des "
"instances retournées. Si aucun alias n'existe, vous pouvez vous référer aux "
"propriétés par leur nom : "

#. Tag: para
#, no-c-format
msgid "If there is an alias, use a qualified property name:"
msgstr "S'il y a un alias, utilisez un nom de propriété qualifié :"

#. Tag: para
#, no-c-format
msgid "This returns instances of <literal>Cat</literal> named 'Fritz'."
msgstr "Retourne les instances de <literal>Cat</literal> appelé  'Fritz'."

#. Tag: para
#, no-c-format
msgid "The following query:"
msgstr "La requête suivante :"

#. Tag: para
#, no-c-format
msgid ""
"returns all instances of <literal>Foo</literal> with an instance of "
"<literal>bar</literal> with a <literal>date</literal> property equal to the "
"<literal>startDate</literal> property of the <literal>Foo</literal>. "
"Compound path expressions make the <literal>where</literal> clause extremely "
"powerful. Consider the following:"
msgstr ""
"retournera les instances de <literal>Foo</literal> pour lesquelles il existe "
"une instance de <literal>bar</literal> avec la propriété <literal>date</"
"literal> égale à la propriété <literal>startDate</literal> de <literal>Foo</"
"literal>. Les expressions de chemin composées rendent la clause "
"<literal>where</literal> extrêmement puissante. Soit : "

#. Tag: para
#, no-c-format
msgid ""
"This query translates to an SQL query with a table (inner) join. For example:"
msgstr ""
"Cette requête se traduit en une requête SQL par une jointure interne de "
"table. Si vous souhaitez écrire quelque chose comme :"

#. Tag: para
#, no-c-format
msgid "would result in a query that would require four table joins in SQL."
msgstr ""
"vous finiriez avec une requête qui nécessiterait quatre jointures de table "
"en SQL. "

#. Tag: para
#, no-c-format
msgid ""
"The <literal>=</literal> operator can be used to compare not only "
"properties, but also instances:"
msgstr ""
"L'opérateur <literal>=</literal> peut être utilisé pour comparer aussi bien "
"des propriétés que des instances : "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The special property (lowercase) <literal>id</literal> can be used to "
"reference the unique identifier of an object. See <xref linkend=\"queryhql-"
"identifier-property\" /> for more information."
msgstr ""
"La propriété spéciale (en minuscule) <literal>id</literal> peut être "
"utilisée pour référencer l'identifiant unique d'un objet. Pour plus "
"d'informations, consultez <xref linkend=\"queryhql-identifier-property\" />."

#. Tag: para
#, no-c-format
msgid "The second query is efficient and does not require a table join."
msgstr ""
"La seconde requête est particulièrement efficace. Aucune jointure n'est "
"nécessaire ! "

#. Tag: para
#, no-c-format
msgid ""
"Properties of composite identifiers can also be used. Consider the following "
"example where <literal>Person</literal> has composite identifiers consisting "
"of <literal>country</literal> and <literal>medicareNumber</literal>:"
msgstr ""
"Les propriétés d'identifiants composites peuvent aussi être utilisées. "
"Supposez que <literal>Person</literal> ait un identifiant composite composé "
"de  <literal>country</literal> et <literal>medicareNumber</literal>. "

#. Tag: para
#, no-c-format
msgid "Once again, the second query does not require a table join."
msgstr ""
"Une fois de plus, la seconde requête ne nécessite pas de jointure de table. "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"See <xref linkend=\"queryhql-identifier-property\" /> for more information "
"regarding referencing identifier properties)"
msgstr ""
"Voir <xref linkend=\"queryhql-identifier-property\" /> pour obtenir des "
"informations supplémentaires sur le référencement de propriétés "
"d'identifiant."

#. Tag: para
#, no-c-format
msgid ""
"The special property <literal>class</literal> accesses the discriminator "
"value of an instance in the case of polymorphic persistence. A Java class "
"name embedded in the where clause will be translated to its discriminator "
"value."
msgstr ""
"De même, la propriété spéciale <literal>class</literal> accède à la valeur "
"discriminante d'une instance dans le cas d'une persistance polymorphique. Le "
"nom d'une classe Java incorporée dans la clause where sera traduite par sa "
"valeur discriminante. "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can also use components or composite user types, or properties of said "
"component types. See <xref linkend=\"queryhql-components\" /> for more "
"information."
msgstr ""
"Vous pouvez également utiliser des composants ou des types d'utilisateur "
"composites, ou des propriétés de types composant. Consultez <xref linkend="
"\"queryhql-components\" /> pour plus d'informations. "

#. Tag: para
#, no-c-format
msgid ""
"An \"any\" type has the special properties <literal>id</literal> and "
"<literal>class</literal> that allows you to express a join in the following "
"way (where <literal>AuditLog.item</literal> is a property mapped with "
"<literal>&lt;any&gt;</literal>):"
msgstr ""
"Un type \"any\" possède les propriétés particulières <literal>id</literal> "
"et <literal>class</literal>, qui nous permettent d'exprimer une jointure de "
"la manière suivante (là où <literal>AuditLog.item</literal> est une "
"propriété mappée avec <literal>&lt;any&gt;</literal>) :"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>log.item.class</literal> and <literal>payment.class</literal> "
"would refer to the values of completely different database columns in the "
"above query."
msgstr ""
"Dans la requête précédente, notez que <literal>log.item.class</literal> et "
"<literal>payment.class</literal> feraient référence à des valeurs de "
"colonnes de la base de données complètement différentes. "

#. Tag: title
#, no-c-format
msgid "Expressions"
msgstr "Expressions"

#. Tag: para
#, no-c-format
msgid ""
"Expressions used in the <literal>where</literal> clause include the "
"following:"
msgstr ""
"Les expressions permises dans la clause <literal>where</literal> incluent :"

#. Tag: para
#, no-c-format
msgid "mathematical operators: <literal>+, -, *, /</literal>"
msgstr "opérateurs mathématiques : <literal>+, -, *, /</literal> "

#. Tag: para
#, no-c-format
msgid ""
"binary comparison operators: <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</"
"literal>"
msgstr ""
"opérateurs de comparaison binaire : <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, "
"like</literal>"

#. Tag: para
#, no-c-format
msgid "logical operations <literal>and, or, not</literal>"
msgstr "opérations logiques : <literal>and, or, not</literal>"

#. Tag: para
#, no-c-format
msgid "Parentheses <literal>( )</literal> that indicates grouping"
msgstr "Parenthèses <literal>( )</literal>, indiquant un regroupement "

#. Tag: para
#, no-c-format
msgid ""
"<literal>in</literal>, <literal>not in</literal>, <literal>between</"
"literal>, <literal>is null</literal>, <literal>is not null</literal>, "
"<literal>is empty</literal>, <literal>is not empty</literal>, "
"<literal>member of</literal> and <literal>not member of</literal>"
msgstr ""
"<literal>in</literal>, <literal>not in</literal>, <literal>between</"
"literal>, <literal>is null</literal>, <literal>is not null</literal>, "
"<literal>is empty</literal>, <literal>is not empty</literal>, "
"<literal>member of</literal> et <literal>not member of</literal>"

#. Tag: para
#, no-c-format
msgid ""
"\"Simple\" case, <literal>case ... when ... then ... else ... end</literal>, "
"and \"searched\" case, <literal>case when ... then ... else ... end</literal>"
msgstr ""
"Cas simple <literal>case ... when ... then ... else ... end</literal>, et "
"cas \"searched\", <literal>case when ... then ... else ... end</literal>"

#. Tag: para
#, no-c-format
msgid ""
"string concatenation <literal>...||...</literal> or <literal>concat(...,...)"
"</literal>"
msgstr ""
"concaténation de chaîne de caractères <literal>...||...</literal> ou "
"<literal>concat(...,...)</literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>current_date()</literal>, <literal>current_time()</literal>, and "
"<literal>current_timestamp()</literal>"
msgstr ""
"<literal>current_date()</literal>, <literal>current_time()</literal>, and "
"<literal>current_timestamp()</literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour"
"(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, "
"and <literal>year(...)</literal>"
msgstr ""
"<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour"
"(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, "
"<literal>year(...)</literal>,"

#. Tag: para
#, no-c-format
msgid ""
"Any function or operator defined by EJB-QL 3.0: <literal>substring(), trim"
"(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()"
"</literal>"
msgstr ""
"N'importe quelle fonction ou opérateur défini par EJB-QL 3.0 : "
"<literal>substring(), trim(), lower(), upper(), length(), locate(), abs(), "
"sqrt(), bit_length(), mod()</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>coalesce()</literal> and <literal>nullif()</literal>"
msgstr "<literal>coalesce()</literal> et <literal>nullif()</literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>str()</literal> for converting numeric or temporal values to a "
"readable string"
msgstr ""
"<literal>str()</literal> pour convertir des valeurs numériques ou "
"temporelles vers une chaîne de caractères lisible"

#. Tag: para
#, no-c-format
msgid ""
"<literal>cast(... as ...)</literal>, where the second argument is the name "
"of a Hibernate type, and <literal>extract(... from ...)</literal> if ANSI "
"<literal>cast()</literal> and <literal>extract()</literal> is supported by "
"the underlying database"
msgstr ""
"<literal>cast(... as ...)</literal>, où le second argument est le nom d'un "
"type Hibernate, et <literal>extract(... from ...)</literal> si le "
"<literal>cast()</literal> ANSI et <literal>extract()</literal> sont "
"supportés par la base de données sous-jacente"

#. Tag: para
#, no-c-format
msgid ""
"the HQL <literal>index()</literal> function, that applies to aliases of a "
"joined indexed collection"
msgstr ""
"La fonction HQL <literal>index()</literal>, qui s'applique aux alias d'une "
"collection indexée jointe"

#. Tag: para
#, no-c-format
msgid ""
"HQL functions that take collection-valued path expressions: <literal>size(), "
"minelement(), maxelement(), minindex(), maxindex()</literal>, along with the "
"special <literal>elements()</literal> and <literal>indices</literal> "
"functions that can be quantified using <literal>some, all, exists, any, in</"
"literal>."
msgstr ""
"Les fonctions HQL qui prennent des expressions de chemin représentant des "
"collections : <literal>size(), minelement(), maxelement(), minindex(), "
"maxindex()</literal>, ainsi que les fonctions particulières <literal>elements"
"()</literal> et <literal>indices</literal> qui peuvent être quantifiées en "
"utilisant <literal>some, all, exists, any, in</literal>. "

#. Tag: para
#, no-c-format
msgid ""
"Any database-supported SQL scalar function like <literal>sign()</literal>, "
"<literal>trunc()</literal>, <literal>rtrim()</literal>, and <literal>sin()</"
"literal>"
msgstr ""
"N'importe quelle fonction scalaire SQL supportée par la base de données "
"comme <literal>sign()</literal>, <literal>trunc()</literal>, <literal>rtrim()"
"</literal>, et <literal>sin()</literal>"

#. Tag: para
#, no-c-format
msgid "JDBC-style positional parameters <literal>?</literal>"
msgstr "Les paramètres de position de JDBC <literal>?</literal>"

#. Tag: para
#, no-c-format
msgid ""
"named parameters <literal>:name</literal>, <literal>:start_date</literal>, "
"and <literal>:x1</literal>"
msgstr ""
"paramètres nommés <literal>:name</literal>, <literal>:start_date</literal>, "
"et <literal>:x1</literal>"

#. Tag: para
#, no-c-format
msgid ""
"SQL literals <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E"
"+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"
msgstr ""
"SQL textuel <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E"
"+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"

#. Tag: para
#, no-c-format
msgid ""
"Java <literal>public static final</literal> constants <literal>eg.Color."
"TABBY</literal>"
msgstr ""
"Constantes Java <literal>public static final</literal><literal>eg.Color."
"TABBY</literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>in</literal> and <literal>between</literal> can be used as follows:"
msgstr ""
"<literal>in</literal> et <literal>between</literal> peuvent être utilisés "
"comme suit : "

#. Tag: para
#, no-c-format
msgid "The negated forms can be written as follows:"
msgstr "Les formes négatives peuvent être écrites ainsi :"

#. Tag: para
#, no-c-format
msgid ""
"Similarly, <literal>is null</literal> and <literal>is not null</literal> can "
"be used to test for null values."
msgstr ""
"De même, <literal>is null</literal> et <literal>is not null</literal> "
"peuvent être utilisés pour tester les valeurs nulles."

#. Tag: para
#, no-c-format
msgid ""
"Booleans can be easily used in expressions by declaring HQL query "
"substitutions in Hibernate configuration:"
msgstr ""
"Les booléens peuvent être facilement utilisés en déclarant les substitutions "
"de requêtes HQL dans la configuration Hibernate : "

#. Tag: para
#, no-c-format
msgid ""
"This will replace the keywords <literal>true</literal> and <literal>false</"
"literal> with the literals <literal>1</literal> and <literal>0</literal> in "
"the translated SQL from this HQL:"
msgstr ""
"Ce qui remplacera les mots clés <literal>true</literal> et <literal>false</"
"literal> par <literal>1</literal> et <literal>0</literal> dans la traduction "
"SQL du HQL suivant :"

#. Tag: para
#, no-c-format
msgid ""
"You can test the size of a collection with the special property "
"<literal>size</literal> or the special <literal>size()</literal> function."
msgstr ""
"Vous pouvez tester la taille d'une collection par la propriété particulière  "
"<literal>size</literal>, ou la fonction spéciale <literal>size()</literal>. "

#. Tag: para
#, no-c-format
msgid ""
"For indexed collections, you can refer to the minimum and maximum indices "
"using <literal>minindex</literal> and <literal>maxindex</literal> functions. "
"Similarly, you can refer to the minimum and maximum elements of a collection "
"of basic type using the <literal>minelement</literal> and "
"<literal>maxelement</literal> functions. For example:"
msgstr ""
"Pour les collections indexées, vous pouvez faire référence aux indices "
"minimum et maximum en utilisant les fonctions <literal>minindex</literal> et "
"<literal>maxindex</literal>. De manière similaire, vous pouvez faire "
"référence aux éléments minimum et maximum d'une collection de type basique "
"en utilisant les fonctions <literal>minelement</literal> et "
"<literal>maxelement</literal>. Par exemple : "

#. Tag: para
#, no-c-format
msgid ""
"The SQL functions <literal>any, some, all, exists, in</literal> are "
"supported when passed the element or index set of a collection "
"(<literal>elements</literal> and <literal>indices</literal> functions) or "
"the result of a subquery (see below):"
msgstr ""
"Les fonctions SQL <literal>any, some, all, exists, in</literal> sont "
"supportées quand l'élément ou l'ensemble des indexes d'une collection (les "
"fonctions <literal>elements</literal> et <literal>indices</literal>) ou le "
"résultat d'une sous requête sont passés (voir ci dessous) :"

#. Tag: para
#, no-c-format
msgid ""
"Note that these constructs - <literal>size</literal>, <literal>elements</"
"literal>, <literal>indices</literal>, <literal>minindex</literal>, "
"<literal>maxindex</literal>, <literal>minelement</literal>, "
"<literal>maxelement</literal> - can only be used in the where clause in "
"Hibernate3."
msgstr ""
"Notez que l'écriture de - <literal>size</literal>, <literal>elements</"
"literal>, <literal>indices</literal>, <literal>minindex</literal>, "
"<literal>maxindex</literal>, <literal>minelement</literal>, "
"<literal>maxelement</literal> - peut seulement être utilisée dans la clause "
"where dans Hibernate3. "

#. Tag: para
#, no-c-format
msgid ""
"Elements of indexed collections (arrays, lists, and maps) can be referred to "
"by index in a where clause only:"
msgstr ""
"Les éléments de collections indexées (arrays, lists, maps) peuvent être "
"référencés via index dans une clause where seulement :"

#. Tag: para
#, no-c-format
msgid ""
"The expression inside <literal>[]</literal> can even be an arithmetic "
"expression:"
msgstr ""
"L'expression entre <literal>[]</literal> peut même être une expression "
"arithmétique :"

#. Tag: para
#, no-c-format
msgid ""
"HQL also provides the built-in <literal>index()</literal> function for "
"elements of a one-to-many association or collection of values."
msgstr ""
"HQL propose aussi une fonction <literal>index()</literal> interne, pour les "
"éléments d'une association un-à-plusieurs ou d'une collection de valeurs."

#. Tag: para
#, no-c-format
msgid "Scalar SQL functions supported by the underlying database can be used:"
msgstr ""
"Les fonctions SQL scalaires supportées par la base de données utilisée "
"peuvent être utilisées :"

#. Tag: para
#, no-c-format
msgid ""
"Consider how much longer and less readable the following query would be in "
"SQL:"
msgstr ""
"Si vous n'êtes pas encore convaincu par tout cela, imaginez la taille et "
"l'illisibilité qui caractériseraient la requête suivante en SQL :"

#. Tag: para
#, no-c-format
msgid "<emphasis>Hint:</emphasis> something like"
msgstr "<emphasis>Un indice :</emphasis> cela donne quelque chose comme"

#. Tag: title
#, no-c-format
msgid "The order by clause"
msgstr "La clause order by"

#. Tag: para
#, no-c-format
msgid ""
"The list returned by a query can be ordered by any property of a returned "
"class or components:"
msgstr ""
"La liste retournée par la requête peut être triée par n'importe quelle "
"propriété de la classe ou des composants retournés : "

#. Tag: para
#, no-c-format
msgid ""
"The optional <literal>asc</literal> or <literal>desc</literal> indicate "
"ascending or descending order respectively."
msgstr ""
"Le mot optionnel <literal>asc</literal> ou <literal>desc</literal> indique "
"respectivement si le tri doit être croissant ou décroissant."

#. Tag: title
#, no-c-format
msgid "The group by clause"
msgstr "La clause group by"

#. Tag: para
#, no-c-format
msgid ""
"A query that returns aggregate values can be grouped by any property of a "
"returned class or components:"
msgstr ""
"Si la requête retourne des valeurs agrégées, celles-ci peuvent être groupées "
"par propriété d'une classe retournée ou par des composants : "

#. Tag: para
#, no-c-format
msgid "A <literal>having</literal> clause is also allowed."
msgstr "Une clause <literal>having</literal> est aussi permise."

#. Tag: para
#, no-c-format
msgid ""
"SQL functions and aggregate functions are allowed in the <literal>having</"
"literal> and <literal>order by</literal> clauses if they are supported by "
"the underlying database (i.e., not in MySQL)."
msgstr ""
"Les fonctions SQL et les fonctions d'agrégat sont permises dans les clauses "
"<literal>having</literal> et <literal>order by</literal>, si elles sont "
"prises en charge par la base de données sous-jacente (ce que ne fait pas "
"MySQL par exemple). "

#. Tag: para
#, no-c-format
msgid ""
"Neither the <literal>group by</literal> clause nor the <literal>order by</"
"literal> clause can contain arithmetic expressions. Hibernate also does not "
"currently expand a grouped entity, so you cannot write <literal>group by "
"cat</literal> if all properties of <literal>cat</literal> are non-"
"aggregated. You have to list all non-aggregated properties explicitly."
msgstr ""
"Notez que ni la clause <literal>group by</literal> ni la clause "
"<literal>order by</literal> ne peuvent contenir d'expressions arithmétiques. "
"Notez aussi qu'Hibernate ne développe pas actuellement une entité faisant "
"partie du regroupement, donc vous ne pouvez pas écrire <literal>group by "
"cat</literal> si toutes les propriétés de <literal>cat</literal> sont non-"
"agrégées. Vous devez lister toutes les propriétés non-agrégées explicitement."

#. Tag: title
#, no-c-format
msgid "Subqueries"
msgstr "Sous-requêtes"

#. Tag: para
#, no-c-format
msgid ""
"For databases that support subselects, Hibernate supports subqueries within "
"queries. A subquery must be surrounded by parentheses (often by an SQL "
"aggregate function call). Even correlated subqueries (subqueries that refer "
"to an alias in the outer query) are allowed."
msgstr ""
"Pour les bases de données supportant les sous-selects, Hibernate supporte "
"les sous requêtes dans les requêtes. Une sous-requête doit être entre "
"parenthèses (souvent pour un appel à une fonction d'agrégation SQL). Même "
"les sous-requêtes corrélées (celles qui font référence à un alias de la "
"requête principale) sont supportées."

#. Tag: para
#, no-c-format
msgid "Note that HQL subqueries can occur only in the select or where clauses."
msgstr ""
"Notez que les sous-requêtes HQL peuvent survenir uniquement dans les clauses "
"select ou where. "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Note that subqueries can also utilize <literal>row value constructor</"
"literal> syntax. See <xref linkend=\"queryhql-tuple\" /> for more "
"information."
msgstr ""
"Notez que les sous-requêtes peuvent également utiliser la syntaxe "
"<literal>row value constructor</literal>. Pour plus d'informations, "
"consultez <xref linkend=\"queryhql-tuple\" />."

#. Tag: title
#, no-c-format
msgid "HQL examples"
msgstr "Exemples HQL"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate queries can be quite powerful and complex. In fact, the power of "
"the query language is one of Hibernate's main strengths. The following "
"example queries are similar to queries that have been used on recent "
"projects. Please note that most queries you will write will be much simpler "
"than the following examples."
msgstr ""
"Les requêtes Hibernate peuvent être relativement puissantes et complexes. En "
"fait, la puissance du langage d'interrogation est l'un des arguments "
"principaux de vente de Hibernate. Voici quelques exemples très similaires "
"aux requêtes que nous avons utilisées lors d'un récent projet. Notez que la "
"plupart des requêtes que vous écrirez seront plus simples que les exemples "
"qui suivent."

#. Tag: para
#, no-c-format
msgid ""
"The following query returns the order id, number of items, the given minimum "
"total value and the total value of the order for all unpaid orders for a "
"particular customer. The results are ordered by total value. In determining "
"the prices, it uses the current catalog. The resulting SQL query, against "
"the <literal>ORDER</literal>, <literal>ORDER_LINE</literal>, "
"<literal>PRODUCT</literal>, <literal>CATALOG</literal> and <literal>PRICE</"
"literal> tables has four inner joins and an (uncorrelated) subselect."
msgstr ""
"La requête suivante retourne l'id de commande, le nombre d'articles et la "
"valeur totale de la commande pour toutes les commandes non payées d'un "
"client particulier pour une valeur totale minimum donnée, ces résultats "
"étant triés par la valeur totale. La requête SQL générée sur les tables "
"<literal>ORDER</literal>, <literal>ORDER_LINE</literal>, <literal>PRODUCT</"
"literal>, <literal>CATALOG</literal> et <literal>PRICE</literal> est "
"composée de quatre jointures internes ainsi que d'un sous-select (non "
"corrélé)."

#. Tag: para
#, no-c-format
msgid ""
"What a monster! Actually, in real life, I'm not very keen on subqueries, so "
"my query was really more like this:"
msgstr ""
"Quel monstre ! En principe, dans des situations réelles, nous n'approuvons "
"pas les sous-requêtes, notre requête ressemblait donc plutôt à ce qui suit :"

#. Tag: para
#, no-c-format
msgid ""
"The next query counts the number of payments in each status, excluding all "
"payments in the <literal>AWAITING_APPROVAL</literal> status where the most "
"recent status change was made by the current user. It translates to an SQL "
"query with two inner joins and a correlated subselect against the "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal> and "
"<literal>PAYMENT_STATUS_CHANGE</literal> tables."
msgstr ""
"La requête suivante compte le nombre de paiements pour chaque statut, en "
"excluant tout paiement dans le statut <literal>AWAITING_APPROVAL</literal> "
"où le changement de statut le plus récent à été fait par l'utilisateur "
"courant. En SQL, cette requête effectue deux jointures internes et un sous-"
"select corrélé sur les tables <literal>PAYMENT</literal>, "
"<literal>PAYMENT_STATUS</literal> et <literal>PAYMENT_STATUS_CHANGE</"
"literal>."

#. Tag: para
#, no-c-format
msgid ""
"If the <literal>statusChanges</literal> collection was mapped as a list, "
"instead of a set, the query would have been much simpler to write."
msgstr ""
"Si nous avions mappé la collection <literal>statusChanges</literal> comme "
"une liste, au lieu d'un ensemble, la requête aurait été plus facile à "
"écrire. "

#. Tag: para
#, no-c-format
msgid ""
"The next query uses the MS SQL Server <literal>isNull()</literal> function "
"to return all the accounts and unpaid payments for the organization to which "
"the current user belongs. It translates to an SQL query with three inner "
"joins, an outer join and a subselect against the <literal>ACCOUNT</literal>, "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal>, "
"<literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> and "
"<literal>ORG_USER</literal> tables."
msgstr ""
"La prochaine requête utilise la fonction de serveur MS SQL <literal>isNull()"
"</literal> pour retourner tous les comptes et paiements impayés pour "
"l'organisation à laquelle l'utilisateur courant appartient. Elle est "
"traduite en SQL par trois jointures internes, une jointure externe ainsi "
"qu'un sous-select sur les tables <literal>ACCOUNT</literal>, "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal>, "
"<literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> et "
"<literal>ORG_USER</literal>."

#. Tag: para
#, no-c-format
msgid ""
"For some databases, we would need to do away with the (correlated) subselect."
msgstr ""
"Pour certaines bases de données, nous devons éliminer le sous-select "
"(corrélé)."

#. Tag: title
#, no-c-format
msgid "Bulk update and delete"
msgstr "Nombreuses mises à jour et suppressions "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"HQL now supports <literal>update</literal>, <literal>delete</literal> and "
"<literal>insert ... select ...</literal> statements. See <xref linkend="
"\"batch-direct\" /> for more information."
msgstr ""
"HQL supporte maintenant les expressions <literal>update</literal>, "
"<literal>delete</literal> et <literal>insert ... select ...</literal>. Voir "
"<xref linkend=\"batch-direct\" /> pour des informations plus détaillées."

#. Tag: title
#, no-c-format
msgid "Tips &amp; Tricks"
msgstr "Trucs &amp; Astuces"

#. Tag: para
#, no-c-format
msgid "You can count the number of query results without returning them:"
msgstr ""
"Vous pouvez compter le nombre de résultats d'une requête sans les "
"retourner : "

#. Tag: para
#, no-c-format
msgid "To order a result by the size of a collection, use the following query:"
msgstr ""
"Pour trier les résultats par la taille d'une collection, utilisez la requête "
"suivante :"

#. Tag: para
#, no-c-format
msgid ""
"If your database supports subselects, you can place a condition upon "
"selection size in the where clause of your query:"
msgstr ""
"Si votre base de données supporte les sous-selects, vous pouvez placer des "
"conditions sur la taille de la sélection dans la clause where de votre "
"requête :"

#. Tag: para
#, no-c-format
msgid "If your database does not support subselects, use the following query:"
msgstr ""
"Si votre base de données ne supporte pas les sous-selects, utilisez la "
"requête suivante : "

#. Tag: para
#, no-c-format
msgid ""
"As this solution cannot return a <literal>User</literal> with zero messages "
"because of the inner join, the following form is also useful:"
msgstr ""
"Cette solution ne peut pas retourner un <literal>User</literal> avec zéro "
"message à cause de la jointure interne, la forme suivante peut donc être "
"utile : "

#. Tag: para
#, no-c-format
msgid "Properties of a JavaBean can be bound to named query parameters:"
msgstr ""
"Les propriétés d'un JavaBean peuvent être injectées dans les paramètres "
"nommés d'une requête :"

#. Tag: para
#, no-c-format
msgid ""
"Collections are pageable by using the <literal>Query</literal> interface "
"with a filter:"
msgstr ""
"Les collections sont paginables via l'utilisation de l'interface "
"<literal>Query</literal> avec un filtre :"

#. Tag: para
#, no-c-format
msgid "Collection elements can be ordered or grouped using a query filter:"
msgstr ""
"Les éléments d'une collection peuvent être triés ou groupés en utilisant un "
"filtre de requête : "

#. Tag: para
#, no-c-format
msgid "You can find the size of a collection without initializing it:"
msgstr "Vous pouvez récupérer la taille d'une collection sans l'initialiser :"

#. Tag: title
#, no-c-format
msgid "Components"
msgstr "Composants"

#. Tag: para
#, no-c-format
msgid ""
"Components can be used similarly to the simple value types that are used in "
"HQL queries. They can appear in the <literal>select</literal> clause as "
"follows:"
msgstr ""
"Les composants peuvent être utilisés dans presque tous les cas comme les "
"types de valeur dans les requêtes HQL. Ils peuvent apparaître dans la clause "
"<literal>select</literal> comme ce qui suit :"

#. Tag: para
#, no-c-format
msgid ""
"where the Person's name property is a component. Components can also be used "
"in the <literal>where</literal> clause:"
msgstr ""
"où la propriété de nom de Person est un composant. Des composants peuvent "
"aussi être utilisés dans la clause <literal>where</literal> :"

#. Tag: para
#, no-c-format
msgid "Components can also be used in the <literal>order by</literal> clause:"
msgstr ""
"Des composants peuvent être utilisés dans la clause <literal>order by</"
"literal> :"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Another common use of components is in <link linkend=\"queryhql-tuple\">row "
"value constructors</link>."
msgstr ""
"Voici encore un usage commun des composants <xref linkend=\"queryhql-tuple"
"\" />."

#. Tag: title
#, no-c-format
msgid "Row value constructor syntax"
msgstr "Syntaxe des constructeurs de valeur de ligne"

#. Tag: para
#, no-c-format
msgid ""
"HQL supports the use of ANSI SQL <literal>row value constructor</literal> "
"syntax, sometimes referred to AS <literal>tuple</literal> syntax, even "
"though the underlying database may not support that notion. Here, we are "
"generally referring to multi-valued comparisons, typically associated with "
"components. Consider an entity Person which defines a name component:"
msgstr ""
"HQL supporte l'utilisation de la syntaxe <literal>row value constructor</"
"literal> SQL ANSI (aussi appelée syntaxe <literal>tuple</literal>), bien que "
"la base de données sous-jacente ne supporte pas nécessairement cette notion. "
"Là, nous faisons généralement référence à des comparaisons multi-valuées, "
"typiquement associées à des composants. Considérez une entité Person qui "
"définit un composant de nom :"

#. Tag: para
#, no-c-format
msgid ""
"That is valid syntax although it is a little verbose. You can make this more "
"concise by using <literal>row value constructor</literal> syntax:"
msgstr ""
"Voici une syntaxe valide, bien que quelque peu fastidieuse. Pour la rendre "
"plus concise, utilisez la syntaxe <literal>row value constructor</literal> :"

#. Tag: para
#, no-c-format
msgid ""
"It can also be useful to specify this in the <literal>select</literal> "
"clause:"
msgstr ""
"Il est utile de spécifier cela dans la clause <literal>select</literal> :"

#. Tag: para
#, no-c-format
msgid ""
"Using <literal>row value constructor</literal> syntax can also be beneficial "
"when using subqueries that need to compare against multiple values:"
msgstr ""
"Alternativement, utiliser la syntaxe <literal>row value constructor</"
"literal> peut être avantageux quand vous utilisez des sous-requêtes "
"nécessitant une comparaison avec des valeurs multiples : "

#. Tag: para
#, no-c-format
msgid ""
"One thing to consider when deciding if you want to use this syntax, is that "
"the query will be dependent upon the ordering of the component sub-"
"properties in the metadata."
msgstr ""
"Si vous décidez d'utiliser cette syntaxe, il vous faudra prendre en "
"considération le fait que la requête sera dépendante de la commande des sous-"
"propriétés du composant dans les métadonnées. "

#, fuzzy
#~ msgid "left outer join"
#~ msgstr "<literal>left outer join</literal> (jointure ouverte par la gauche)"

#, fuzzy
#~ msgid "right outer join"
#~ msgstr ""
#~ "<literal>right outer join</literal> (jointure ouverte par la droite)"
