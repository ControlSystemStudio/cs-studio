# translation of transactions.po to
# Michael H. Smith <mhideo@redhat.com>, 2007.
# Angela Garcia <agarcia@redhat.com>, 2009, 2010.
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
msgid ""
msgstr ""
"Project-Id-Version: transactions\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:16\n"
"PO-Revision-Date: 2010-03-15 13:11+1000\n"
"Last-Translator: Angela Garcia <agarcia@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Transactions and Concurrency"
msgstr "Transacciones y concurrencia"

#. Tag: para
#, no-c-format
msgid ""
"The most important point about Hibernate and concurrency control is that it "
"is easy to understand. Hibernate directly uses JDBC connections and JTA "
"resources without adding any additional locking behavior. It is recommended "
"that you spend some time with the JDBC, ANSI, and transaction isolation "
"specification of your database management system."
msgstr ""
"El punto más importante sobre Hibernate y el control de concurrencia es que "
"es fácil de comprender. Hibernate usa directamente conexiones JDBC y "
"recursos JTA sin agregar ningún comportamiento de bloqueo adicional. Le "
"recomendamos bastante que tome algo de tiempo con la especificación de JDBC, "
"ANSI y el aislamiento de transacciones de su sistema de gestión de base de "
"datos. "

#. Tag: para
#, no-c-format
msgid ""
"Hibernate does not lock objects in memory. Your application can expect the "
"behavior as defined by the isolation level of your database transactions. "
"Through <literal>Session</literal>, which is also a transaction-scoped "
"cache, Hibernate provides repeatable reads for lookup by identifier and "
"entity queries and not reporting queries that return scalar values."
msgstr ""
"Hibernate no bloquea objetos en la memoria. Su aplicación puede esperar el "
"comportamiento definido por el nivel de aislamiento de sus transacciones de "
"las bases de datos. Gracias a la <literal>Session</literal>, la cual también "
"es un caché con alcance de transacción, Hibernate proporciona lecturas "
"repetidas para búsquedas del identificador y consultas de entidad y no "
"consultas de reporte que retornan valores escalares."

#. Tag: para
#, no-c-format
msgid ""
"In addition to versioning for automatic optimistic concurrency control, "
"Hibernate also offers, using the <literal>SELECT FOR UPDATE</literal> "
"syntax, a (minor) API for pessimistic locking of rows. Optimistic "
"concurrency control and this API are discussed later in this chapter."
msgstr ""
"Además del versionado del control de concurrencia optimista automático, "
"Hibernate también ofrece una API (menor) para bloqueo pesimista de filas, "
"usando la sintáxis <literal>SELECT FOR UPDATE</literal>. Esta API y el "
"control de concurrencia optimista se discuten más adelante en este capítulo."

#. Tag: para
#, no-c-format
msgid ""
"The discussion of concurrency control in Hibernate begins with the "
"granularity of <literal>Configuration</literal>, <literal>SessionFactory</"
"literal>, and <literal>Session</literal>, as well as database transactions "
"and long conversations."
msgstr ""
"Comenzamos la discusión del control de concurrencia en Hibernate con la "
"granularidad de <literal>Configuration</literal>, <literal>SessionFactory</"
"literal> y <literal>Session</literal>, así como las transacciones de la base "
"de datos y las conversaciones largas."

#. Tag: title
#, no-c-format
msgid "Session and transaction scopes"
msgstr "Ámbitos de sesión y de transacción"

#. Tag: para
#, no-c-format
msgid ""
"A <literal>SessionFactory</literal> is an expensive-to-create, threadsafe "
"object, intended to be shared by all application threads. It is created "
"once, usually on application startup, from a <literal>Configuration</"
"literal> instance."
msgstr ""
"Una <literal>SessionFactory</literal> es un objeto seguro entre hilos y "
"costoso de crear pensado para que todas las hebras de la aplicación lo "
"compartan. Se crea una sola vez, usualmente en el inicio de la aplicación, a "
"partir de una instancia <literal>Configuration</literal>."

#. Tag: para
#, no-c-format
msgid ""
"A <literal>Session</literal> is an inexpensive, non-threadsafe object that "
"should be used once and then discarded for: a single request, a conversation "
"or a single unit of work. A <literal>Session</literal> will not obtain a "
"JDBC <literal>Connection</literal>, or a <literal>Datasource</literal>, "
"unless it is needed. It will not consume any resources until used."
msgstr ""
"Una <literal>Session</literal> es un objeto de bajo costo, inseguro entre "
"hilos que se debe utilizar una sola vez y luego se debe descartar: para un "
"sólo pedido, una sola conversación o una sóla unidad de trabajo. Una "
"<literal>Session</literal> no obtendrá una <literal>Connection</literal> "
"JDBC o un <literal>Datasource</literal> a menos de que sea necesario. No "
"consumirá recursos hasta que se utilice."

#. Tag: para
#, no-c-format
msgid ""
"In order to reduce lock contention in the database, a database transaction "
"has to be as short as possible. Long database transactions will prevent your "
"application from scaling to a highly concurrent load. It is not recommended "
"that you hold a database transaction open during user think time until the "
"unit of work is complete."
msgstr ""
"Una transacción de la base de datos tiene que ser tan corta como sea posible "
"para reducir la contención de bloqueos en la base de datos. Las "
"transacciones largas de la base de datos prevendrán a su aplicación de "
"escalar a una carga altamente concurrente. Por lo tanto, no se recomienda "
"que mantenga una transacción de la base de datos abierta durante el tiempo "
"para pensar del usuario, hasta que la unidad de trabajo se encuentre "
"completa."

#. Tag: para
#, no-c-format
msgid ""
"What is the scope of a unit of work? Can a single Hibernate "
"<literal>Session</literal> span several database transactions, or is this a "
"one-to-one relationship of scopes? When should you open and close a "
"<literal>Session</literal> and how do you demarcate the database transaction "
"boundaries? These questions are addressed in the following sections."
msgstr ""
"¿Cuál es el ámbito de una unidad de trabajo? ¿Puede una sola "
"<literal>Session</literal> de Hibernate extenderse a través de varias "
"transacciones de la base de datos o ésta es una relación uno-a-uno de "
"ámbitos? ¿Cuándo debe abrir y cerrar una <literal>Session</literal>? y ¿cómo "
"demarca los límites de la transacción de la base de datos? En las siguientes "
"secciones abordaremos estas preguntas. "

#. Tag: title
#, no-c-format
msgid "Unit of work"
msgstr "Unidad de trabajo"

#. Tag: para
#, no-c-format
msgid ""
"First, let's define a unit of work. A unit of work is a design pattern "
"described by Martin Fowler as <quote> [maintaining] a list of objects "
"affected by a business transaction and coordinates the writing out of "
"changes and the resolution of concurrency problems. </quote><citation>PoEAA</"
"citation> In other words, its a series of operations we wish to carry out "
"against the database together. Basically, it is a transaction, though "
"fulfilling a unit of work will often span multiple physical database "
"transactions (see <xref linkend=\"transactions-basics-apptx\" />). So really "
"we are talking about a more abstract notion of a transaction. The term "
"\"business transaction\" is also sometimes used in lieu of unit of work."
msgstr ""
"Primero, vamos a definir una unidad de trabajo. Una unidad de trabajo es un "
"patrón de diseño que Martin Fowler describe como <quote> [mantener] una "
"lista de objetos afectados por una transacción empresarial y coordina la "
"escritura de los cambios y la resolución de problemas de concurrencia. </"
"quote><citation>PoEAA</citation> En otras palabras, es una serie de "
"operaciones que deseamos llevar a cabo frente a la base de datos. "
"Básicamente es una transacción, aunque el llevar a cabo una unidad de "
"trabajo con frecuencia abarca múltiples transacciones de la base de datos "
"física (consulte <xref linkend=\"transactions-basics-apptx\"/>). Así que "
"realmente estamos hablando sobre una noción más abstracta de una "
"transacción. El término \"transacción empresarial\" también se utiliza a "
"veces en lugar de unidad de trabajo. "

#. Tag: para
#, no-c-format
msgid ""
"Do not use the <emphasis>session-per-operation</emphasis> antipattern: do "
"not open and close a <literal>Session</literal> for every simple database "
"call in a single thread. The same is true for database transactions. "
"Database calls in an application are made using a planned sequence; they are "
"grouped into atomic units of work. This also means that auto-commit after "
"every single SQL statement is useless in an application as this mode is "
"intended for ad-hoc SQL console work. Hibernate disables, or expects the "
"application server to disable, auto-commit mode immediately. Database "
"transactions are never optional. All communication with a database has to "
"occur inside a transaction. Auto-commit behavior for reading data should be "
"avoided, as many small transactions are unlikely to perform better than one "
"clearly defined unit of work. The latter is also more maintainable and "
"extensible."
msgstr ""
"Primero, no use el antipatrón <emphasis>sesión-por-operación</emphasis>: no "
"abra y cierre una <literal>Session</literal> para cada llamada simple a la "
"base de datos en un solo hilo. Lo mismo aplica para las transacciones de "
"base de datos. Las llamadas a la base de datos en una aplicación se hacen "
"usando una secuencia planeada; estas se agrupan dentro de unidades de "
"trabajo atómicas. Esto también significa que el auto-commit después de cada "
"una de las declaraciones SQL es inútil en una aplicación ya que este modo "
"está pensado para trabajo ad-hoc de consola SQL. Hibernate deshabilita, o "
"espera que el servidor de aplicaciones lo haga, el modo auto-commit "
"inmediatamente. Las transacciones de las bases de datos nunca son "
"opcionales. Toda comunicación con una base de datos tiene que ocurrir dentro "
"de una transacción. El comportamiento auto-commit para leer datos se debe "
"evitar, ya que hay muy poca probabilidad de que las transacciones pequeñas "
"funcionen mejor que una unidad de trabajo definida claramente. La última es "
"mucho más sostenible y extensible."

#. Tag: para
#, no-c-format
msgid ""
"The most common pattern in a multi-user client/server application is "
"<emphasis>session-per-request</emphasis>. In this model, a request from the "
"client is sent to the server, where the Hibernate persistence layer runs. A "
"new Hibernate <literal>Session</literal> is opened, and all database "
"operations are executed in this unit of work. On completion of the work, and "
"once the response for the client has been prepared, the session is flushed "
"and closed. Use a single database transaction to serve the clients request, "
"starting and committing it when you open and close the <literal>Session</"
"literal>. The relationship between the two is one-to-one and this model is a "
"perfect fit for many applications."
msgstr ""
"El patrón más común en una aplicación multiusuario cliente/servidor es "
"<emphasis>sesión-por-petición</emphasis>. En este modelo, una petición del "
"cliente se envia al servidor, en donde se ejecuta la capa de persistencia de "
"Hibernate. Se abre una nueva <literal>Session</literal> de Hibernate y todas "
"las operaciones de la base de datos se ejecutan en esta unidad de trabajo. "
"Una vez completado el trabajo, y una vez se ha preparado la respuesta para "
"el cliente, se limpia la sesión y se cierra. Use una sóla transacción de la "
"base de datos para servir la petición del cliente, dándole inicio y "
"guardándola cuando abre y cierra la <literal>Session</literal>. La relación "
"entre las dos es uno-a-uno y este modelo es a la medida perfecta de muchas "
"aplicaciones."

#. Tag: para
#, no-c-format
msgid ""
"The challenge lies in the implementation. Hibernate provides built-in "
"management of the \"current session\" to simplify this pattern. Start a "
"transaction when a server request has to be processed, and end the "
"transaction before the response is sent to the client. Common solutions are "
"<literal>ServletFilter</literal>, AOP interceptor with a pointcut on the "
"service methods, or a proxy/interception container. An EJB container is a "
"standardized way to implement cross-cutting aspects such as transaction "
"demarcation on EJB session beans, declaratively with CMT. If you use "
"programmatic transaction demarcation, for ease of use and code portability "
"use the Hibernate <literal>Transaction</literal> API shown later in this "
"chapter."
msgstr ""
"El reto se encuentra en la implementación. Hibernate brinda administración "
"incorporada de la \"sesión actual\" para simplificar este patrón. Inicie una "
"transacción cuando se tiene que procesar un pedido del servidor y termine la "
"transacción antes de que se envie la respuesta al cliente. Las soluciones "
"más comunes son <literal>ServletFilter</literal>, un interceptor AOP con un "
"punto de corte en los métodos del servicio o un contenedor proxy/"
"intercepción. Un contenedor EJB es una manera estandarizada de implementar "
"aspectos de doble filo como demarcación de transacción en beans de sesión "
"EJB, declarativamente con CMT. Si decide utilizar la demarcación de "
"transacción programática, use el API <literal>Transaction</literal> de "
"Hibernate de fácil uso y portable que se muestra más adelante en este "
"capítulo."

#. Tag: para
#, no-c-format
msgid ""
"Your application code can access a \"current session\" to process the "
"request by calling <literal>sessionFactory.getCurrentSession()</literal>. "
"You will always get a <literal>Session</literal> scoped to the current "
"database transaction. This has to be configured for either resource-local or "
"JTA environments, see <xref linkend=\"architecture-current-session\" />."
msgstr ""
"Su código de aplicación puede acceder a una \"sesión actual\" para procesar "
"el pedido llamando a <literal>sessionFactory.getCurrentSession()</literal>. Siempre obtendrá una <literal>Session</literal> con ámbito a la transacción "
"de la base de datos actual. Esto tiene que ser configurado para entornos JTA "
"o recursos-locales, consulte <xref linkend=\"architecture-current-session\" />."

#. Tag: para
#, no-c-format
msgid ""
"You can extend the scope of a <literal>Session</literal> and database "
"transaction until the \"view has been rendered\". This is especially useful "
"in servlet applications that utilize a separate rendering phase after the "
"request has been processed. Extending the database transaction until view "
"rendering, is achieved by implementing your own interceptor. However, this "
"will be difficult if you rely on EJBs with container-managed transactions. A "
"transaction will be completed when an EJB method returns, before rendering "
"of any view can start. See the Hibernate website and forum for tips and "
"examples relating to this <emphasis>Open Session in View</emphasis> pattern."
msgstr ""
"Puede extender el ámbito de una <literal>Session</literal> y transacción de "
"la base de datos hasta que \"se ha presentado la vista\". Esto es bastante "
"útil en aplicaciones de servlet que utilizan una fase de entrega separada "
"después de que se ha procesado el pedido. El extender la transacción de la "
"base de datos hasta que la entrega de la vista se encuentre completa es "
"fácil de lograr si implementa su propio interceptor. Sin embargo, no se "
"logra fácilmente si depende de EJBs con transacciones administradas por el "
"contenedor. Una transacción se completará cuando un método EJB retorna, "
"antes de que pueda empezar la entrega de cualquier vista. Vea el sitio web "
"de Hibernate y el foro para encontrar consejos y ejemplos sobre este patrón "
"de <emphasis>sesión abierta en vista</emphasis>."

#. Tag: title
#, no-c-format
msgid "Long conversations"
msgstr "Conversaciones largas"

#. Tag: para
#, no-c-format
msgid ""
"The session-per-request pattern is not the only way of designing units of "
"work. Many business processes require a whole series of interactions with "
"the user that are interleaved with database accesses. In web and enterprise "
"applications, it is not acceptable for a database transaction to span a user "
"interaction. Consider the following example:"
msgstr ""
"El patrón sesión-por-petición no es la única forma de diseñar unidades de "
"trabajo. Muchos procesos empresariales requieren una serie completa de "
"interacciones con el usuario intercaladas con accesos a la base de datos. En "
"aplicaciones empresariales y web no es aceptable que una transacción de la "
"base de datos abarque la interacción de un usuario. Considere el siguiente "
"ejemplo:"

#. Tag: para
#, no-c-format
msgid ""
"The first screen of a dialog opens. The data seen by the user has been "
"loaded in a particular <literal>Session</literal> and database transaction. "
"The user is free to modify the objects."
msgstr ""
"Se abre la primera pantalla de un diálogo. Los datos que ve el usuario han "
"sido cargados en una <literal>Session</literal> en particular y en una "
"transacción de la base de datos. El usuario es libre de modificar los "
"objetos."

#. Tag: para
#, no-c-format
msgid ""
"The user clicks \"Save\" after 5 minutes and expects their modifications to "
"be made persistent. The user also expects that they were the only person "
"editing this information and that no conflicting modification has occurred."
msgstr ""
"El usuario hace click en \"Guardar\" después de 5 minutos y espera que sus "
"modificaciones se hagan persistentes. También espera que él sea la única "
"persona editando esta información y que no ocurra ningún conflicto en la "
"modificación."

#. Tag: para
#, no-c-format
msgid ""
"From the point of view of the user, we call this unit of work a long-running "
"<emphasis>conversation</emphasis> or <emphasis>application transaction</"
"emphasis>. There are many ways to implement this in your application."
msgstr ""
"Desde el punto de vista del usuario, llamamos a esta unidad de trabajo, una "
"larga <emphasis>conversación</emphasis> o <emphasis>transacción de "
"aplicación</emphasis>. Hay muchas formas de implementar esto en su "
"aplicación."

#. Tag: para
#, no-c-format
msgid ""
"A first naive implementation might keep the <literal>Session</literal> and "
"database transaction open during user think time, with locks held in the "
"database to prevent concurrent modification and to guarantee isolation and "
"atomicity. This is an anti-pattern, since lock contention would not allow "
"the application to scale with the number of concurrent users."
msgstr ""
"Una primera implementación ingenua podría mantener abierta la "
"<literal>Session</literal> y la transacción de la base de datos durante el "
"tiempo para pensar del usuario, con bloqueos en la base de datos para "
"prevenir la modificación simultánea y para garantizar el aislamiento y la "
"atomicidad. Esto es un antipatrón, ya que la contención de bloqueo no "
"permitiría a la aplicación escalar con el número de usuarios simultáneos."

#. Tag: para
#, no-c-format
msgid ""
"You have to use several database transactions to implement the conversation. "
"In this case, maintaining isolation of business processes becomes the "
"partial responsibility of the application tier. A single conversation "
"usually spans several database transactions. It will be atomic if only one "
"of these database transactions (the last one) stores the updated data. All "
"others simply read data (for example, in a wizard-style dialog spanning "
"several request/response cycles). This is easier to implement than it might "
"sound, especially if you utilize some of Hibernate's features:"
msgstr ""
"Tiene que usar varias transacciones de la base de datos para implementar la "
"conversación. En este caso, mantener el aislamiento de los procesos "
"empresariales se vuelve una responsabilidad parcial de la capa de la "
"aplicación. Una sóla conversación usualmente abarca varias transacciones de "
"la base de datos. Será atómica si sólo una de estas transacciones de la base "
"de datos (la última) almacena los datos actualizados. Todas las otras "
"simplemente leen datos (por ejemplo, en un diálogo de estilo-asistente "
"abarcando muchos ciclos petición/respuesta). Esto es más fácil de "
"implementar de lo que suena, especialmente si usa las funcionalidades de "
"Hibernate:"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Automatic Versioning</emphasis>: Hibernate can perform automatic "
"optimistic concurrency control for you. It can automatically detect if a "
"concurrent modification occurred during user think time. Check for this at "
"the end of the conversation."
msgstr ""
"<emphasis>Versionado automático</emphasis> - Hibernate puede realizar un "
"control automático de concurrencia optimista por usted .Puede detectar "
"automáticamente si ha ocurrido una modificación simultánea durante el tiempo "
"para pensar del usuario. Chequee esto al final de la conversación. "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Detached Objects</emphasis>: if you decide to use the "
"<emphasis>session-per-request</emphasis> pattern, all loaded instances will "
"be in the detached state during user think time. Hibernate allows you to "
"reattach the objects and persist the modifications. The pattern is called "
"<emphasis>session-per-request-with-detached-objects</emphasis>. Automatic "
"versioning is used to isolate concurrent modifications."
msgstr ""
"<emphasis>Objetos separados</emphasis>: Si decide usar el patrón "
"<emphasis>sesión-por-petición</emphasis>, todas las instancias cargadas "
"estarán en estado separado durante el tiempo para pensar del usuario. "
"Hibernate le permite volver a unir los objetos y hacer persistentes las "
"modificaciones. El patrón se llama <emphasis>sesión-por-petición-con-objetos-"
"separados</emphasis>. Se usa el versionado automático para aislar las "
"modificaciones simultáneas."

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Extended (or Long) Session</emphasis>: the Hibernate "
"<literal>Session</literal> can be disconnected from the underlying JDBC "
"connection after the database transaction has been committed and reconnected "
"when a new client request occurs. This pattern is known as <emphasis>session-"
"per-conversation</emphasis> and makes even reattachment unnecessary. "
"Automatic versioning is used to isolate concurrent modifications and the "
"<literal>Session</literal> will not be allowed to be flushed automatically, "
"but explicitly."
msgstr ""
"<emphasis>Sesión extendida (o larga) </emphasis> - La <literal>Session</"
"literal> de Hibernate puede ser desconectada de la conexión JDBC subyacente "
"después de que haya guardado la transacción de la base de datos y haya "
"reconectado cuando ocurra una nueva petición del cliente. Este patrón se "
"conoce como <emphasis>sesión-por-conversación</emphasis> y hace la re-unión "
"innecesaria. Para aislar las modificaciones simultáneas se usa el versionado "
"automático y usualmente no se permite que se limpie la <literal>Session</"
"literal> automáticamente sino explícitamente."

#. Tag: para
#, no-c-format
msgid ""
"Both <emphasis>session-per-request-with-detached-objects</emphasis> and "
"<emphasis>session-per-conversation</emphasis> have advantages and "
"disadvantages. These disadvantages are discussed later in this chapter in "
"the context of optimistic concurrency control."
msgstr ""
"Tanto la <emphasis>sesión-por-petición-con-objetos-separados</emphasis> como "
"la <emphasis>sesión-por-conversación</emphasis> tienen ventajas y "
"desventajas. Estas desventajas las discutimos más adelante en este capítulo "
"en el contexto del control optimista de concurrencia."

#. Tag: title
#, no-c-format
msgid "Considering object identity"
msgstr "Consideración de la identidad del objeto"

#. Tag: para
#, no-c-format
msgid ""
"An application can concurrently access the same persistent state in two "
"different <literal>Session</literal>s. However, an instance of a persistent "
"class is never shared between two <literal>Session</literal> instances. It "
"is for this reason that there are two different notions of identity:"
msgstr ""
"Una aplicación puede acceder simultáneamente al mismo estado persistente en "
"dos <literal>Session</literal>es diferentes. Sin embargo, una instancia de "
"una clase persistente nunca se comparte entre dos instancias de "
"<literal>Session</literal>. Por lo tanto, existen dos nociones diferentes de "
"identidad: "

#. Tag: term
#, no-c-format
msgid "Database Identity"
msgstr "Identidad de Base de Datos"

#. Tag: para
#, no-c-format
msgid "<literal>foo.getId().equals( bar.getId() )</literal>"
msgstr "<literal>foo.getId().equals( bar.getId() )</literal>"

#. Tag: term
#, no-c-format
msgid "JVM Identity"
msgstr "Identidad JVM"

#. Tag: para
#, no-c-format
msgid "<literal>foo==bar</literal>"
msgstr "<literal>foo==bar</literal>"

#. Tag: para
#, no-c-format
msgid ""
"For objects attached to a <emphasis>particular</emphasis> <literal>Session</"
"literal> (i.e., in the scope of a <literal>Session</literal>), the two "
"notions are equivalent and JVM identity for database identity is guaranteed "
"by Hibernate. While the application might concurrently access the \"same"
"\" (persistent identity) business object in two different sessions, the two "
"instances will actually be \"different\" (JVM identity). Conflicts are "
"resolved using an optimistic approach and automatic versioning at flush/"
"commit time."
msgstr ""
"Para los bjetos unidos a una <literal>Session</literal><emphasis> en "
"particular</emphasis> (por ejemplo, en el ámbito de una <literal>Session</"
"literal>) las dos nociones son equivalentes y la identidad de la MVJ para la "
"identidad de la base de datos se encuentra garantizada por Hibernate. "
"Mientras la aplicación acceda simultáneamente al \"mismo\" objeto "
"empresarial (identidad persistente) en dos sesiones diferentes, las dos "
"instancias serán realmente \"diferentes\" (identidad MVJ). Los conflictos se "
"resuelven usando un enfoque optimista y el versionado automático en tiempo "
"de vaciado/ al guardar."

#. Tag: para
#, no-c-format
msgid ""
"This approach leaves Hibernate and the database to worry about concurrency. "
"It also provides the best scalability, since guaranteeing identity in single-"
"threaded units of work means that it does not need expensive locking or "
"other means of synchronization. The application does not need to synchronize "
"on any business object, as long as it maintains a single thread per "
"<literal>Session</literal>. Within a <literal>Session</literal> the "
"application can safely use <literal>==</literal> to compare objects."
msgstr ""
"Este enfoque deja que Hibernate y la base de datos se preocupen de la "
"concurrencia. Además provee la mejor escalabilidad, ya que garantizando la "
"identidad en unidades de trabajo monohilo no se necesitan bloqueos caros u "
"otros medios de sincronización. La aplicación no necesita sincronizar sobre "
"ningún objeto empresarial, siempre que se mantenga un solo hilo por "
"<literal>Session</literal>. Dentro de una <literal>Session</literal> la "
"aplicación puede usar con seguridad <literal>==</literal> para comparar "
"objetos."

#. Tag: para
#, no-c-format
msgid ""
"However, an application that uses <literal>==</literal> outside of a "
"<literal>Session</literal> might produce unexpected results. This might "
"occur even in some unexpected places. For example, if you put two detached "
"instances into the same <literal>Set</literal>, both might have the same "
"database identity (i.e., they represent the same row). JVM identity, "
"however, is by definition not guaranteed for instances in a detached state. "
"The developer has to override the <literal>equals()</literal> and "
"<literal>hashCode()</literal> methods in persistent classes and implement "
"their own notion of object equality. There is one caveat: never use the "
"database identifier to implement equality. Use a business key that is a "
"combination of unique, usually immutable, attributes. The database "
"identifier will change if a transient object is made persistent. If the "
"transient instance (usually together with detached instances) is held in a "
"<literal>Set</literal>, changing the hashcode breaks the contract of the "
"<literal>Set</literal>. Attributes for business keys do not have to be as "
"stable as database primary keys; you only have to guarantee stability as "
"long as the objects are in the same <literal>Set</literal>. See the "
"Hibernate website for a more thorough discussion of this issue. Please note "
"that this is not a Hibernate issue, but simply how Java object identity and "
"equality has to be implemented."
msgstr ""
"Sin embargo, una aplicación que usa <literal>==</literal> fuera de una "
"<literal>Session</literal>, podría ver resultados inesperados. Esto podría "
"ocurrir incluso en sitios algo inesperados. Por ejemplo, si pone dos "
"instancias separadas dentro del mismo <literal>Set</literal> ambas podrían "
"tener la misma identidad de la base de datos (por ejemplo, representar la "
"misma fila). Sin embargo, la identidad MVJ, por definición, no está "
"garantizada para las instancias en estado separado. El desarrollador tiene "
"que sobrescribir los métodos <literal>equals()</literal> y <literal>hashCode"
"()</literal> en las clases persistentes e implementar su propia noción de "
"igualdad de objetos. Hay una advertencia: nunca use el identificador de la "
"base de datos para implementar la igualdad. Use una clave de negocio, una "
"combinación de atributos únicos, usualmente inmutables. El identificador de "
"la base de datos cambiará si un objeto transitorio es hecho persistente. Si "
"la instancia transitoria (usualmente junto a las instancias separadas) es "
"mantenida en un <literal>Set</literal>, cambiar el código hash rompe el "
"contrato del <literal>Set</literal>. Los atributos para las claves "
"empresariales no tienen que ser tan estables como las claves principales de "
"la base de datos, sólo tiene que garantizar estabilidad en tanto los objetos "
"estén en el mismo <literal>Set</literal>. Mire el sitio web de Hibernate "
"para obetener una discusión más profunda de este tema. Note también que éste "
"no es problema de Hibernate, sino que simplemente se tiene que implementar "
"la identidad y la igualdad de los objetos Java."

#. Tag: title
#, no-c-format
msgid "Common issues"
msgstr "Temas comúnes"

#. Tag: para
#, no-c-format
msgid ""
"Do not use the anti-patterns <emphasis>session-per-user-session</emphasis> "
"or <emphasis>session-per-application</emphasis> (there are, however, rare "
"exceptions to this rule). Some of the following issues might also arise "
"within the recommended patterns, so ensure that you understand the "
"implications before making a design decision:"
msgstr ""
"No use los antipatrones <emphasis>sesión-por-sesión-de-usuario</emphasis> o "
"<emphasis>sesión-por-aplicación</emphasis> (hay excepciones raras a esta "
"regla). Algunos de los siguientes temas también podrían aparecer con los "
"patrones recomendados así que asegúrese de que entiende las implicaciones "
"antes de tomar una decisión de diseño:"

#. Tag: para
#, no-c-format
msgid ""
"A <literal>Session</literal> is not thread-safe. Things that work "
"concurrently, like HTTP requests, session beans, or Swing workers, will "
"cause race conditions if a <literal>Session</literal> instance is shared. If "
"you keep your Hibernate <literal>Session</literal> in your "
"<literal>HttpSession</literal> (this is discussed later in the chapter), you "
"should consider synchronizing access to your Http session. Otherwise, a user "
"that clicks reload fast enough can use the same <literal>Session</literal> "
"in two concurrently running threads."
msgstr ""
"Una <literal>Session</literal> no es segura entre hilos. Las cosas que "
"funcionan de manera simultánea, como las peticiones HTTP, beans de sesión, o "
"workers de Swing, provocarán condiciones de competencia si una instancia de "
"<literal>Session</literal> se comparte. Si guarda su <literal>Session</"
"literal> de Hibernate en su <literal>HttpSession</literal> (se discute más "
"adelante), debe considerar el sincronizar el acceso a su sesión HTTP. De "
"otro modo, un usuario que hace click lo suficientemente rápido puede llegar "
"a usar la misma <literal>Session</literal> en dos hilos ejecutándose "
"simultáneamente."

#. Tag: para
#, no-c-format
msgid ""
"An exception thrown by Hibernate means you have to rollback your database "
"transaction and close the <literal>Session</literal> immediately (this is "
"discussed in more detail later in the chapter). If your <literal>Session</"
"literal> is bound to the application, you have to stop the application. "
"Rolling back the database transaction does not put your business objects "
"back into the state they were at the start of the transaction. This means "
"that the database state and the business objects will be out of sync. "
"Usually this is not a problem, because exceptions are not recoverable and "
"you will have to start over after rollback anyway."
msgstr ""
"Una excepción lanzada por Hibernate significa que tiene que deshacer su "
"transacción de la base de datos y cerrar la <literal>Session</literal> "
"inmediatamente (se discute en más detalle más adelante en este capítulo). Si "
"su <literal>Session</literal> está vinculada a la aplicación, tiene que "
"parar la aplicación. Deshacer la transacción de la base de datos no pone a "
"sus objetos de vuelta al estado en que estaban al comienzo de la "
"transacción. Esto significa que el estado de la base de datos y los objetos "
"empreariales quedan fuera de sincronía. Usualmente esto no es un problema, "
"pues las excepciones no son recuperables y tendrá que volver a comenzar "
"después de deshacer de todos modos."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>Session</literal> caches every object that is in a persistent "
"state (watched and checked for dirty state by Hibernate). If you keep it "
"open for a long time or simply load too much data, it will grow endlessly "
"until you get an OutOfMemoryException. One solution is to call <literal>clear"
"()</literal> and <literal>evict()</literal> to manage the <literal>Session</"
"literal> cache, but you should consider a Stored Procedure if you need mass "
"data operations. Some solutions are shown in <xref linkend=\"batch\" />. "
"Keeping a <literal>Session</literal> open for the duration of a user session "
"also means a higher probability of stale data."
msgstr ""
"La <literal>Session</literal> pone en caché todo objeto que esté en estado "
"persistente (Hibernate vigila y chequea para identificar estados "
"desactualizados). Si la mantiene abierta por un largo tiempo o simplemente "
"carga demasiados datos crece sin fin hasta que obtiene una "
"OutOfMemoryException. Una solución para esto es llamar a <literal>clear()</"
"literal> y <literal>evict()</literal> para gestionar el caché de la "
"<literal>Session</literal>, pero probablemente deba considerar un "
"procedimiento almacenado si necesita operaciones de datos masivs. Se pueden "
"ver algunas soluciones en <xref linkend=\"batch\"/>. Mantener una "
"<literal>Session</literal> abierta durante una sesión de usuario también "
"significa una alta probabilidad de datos desactualizados. "

#. Tag: title
#, no-c-format
msgid "Database transaction demarcation"
msgstr "Demarcación de la transacción de la base de datos"

#. Tag: para
#, no-c-format
msgid ""
"Database, or system, transaction boundaries are always necessary. No "
"communication with the database can occur outside of a database transaction "
"(this seems to confuse many developers who are used to the auto-commit "
"mode). Always use clear transaction boundaries, even for read-only "
"operations. Depending on your isolation level and database capabilities this "
"might not be required, but there is no downside if you always demarcate "
"transactions explicitly. Certainly, a single database transaction is going "
"to perform better than many small transactions, even for reading data."
msgstr ""
"Los límites de las transacciones de la base de datos o el sistema son "
"siempre necesarios. Ninguna comunicación con la base de datos puede darse "
"fuera de una transacción de la base de datos (esto parece confundir a muchos "
"desarrolladores acostumbrados al modo auto-commit). Siempre use límites de "
"transacción claros, incluso para las operaciones de sólo lectura. "
"Dependiendo del nivel de aislamiento y las capacidades de la base de datos, "
"esto podría requerirse o no, pero no hay inconvenientes si siempre demarca "
"explícitamente las transacciones. Con seguridad, una transacción única de "
"base de datos va a funcionar mejor que muchas transacciones pequeñas, "
"inclusive para leer datos."

#. Tag: para
#, no-c-format
msgid ""
"A Hibernate application can run in non-managed (i.e., standalone, simple "
"Web- or Swing applications) and managed J2EE environments. In a non-managed "
"environment, Hibernate is usually responsible for its own database "
"connection pool. The application developer has to manually set transaction "
"boundaries (begin, commit, or rollback database transactions) themselves. A "
"managed environment usually provides container-managed transactions (CMT), "
"with the transaction assembly defined declaratively (in deployment "
"descriptors of EJB session beans, for example). Programmatic transaction "
"demarcation is then no longer necessary."
msgstr ""
"Una aplicación Hibernate puede ejecutarse en entornos no administrados (por "
"ejemplo, aplicaciones simples Web o Swing autónomas) y entornos "
"administrados por J2EE. En un entorno no administrado, Hibernate es "
"usualmente responsable de su propio pool de conexiones de la base de datos. "
"El desarrollador de aplicaciones tiene que establecer manualmente los "
"límites de transacción (inicar, guardar o deshacer las transacciones de la "
"base de datos) por sí mismo. Un entorno administrado usualmente proporciona "
"transacciones gestionadas por contenedor, con el ensamble de transacción "
"definido declarativamente (por ejemplo, en descriptores de despliegue de "
"beans de sesión EJB). La demarcación programática de transacciones ya no es "
"necesaria."

#. Tag: para
#, no-c-format
msgid ""
"However, it is often desirable to keep your persistence layer portable "
"between non-managed resource-local environments, and systems that can rely "
"on JTA but use BMT instead of CMT. In both cases use programmatic "
"transaction demarcation. Hibernate offers a wrapper API called "
"<literal>Transaction</literal> that translates into the native transaction "
"system of your deployment environment. This API is actually optional, but we "
"strongly encourage its use unless you are in a CMT session bean."
msgstr ""
"Sin embargo, comúnmente se quiere mantener su capa de persistencia portátil "
"entre entornos locales- de recursos no-administrados y sistemas que pueden "
"confiar en JTA, pero utilizar BMT en vez de CMT. En ambos casos utilizaría "
"la demarcación de transacción programática. Hibernate ofrece una API de "
"envoltura llamada <literal>Transaction</literal> que se traduce al sistema "
"de transacciones nativo de su entorno de despliegue. Esta API es de hecho "
"opcional, pero le recomendamos bastante su uso salvo que esté en un bean de "
"sesión CMT. "

#. Tag: para
#, no-c-format
msgid "Ending a <literal>Session</literal> usually involves four distinct phases:"
msgstr ""
"Usualmente, el finalizar una <literal>Session</literal> implica cuatro fases "
"distintas:"

#. Tag: para
#, no-c-format
msgid "flush the session"
msgstr "limpiar la sesión"

#. Tag: para
#, no-c-format
msgid "commit the transaction"
msgstr "someter la transacción"

#. Tag: para
#, no-c-format
msgid "close the session"
msgstr "cerrar la sesión"

#. Tag: para
#, no-c-format
msgid "handle exceptions"
msgstr "manejar excepciones"

#. Tag: para
#, no-c-format
msgid ""
"We discussed Flushing the session earlier, so we will now have a closer look "
"at transaction demarcation and exception handling in both managed and non-"
"managed environments."
msgstr ""
"Anteriormente se discutió el vacido de la sesión así que ahora vamos a mirar "
"más de cerca la demarcación de transacciones y el manejo de excepciones en "
"los dos entornos administrado y no administrado."

#. Tag: title
#, no-c-format
msgid "Non-managed environment"
msgstr "Entorno no administrado"

#. Tag: para
#, no-c-format
msgid ""
"If a Hibernate persistence layer runs in a non-managed environment, database "
"connections are usually handled by simple (i.e., non-DataSource) connection "
"pools from which Hibernate obtains connections as needed. The session/"
"transaction handling idiom looks like this:"
msgstr ""
"Si una capa de persistencia Hibernate se ejecuta en un entorno no "
"administrado, las conexiones de la base de datos se manejan usualmente por "
"simples pools de conexión (por ejemplo, no-DataSource) del cual Hibernate "
"obtiene conexiones al ser necesario. El idioma de manejo de sesión/"
"transacción se ve así:"

#. Tag: para
#, no-c-format
msgid ""
"You do not have to <literal>flush()</literal> the <literal>Session</literal> "
"explicitly: the call to <literal>commit()</literal> automatically triggers "
"the synchronization depending on the <link linkend=\"objectstate-flushing"
"\">FlushMode</link> for the session. A call to <literal>close()</literal> "
"marks the end of a session. The main implication of <literal>close()</"
"literal> is that the JDBC connection will be relinquished by the session. "
"This Java code is portable and runs in both non-managed and JTA environments."
msgstr ""
"No tiene que vaciar con <literal>flush()</literal> la <literal>Session</"
"literal> explícitamente: la llamada a <literal>commit()</literal> "
"automáticamente dispara la sincronización dependiendo del <link linkend=\"objectstate-flushing"
"\">FlushMode</link> para la sesión. Una llamada a <literal>close()</"
"literal> marca el final de una sesión. La implicación principal de "
"<literal>close()</literal> es que la conexión JDBC será abandonada por la "
"sesión. Este código Java es portátil y ejecuta en entornos tanto no-"
"administrados como JTA."

#. Tag: para
#, no-c-format
msgid ""
"As outlined earlier, a much more flexible solution is Hibernate's built-in "
"\"current session\" context management:"
msgstr ""
"Como se mencionó anteriormente, una solución mucho más flexible es la "
"administración de contexto \"sesión actual\" incorporada en Hibernate:"

#. Tag: para
#, no-c-format
msgid ""
"You will not see these code snippets in a regular application; fatal "
"(system) exceptions should always be caught at the \"top\". In other words, "
"the code that executes Hibernate calls in the persistence layer, and the "
"code that handles <literal>RuntimeException</literal> (and usually can only "
"clean up and exit), are in different layers. The current context management "
"by Hibernate can significantly simplify this design by accessing a "
"<literal>SessionFactory</literal>. Exception handling is discussed later in "
"this chapter."
msgstr ""
"No verá estos pedazos de código en una aplicación normal; las excepciones "
"fatales (del sistema) siempre deben ser capturadas en la \"cima\". En otras "
"palabras, el código que ejecuta las llamadas de Hibernate en la capa de "
"persistencia y el código que maneja <literal>RuntimeException</literal> (y "
"usualmente sólo puede limpiar y salir) se encuentran en capas diferentes. La "
"administración de contexto actual de Hibernate puede simplificar de manera "
"importante este diseño, ya que todo lo que necesita hacer es acceder a "
"<literal>SessionFactory</literal>. El manejo de excepciones se discute más "
"adelante en este capítulo."

#. Tag: para
#, no-c-format
msgid ""
"You should select <literal>org.hibernate.transaction.JDBCTransactionFactory</"
"literal>, which is the default, and for the second example select <literal>"
"\"thread\"</literal> as your <literal>hibernate."
"current_session_context_class</literal>."
msgstr ""
"Debe seleccionar <literal>org.hibernate.transaction.JDBCTransactionFactory</"
"literal>, el cual es el predeterminado, y para el segundo ejemplo "
"seleccionar <literal>\"thread\"</literal> como su <literal>hibernate."
"current_session_context_class</literal>."

#. Tag: title
#, no-c-format
msgid "Using JTA"
msgstr "Utilización de JTA"

#. Tag: para
#, no-c-format
msgid ""
"If your persistence layer runs in an application server (for example, behind "
"EJB session beans), every datasource connection obtained by Hibernate will "
"automatically be part of the global JTA transaction. You can also install a "
"standalone JTA implementation and use it without EJB. Hibernate offers two "
"strategies for JTA integration."
msgstr ""
"Si su capa de persistencia se ejecuta en un servidor de aplicaciones (por "
"ejemplo, detrás de los beans de sesión EJB), cada conexión de fuente de "
"datos obtenida por Hibernate será parte de la transacción JTA global de "
"manera automática. También puede instalar una implementación JTA autónoma y "
"utilizarla sin EJB. Hibernate ofrece dos estrategias para esta integración "
"JTA."

#. Tag: para
#, no-c-format
msgid ""
"If you use bean-managed transactions (BMT), Hibernate will tell the "
"application server to start and end a BMT transaction if you use the "
"<literal>Transaction</literal> API. The transaction management code is "
"identical to the non-managed environment."
msgstr ""
"Si usa transacciones gestionadas-por-bean (BMT) Hibernate le dirá al "
"servidor de aplicaciones que comience y finalice una transacción BMT si usa "
"la API de <literal>Transaction</literal>. De modo que, el código de gestión "
"de la transacción es idéntico al de un entorno no administrado. "

#. Tag: para
#, no-c-format
msgid ""
"If you want to use a transaction-bound <literal>Session</literal>, that is, "
"the <literal>getCurrentSession()</literal> functionality for easy context "
"propagation, use the JTA <literal>UserTransaction</literal> API directly:"
msgstr ""
"Si quiere utilizar un vínculo de transacción <literal>Session</literal>, es "
"decir, la funcionalidad <literal>getCurrentSession()</literal> para "
"propagación de contexto de manera fácil, tendrá que utilizar el API "
"<literal>UserTransaction</literal> del JTA directamente: "

#. Tag: para
#, no-c-format
msgid ""
"With CMT, transaction demarcation is completed in session bean deployment "
"descriptors, not programmatically. The code is reduced to:"
msgstr ""
"Con CMT, la demarcación de transacción se realiza en los descriptores de "
"implementacion bean de sesión, no programáticamente. Por lo tanto el código "
"se reduce a:"

#. Tag: para
#, no-c-format
msgid ""
"In a CMT/EJB, even rollback happens automatically. An unhandled "
"<literal>RuntimeException</literal> thrown by a session bean method tells "
"the container to set the global transaction to rollback. <emphasis>You do "
"not need to use the Hibernate <literal>Transaction</literal> API at all with "
"BMT or CMT, and you get automatic propagation of the \"current\" Session "
"bound to the transaction.</emphasis>"
msgstr ""
"En un CMT/EJB incluso el deshacer sucede de forma automática. Un "
"<literal>RuntimeException</literal> lanzado por un método bean de sesión le "
"dice al contenedor que establezca una transacción global para deshacer. "
"<emphasis>No necesita utilizar el API <literal>Transaction</literal> de "
"Hibernate con BMT o CMT y obtiene la propagación automática de sesión\"actual"
"\" vinculada a la transacción.</emphasis>"

#. Tag: para
#, no-c-format
msgid ""
"When configuring Hibernate's transaction factory, choose <literal>org."
"hibernate.transaction.JTATransactionFactory</literal> if you use JTA "
"directly (BMT), and <literal>org.hibernate.transaction."
"CMTTransactionFactory</literal> in a CMT session bean. Remember to also set "
"<literal>hibernate.transaction.manager_lookup_class</literal>. Ensure that "
"your <literal>hibernate.current_session_context_class</literal> is either "
"unset (backwards compatibility), or is set to <literal>\"jta\"</literal>."
msgstr ""
"Al configurar la fábrica de transacciones de Hibernate, escoja <literal>org."
"hibernate.transaction.JTATransactionFactory</literal> si utiliza JTA "
"directamente (BMT) y <literal>org.hibernate.transaction."
"CMTTransactionFactory</literal> en una bean de sesión CMT. Recuerde "
"establecer también <literal>hibernate.transaction.manager_lookup_class</"
"literal>. Asegúrese de que su <literal>hibernate."
"current_session_context_class</literal> no se encuentra configurado "
"(compatibilidad retrasada) o configurada como <literal>\"jta\"</literal>."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>getCurrentSession()</literal> operation has one downside in a "
"JTA environment. There is one caveat to the use of <literal>after_statement</"
"literal> connection release mode, which is then used by default. Due to a "
"limitation of the JTA spec, it is not possible for Hibernate to "
"automatically clean up any unclosed <literal>ScrollableResults</literal> or "
"<literal>Iterator</literal> instances returned by <literal>scroll()</"
"literal> or <literal>iterate()</literal>. You <emphasis>must</emphasis> "
"release the underlying database cursor by calling <literal>ScrollableResults."
"close()</literal> or <literal>Hibernate.close(Iterator)</literal> explicitly "
"from a <literal>finally</literal> block. Most applications can easily avoid "
"using <literal>scroll()</literal> or <literal>iterate()</literal> from the "
"JTA or CMT code.)"
msgstr ""
"La operación <literal>getCurrentSession()</literal> tiene un inconveniente "
"en un entorno JTA. Hay una desventaja en el uso del modo de liberación de la "
"conección <literal>after_statement</literal>, la cual luego se utiliza por "
"defecto. Debido a una limitación de la especificación JTA, no le es posible "
"a Hibernate limpiar automáticamente cualquier instancia "
"<literal>ScrollableResults</literal> o <literal>Iterator</literal> no "
"cerradas y retornadas por <literal>scroll()</literal> o <literal>iterate()</"
"literal>. <emphasis>Tiene</emphasis> que liberar el cursor de la base de "
"datos subyacente llamando a <literal>ScrollableResults.close()</literal> o "
"<literal>Hibernate.close(Iterator)</literal> explícitamente desde un bloque "
"<literal>finally</literal>. La mayoría de las aplicaciones pueden evitar "
"fácilmente el utilizar <literal>scroll()</literal> o <literal>iterate()</"
"literal> del código JTA o CMT."

#. Tag: title
#, no-c-format
msgid "Exception handling"
msgstr "Manejo de excepciones"

#. Tag: para
#, no-c-format
msgid ""
"If the <literal>Session</literal> throws an exception, including any "
"<literal>SQLException</literal>, immediately rollback the database "
"transaction, call <literal>Session.close()</literal> and discard the "
"<literal>Session</literal> instance. Certain methods of <literal>Session</"
"literal> will <emphasis>not</emphasis> leave the session in a consistent "
"state. No exception thrown by Hibernate can be treated as recoverable. "
"Ensure that the <literal>Session</literal> will be closed by calling "
"<literal>close()</literal> in a <literal>finally</literal> block."
msgstr ""
"Si la <literal>Session</literal> lanza una excepción, incluyendo cualquier "
"<literal>SQLException</literal>, debe deshacer inmediatamente la transacción "
"de la base de datos, llamar a <literal>Session.close()</literal> y descartar "
"la instancia de <literal>Session</literal>. Ciertos métodos de "
"<literal>Session</literal> <emphasis>no</emphasis> dejarán la sesión en un "
"estado consistente. Ninguna excepción lanzada por Hibernate puede ser "
"tratada como recuperable. Asegúrese de que la <literal>Session</literal> se "
"cierre llamando a <literal>close()</literal> en un bloque <literal>finally</"
"literal>."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>HibernateException</literal>, which wraps most of the errors "
"that can occur in a Hibernate persistence layer, is an unchecked exception. "
"It was not in older versions of Hibernate. In our opinion, we should not "
"force the application developer to catch an unrecoverable exception at a low "
"layer. In most systems, unchecked and fatal exceptions are handled in one of "
"the first frames of the method call stack (i.e., in higher layers) and "
"either an error message is presented to the application user or some other "
"appropriate action is taken. Note that Hibernate might also throw other "
"unchecked exceptions that are not a <literal>HibernateException</literal>. "
"These are not recoverable and appropriate action should be taken."
msgstr ""
"La <literal>HibernateException</literal>, que envuelve a la mayoría de los "
"errores que pueden ocurrir en la capa de persistencia de Hibernate, es una "
"excepción no chequeada. No lo era en versiones anteriores de Hibernate. En "
"nuestra opinión, no debemos forzar al desarrollador de aplicaciones a "
"capturar una excepción irrecuperable en una capa baja. En la mayoría de los "
"sistemas, las excepciones no chequeadas y fatales son manejadas en uno de "
"los primeros cuadros de la pila de llamadas a métodos (por ejemplo, en las "
"capas más altas) y presenta un mensaje de error al usuario de la aplicación "
"o se toma alguna otra acción apropiada. Note que Hibernate podría también "
"lanzar otras excepciones no chequeadas que no sean una "
"<literal>HibernateException</literal>. Estas no son recuperables y debe "
"tomarse una acción apropiada."

#. Tag: para
#, no-c-format
msgid ""
"Hibernate wraps <literal>SQLException</literal>s thrown while interacting "
"with the database in a <literal>JDBCException</literal>. In fact, Hibernate "
"will attempt to convert the exception into a more meaningful subclass of "
"<literal>JDBCException</literal>. The underlying <literal>SQLException</"
"literal> is always available via <literal>JDBCException.getCause()</"
"literal>. Hibernate converts the <literal>SQLException</literal> into an "
"appropriate <literal>JDBCException</literal> subclass using the "
"<literal>SQLExceptionConverter</literal> attached to the "
"<literal>SessionFactory</literal>. By default, the "
"<literal>SQLExceptionConverter</literal> is defined by the configured "
"dialect. However, it is also possible to plug in a custom implementation. "
"See the javadocs for the <literal>SQLExceptionConverterFactory</literal> "
"class for details. The standard <literal>JDBCException</literal> subtypes "
"are:"
msgstr ""
"Hibernate envuelve <literal>SQLException</literal>s lanzadas mientras se "
"interactúa con la base de datos en una <literal>JDBCException</literal>. De "
"hecho, Hibernate intentará convertir la excepción en una subclase de "
"<literal>JDBCException</literal> más significativa. La "
"<literal>SQLException</literal> subyacente siempre está disponible por medio "
"de <literal>JDBCException.getCause()</literal>. Hibernate convierte la "
"<literal>SQLException</literal> en una subclase de <literal>JDBCException</"
"literal> apropiada usando el <literal>SQLExceptionConverter</literal> "
"adjunto a la <literal>SessionFactory</literal>. Por defecto, el "
"<literal>SQLExceptionConverter</literal> está definido por el dialecto "
"configurado. Sin embargo, también es posible enchufar una implementación "
"personalizada . Consulte los javadocs de la clase "
"<literal>SQLExceptionConverterFactory</literal> para obtener más detalles. "
"Los subtipos estándar de <literal>JDBCException</literal> son: "

#. Tag: para
#, no-c-format
msgid ""
"<literal>JDBCConnectionException</literal>: indicates an error with the "
"underlying JDBC communication."
msgstr ""
"<literal>JDBCConnectionException</literal>: indica un error con la "
"comunicación JDBC subyacente."

#. Tag: para
#, no-c-format
msgid ""
"<literal>SQLGrammarException</literal>: indicates a grammar or syntax "
"problem with the issued SQL."
msgstr ""
"<literal>SQLGrammarException</literal>: indica un problema de gramática o "
"sintáxis con el SQL publicado."

#. Tag: para
#, no-c-format
msgid ""
"<literal>ConstraintViolationException</literal>: indicates some form of "
"integrity constraint violation."
msgstr ""
"<literal>ConstraintViolationException</literal>: indica alguna forma de "
"violación de restricción de integridad."

#. Tag: para
#, no-c-format
msgid ""
"<literal>LockAcquisitionException</literal>: indicates an error acquiring a "
"lock level necessary to perform the requested operation."
msgstr ""
"<literal>LockAcquisitionException</literal>: indica un error adquiriendo un "
"nivel de bloqueo necesario para realizar una operación solicitada."

#. Tag: para
#, no-c-format
msgid ""
"<literal>GenericJDBCException</literal>: a generic exception which did not "
"fall into any of the other categories."
msgstr ""
"<literal>GenericJDBCException</literal>: una excepción genérica que no "
"encajó en ninguna de las otras categorías."

#. Tag: title
#, no-c-format
msgid "Transaction timeout"
msgstr "Tiempo de espera de la transacción"

#. Tag: para
#, no-c-format
msgid ""
"An important feature provided by a managed environment like EJB, that is "
"never provided for non-managed code, is transaction timeout. Transaction "
"timeouts ensure that no misbehaving transaction can indefinitely tie up "
"resources while returning no response to the user. Outside a managed (JTA) "
"environment, Hibernate cannot fully provide this functionality. However, "
"Hibernate can at least control data access operations, ensuring that "
"database level deadlocks and queries with huge result sets are limited by a "
"defined timeout. In a managed environment, Hibernate can delegate "
"transaction timeout to JTA. This functionality is abstracted by the "
"Hibernate <literal>Transaction</literal> object."
msgstr ""
"Una característica importante proporcionada por un entorno administrado como "
"EJB que nunca es proporcionado para un código no-administrado, es el tiempo "
"de espera de la transacción. Estos tiempos de espera se aseguran de que "
"ninguna transacción que se comporte inapropiadamente pueda vincular recursos "
"mientras no devuelva una respuesta al usuario. Fuera de un entorno "
"administrado (JTA), Hibernate no puede proporcionar completamente esta "
"funcionalidad. Sin embargo, Hibernate puede por lo menos controlar las "
"operaciones de acceso de datos, asegurándose de que los bloqueos a nivel de "
"base de datos y las consultas con grandes grupos de resultados se encuentran "
"limitados por un tiempo de espera definido. En un entorno administrado, "
"Hibernate puede delegar el tiempo de espera de la transacción a JTA. Esta "
"funcionalidad es abstraída por el objeto <literal>Transaction</literal> de "
"Hibernate."

#. Tag: para
#, no-c-format
msgid ""
"<literal>setTimeout()</literal> cannot be called in a CMT bean, where "
"transaction timeouts must be defined declaratively."
msgstr ""
"<literal>setTimeout()</literal> no se puede llamar en un bean CMT, en donde "
"se deben definir declarativamente los tiempos de espera de las transacciones."

#. Tag: title
#, no-c-format
msgid "Optimistic concurrency control"
msgstr "Control de concurrencia optimista"

#. Tag: para
#, no-c-format
msgid ""
"The only approach that is consistent with high concurrency and high "
"scalability, is optimistic concurrency control with versioning. Version "
"checking uses version numbers, or timestamps, to detect conflicting updates "
"and to prevent lost updates. Hibernate provides three possible approaches to "
"writing application code that uses optimistic concurrency. The use cases we "
"discuss are in the context of long conversations, but version checking also "
"has the benefit of preventing lost updates in single database transactions."
msgstr ""
"El único enfoque consistente con una alta concurrencia y una alta "
"escalabilidad es el control de concurrencia optimista con versionamiento. El "
"chequeo de versión utiliza números de versión, o sellos de fecha "
"(timestamps), para detectar actualizaciones en conflicto y para prevenir la "
"pérdida de actualizaciones. Hibernate proporciona tres enfoques posibles de "
"escribir código de aplicación que utilice concurrencia optimista. Los casos "
"de uso que mostramos se encuentran en el contexto de conversaciones largas, "
"pero el chequeo de versiones tiene además el beneficio de prevenir la "
"pérdida de actualizaciones en transacciones individuales de la base de datos."

#. Tag: title
#, no-c-format
msgid "Application version checking"
msgstr "Chequeo de versiones de la aplicación"

#. Tag: para
#, no-c-format
msgid ""
"In an implementation without much help from Hibernate, each interaction with "
"the database occurs in a new <literal>Session</literal> and the developer is "
"responsible for reloading all persistent instances from the database before "
"manipulating them. The application is forced to carry out its own version "
"checking to ensure conversation transaction isolation. This approach is the "
"least efficient in terms of database access. It is the approach most similar "
"to entity EJBs."
msgstr ""
"En una implementación que no tiene mucha ayuda de Hibernate, cada "
"interacción con la base de datos ocurre en una nueva <literal>Session</"
"literal> y el desarrollador es el responsable de recargar todas las "
"intancias persistentes desde la base de datos antes de manipularlas. Este "
"enfoque fuerza a la aplicación a realizar su propio chequeo de versiones "
"para asegurar el aislamiento de transacciones de conversaciones. Este "
"enfoque es el menos eficiente en términos de acceso a la base de datos. Es "
"el enfoque más similar a los EJBs de entidad."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>version</literal> property is mapped using <literal>&lt;"
"version&gt;</literal>, and Hibernate will automatically increment it during "
"flush if the entity is dirty."
msgstr ""
"La propiedad <literal>version</literal> se mapea utilizando <literal>&lt;"
"version&gt;</literal>, e Hibernate la incrementará automáticamente durante "
"la limpieza si la entidad está desactualizada."

#. Tag: para
#, no-c-format
msgid ""
"If you are operating in a low-data-concurrency environment, and do not "
"require version checking, you can use this approach and skip the version "
"check. In this case, <emphasis>last commit wins</emphasis> is the default "
"strategy for long conversations. Be aware that this might confuse the users "
"of the application, as they might experience lost updates without error "
"messages or a chance to merge conflicting changes."
msgstr ""
"Si está operando un entorno de baja-concurrencia-de-datos y no requiere "
"chequeo de versiones, puede usar este enfoque y simplemente saltarse el "
"chequeo de versiones. En ese caso, <emphasis>el último que guarda gana</"
"emphasis> y será la estrategia por defecto para conversaciones largas. Tenga "
"en mente que esto podría confundir a los usuarios de la aplicación, pues "
"podrían experimentar pérdidas de actualizaciones sin mensajes de error ni "
"oportunidad de fusionar los cambios conflictivos."

#. Tag: para
#, no-c-format
msgid ""
"Manual version checking is only feasible in trivial circumstances and not "
"practical for most applications. Often not only single instances, but "
"complete graphs of modified objects, have to be checked. Hibernate offers "
"automatic version checking with either an extended <literal>Session</"
"literal> or detached instances as the design paradigm."
msgstr ""
"El chequeo manual de versiones es factible sólamente en circunstancias muy "
"triviales y no es práctico para la mayoría de las aplicaciones. Con "
"frecuencia se tienen que chequear no sólamente las intancias sólas, sino "
"también grafos completos de objetos modificados. Hibernate ofrece el chequeo "
"de versiones automático con el paradigma de diseño de <literal>Session</"
"literal> larga o de instancias separadas."

#. Tag: title
#, no-c-format
msgid "Extended session and automatic versioning"
msgstr "Sesión extendida y versionado automático"

#. Tag: para
#, no-c-format
msgid ""
"A single <literal>Session</literal> instance and its persistent instances "
"that are used for the whole conversation are known as <emphasis>session-per-"
"conversation</emphasis>. Hibernate checks instance versions at flush time, "
"throwing an exception if concurrent modification is detected. It is up to "
"the developer to catch and handle this exception. Common options are the "
"opportunity for the user to merge changes or to restart the business "
"conversation with non-stale data."
msgstr ""
"Una sóla instancia de <literal>Session</literal> y sus instancias "
"persistentes se utilizan para toda la convervsación conocida como "
"<emphasis>sesión-por-conversación</emphasis>. Hibernate chequea las "
"versiones de instancia en el momento de vaciado, lanzando una excepción si "
"se detecta una modificación concurrente. Le concierne al desarrollador "
"capturar y manejar esta excepción. Las opciones comunes son la oportunidad "
"del usuario de fusionar los cambios, o de recomenzar el proceso empresarial "
"sin datos desactualizados."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>Session</literal> is disconnected from any underlying JDBC "
"connection when waiting for user interaction. This approach is the most "
"efficient in terms of database access. The application does not version "
"check or reattach detached instances, nor does it have to reload instances "
"in every database transaction."
msgstr ""
"La <literal>Session</literal> se desconecta de cualquier conexión JDBC "
"subyacente a la espera de una interacción del usuario. Este enfoque es el "
"más eficiente en términos de acceso a la base de datos. La aplicación no "
"necesita por sí misma tratar con el chequeo de versiones, ni re-unir "
"instancias separadas, ni tiene que recargar instancias en cada transacción "
"de la base de datos."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>foo</literal> object knows which <literal>Session</literal> it "
"was loaded in. Beginning a new database transaction on an old session "
"obtains a new connection and resumes the session. Committing a database "
"transaction disconnects a session from the JDBC connection and returns the "
"connection to the pool. After reconnection, to force a version check on data "
"you are not updating, you can call <literal>Session.lock()</literal> with "
"<literal>LockMode.READ</literal> on any objects that might have been updated "
"by another transaction. You do not need to lock any data that you "
"<emphasis>are</emphasis> updating. Usually you would set <literal>FlushMode."
"MANUAL</literal> on an extended <literal>Session</literal>, so that only the "
"last database transaction cycle is allowed to actually persist all "
"modifications made in this conversation. Only this last database transaction "
"will include the <literal>flush()</literal> operation, and then "
"<literal>close()</literal> the session to end the conversation."
msgstr ""
"El objeto <literal>foo</literal> sabe en qué <literal>Session</literal> fue "
"cargado. El dar inicio a una nueva base de datos en una sesión vieja obtiene "
"una nueva conexión y reanuda la sesión. El guardar una transacción de la "
"base de datos desconecta una sesión de la conexion JDBC y devuelve la "
"conexión al pool. Después de la reconexión, para poder forzar una "
"verificación de versión sobre datos que usted no está actalizando, puede "
"llamar a <literal>Session.lock()</literal> con <literal>LockMode.READ</"
"literal> en cualquier objeto que pueda haber sido actualizado por otra "
"transacción. No necesita bloquear ningún dato que <emphasis>sí esté</"
"emphasis> actualizando. Usualmente configuraría <literal>FlushMode.MANUAL</"
"literal> en una <literal>Session</literal> extendida, de manera que de hecho "
"sólamente se permite persistir el último ciclo de transacción de la base de "
"datos de todas las modificaciones realizadas en esta conversación. Sólamente "
"esta última transacción de la base de datos incluiría la operación "
"<literal>flush()</literal> y luego cierra -<literal>close()</literal>- la "
"sesión para dar fin a la conversación."

#. Tag: para
#, no-c-format
msgid ""
"This pattern is problematic if the <literal>Session</literal> is too big to "
"be stored during user think time (for example, an <literal>HttpSession</"
"literal> should be kept as small as possible). As the <literal>Session</"
"literal> is also the first-level cache and contains all loaded objects, we "
"can probably use this strategy only for a few request/response cycles. Use a "
"<literal>Session</literal> only for a single conversation as it will soon "
"have stale data."
msgstr ""
"Este patrón es problemático si la <literal>Session</literal> es demasiado "
"grande para almacenarla durante el tiempo para pensar del usuario, por "
"ejemplo, una <literal>HttpSession</literal> se debe mantener tan pequeña "
"como sea posible. Como la <literal>Session</literal> también lo es el caché "
"de primer nivel (obligatorio) y comprende todos los objetos cargados, "
"probablemente podemos utilizar esta estrategia sólamente para unos pocos "
"ciclos de pedido/respuesta. Debe utilizar una <literal>Session</literal> "
"sólamente para una conversación única ya que pronto también tendrá  datos "
"añejos."

#. Tag: title
#, no-c-format
msgid "Note"
msgstr "Nota"

#. Tag: para
#, no-c-format
msgid ""
"Earlier versions of Hibernate required explicit disconnection and "
"reconnection of a <literal>Session</literal>. These methods are deprecated, "
"as beginning and ending a transaction has the same effect."
msgstr ""
"Las versiones anteriores de Hibernate necesitaban desconexión explícita y "
"reconexión de una <literal>Session</literal>. Estos métodos ya no se "
"aprueban ya que tienen el mismo efecto que dar inicio o finalizar a una "
"transacción."

#. Tag: para
#, no-c-format
msgid ""
"Keep the disconnected <literal>Session</literal> close to the persistence "
"layer. Use an EJB stateful session bean to hold the <literal>Session</"
"literal> in a three-tier environment. Do not transfer it to the web layer, "
"or even serialize it to a separate tier, to store it in the "
"<literal>HttpSession</literal>."
msgstr ""
"Mantenga la <literal>Session</literal> desconectada cerca a la capa de "
"persistencia. Use un bean de sesión EJB con estado para mantener la "
"<literal>Session</literal> en un entorno de tres capas . No la transfiera a "
"la capa web ni la serialice en una capa separada para almacenarla en la "
"<literal>HttpSession</literal>."

#. Tag: para
#, no-c-format
msgid ""
"The extended session pattern, or <emphasis>session-per-conversation</"
"emphasis>, is more difficult to implement with automatic current session "
"context management. You need to supply your own implementation of the "
"<literal>CurrentSessionContext</literal> for this. See the Hibernate Wiki "
"for examples."
msgstr ""
"El patrón de sesión extendido, o <emphasis>sesión-por-conversación</"
"emphasis>, es más dificil de implementar con la administración de contexto "
"de sesión actual. Necesita proporcionar su propia implementación de la "
"<literal>CurrentSessionContext</literal> para esto, vea el Wiki de Hibernate "
"para obtener más ejemplos."

#. Tag: title
#, no-c-format
msgid "Detached objects and automatic versioning"
msgstr "Objetos separados y versionado automático"

#. Tag: para
#, no-c-format
msgid ""
"Each interaction with the persistent store occurs in a new <literal>Session</"
"literal>. However, the same persistent instances are reused for each "
"interaction with the database. The application manipulates the state of "
"detached instances originally loaded in another <literal>Session</literal> "
"and then reattaches them using <literal>Session.update()</literal>, "
"<literal>Session.saveOrUpdate()</literal>, or <literal>Session.merge()</"
"literal>."
msgstr ""
"Cada interacción con el almacenamiento persistente ocurre en una nueva "
"<literal>Session</literal>. Sin embargo, las mismas instancias persistentes "
"son reutilizadas para cada interacción con la base de datos. La aplicación "
"manipula el estado de las instancias separadas cargadas originalmente en "
"otra <literal>Session</literal> y luego las readjunta usando "
"<literal>Session.update()</literal>, <literal>Session.saveOrUpdate()</"
"literal>, o <literal>Session.merge()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Again, Hibernate will check instance versions during flush, throwing an "
"exception if conflicting updates occurred."
msgstr ""
"De nuevo, Hibernate chequeará las versiones de la instancia durante el "
"vaciado, lanzando una excepción si tuvieron lugar conflictos en las "
"actualizaciones."

#. Tag: para
#, no-c-format
msgid ""
"You can also call <literal>lock()</literal> instead of <literal>update()</"
"literal>, and use <literal>LockMode.READ</literal> (performing a version "
"check and bypassing all caches) if you are sure that the object has not been "
"modified."
msgstr ""
"También puede llamar a <literal>lock()</literal> en lugar de <literal>update"
"()</literal> y utilizar <literal>LockMode.READ</literal> (realizando un "
"chequeo de versión, evitando todos los cachés) si está seguro de que el "
"objeto no ha sido modificado."

#. Tag: title
#, no-c-format
msgid "Customizing automatic versioning"
msgstr "Personalización del versionado automático"

#. Tag: para
#, no-c-format
msgid ""
"You can disable Hibernate's automatic version increment for particular "
"properties and collections by setting the <literal>optimistic-lock</literal> "
"mapping attribute to <literal>false</literal>. Hibernate will then no longer "
"increment versions if the property is dirty."
msgstr ""
"Puede deshabilitar el incremento de la versión automática de Hibernate para "
"ciertas propiedades y colecciones en particular estableciendo el atributo de "
"mapeo <literal>optimistic-lock</literal> como <literal>false</literal>. "
"Hibernate entonces ya no incrementará más las versiones si la propiedad se "
"encuentra desactualizada."

#. Tag: para
#, no-c-format
msgid ""
"Legacy database schemas are often static and cannot be modified. Or, other "
"applications might access the same database and will not know how to handle "
"version numbers or even timestamps. In both cases, versioning cannot rely on "
"a particular column in a table. To force a version check with a comparison "
"of the state of all fields in a row but without a version or timestamp "
"property mapping, turn on <literal>optimistic-lock=\"all\"</literal> in the "
"<literal>&lt;class&gt;</literal> mapping. This conceptually only works if "
"Hibernate can compare the old and the new state (i.e., if you use a single "
"long <literal>Session</literal> and not session-per-request-with-detached-"
"objects)."
msgstr ""
"Los esquemas heredados de la base de datos con frecuencia son estáticos y no "
"pueden ser modificados. Inclusive otras aplicaciones podrían también acceder "
"la misma base de datos y no saber cómo manejar los números de versión ni los "
"sellos de fecha. En ambos casos, el versionado no puede confiarse a una "
"columna en particular en una tabla. Para forzar un chequeo de versiones sin "
"un mapeo de propiedad de versión o sello de fecha, con una comparación del "
"estado de todos los campos en una fila, active <literal>optimistic-lock=\"all"
"\"</literal> en el mapeo de <literal>&lt;class&gt;</literal>. Esto funciona "
"conceptualmente sólamente si Hibernate puede comparar el estado viejo y el "
"nuevo, es decir, si usa una sóla <literal>Session</literal> larga y no "
"sesión-por-petición-con-instancias-separadas."

#. Tag: para
#, no-c-format
msgid ""
"Concurrent modification can be permitted in instances where the changes that "
"have been made do not overlap. If you set <literal>optimistic-lock=\"dirty"
"\"</literal> when mapping the <literal>&lt;class&gt;</literal>, Hibernate "
"will only compare dirty fields during flush."
msgstr ""
"Las modificaciones simultáneas pueden permitirse en instancias en tanto los "
"cambios que se hayan realizado no se superpongan. Si establece "
"<literal>optimistic-lock=\"dirty\"</literal> al mapear la <literal>&lt;"
"class&gt;</literal>, Hibernate sólo comparará los campos desactualizados "
"durante el vaciado."

#. Tag: para
#, no-c-format
msgid ""
"In both cases, with dedicated version/timestamp columns or with a full/dirty "
"field comparison, Hibernate uses a single <literal>UPDATE</literal> "
"statement, with an appropriate <literal>WHERE</literal> clause, per entity "
"to execute the version check and update the information. If you use "
"transitive persistence to cascade reattachment to associated entities, "
"Hibernate may execute unnecessary updates. This is usually not a problem, "
"but <emphasis>on update</emphasis> triggers in the database might be "
"executed even when no changes have been made to detached instances. You can "
"customize this behavior by setting <literal>select-before-update=\"true\"</"
"literal> in the <literal>&lt;class&gt;</literal> mapping, forcing Hibernate "
"to <literal>SELECT</literal> the instance to ensure that changes did occur "
"before updating the row."
msgstr ""
"En ambos casos, con columnas de versión/sello de fecha dedicadas o con "
"comparación de campos completos/desactualizados, Hibernate utiliza una sóla "
"declaración <literal>UPDATE</literal> (con una cláusula <literal>WHERE</"
"literal> apropiada) por entidad para ejecutar el chequeo de versiones y "
"actualizar la información. Si utiliza una persistencia transitiva para la re-"
"unión en cascada de entidades asociadas, Hibernate podría ejecutar "
"actualizaciones innecesarias. Esto usualmente no es problema, pero podrían "
"ejecutarse disparadores (triggers) <emphasis>enactualizazción</emphasis> en "
"la base de datos incluso cuando no se haya hecho ningún cambio a las "
"instancias separadas. Puede personalizar este comportamiento estableciendo "
"<literal>select-before-update=\"true\"</literal> en el mapeo de <literal>&lt;"
"class&gt;</literal>, forzando a Hibernate a <literal>SELECT</literal> la "
"instancia para asegurar que las actualizaciones realmente ocurran, antes de "
"actualizar la fila."

#. Tag: title
#, no-c-format
msgid "Pessimistic locking"
msgstr "Bloqueo pesimista "

#. Tag: para
#, no-c-format
msgid ""
"It is not intended that users spend much time worrying about locking "
"strategies. It is usually enough to specify an isolation level for the JDBC "
"connections and then simply let the database do all the work. However, "
"advanced users may wish to obtain exclusive pessimistic locks or re-obtain "
"locks at the start of a new transaction."
msgstr ""
"No se pretende que los usuarios tomen mucho tiempo preocupándose de las "
"estrategias de bloqueo. Usualmente es suficiente con especificar un nivel de "
"aislamiento para las conexiones JDBC y entonces simplemente dejar que la "
"base de datos haga todo el trabajo. Sin embargo, los usuarios avanzados a "
"veces pueden obtener bloqueos exclusivos pesimistas, o reobtener bloqueos al "
"comienzo de una nueva transacción."

#. Tag: para
#, no-c-format
msgid ""
"Hibernate will always use the locking mechanism of the database; it never "
"lock objects in memory."
msgstr ""
"Hibernate siempre usará el mecanismo de bloqueo de la base de datos, nunca "
"el bloqueo de objetos en memoria."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>LockMode</literal> class defines the different lock levels that "
"can be acquired by Hibernate. A lock is obtained by the following mechanisms:"
msgstr ""
"La clase <literal>LockMode</literal> define los diferentes niveles de "
"bloqueo que Hibernate puede adquirir. Un bloqueo se obtiene por medio de los "
"siguientes mecanismos: "

#. Tag: para
#, no-c-format
msgid ""
"<literal>LockMode.WRITE</literal> is acquired automatically when Hibernate "
"updates or inserts a row."
msgstr ""
"<literal>LockMode.WRITE</literal> se adquiere automáticamente cuando "
"Hibernate actualiza o inserta una fila."

#. Tag: para
#, no-c-format
msgid ""
"<literal>LockMode.UPGRADE</literal> can be acquired upon explicit user "
"request using <literal>SELECT ... FOR UPDATE</literal> on databases which "
"support that syntax."
msgstr ""
"<literal>LockMode.UPGRADE</literal> se puede ser adquirir bajo petición "
"explícita del usuario usando <literal>SELECT ... FOR UPDATE</literal> en "
"bases de datos que soporten esa sintáxis."

#. Tag: para
#, no-c-format
msgid ""
"<literal>LockMode.UPGRADE_NOWAIT</literal> can be acquired upon explicit "
"user request using a <literal>SELECT ... FOR UPDATE NOWAIT</literal> under "
"Oracle."
msgstr ""
"<literal>LockMode.UPGRADE_NOWAIT</literal> se puede adquirir bajo petición "
"explícita del usuario usando un <literal>SELECT ... FOR UPDATE NOWAIT</"
"literal> bajo Oracle."

#. Tag: para
#, no-c-format
msgid ""
"<literal>LockMode.READ</literal> is acquired automatically when Hibernate "
"reads data under Repeatable Read or Serializable isolation level. It can be "
"re-acquired by explicit user request."
msgstr ""
"<literal>LockMode.READ</literal> se adquiere automáticamente cuando "
"Hibernate lee los datos bajo los niveles de aislamiento de lectura repetible "
"o serializable. Se puede readquirir por pedido explícito del usuario."

#. Tag: para
#, no-c-format
msgid ""
"<literal>LockMode.NONE</literal> represents the absence of a lock. All "
"objects switch to this lock mode at the end of a <literal>Transaction</"
"literal>. Objects associated with the session via a call to <literal>update()"
"</literal> or <literal>saveOrUpdate()</literal> also start out in this lock "
"mode."
msgstr ""
"<literal>LockMode.NONE</literal> representa la ausencia de un bloqueo. Todos "
"los objetos se pasan a este modo de bloqueo al final de una "
"<literal>Transaction</literal>. Los objetos asociados con una sesión por "
"medio de una llamada a <literal>update()</literal> o <literal>saveOrUpdate()"
"</literal> también comienzan en este modo de bloqueo."

#. Tag: para
#, no-c-format
msgid "The \"explicit user request\" is expressed in one of the following ways:"
msgstr ""
"La \"petición explícita del usuario\" se expresa en una de las siguientes "
"formas:"

#. Tag: para
#, no-c-format
msgid ""
"A call to <literal>Session.load()</literal>, specifying a <literal>LockMode</"
"literal>."
msgstr ""
"Una llamada a <literal>Session.load()</literal>, especificando un "
"<literal>LockMode</literal>."

#. Tag: para
#, no-c-format
msgid "A call to <literal>Session.lock()</literal>."
msgstr "Una llamada a <literal>Session.lock()</literal>."

#. Tag: para
#, no-c-format
msgid "A call to <literal>Query.setLockMode()</literal>."
msgstr "Una llamada a <literal>Query.setLockMode()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"If <literal>Session.load()</literal> is called with <literal>UPGRADE</"
"literal> or <literal>UPGRADE_NOWAIT</literal>, and the requested object was "
"not yet loaded by the session, the object is loaded using "
"<literal>SELECT ... FOR UPDATE</literal>. If <literal>load()</literal> is "
"called for an object that is already loaded with a less restrictive lock "
"than the one requested, Hibernate calls <literal>lock()</literal> for that "
"object."
msgstr ""
"Si se llama a <literal>Session.load()</literal> con <literal>UPGRADE</"
"literal> o <literal>UPGRADE_NOWAIT</literal>, y el objeto pedido no ha sido "
"cargado todavía por la sesión, el objeto es cargado usando "
"<literal>SELECT ... FOR UPDATE</literal>. Si se llama a <literal>load()</"
"literal> para un objeto que ya esté cargado con un bloqueo menos restrictivo "
"que el pedido, Hibernate llama a <literal>lock()</literal> para ese objeto."

#. Tag: para
#, no-c-format
msgid ""
"<literal>Session.lock()</literal> performs a version number check if the "
"specified lock mode is <literal>READ</literal>, <literal>UPGRADE</literal> "
"or <literal>UPGRADE_NOWAIT</literal>. In the case of <literal>UPGRADE</"
"literal> or <literal>UPGRADE_NOWAIT</literal>, <literal>SELECT ... FOR "
"UPDATE</literal> is used."
msgstr ""
"<literal>Session.lock()</literal> realiza un chequeo de número de versión si "
"el modo de bloqueo especificado es <literal>READ</literal>, "
"<literal>UPGRADE</literal> o <literal>UPGRADE_NOWAIT</literal>. En el caso "
"de <literal>UPGRADE</literal> o <literal>UPGRADE_NOWAIT</literal>, se usa "
"<literal>SELECT ... FOR UPDATE</literal>."

#. Tag: para
#, no-c-format
msgid ""
"If the requested lock mode is not supported by the database, Hibernate uses "
"an appropriate alternate mode instead of throwing an exception. This ensures "
"that applications are portable."
msgstr ""
"Si la base de datos no soporta el modo de bloqueo solicitado, Hibernate usa "
"un modo opcional apropiado en lugar de lanzar una excepción. Esto asegura "
"que las aplicaciones serán portátiles."

#. Tag: title
#, no-c-format
msgid "Connection release modes"
msgstr "Modos de liberación de la conexión"

#. Tag: para
#, no-c-format
msgid ""
"One of the legacies of Hibernate 2.x JDBC connection management meant that a "
"<literal>Session</literal> would obtain a connection when it was first "
"required and then maintain that connection until the session was closed. "
"Hibernate 3.x introduced the notion of connection release modes that would "
"instruct a session how to handle its JDBC connections. The following "
"discussion is pertinent only to connections provided through a configured "
"<literal>ConnectionProvider</literal>. User-supplied connections are outside "
"the breadth of this discussion. The different release modes are identified "
"by the enumerated values of <literal>org.hibernate.ConnectionReleaseMode</"
"literal>:"
msgstr ""
"La herencia (2x) de Hibernate en relación con la administración de la "
"conexion JDBC fue que una <literal>Session</literal> obtendría una conexión "
"cuando se necesitara por primera vez y luego la mantendría hasta que se "
"cerrara la sesión. Hibernate 3.x introdujo la noción de modos de liberación "
"de conexión para decirle a la sesión como manejar sus conexiones JDBC. La "
"siguiente discusión sólamente es pertinente para las conexiones provistas "
"por medio de un <literal>ConnectionProvider</literal> configurado. Las "
"conexiones provistas por el usuario no se discuten aquí. Los diferentes "
"modos de liberación se identifican por los valores numerados de <literal>org."
"hibernate.ConnectionReleaseMode</literal>:"

#. Tag: para
#, no-c-format
msgid ""
"<literal>ON_CLOSE</literal>: is the legacy behavior described above. The "
"Hibernate session obtains a connection when it first needs to perform some "
"JDBC access and maintains that connection until the session is closed."
msgstr ""
"<literal>ON_CLOSE</literal>: es el comportamiento heredado descrito "
"anteriormente. La sesión de Hibernate obtiene una conexión cuando necesita "
"acceder a JDBC la primera vez y mantiene esa conexión hasta que se cierra la "
"sesión."

#. Tag: para
#, no-c-format
msgid ""
"<literal>AFTER_TRANSACTION</literal>: releases connections after a "
"<literal>org.hibernate.Transaction</literal> has been completed."
msgstr ""
"<literal>AFTER_TRANSACTION</literal>: libera las conecciones después de que "
"se ha completado una <literal>org.hibernate.Transaction</literal>."

#. Tag: para
#, no-c-format
msgid ""
"<literal>AFTER_STATEMENT</literal> (also referred to as aggressive release): "
"releases connections after every statement execution. This aggressive "
"releasing is skipped if that statement leaves open resources associated with "
"the given session. Currently the only situation where this occurs is through "
"the use of <literal>org.hibernate.ScrollableResults</literal>."
msgstr ""
"<literal>AFTER_STATEMENT</literal> (también se conoce como una liberación "
"agresiva): libera conexiones después de cada ejecución de una declaración. "
"Se salta esta liberación agresiva si la declaración deja abiertos recursos "
"asociados con la sesión dada. Actualmente la única situación donde ocurre "
"esto es por medio del uso de <literal>org.hibernate.ScrollableResults</"
"literal>."

#. Tag: para
#, no-c-format
msgid ""
"The configuration parameter <literal>hibernate.connection.release_mode</"
"literal> is used to specify which release mode to use. The possible values "
"are as follows:"
msgstr ""
"El parámetro de configuración <literal>hibernate.connection.release_mode</"
"literal> se utiliza para especificar el modo de liberación a utilizar. Los "
"valores posibles son los siguientes:"

#. Tag: para
#, no-c-format
msgid ""
"<literal>auto</literal> (the default): this choice delegates to the release "
"mode returned by the <literal>org.hibernate.transaction.TransactionFactory."
"getDefaultReleaseMode()</literal> method. For JTATransactionFactory, this "
"returns ConnectionReleaseMode.AFTER_STATEMENT; for JDBCTransactionFactory, "
"this returns ConnectionReleaseMode.AFTER_TRANSACTION. Do not change this "
"default behavior as failures due to the value of this setting tend to "
"indicate bugs and/or invalid assumptions in user code."
msgstr ""
"<literal>auto</literal> (predeterminado): esta opción delega al modo de "
"liberación devuelto por el método <literal>org.hibernate.transaction."
"TransactionFactory.getDefaultReleaseMode()</literal>. Para "
"JTATransactionFactory, esto devuelve ConnectionReleaseMode.AFTER_STATEMENT; "
"para JDBCTransactionFactory, esto devuelve ConnectionReleaseMode."
"AFTER_TRANSACTION. No cambie este comportamiento predeterminado ya que las "
"fallas debido a este valor de esta configuración tienden a indicar errores y/"
"o suposiciones en el código del usuario."

#. Tag: para
#, no-c-format
msgid ""
"<literal>on_close</literal>: uses ConnectionReleaseMode.ON_CLOSE. This "
"setting is left for backwards compatibility, but its use is discouraged."
msgstr ""
"<literal>on_close</literal>: usa ConnectionReleaseMode.ON_CLOSE. Esta "
"configuración se deja para la compatibilidad con versiones anteriores, pero "
"no se recomienda para nada su utilización."

#. Tag: para
#, no-c-format
msgid ""
"<literal>after_transaction</literal>: uses ConnectionReleaseMode."
"AFTER_TRANSACTION. This setting should not be used in JTA environments. Also "
"note that with ConnectionReleaseMode.AFTER_TRANSACTION, if a session is "
"considered to be in auto-commit mode, connections will be released as if the "
"release mode were AFTER_STATEMENT."
msgstr ""
"<literal>after_transaction</literal>: utiliza ConnectionReleaseMode."
"AFTER_TRANSACTION. Esta configuración no se debe utilizar en entornos JTA. "
"También note que con ConnectionReleaseMode.AFTER_TRANSACTION, si se "
"considera que una sesión se encuentra en modo auto-commit, las conexiones "
"serán liberada como si el modo de liberación fuese AFTER_STATEMENT."

#. Tag: para
#, no-c-format
msgid ""
"<literal>after_statement</literal>: uses ConnectionReleaseMode."
"AFTER_STATEMENT. Additionally, the configured <literal>ConnectionProvider</"
"literal> is consulted to see if it supports this setting "
"(<literal>supportsAggressiveRelease()</literal>). If not, the release mode "
"is reset to ConnectionReleaseMode.AFTER_TRANSACTION. This setting is only "
"safe in environments where we can either re-acquire the same underlying JDBC "
"connection each time you make a call into <literal>ConnectionProvider."
"getConnection()</literal> or in auto-commit environments where it does not "
"matter if we re-establish the same connection."
msgstr ""
"<literal>after_statement</literal>: usa ConnectionReleaseMode."
"AFTER_STATEMENT. Además se consulta la <literal>ConnectionProvider</literal> "
"configurada para ver si soporta esta característica "
"<literal>supportsAggressiveRelease()</literal>. Si no, el modo de liberación "
"se vuelve a establecer como ConnectionReleaseMode.AFTER_TRANSACTION. Esta "
"configuración sólamente es segura en entornos en donde podemos re-adquirir "
"la misma conexión JDBC subyacente cada vez que llamamos a "
"<literal>ConnectionProvider.getConnection()</literal> o en entornos auto-"
"commit, en donde no importa si recibimos la misma conexión."

