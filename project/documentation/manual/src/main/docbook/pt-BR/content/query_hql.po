# translation of query_hql.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# Michael H. Smith <mhideo@redhat.com>, 2007.
# Glaucia Cintra <gcintra@redhat.com>, 2007.
msgid ""
msgstr ""
"Project-Id-Version: query_hql\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:15\n"
"PO-Revision-Date: 2010-03-19 09:37+1000\n"
"Last-Translator: \n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "HQL: The Hibernate Query Language"
msgstr "HQL: A Linguagem de Consultas do Hibernate"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate uses a powerful query language (HQL) that is similar in appearance "
"to SQL. Compared with SQL, however, HQL is fully object-oriented and "
"understands notions like inheritance, polymorphism and association."
msgstr ""
"O Hibernate vem com uma poderosa linguagem de consulta (HQL) que é muito "
"parecida com o SQL. No entanto, comparado com o SQL o HQL é totalmente "
"orientado à objetos, e compreende noções de herança, polimorfismo e "
"associações."

#. Tag: title
#, no-c-format
msgid "Case Sensitivity"
msgstr "Diferenciação de maiúscula e minúscula"

#. Tag: para
#, no-c-format
msgid ""
"With the exception of names of Java classes and properties, queries are case-"
"insensitive. So <literal>SeLeCT</literal> is the same as <literal>sELEct</"
"literal> is the same as <literal>SELECT</literal>, but <literal>org."
"hibernate.eg.FOO</literal> is not <literal>org.hibernate.eg.Foo</literal>, "
"and <literal>foo.barSet</literal> is not <literal>foo.BARSET</literal>."
msgstr ""
"As Consultas não diferenciam maiúscula de minúscula, exceto pelo nomes das "
"classes e propriedades Java. Portanto, <literal>SeLeCT</literal> é o mesmo "
"que <literal>sELEct</literal> que é o mesmo que <literal>SELECT</literal>, "
"mas <literal>org.hibernate.eg.FOO</literal> não é <literal>org.hibernate.eg."
"Foo</literal> e <literal>foo.barSet</literal> não é <literal>foo.BARSET</"
"literal>."

#. Tag: para
#, no-c-format
msgid ""
"This manual uses lowercase HQL keywords. Some users find queries with "
"uppercase keywords more readable, but this convention is unsuitable for "
"queries embedded in Java code."
msgstr ""
"Esse manual usa as palavras chave HQL em letras minúsculas. Alguns usuários "
"acreditam que com letras maiúsculas as consultas ficam mais legíveis, mas "
"nós acreditamos que este formato não é apropriado para o código Java. "

#. Tag: title
#, no-c-format
msgid "The from clause"
msgstr "A cláusula from"

#. Tag: para
#, no-c-format
msgid "The simplest possible Hibernate query is of the form:"
msgstr "A consulta mais simples possível do Hibernate é a seguinte:"

#. Tag: para
#, no-c-format
msgid ""
"This returns all instances of the class <literal>eg.Cat</literal>. You do "
"not usually need to qualify the class name, since <literal>auto-import</"
"literal> is the default. For example:"
msgstr ""
"Isto simplesmente retornará todas as instâncias da classe <literal>eg.Cat</"
"literal>. Geralmente não precisamos qualificar o nome da classe, uma vez que "
"o <literal>auto-import</literal> é o padrão. Por exemplo:"

#. Tag: para
#, no-c-format
msgid ""
"In order to refer to the <literal>Cat</literal> in other parts of the query, "
"you will need to assign an <emphasis>alias</emphasis>. For example:"
msgstr ""
"Com o objetivo de referir-se ao <literal>Cat</literal> em outras partes da "
"consulta, você precisará determinar um <emphasis>alias</emphasis>. Por "
"exemplo:"

#. Tag: para
#, no-c-format
msgid ""
"This query assigns the alias <literal>cat</literal> to <literal>Cat</"
"literal> instances, so you can use that alias later in the query. The "
"<literal>as</literal> keyword is optional. You could also write:"
msgstr ""
"Essa consulta atribui um alias a <literal>cat</literal> para as instâncias "
"de <literal>Cat</literal>, portanto poderemos usar esse alias mais tarde na "
"consulta. A palavra chave <literal>as</literal> é opcional. Você também pode "
"escrever assim:"

#. Tag: para
#, no-c-format
msgid ""
"Multiple classes can appear, resulting in a cartesian product or \"cross\" "
"join."
msgstr ""
"Classes múltiplas podem ser envolvidas, resultando em um produto cartesiano "
"ou união \"cruzada\". "

#. Tag: para
#, no-c-format
msgid ""
"It is good practice to name query aliases using an initial lowercase as this "
"is consistent with Java naming standards for local variables (e.g. "
"<literal>domesticCat</literal>)."
msgstr ""
"É considerada uma boa prática nomear alias de consulta, utilizando uma letra "
"minúscula inicial, consistente com os padrões de nomeação Java para "
"variáveis locais (ex.: <literal>domesticCat</literal>). "

#. Tag: title
#, no-c-format
msgid "Associations and joins"
msgstr "Associações e uniões"

#. Tag: para
#, no-c-format
msgid ""
"You can also assign aliases to associated entities or to elements of a "
"collection of values using a <literal>join</literal>. For example:"
msgstr ""
"Podemos também atribuir aliases em uma entidade associada, ou mesmo em "
"elementos de uma coleção de valores, usando uma <literal>join</literal>. Por "
"exemplo:"

#. Tag: para
#, no-c-format
msgid "The supported join types are borrowed from ANSI SQL:"
msgstr "Os tipos de uniões suportados foram inspirados no ANSI SQL:"

#. Tag: para
#, no-c-format
msgid "<literal>inner join</literal>"
msgstr "<literal>inner join</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>left outer join</literal>"
msgstr "<literal>left outer join</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>right outer join</literal>"
msgstr "<literal>right outer join</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>full join</literal> (not usually useful)"
msgstr "<literal>união completa</literal> (geralmente não é útil)"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>inner join</literal>, <literal>left outer join</literal> and "
"<literal>right outer join</literal> constructs may be abbreviated."
msgstr ""
"As construções <literal>inteiro</literal>, <literal>união esquerda externa</"
"literal> e <literal>união direita externa</literal> podem ser abreviadas."

#. Tag: para
#, no-c-format
msgid ""
"You may supply extra join conditions using the HQL <literal>with</literal> "
"keyword."
msgstr ""
"Você pode fornecer condições extras de união usando a palavra chave do HQL "
"<literal>with</literal>."

#. Tag: para
#, no-c-format
msgid ""
"A \"fetch\" join allows associations or collections of values to be "
"initialized along with their parent objects using a single select. This is "
"particularly useful in the case of a collection. It effectively overrides "
"the outer join and lazy declarations of the mapping file for associations "
"and collections. See <xref linkend=\"performance-fetching\" /> for more "
"information."
msgstr ""
"A união de \"busca\" permite que associações ou coleções de valores sejam "
"inicializadas junto com o objeto pai, usando apenas um select. Isso é muito "
"útil no caso das coleções. Isso efetivamente substitui as declarações união "
"externa e declarações lazy do arquivo de mapeamento para associações e coleções. Consulte <xref linkend=\"performance-fetching\" /> para mais informações."

#. Tag: para
#, no-c-format
msgid ""
"A fetch join does not usually need to assign an alias, because the "
"associated objects should not be used in the <literal>where</literal> clause "
"(or any other clause). The associated objects are also not returned directly "
"in the query results. Instead, they may be accessed via the parent object. "
"The only reason you might need an alias is if you are recursively join "
"fetching a further collection:"
msgstr ""
"Geralmente, uma união de busca não precisa atribuir um alias, pois o objeto "
"associado não deve ser usado na cláusula <literal>where</literal> (ou em "
"qualquer outra cláusula). Também, os objetos associados não são retornados "
"diretamente nos resultados da consulta. Ao invés disso, eles devem ser "
"acessados usando o objeto pai. A única razão pela qual precisariamos de um "
"alias é quando fazemos uma união de busca recursivamente em uma coleção "
"adicional: "

#. Tag: para
#, no-c-format
msgid ""
"The <literal>fetch</literal> construct cannot be used in queries called "
"using <literal>iterate()</literal> (though <literal>scroll()</literal> can "
"be used). <literal>Fetch</literal> should be used together with "
"<literal>setMaxResults()</literal> or <literal>setFirstResult()</literal>, "
"as these operations are based on the result rows which usually contain "
"duplicates for eager collection fetching, hence, the number of rows is not "
"what you would expect. <literal>Fetch</literal> should also not be used "
"together with impromptu <literal>with</literal> condition. It is possible to "
"create a cartesian product by join fetching more than one collection in a "
"query, so take care in this case. Join fetching multiple collection roles "
"can produce unexpected results for bag mappings, so user discretion is "
"advised when formulating queries in this case. Finally, note that "
"<literal>full join fetch</literal> and <literal>right join fetch</literal> "
"are not meaningful."
msgstr ""
"Observe que a construção <literal>busca</literal> não deve ser usada em "
"consultas invocadas usando <literal>iterate()</literal> (embora possa ser "
"usado com <literal>scroll()</literal>). O <literal>Fetch</literal> também "
"não deve ser usado junto com o <literal>setMaxResults()</literal> ou "
"<literal>setFirstResult()</literal> pois essas operações são baseadas nas "
"linhas retornadas, que normalmente contém duplicidade devido à busca das "
"coleções, então o número de linhas pode não ser o que você espera. A "
"<literal>Fetch</literal> não deve ser usada junto com uma condição "
"<literal>with</literal>. É possível que seja criado um produto cartesiano "
"pela busca de união em mais do que uma coleção em uma consulta, então tome "
"cuidado nesses casos. Uma busca de união em várias coleções pode trazer "
"resultados inesperados para mapeamentos do tipo bag, tome cuidado na hora de "
"formular consultas como essas. Finalmente, observe o seguinte, a "
"<literal>busca de união completa</literal> e <literal>busca de união "
"direita</literal> não são importantes."

#. Tag: para
#, no-c-format
msgid ""
"If you are using property-level lazy fetching (with bytecode "
"instrumentation), it is possible to force Hibernate to fetch the lazy "
"properties in the first query immediately using <literal>fetch all "
"properties</literal>."
msgstr ""
"Se estiver usando o nível de propriedade busca lazy (com instrumentação de "
"bytecode), é possível forçar o Hibernate a buscar as propriedades lazy "
"imediatamente na primeira consulta, usando <literal>buscar todas as "
"propriedades </literal>. "

#. Tag: title
#, no-c-format
msgid "Forms of join syntax"
msgstr "Formas de sintáxe de uniões"

#. Tag: para
#, no-c-format
msgid ""
"HQL supports two forms of association joining: <literal>implicit</literal> "
"and <literal>explicit</literal>."
msgstr ""
"O HQL suporta duas formas de associação para união: <literal>implícita</"
"literal> e <literal>explícita</literal>."

#. Tag: para
#, no-c-format
msgid ""
"The queries shown in the previous section all use the <literal>explicit</"
"literal> form, that is, where the join keyword is explicitly used in the "
"from clause. This is the recommended form."
msgstr ""
"As consultas apresentadas na seção anterior usam a forma <literal>explícita</"
"literal>, onde a palavra chave união é explicitamente usada na cláusula "
"from. Essa é a forma recomendada."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>implicit</literal> form does not use the join keyword. Instead, "
"the associations are \"dereferenced\" using dot-notation. <literal>implicit</"
"literal> joins can appear in any of the HQL clauses. <literal>implicit</"
"literal> join result in inner joins in the resulting SQL statement."
msgstr ""
"A forma <literal>implícita</literal> não usa a palavra chave \"união\". "
"Entretanto, as associações são \"diferenciadas\" usando pontuação (\".\" - "
"dot-notation). Uniões<literal>implícitas</literal> podem aparecer em "
"qualquer uma das cláusulas HQL. A união <literal>implícita</literal> resulta "
"em declarações SQL que contém uniões inteiras."

#. Tag: title
#, no-c-format
msgid "Referring to identifier property"
msgstr "Referência à propriedade do identificador "

#. Tag: para
#, no-c-format
msgid "There are 2 ways to refer to an entity's identifier property:"
msgstr ""
"Geralmente, existem duas formas para se referir à propriedade do "
"indentificador de uma entidade: "

#. Tag: para
#, no-c-format
msgid ""
"The special property (lowercase) <literal>id</literal> may be used to "
"reference the identifier property of an entity <emphasis>provided that the "
"entity does not define a non-identifier property named id</emphasis>."
msgstr ""
"A propriedade especial (em letra minúscula) <literal>id</literal> pode ser "
"usada para se referir à propriedade do identificador de uma entidade "
"<emphasis>considerando que a entidade não define uma propriedade não "
"identificadora chamada id</emphasis>."

#. Tag: para
#, no-c-format
msgid ""
"If the entity defines a named identifier property, you can use that property "
"name."
msgstr ""
"Se a entidade definir a propriedade do identificador nomeada, você poderá "
"usar este nome de propriedade. "

#. Tag: para
#, no-c-format
msgid ""
"References to composite identifier properties follow the same naming rules. "
"If the entity has a non-identifier property named id, the composite "
"identifier property can only be referenced by its defined named. Otherwise, "
"the special <literal>id</literal> property can be used to reference the "
"identifier property."
msgstr ""
"As referências à composição das propriedades do identificador seguem as "
"mesmas regras de nomeação. Se a entidade tiver uma propriedade de não "
"identificador chamada id, a composição da propriedade do identificador pode "
"somente ser referenciada pelo seu nome definido. Do contrário, uma "
"propriedade especial <literal>id</literal> poderá ser usada para referenciar "
"a propriedade do identificador. "

#. Tag: para
#, no-c-format
msgid ""
"Please note that, starting in version 3.2.2, this has changed significantly. "
"In previous versions, <literal>id</literal> <emphasis>always</emphasis> "
"referred to the identifier property regardless of its actual name. A "
"ramification of that decision was that non-identifier properties named "
"<literal>id</literal> could never be referenced in Hibernate queries."
msgstr ""
"Observe: esta ação mudou completamente na versão 3.2.2. Nas versões "
"anteriores o <literal>id</literal> <emphasis>sempre</emphasis> referia-se à "
"propriedade do identificador não importando seu nome atual. Uma ramificação "
"desta decisão era que as propriedades do não identificador de chamadas "
"<literal>id</literal> nunca poderiam ser referenciadas nas consultas do "
"Hibernate. "

#. Tag: title
#, no-c-format
msgid "The select clause"
msgstr "A cláusula select"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>select</literal> clause picks which objects and properties to "
"return in the query result set. Consider the following:"
msgstr ""
"A cláusula <literal>select</literal> seleciona quais objetos e propriedades "
"retornam no resultado da consulta. Considere: "

#. Tag: para
#, no-c-format
msgid ""
"The query will select <literal>mate</literal>s of other <literal>Cat</"
"literal>s. You can express this query more compactly as:"
msgstr ""
"A consulta selecionará <literal>mate</literal>s (parceiros), de outros "
"<literal>Cat</literal>s. Atualmente, podemos expressar a consulta de forma "
"mais compacta como: "

#. Tag: para
#, no-c-format
msgid ""
"Queries can return properties of any value type including properties of "
"component type:"
msgstr ""
"As consultas podem retornar propriedades de qualquer tipo de valor, "
"incluindo propriedades de tipo de componente: "

#. Tag: para
#, no-c-format
msgid ""
"Queries can return multiple objects and/or properties as an array of type "
"<literal>Object[]</literal>:"
msgstr ""
"As consultas podem retornar múltiplos objetos e/ou propriedades como uma "
"matriz do tipo <literal>Object[]</literal>:"

#. Tag: para
#, no-c-format
msgid "Or as a <literal>List</literal>:"
msgstr "Ou como um <literal>List</literal>:"

#. Tag: para
#, no-c-format
msgid ""
"Or - assuming that the class <literal>Family</literal> has an appropriate "
"constructor - as an actual typesafe Java object:"
msgstr ""
"Ou - considerando que a classe <literal>Family</literal> tenha um construtor "
"apropriado - como um objeto Java typesafe atual:"

#. Tag: para
#, no-c-format
msgid "You can assign aliases to selected expressions using <literal>as</literal>:"
msgstr ""
"Pode-se designar alias à expressões selecionadas usando <literal>as</"
"literal>:"

#. Tag: para
#, no-c-format
msgid ""
"This is most useful when used together with <literal>select new map</"
"literal>:"
msgstr ""
"Isto é bem mais útil quando usado junto <literal>com</"
"literal><literal>selecione novo mapa</literal>:"

#. Tag: para
#, no-c-format
msgid "This query returns a <literal>Map</literal> from aliases to selected values."
msgstr ""
"Esta consulta retorna um <literal>Mapa</literal> de referências para valores "
"selecionados."

#. Tag: title
#, no-c-format
msgid "Aggregate functions"
msgstr "Funções de agregação"

#. Tag: para
#, no-c-format
msgid "HQL queries can even return the results of aggregate functions on properties:"
msgstr ""
"As consultas HQL podem retornar o resultado de funções agregadas nas "
"propriedades:"

#. Tag: para
#, no-c-format
msgid "The supported aggregate functions are:"
msgstr "As funções agregadas suportadas são: "

#. Tag: para
#, no-c-format
msgid "<literal>avg(...), sum(...), min(...), max(...)</literal>"
msgstr "<literal>avg(...), sum(...), min(...), max(...)</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>count(*)</literal>"
msgstr "<literal>count(*)</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>count(...), count(distinct ...), count(all...)</literal>"
msgstr "<literal>count(...), count(distinct ...), count(all...)</literal>"

#. Tag: para
#, no-c-format
msgid ""
"You can use arithmetic operators, concatenation, and recognized SQL "
"functions in the select clause:"
msgstr ""
"Pode-se usar operadores aritméticos, concatenação e funções SQL reconhecidas "
"na cláusula select: "

#. Tag: para
#, no-c-format
msgid ""
"The <literal>distinct</literal> and <literal>all</literal> keywords can be "
"used and have the same semantics as in SQL."
msgstr ""
"As palavras <literal>distinct</literal> e <literal>all</literal> podem ser "
"usadas e têm a mesma semântica que no SQL. "

#. Tag: title
#, no-c-format
msgid "Polymorphic queries"
msgstr "Pesquisas Polimórficas"

#. Tag: para
#, no-c-format
msgid "A query like:"
msgstr "A consulta:"

#. Tag: para
#, no-c-format
msgid ""
"returns instances not only of <literal>Cat</literal>, but also of subclasses "
"like <literal>DomesticCat</literal>. Hibernate queries can name "
"<emphasis>any</emphasis> Java class or interface in the <literal>from</"
"literal> clause. The query will return instances of all persistent classes "
"that extend that class or implement the interface. The following query would "
"return all persistent objects:"
msgstr ""
"retorna instâncias não só de <literal>Cat</literal>, mas também de "
"subclasses como <literal>DomesticCat</literal>. As consultas do Hibernate "
"podem nomear qualquer classe Java ou interface na cláusula <literal>from</"
"literal>. A consulta retornará instâncias de todas as classes persistentes "
"que extendam a determinada classe ou implemente a determinada interface. A "
"consulta a seguir, poderia retornar todos os objetos persistentes: "

#. Tag: para
#, no-c-format
msgid ""
"The interface <literal>Named</literal> might be implemented by various "
"persistent classes:"
msgstr ""
"A interface <literal>Named</literal> pode ser implementada por várias "
"classes persistentes:"

#. Tag: para
#, no-c-format
msgid ""
"These last two queries will require more than one SQL <literal>SELECT</"
"literal>. This means that the <literal>order by</literal> clause does not "
"correctly order the whole result set. It also means you cannot call these "
"queries using <literal>Query.scroll()</literal>."
msgstr ""
"Note que as duas últimas consultas requerem mais de um SQL <literal>SELECT</"
"literal>. Isto significa que a cláusula <literal>order by</literal> não "
"ordena corretamente todo o resultado. Isso também significa que você não "
"pode chamar essas consultas usando <literal>consulta.scroll()</literal>."

#. Tag: title
#, no-c-format
msgid "The where clause"
msgstr "A cláusula where"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>where</literal> clause allows you to refine the list of "
"instances returned. If no alias exists, you can refer to properties by name:"
msgstr ""
"A cláusula <literal>where</literal> permite estreitar a lista de instâncias "
"retornadas. Se não houver referência alguma, pode-se referir à propriedades "
"pelo nome: "

#. Tag: para
#, no-c-format
msgid "If there is an alias, use a qualified property name:"
msgstr "Se houver uma referência, use o nome da propriedade qualificada:"

#. Tag: para
#, no-c-format
msgid "This returns instances of <literal>Cat</literal> named 'Fritz'."
msgstr "Isto retorna instâncias de <literal>Cat</literal> com nome ‘Fritz’."

#. Tag: para
#, no-c-format
msgid "The following query:"
msgstr "A seguinte consulta:"

#. Tag: para
#, no-c-format
msgid ""
"returns all instances of <literal>Foo</literal> with an instance of "
"<literal>bar</literal> with a <literal>date</literal> property equal to the "
"<literal>startDate</literal> property of the <literal>Foo</literal>. "
"Compound path expressions make the <literal>where</literal> clause extremely "
"powerful. Consider the following:"
msgstr ""
"retornará todas as instâncias de <literal>Foo</literal>, para cada um que "
"tiver uma instância de <literal>bar</literal> com a propriedade "
"<literal>date</literal> igual a propriedade <literal>startDate</literal> de "
"<literal>Foo</literal>. Expressões de caminho compostas fazem da cláusula "
"<literal>where</literal>, extremamente poderosa. Consideremos: "

#. Tag: para
#, no-c-format
msgid "This query translates to an SQL query with a table (inner) join. For example:"
msgstr ""
"Esta consulta traduz para uma consulta SQL com uma tabela (inner) união. Por "
"exemplo:"

#. Tag: para
#, no-c-format
msgid "would result in a query that would require four table joins in SQL."
msgstr "resultaria numa consulta que necessitasse de união de quatro tabelas, no SQL."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>=</literal> operator can be used to compare not only "
"properties, but also instances:"
msgstr ""
"O operador <literal>=</literal> pode ser usado para comparar não apenas "
"propriedades, mas também instâncias: "

#. Tag: para
#, no-c-format
msgid ""
"The special property (lowercase) <literal>id</literal> can be used to "
"reference the unique identifier of an object. See <xref linkend=\"queryhql-"
"identifier-property\" /> for more information."
msgstr ""
"A propriedade especial (letra minúscula) <literal>id</literal> pode ser "
"usada para referenciar o identificador único de um objeto. Para maiores "
"informações consulte a <xref linkend=\"queryhql-"
"identifier-property\" />.  "

#. Tag: para
#, no-c-format
msgid "The second query is efficient and does not require a table join."
msgstr "A segunda consulta é eficiente e não requer nenhuma união de tabelas."

#. Tag: para
#, no-c-format
msgid ""
"Properties of composite identifiers can also be used. Consider the following "
"example where <literal>Person</literal> has composite identifiers consisting "
"of <literal>country</literal> and <literal>medicareNumber</literal>:"
msgstr ""
"As propriedades de identificadores compostas também podem ser usadas. "
"Considere o seguinte exemplo onde <literal>Person</literal> possui "
"identificadores compostos que consistem de <literal>country</literal> e "
"<literal>medicareNumber</literal>: "

#. Tag: para
#, no-c-format
msgid "Once again, the second query does not require a table join."
msgstr "Mais uma vez, a segunda consulta não precisa de nenhuma união de tabela."

#. Tag: para
#, no-c-format
msgid ""
"See <xref linkend=\"queryhql-identifier-property\" /> for more information "
"regarding referencing identifier properties)"
msgstr ""
"Veja <xref linkend=\"queryhql-identifier-property\" /> para maiores "
"informações a respeito das propriedades do identificador referenciado) "

#. Tag: para
#, no-c-format
msgid ""
"The special property <literal>class</literal> accesses the discriminator "
"value of an instance in the case of polymorphic persistence. A Java class "
"name embedded in the where clause will be translated to its discriminator "
"value."
msgstr ""
"Da mesma forma, a propriedade especial <literal>class</literal> acessa o "
"valor discriminador da instância, no caso de persistência polimórfica. O "
"nome de uma classe Java inclusa em uma cláusula where, será traduzida para "
"seu valor discriminante."

#. Tag: para
#, no-c-format
msgid ""
"You can also use components or composite user types, or properties of said "
"component types. See <xref linkend=\"queryhql-components\" /> for more "
"information."
msgstr ""
"Pode-se também utilizar componentes ou tipos de usuários de composição, ou "
"propriedades dos tipos de componentes mencionados. Veja <xref linkend=\"queryhql-components\" /> para maiores informações."

#. Tag: para
#, no-c-format
msgid ""
"An \"any\" type has the special properties <literal>id</literal> and "
"<literal>class</literal> that allows you to express a join in the following "
"way (where <literal>AuditLog.item</literal> is a property mapped with "
"<literal>&lt;any&gt;</literal>):"
msgstr ""
"Um tipo \"any\" possui as propriedades <literal>id</literal> e "
"<literal>class</literal> especiais, nos permitindo expressar uma união da "
"seguinte forma (onde <literal>AuditLog.item</literal> é uma propriedade "
"mapeada <literal>com</literal><literal>&lt;any&gt;</literal>):"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>log.item.class</literal> and <literal>payment.class</literal> "
"would refer to the values of completely different database columns in the "
"above query."
msgstr ""
"Veja que <literal>log.item.class</literal> e <literal>payment.class</"
"literal> podem referir-se à valores de colunas de banco de dados "
"completamente diferentes, na consulta acima. "

#. Tag: title
#, no-c-format
msgid "Expressions"
msgstr "Expressões"

#. Tag: para
#, no-c-format
msgid ""
"Expressions used in the <literal>where</literal> clause include the "
"following:"
msgstr ""
"As expressões permitidas na cláusula <literal>where</literal> incluem o "
"seguinte:"

#. Tag: para
#, no-c-format
msgid "mathematical operators: <literal>+, -, *, /</literal>"
msgstr "operadores matemáticos: <literal>+, -, *, /</literal>"

#. Tag: para
#, no-c-format
msgid ""
"binary comparison operators: <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</"
"literal>"
msgstr ""
"operadores de comparação binários: <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, "
"like</literal>"

#. Tag: para
#, no-c-format
msgid "logical operations <literal>and, or, not</literal>"
msgstr "operadores lógicos <literal>and, or, not</literal>"

#. Tag: para
#, no-c-format
msgid "Parentheses <literal>( )</literal> that indicates grouping"
msgstr "Parênteses <literal>( )</literal> que indica o agrupamento"

#. Tag: para
#, no-c-format
msgid ""
"<literal>in</literal>, <literal>not in</literal>, <literal>between</"
"literal>, <literal>is null</literal>, <literal>is not null</literal>, "
"<literal>is empty</literal>, <literal>is not empty</literal>, "
"<literal>member of</literal> and <literal>not member of</literal>"
msgstr ""
"<literal>in</literal>, <literal>not in</literal>, <literal>between</"
"literal>, <literal>is null</literal>, <literal>is not null</literal>, "
"<literal>is empty</literal>, <literal>is not empty</literal>, "
"<literal>member of</literal> and <literal>not member of</literal>"

#. Tag: para
#, no-c-format
msgid ""
"\"Simple\" case, <literal>case ... when ... then ... else ... end</literal>, "
"and \"searched\" case, <literal>case when ... then ... else ... end</literal>"
msgstr ""
"case \"simples\" , <literal>case ... when ... then ... else ... end</"
"literal>, and \"searched\" case, <literal>case when ... then ... else ... "
"end</literal>"

#. Tag: para
#, no-c-format
msgid ""
"string concatenation <literal>...||...</literal> or <literal>concat(...,...)"
"</literal>"
msgstr ""
"concatenação de string <literal>...||...</literal> ou <literal>concat"
"(...,...)</literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>current_date()</literal>, <literal>current_time()</literal>, and "
"<literal>current_timestamp()</literal>"
msgstr ""
"<literal>current_date()</literal>, <literal>current_time()</literal> e "
"<literal>current_timestamp()</literal> "

#. Tag: para
#, no-c-format
msgid ""
"<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour"
"(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, "
"and <literal>year(...)</literal>"
msgstr ""
"<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour"
"(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal> "
"e <literal>year(...)</literal>"

#. Tag: para
#, no-c-format
msgid ""
"Any function or operator defined by EJB-QL 3.0: <literal>substring(), trim"
"(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()"
"</literal>"
msgstr ""
"qualquer função ou operador definidos pela EJB-QL 3.0: <literal>substring(), "
"trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), "
"mod()</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>coalesce()</literal> and <literal>nullif()</literal>"
msgstr "<literal>coalesce()</literal> and <literal>nullif()</literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>str()</literal> for converting numeric or temporal values to a "
"readable string"
msgstr ""
"<literal>str()</literal> para converter valores numéricos ou temporais para "
"uma string de leitura"

#. Tag: para
#, no-c-format
msgid ""
"<literal>cast(... as ...)</literal>, where the second argument is the name "
"of a Hibernate type, and <literal>extract(... from ...)</literal> if ANSI "
"<literal>cast()</literal> and <literal>extract()</literal> is supported by "
"the underlying database"
msgstr ""
"<literal>cast(... as ...)</literal>, onde o segundo argumento é o nome do "
"tipo hibernate, e<literal>extract(... from ...)</literal> se ANSI "
"<literal>cast()</literal> e <literal>extract()</literal> é suportado pelo "
"banco de dados adjacente"

#. Tag: para
#, no-c-format
msgid ""
"the HQL <literal>index()</literal> function, that applies to aliases of a "
"joined indexed collection"
msgstr ""
"A função HQL <literal>index()</literal> , que se aplicam às referências de "
"coleçôes associadas e indexadas"

#. Tag: para
#, no-c-format
msgid ""
"HQL functions that take collection-valued path expressions: <literal>size(), "
"minelement(), maxelement(), minindex(), maxindex()</literal>, along with the "
"special <literal>elements()</literal> and <literal>indices</literal> "
"functions that can be quantified using <literal>some, all, exists, any, in</"
"literal>."
msgstr ""
"As funções HQL que retornam expressões de coleções de valores: <literal>size"
"(), minelement(), maxelement(), minindex(), maxindex()</literal>, junto com "
"o elemento especial, <literal>elements()</literal> e funções de "
"<literal>índices</literal> que podem ser quantificadas usando <literal>some, "
"all, exists, any, in</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Any database-supported SQL scalar function like <literal>sign()</literal>, "
"<literal>trunc()</literal>, <literal>rtrim()</literal>, and <literal>sin()</"
"literal>"
msgstr ""
"Qualquer função escalar suportada pelo banco de dados como <literal>sign()</"
"literal>, <literal>trunc()</literal>, <literal>rtrim()</literal> e "
"<literal>sin()</literal>"

#. Tag: para
#, no-c-format
msgid "JDBC-style positional parameters <literal>?</literal>"
msgstr "Parâmetros posicionais ao estilo JDBC <literal>?</literal>"

#. Tag: para
#, no-c-format
msgid ""
"named parameters <literal>:name</literal>, <literal>:start_date</literal>, "
"and <literal>:x1</literal>"
msgstr ""
"Parâmetros nomeados <literal>:name</literal>, <literal>:start_date</literal> "
"e <literal>:x1</literal>"

#. Tag: para
#, no-c-format
msgid ""
"SQL literals <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E"
"+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"
msgstr ""
"Literais SQL <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E"
"+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"

#. Tag: para
#, no-c-format
msgid ""
"Java <literal>public static final</literal> constants <literal>eg.Color."
"TABBY</literal>"
msgstr ""
"Constantes Java <literal>final estático público</literal><literal>ex: Color."
"TABBY</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>in</literal> and <literal>between</literal> can be used as follows:"
msgstr ""
"<literal>in</literal> e <literal>between</literal> podem ser usadas da "
"seguinte maneira: "

#. Tag: para
#, no-c-format
msgid "The negated forms can be written as follows:"
msgstr "As formas negativas podem ser escritas conforme segue abaixo:"

#. Tag: para
#, no-c-format
msgid ""
"Similarly, <literal>is null</literal> and <literal>is not null</literal> can "
"be used to test for null values."
msgstr ""
"Da mesma forma, <literal>is null</literal> e <literal>is not null</literal> "
"podem ser usados para testar valores nulos."

#. Tag: para
#, no-c-format
msgid ""
"Booleans can be easily used in expressions by declaring HQL query "
"substitutions in Hibernate configuration:"
msgstr ""
"Booleanos podem ser facilmente usados em expressões, declarando as "
"substituições da consulta HQL, na configuração do Hibernate:"

#. Tag: para
#, no-c-format
msgid ""
"This will replace the keywords <literal>true</literal> and <literal>false</"
"literal> with the literals <literal>1</literal> and <literal>0</literal> in "
"the translated SQL from this HQL:"
msgstr ""
"Isso irá substituir as palavras chave <literal>true</literal> e "
"<literal>false</literal><literal>pelos</literal> literais <literal>1</"
"literal> e <literal>0</literal> na tradução do HQL para SQL."

#. Tag: para
#, no-c-format
msgid ""
"You can test the size of a collection with the special property "
"<literal>size</literal> or the special <literal>size()</literal> function."
msgstr ""
"Pode-se testar o tamanho de uma coleção com a propriedade especial "
"<literal>size</literal> ou a função especial <literal>size()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"For indexed collections, you can refer to the minimum and maximum indices "
"using <literal>minindex</literal> and <literal>maxindex</literal> functions. "
"Similarly, you can refer to the minimum and maximum elements of a collection "
"of basic type using the <literal>minelement</literal> and "
"<literal>maxelement</literal> functions. For example:"
msgstr ""
"Para coleções indexadas, você pode se referir aos índices máximo e mínimo, "
"usando as funções <literal>minindex</literal> e <literal>maxindex</literal>. "
"Igualmente, pode-se referir aos elementos máximo e mínimo de uma coleção de "
"tipos básicos usando as funções <literal>minelement</literal> e "
"<literal>maxelement</literal>. Por exemplo:"

#. Tag: para
#, no-c-format
msgid ""
"The SQL functions <literal>any, some, all, exists, in</literal> are "
"supported when passed the element or index set of a collection "
"(<literal>elements</literal> and <literal>indices</literal> functions) or "
"the result of a subquery (see below):"
msgstr ""
"As funções SQL <literal>any, some, all, exists, in</literal> são suportadas "
"quando passado o elemento ou o conjunto de índices de uma coleção "
"(<literal>elements</literal> e <literal>índices</literal> de funções) ou o "
"resultado de uma subconsulta (veja abaixo):"

#. Tag: para
#, no-c-format
msgid ""
"Note that these constructs - <literal>size</literal>, <literal>elements</"
"literal>, <literal>indices</literal>, <literal>minindex</literal>, "
"<literal>maxindex</literal>, <literal>minelement</literal>, "
"<literal>maxelement</literal> - can only be used in the where clause in "
"Hibernate3."
msgstr ""
"Note que essas construções - <literal>tamanho</literal>, <literal>elementos</"
"literal>, <literal>índices</literal>, <literal>minindex</literal>, "
"<literal>maxindex</literal>, <literal>minelement</literal>, "
"<literal>maxelement</literal> – só podem ser usados na cláusula where do "
"Hibernate3."

#. Tag: para
#, no-c-format
msgid ""
"Elements of indexed collections (arrays, lists, and maps) can be referred to "
"by index in a where clause only:"
msgstr ""
"Elementos de coleções com índice (matriz, listas, mapas) podem ser "
"referenciadas pelo índice (apenas na cláusula where):"

#. Tag: para
#, no-c-format
msgid ""
"The expression inside <literal>[]</literal> can even be an arithmetic "
"expression:"
msgstr ""
"A expressão entre colchetes <literal>[]</literal> pode ser até uma expressão "
"aritimética:"

#. Tag: para
#, no-c-format
msgid ""
"HQL also provides the built-in <literal>index()</literal> function for "
"elements of a one-to-many association or collection of values."
msgstr ""
"O HQL também provê a função interna <literal>index()</literal> para "
"elementos de associação um-para-muitos ou coleção de valores."

#. Tag: para
#, no-c-format
msgid "Scalar SQL functions supported by the underlying database can be used:"
msgstr ""
"Funções escalares SQL, suportadas pelo banco de dados subjacente podem ser "
"usadas:"

#. Tag: para
#, no-c-format
msgid ""
"Consider how much longer and less readable the following query would be in "
"SQL:"
msgstr ""
"Se ainda não estiver totalmente convencido, pense o quão maior e menos "
"legível poderia ser a consulta a seguir, em SQL: "

#. Tag: para
#, no-c-format
msgid "<emphasis>Hint:</emphasis> something like"
msgstr "<emphasis>Hint:</emphasis> algo como:"

#. Tag: title
#, no-c-format
msgid "The order by clause"
msgstr "A cláusula ordenar por"

#. Tag: para
#, no-c-format
msgid ""
"The list returned by a query can be ordered by any property of a returned "
"class or components:"
msgstr ""
"A lista retornada pela consulta pode ser ordenada por qualquer propriedade "
"da classe ou componentes retornados:"

#. Tag: para
#, no-c-format
msgid ""
"The optional <literal>asc</literal> or <literal>desc</literal> indicate "
"ascending or descending order respectively."
msgstr ""
"As opções <literal>asc</literal> ou <literal>desc</literal> indicam ordem "
"crescente ou decrescente, respectivamente."

#. Tag: title
#, no-c-format
msgid "The group by clause"
msgstr "A cláusula agrupar por"

#. Tag: para
#, no-c-format
msgid ""
"A query that returns aggregate values can be grouped by any property of a "
"returned class or components:"
msgstr ""
"Uma consulta que retorne valores agregados, podem ser agrupados por qualquer "
"propriedade de uma classe ou componentes retornados:"

#. Tag: para
#, no-c-format
msgid "A <literal>having</literal> clause is also allowed."
msgstr "Uma cláusula <literal>having</literal> também é permitida."

#. Tag: para
#, no-c-format
msgid ""
"SQL functions and aggregate functions are allowed in the <literal>having</"
"literal> and <literal>order by</literal> clauses if they are supported by "
"the underlying database (i.e., not in MySQL)."
msgstr ""
"Funções SQL e funções agregadas são permitidas nas cláusulas "
"<literal>having</literal> e <literal>order by</literal>, se suportadas pelo "
"banco de dados subjacentes (ex: não no MeuSQL). "

#. Tag: para
#, no-c-format
msgid ""
"Neither the <literal>group by</literal> clause nor the <literal>order by</"
"literal> clause can contain arithmetic expressions. Hibernate also does not "
"currently expand a grouped entity, so you cannot write <literal>group by "
"cat</literal> if all properties of <literal>cat</literal> are non-"
"aggregated. You have to list all non-aggregated properties explicitly."
msgstr ""
"Note que, nem a cláusula <literal>group by</literal> ou <literal>order by</"
"literal> podem conter expressões aritméticas. O Hibernate também não expande "
"atualmente uma entidade agrupada, portanto você não pode escrever "
"<literal>group by cat</literal> caso todas as propriedades do <literal>cat</"
"literal> não estiverem agregadas. Você precisa listar claramente todas as "
"propriedades não-agregadas. "

#. Tag: title
#, no-c-format
msgid "Subqueries"
msgstr "Subconsultas"

#. Tag: para
#, no-c-format
msgid ""
"For databases that support subselects, Hibernate supports subqueries within "
"queries. A subquery must be surrounded by parentheses (often by an SQL "
"aggregate function call). Even correlated subqueries (subqueries that refer "
"to an alias in the outer query) are allowed."
msgstr ""
"Para bancos de dados que suportam subseleções, o Hibernate suporta "
"subconsultas dentro de consultas. Uma subconsulta precisa estar entre "
"parênteses (normalmente uma chamada de função agregada SQL). Mesmo "
"subconsultas co-relacionadas (subconsultas que fazem referência à alias de "
"outras consultas), são aceitas."

#. Tag: para
#, no-c-format
msgid "Note that HQL subqueries can occur only in the select or where clauses."
msgstr ""
"Note que HQL subconsultas podem aparecer apenas dentro de cláusulas select "
"ou where. "

#. Tag: para
#, no-c-format
msgid ""
"Note that subqueries can also utilize <literal>row value constructor</"
"literal> syntax. See <xref linkend=\"queryhql-tuple\" /> for more "
"information."
msgstr ""
"Note que as subconsultas também podem utilizar a sintáxe <literal>row value "
"constructor</literal>. Veja <xref linkend=\"queryhql-tuple\" /> para maiores "
"detalhes. "

#. Tag: title
#, no-c-format
msgid "HQL examples"
msgstr "Exemplos de HQL"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate queries can be quite powerful and complex. In fact, the power of "
"the query language is one of Hibernate's main strengths. The following "
"example queries are similar to queries that have been used on recent "
"projects. Please note that most queries you will write will be much simpler "
"than the following examples."
msgstr ""
"As consultas do Hibernate, podem ser muito poderosas e complexas. De fato, o "
"poder da linguagem de consulta é um dos pontos principais na distribuição do "
"Hibernate. Aqui temos algumas consultas de exemplo, muito similares a "
"consultas usadas em um projeto recente. Note que a maioria das consultas que "
"você irá escrever, são mais simples que estas."

#. Tag: para
#, no-c-format
msgid ""
"The following query returns the order id, number of items, the given minimum "
"total value and the total value of the order for all unpaid orders for a "
"particular customer. The results are ordered by total value. In determining "
"the prices, it uses the current catalog. The resulting SQL query, against "
"the <literal>ORDER</literal>, <literal>ORDER_LINE</literal>, "
"<literal>PRODUCT</literal>, <literal>CATALOG</literal> and <literal>PRICE</"
"literal> tables has four inner joins and an (uncorrelated) subselect."
msgstr ""
"A consulta a seguir retorna o id de ordenar, número de ítens e o valor total "
"do ordenar para todos os ordenar não pagos para um cliente particular e "
"valor total mínimo dado, ordenando os resultados por valor total. Para "
"determinar os preços, utiliza-se o catálogo atual. A consulta SQL "
"resultante, usando tabelas <literal>ORDER</literal>, <literal>ORDER_LINE</"
"literal>, <literal>PRODUCT</literal>, <literal>CATALOG</literal> e "
"<literal>PRICE</literal>, têm quatro uniões inteiras e uma subseleção (não "
"correlacionada)."

#. Tag: para
#, no-c-format
msgid ""
"What a monster! Actually, in real life, I'm not very keen on subqueries, so "
"my query was really more like this:"
msgstr ""
"Que monstro! Na verdade, na vida real, eu não sou muito afeiçoado à "
"subconsultas, então minha consulta seria mais parecida com isto:"

#. Tag: para
#, no-c-format
msgid ""
"The next query counts the number of payments in each status, excluding all "
"payments in the <literal>AWAITING_APPROVAL</literal> status where the most "
"recent status change was made by the current user. It translates to an SQL "
"query with two inner joins and a correlated subselect against the "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal> and "
"<literal>PAYMENT_STATUS_CHANGE</literal> tables."
msgstr ""
"A próxima consulta conta o número de pagamentos em cada status, excluindo "
"todos os pagamentos no status <literal>AWAITING_APPROVAL</literal>, onde a "
"mais recente mudança de status foi feita pelo usuário atual. Traduz-se para "
"uma consulta SQL <literal>com</literal> duas uniões inteiras e uma "
"subseleção correlacionada, nas tabelas <literal>PAYMENT</literal>, "
"<literal>PAYMENT_STATUS</literal> e <literal>PAYMENT_STATUS_CHANGE</"
"literal> ."

#. Tag: para
#, no-c-format
msgid ""
"If the <literal>statusChanges</literal> collection was mapped as a list, "
"instead of a set, the query would have been much simpler to write."
msgstr ""
"Se eu tivesse mapeado a coleção <literal>statusChanges</literal> como um "
"List, ao invés de um Set, a consulta teria sido muito mais simples de "
"escrever. "

#. Tag: para
#, no-c-format
msgid ""
"The next query uses the MS SQL Server <literal>isNull()</literal> function "
"to return all the accounts and unpaid payments for the organization to which "
"the current user belongs. It translates to an SQL query with three inner "
"joins, an outer join and a subselect against the <literal>ACCOUNT</literal>, "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal>, "
"<literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> and "
"<literal>ORG_USER</literal> tables."
msgstr ""
"A próxima consulta usa a função <literal>isNull()</literal> do Servidor MS "
"SQL, para retornar todas as contas e pagamentos não efetuados para a "
"organização, para aquele que o usuário atual pertencer. Traduz-se para uma "
"consulta SQL <literal>com</literal> três uniões inteiras, uma união externa "
"e uma subseleção nas tabelas <literal>ACCOUNT</literal>, <literal>PAYMENT</"
"literal>, <literal>PAYMENT_STATUS</literal>, <literal>ACCOUNT_TYPE</"
"literal>, <literal>ORGANIZATION</literal> e <literal>ORG_USER</literal> ."

#. Tag: para
#, no-c-format
msgid "For some databases, we would need to do away with the (correlated) subselect."
msgstr ""
"Para alguns bancos de dados, precisaremos eliminar a subseleção "
"(correlacionada)."

#. Tag: title
#, no-c-format
msgid "Bulk update and delete"
msgstr "Atualização e correção em lote"

#. Tag: para
#, no-c-format
msgid ""
"HQL now supports <literal>update</literal>, <literal>delete</literal> and "
"<literal>insert ... select ...</literal> statements. See <xref linkend="
"\"batch-direct\" /> for more information."
msgstr ""
"Agora o HQL suporta declarações, <literal>update</literal>, <literal>delete</"
"literal> e <literal>insert ... select ...</literal>. Veja <xref linkend="
"\"batch-direct\" />  para mais detalhes. "

#. Tag: title
#, no-c-format
msgid "Tips &amp; Tricks"
msgstr "Dicas &amp; Truques"

#. Tag: para
#, no-c-format
msgid "You can count the number of query results without returning them:"
msgstr "Pode-se contar o número de resultados da consulta, sem realmente retorná-los:"

#. Tag: para
#, no-c-format
msgid "To order a result by the size of a collection, use the following query:"
msgstr ""
"Para ordenar um resultado pelo tamanho de uma coleção, use a consulta a "
"seguir."

#. Tag: para
#, no-c-format
msgid ""
"If your database supports subselects, you can place a condition upon "
"selection size in the where clause of your query:"
msgstr ""
"Se seu banco de dados suporta subseleções, pode-se colocar uma condição "
"sobre tamanho de seleção na cláusula where da sua consulta:"

#. Tag: para
#, no-c-format
msgid "If your database does not support subselects, use the following query:"
msgstr "Se seu banco de dados não suporta subseleções, use a consulta a seguir: "

#. Tag: para
#, no-c-format
msgid ""
"As this solution cannot return a <literal>User</literal> with zero messages "
"because of the inner join, the following form is also useful:"
msgstr ""
"Com essa solução não se pode retornar um <literal>User</literal> sem nenhuma "
"menssagem, por causa da união inteira, a forma a seguir também é útil:"

#. Tag: para
#, no-c-format
msgid "Properties of a JavaBean can be bound to named query parameters:"
msgstr ""
"As propriedades de um JavaBean podem ser limitadas à parâmetros nomeados da "
"consulta:"

#. Tag: para
#, no-c-format
msgid ""
"Collections are pageable by using the <literal>Query</literal> interface "
"with a filter:"
msgstr ""
"As coleções são pagináveis, usando a interface <literal>Query</literal> com "
"um filtro:"

#. Tag: para
#, no-c-format
msgid "Collection elements can be ordered or grouped using a query filter:"
msgstr ""
"Os elementos da coleção podem ser ordenados ou agrupados usando um filtro de "
"consulta: "

#. Tag: para
#, no-c-format
msgid "You can find the size of a collection without initializing it:"
msgstr "Pode-se achar o tamanho de uma coleção sem inicializá-la:"

#. Tag: title
#, no-c-format
msgid "Components"
msgstr "Componentes"

#. Tag: para
#, no-c-format
msgid ""
"Components can be used similarly to the simple value types that are used in "
"HQL queries. They can appear in the <literal>select</literal> clause as "
"follows:"
msgstr ""
"Os componentes podem ser usados de quase todas as formas que os tipos de "
"valores simples são usados nas consultas HQL. Eles podem aparecer na "
"cláusula <literal>select</literal>: "

#. Tag: para
#, no-c-format
msgid ""
"where the Person's name property is a component. Components can also be used "
"in the <literal>where</literal> clause:"
msgstr ""
"onde a propriedade do nome da Person é um componente. Os componentes também "
"podem ser utilizados na cláusula <literal>where</literal>:"

#. Tag: para
#, no-c-format
msgid "Components can also be used in the <literal>order by</literal> clause:"
msgstr ""
"Os componentes também podem ser usados na cláusula <literal>order by</"
"literal>:"

#. Tag: para
#, no-c-format
msgid ""
"Another common use of components is in <link linkend=\"queryhql-tuple\">row "
"value constructors</link>."
msgstr ""
"Outro uso comum dos componentes é nos <link linkend=\"queryhql-tuple\">row "
"value constructors</link>."

#. Tag: title
#, no-c-format
msgid "Row value constructor syntax"
msgstr "Sintáxe do construtor de valores de linha"

#. Tag: para
#, no-c-format
msgid ""
"HQL supports the use of ANSI SQL <literal>row value constructor</literal> "
"syntax, sometimes referred to AS <literal>tuple</literal> syntax, even "
"though the underlying database may not support that notion. Here, we are "
"generally referring to multi-valued comparisons, typically associated with "
"components. Consider an entity Person which defines a name component:"
msgstr ""
"O HQL suporta o uso da sintáxe ANSI SQL <literal>row value constructor</"
"literal>, algumas vezes chamado de sintáxe <literal>tupla</literal>, embora "
"o banco de dados adjacente possa não suportar esta noção. Aqui nós "
"geralmente nos referimos às comparações de valores múltiplos, tipicamente "
"associada aos componentes. Considere uma entidade Person que define um "
"componente de nome:"

#. Tag: para
#, no-c-format
msgid ""
"That is valid syntax although it is a little verbose. You can make this more "
"concise by using <literal>row value constructor</literal> syntax:"
msgstr ""
"Esta é uma sintáxe válida, embora um pouco verbosa. Seria ótimo tornar essa "
"sintáxe um pouco mais concisa e utilizar a sintáxe <literal>row value "
"constructor</literal>:"

#. Tag: para
#, no-c-format
msgid ""
"It can also be useful to specify this in the <literal>select</literal> "
"clause:"
msgstr "Pode também ser útil especificar isto na cláusula <literal>select</literal>:"

#. Tag: para
#, no-c-format
msgid ""
"Using <literal>row value constructor</literal> syntax can also be beneficial "
"when using subqueries that need to compare against multiple values:"
msgstr ""
"Com o uso da sintáxe <literal>row value constructor</literal>, e que pode "
"ser de benéfico, seria quando utilizar as subconsultas que precisem comparar "
"com os valores múltiplos:"

#. Tag: para
#, no-c-format
msgid ""
"One thing to consider when deciding if you want to use this syntax, is that "
"the query will be dependent upon the ordering of the component sub-"
"properties in the metadata."
msgstr ""
"Ao decidir se você quer usar esta sintáxe ou não, deve-se considerar o fato "
"de que a consulta será dependente da ordenação das sub-propriedades do "
"componente no metadados. "

