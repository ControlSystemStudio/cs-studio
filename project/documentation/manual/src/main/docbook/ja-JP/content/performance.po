# translation of Collection_Mapping.po to
# Xi HUANG <xhuang@redhat.com>, 2007, 2010.
msgid ""
msgstr ""
"Project-Id-Version: Collection_Mapping\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:15\n"
"PO-Revision-Date: 2010-01-20 14:25+1000\n"
"Last-Translator: Xi HUANG <xhuang@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Improving performance"
msgstr "パフォーマンスの改善"

#. Tag: title
#, no-c-format
msgid "Fetching strategies"
msgstr "フェッチ戦略"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate uses a <emphasis>fetching strategy</emphasis> to retrieve "
"associated objects if the application needs to navigate the association. "
"Fetch strategies can be declared in the O/R mapping metadata, or over-ridden "
"by a particular HQL or <literal>Criteria</literal> query."
msgstr ""
"<emphasis>フェッチ戦略</emphasis> は、アプリケーションが関連をナビゲートする"
"必要があるときに、 Hibernate が関連オブジェクトを復元するために使用する戦略で"
"す。フェッチ戦略は O/R マッピングのメタデータに宣言するか、特定の HQL 、 "
"<literal>Criteria</literal> クエリでオーバーライドします。"

#. Tag: para
#, no-c-format
msgid "Hibernate3 defines the following fetching strategies:"
msgstr "Hibernate3 は次に示すフェッチ戦略を定義しています:"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Join fetching</emphasis>: Hibernate retrieves the associated "
"instance or collection in the same <literal>SELECT</literal>, using an "
"<literal>OUTER JOIN</literal>."
msgstr ""
"<emphasis>結合フェッチ</emphasis> - Hibernate は <literal>OUTER JOIN</"
"literal> を使って、関連するインスタンスやコレクションを１つの "
"<literal>SELECT</literal> で復元します。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Select fetching</emphasis>: a second <literal>SELECT</literal> is "
"used to retrieve the associated entity or collection. Unless you explicitly "
"disable lazy fetching by specifying <literal>lazy=\"false\"</literal>, this "
"second select will only be executed when you access the association."
msgstr ""
"<emphasis>セレクトフェッチ</emphasis> - 2回目の <literal>SELECT</literal> で"
"関連するエンティティやコレクションを復元します。 <literal>lazy=\"false\"</"
"literal> で明示的に遅延フェッチを無効にしなければ、この2回目の select は実際"
"に関連にアクセスしたときのみ実行されるでしょう。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Subselect fetching</emphasis>: a second <literal>SELECT</literal> "
"is used to retrieve the associated collections for all entities retrieved in "
"a previous query or fetch. Unless you explicitly disable lazy fetching by "
"specifying <literal>lazy=\"false\"</literal>, this second select will only "
"be executed when you access the association."
msgstr ""
"<emphasis>サブセレクトフェッチ</emphasis> - 2回目の <literal>SELECT</"
"literal> で、直前のクエリやフェッチで復元したすべての要素に関連するコレクショ"
"ンを復元します。 <literal>lazy=\"false\"</literal> で明示的に遅延フェッチを無"
"効にしなければ、この2回目の select は実際に関連にアクセスしたときのみ実行され"
"るでしょう。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Batch fetching</emphasis>: an optimization strategy for select "
"fetching. Hibernate retrieves a batch of entity instances or collections in "
"a single <literal>SELECT</literal> by specifying a list of primary or "
"foreign keys."
msgstr ""
"<emphasis>バッチフェッチ</emphasis> - セレクトフェッチのための最適化された戦"
"略 - Hibernate はエンティティのインスタンスやコレクションの一群を1回の "
"<literal>SELECT</literal> で復元します。これは主キーや外部キーのリストを指定"
"することにより行います。"

#. Tag: para
#, no-c-format
msgid "Hibernate also distinguishes between:"
msgstr "Hibernate は次に示す戦略とも区別をします: "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Immediate fetching</emphasis>: an association, collection or "
"attribute is fetched immediately when the owner is loaded."
msgstr ""
"<emphasis>即時フェッチ</emphasis> - 所有者のオブジェクトがロードされたとき"
"に、関連、コレクションは即時にフェッチされます。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Lazy collection fetching</emphasis>: a collection is fetched when "
"the application invokes an operation upon that collection. This is the "
"default for collections."
msgstr ""
"<emphasis>遅延コレクションフェッチ</emphasis> - アプリケーションがコレクショ"
"ンに対して操作を行ったときにコレクションをフェッチします。(これはコレクション"
"に対するデフォルトの動作です)"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>\"Extra-lazy\" collection fetching</emphasis>: individual elements "
"of the collection are accessed from the database as needed. Hibernate tries "
"not to fetch the whole collection into memory unless absolutely needed. It "
"is suitable for large collections."
msgstr ""
"<emphasis>「特別な遅延」コレクションフェッチ</emphasis> - コレクションの要素"
"１つ１つが独立して、必要なときにデータベースから取得されます。 Hibernate は必"
"要ないならば、コレクション全体をメモリにフェッチすることは避けます（とても大"
"きなコレクションに適しています）。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Proxy fetching</emphasis>: a single-valued association is fetched "
"when a method other than the identifier getter is invoked upon the "
"associated object."
msgstr ""
"<emphasis>プロキシフェッチ</emphasis> - 単一値関連は、識別子の getter 以外の"
"メソッドが関連オブジェクトで呼び出されるときにフェッチされます。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>\"No-proxy\" fetching</emphasis>: a single-valued association is "
"fetched when the instance variable is accessed. Compared to proxy fetching, "
"this approach is less lazy; the association is fetched even when only the "
"identifier is accessed. It is also more transparent, since no proxy is "
"visible to the application. This approach requires buildtime bytecode "
"instrumentation and is rarely necessary."
msgstr ""
"<emphasis>「プロキシなし」フェッチ</emphasis> - 単一値関連は、インスタンス変"
"数にアクセスされたときにフェッチされます。プロキシフェッチと比較すると、この"
"方法は遅延の度合いが少ない（関連は識別子にアクセスしただけでもフェッチされま"
"す）ですが、より透過的で、アプリケーションにプロキシが存在しないように見せま"
"す。この方法はビルド時のバイトコード組み込みが必要になり、使う場面はまれで"
"す。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Lazy attribute fetching</emphasis>: an attribute or single valued "
"association is fetched when the instance variable is accessed. This approach "
"requires buildtime bytecode instrumentation and is rarely necessary."
msgstr ""
"<emphasis>遅延属性フェッチ</emphasis> - 属性や単一値関連は、インスタンス変数"
"にアクセスしたときにフェッチされます。この方法はビルド時のバイトコード組み込"
"みが必要になり、使う場面はまれです。"

#. Tag: para
#, no-c-format
msgid ""
"We have two orthogonal notions here: <emphasis>when</emphasis> is the "
"association fetched and <emphasis>how</emphasis> is it fetched. It is "
"important that you do not confuse them. We use <literal>fetch</literal> to "
"tune performance. We can use <literal>lazy</literal> to define a contract "
"for what data is always available in any detached instance of a particular "
"class."
msgstr ""
"二つの直行する概念があります: <emphasis>いつ</emphasis> 関連をフェッチする"
"か、そして、 <emphasis>どうやって</emphasis> フェッチするか（どんな SQL を"
"使って）。これらを混同しないでください。 <literal>fetch</literal> はパフォー"
"マンスチューニングに使います。 <literal>lazy</literal> はあるクラスの分離され"
"たインスタンスのうち、どのデータを常に使用可能にするかの取り決めを定義しま"
"す。"

#. Tag: title
#, no-c-format
msgid "Working with lazy associations"
msgstr "遅延関連の働き"

#. Tag: para
#, no-c-format
msgid ""
"By default, Hibernate3 uses lazy select fetching for collections and lazy "
"proxy fetching for single-valued associations. These defaults make sense for "
"most associations in the majority of applications."
msgstr ""
"デフォルトでは、 Hibernate3 はコレクションに対しては遅延セレクトフェッチを使"
"い、単一値関連には遅延プロキシフェッチを使います。これらのデフォルト動作はほ"
"ぼすべてのアプリケーションのほぼすべての関連で意味があります。"

#. Tag: para
#, no-c-format
msgid ""
"If you set <literal>hibernate.default_batch_fetch_size</literal>, Hibernate "
"will use the batch fetch optimization for lazy fetching. This optimization "
"can also be enabled at a more granular level."
msgstr ""
"<emphasis>注:</emphasis><literal>hibernate.default_batch_fetch_size</"
"literal> をセットしたときは、 Hibernate は遅延フェッチのためのバッチフェッチ"
"最適化を使うでしょう（この最適化はより細かいレベルで有効にすることも出来ま"
"す）。"

#. Tag: para
#, no-c-format
msgid ""
"Please be aware that access to a lazy association outside of the context of "
"an open Hibernate session will result in an exception. For example:"
msgstr ""
"しかし、遅延フェッチは知っておかなければならない一つの問題があります。 "
"Hibernate の session をオープンしているコンテキストの外から遅延関連にアクセス"
"すると、例外が発生します。例："

#. Tag: para
#, no-c-format
msgid ""
"Since the permissions collection was not initialized when the "
"<literal>Session</literal> was closed, the collection will not be able to "
"load its state. <emphasis>Hibernate does not support lazy initialization for "
"detached objects</emphasis>. This can be fixed by moving the code that reads "
"from the collection to just before the transaction is committed."
msgstr ""
"<literal>Session</literal> がクローズされたとき、 permissions コレクションは"
"初期化されていないため、このコレクションは自身の状態をロードできません。 "
"<emphasis>Hibernate は切り離されたオブジェクトの遅延初期化はサポートしていま"
"せん</emphasis> 。修正方法として、コレクションから読み込みを行うコードをトラ"
"ンザクションをコミットする直前に移動させます。"

#. Tag: para
#, no-c-format
msgid ""
"Alternatively, you can use a non-lazy collection or association, by "
"specifying <literal>lazy=\"false\"</literal> for the association mapping. "
"However, it is intended that lazy initialization be used for almost all "
"collections and associations. If you define too many non-lazy associations "
"in your object model, Hibernate will fetch the entire database into memory "
"in every transaction."
msgstr ""
"一方で、 <literal>lazy=\"false\"</literal> を関連マッピングに指定することで、"
"遅延処理をしないコレクションや関連を使うことが出来ます。しかしながら、遅延初"
"期化はほぼすべてのコレクションや関連で使われることを意図しています。もしあな"
"たのオブジェクトモデルの中に遅延処理をしない関連を多く定義してしまうと、 "
"Hibernate は最終的にはトランザクション毎にほぼ完全なデータベースをメモリの中"
"にフェッチすることになるでしょう。"

#. Tag: para
#, no-c-format
msgid ""
"On the other hand, you can use join fetching, which is non-lazy by nature, "
"instead of select fetching in a particular transaction. We will now explain "
"how to customize the fetching strategy. In Hibernate3, the mechanisms for "
"choosing a fetch strategy are identical for single-valued associations and "
"collections."
msgstr ""
"他方では、特定のトランザクションにおいてセレクトフェッチの代わりに結合フェッ"
"チ（当然これは遅延処理ではなくなります）を選択したいことが時々あります。これ"
"からフェッチ戦略をカスタマイズする方法をお見せします。 Hibernate3 では、"
"フェッチ戦略を選択する仕組みは単一値関連とコレクションで変わりはありません。"

#. Tag: title
#, no-c-format
msgid "Tuning fetch strategies"
msgstr "フェッチ戦略のチューニング"

#. Tag: para
#, no-c-format
msgid ""
"Select fetching (the default) is extremely vulnerable to N+1 selects "
"problems, so we might want to enable join fetching in the mapping document:"
msgstr ""
"セレクトフェッチ（デフォルト）は N+1 セレクト問題という大きな弱点があるため、"
"マッピング定義で結合フェッチを有効にすることができます:"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>fetch</literal> strategy defined in the mapping document "
"affects:"
msgstr ""
"マッピング定義で定義した <literal>フェッチ</literal> 戦略は次のものに影響しま"
"す:"

#. Tag: para
#, no-c-format
msgid "retrieval via <literal>get()</literal> or <literal>load()</literal>"
msgstr "<literal>get()</literal> や <literal>load()</literal> による復元"

#. Tag: para
#, no-c-format
msgid "retrieval that happens implicitly when an association is navigated"
msgstr "関連にナビゲートしたときに発生する暗黙的な復元"

#. Tag: para
#, no-c-format
msgid "<literal>Criteria</literal> queries"
msgstr "<literal>Criteria</literal> クエリ"

#. Tag: para
#, no-c-format
msgid "HQL queries if <literal>subselect</literal> fetching is used"
msgstr "<literal>サブセレクト</literal> フェッチを使う HQL クエリ"

#. Tag: para
#, no-c-format
msgid ""
"Irrespective of the fetching strategy you use, the defined non-lazy graph is "
"guaranteed to be loaded into memory. This might, however, result in several "
"immediate selects being used to execute a particular HQL query."
msgstr ""
"たとえどんなフェッチ戦略を使ったとしても、遅延ではないグラフはメモリに読み込"
"まれることが保証されます。つまり、特定の HQL クエリを実行するためにいくつか"
"の SELECT 文が即時実行されることがあるので注意してください。"

#. Tag: para
#, no-c-format
msgid ""
"Usually, the mapping document is not used to customize fetching. Instead, we "
"keep the default behavior, and override it for a particular transaction, "
"using <literal>left join fetch</literal> in HQL. This tells Hibernate to "
"fetch the association eagerly in the first select, using an outer join. In "
"the <literal>Criteria</literal> query API, you would use "
"<literal>setFetchMode(FetchMode.JOIN)</literal>."
msgstr ""
"通常は、マッピング定義でフェッチのカスタマイズは行いません。代わりに、デフォ"
"ルトの動作のままにしておいて、 HQL で <literal>left join fetch</literal> を指"
"定することで特定のトランザクションで動作をオーバーライドします。これは "
"Hibernate に初回のセレクトで外部結合を使って関連を先にフェッチするように指定"
"しています。 <literal>Criteria</literal> クエリの API では、 "
"<literal>setFetchMode(FetchMode.JOIN)</literal> を使うことが出来ます。"

#. Tag: para
#, no-c-format
msgid ""
"If you want to change the fetching strategy used by <literal>get()</literal> "
"or <literal>load()</literal>, you can use a <literal>Criteria</literal> "
"query. For example:"
msgstr ""
"もし <literal>get()</literal> や <literal>load()</literal> で使われるフェッチ"
"戦略を変えたいと感じたときには、単純に <literal>Criteria</literal> クエリを"
"使ってください。例："

#. Tag: para
#, no-c-format
msgid ""
"This is Hibernate's equivalent of what some ORM solutions call a \"fetch plan"
"\"."
msgstr ""
"（これはいくつかの ORM ソリューションが \"fetch plan\" と呼んでいるものと同じ"
"です。）"

#. Tag: para
#, no-c-format
msgid ""
"A completely different approach to problems with N+1 selects is to use the "
"second-level cache."
msgstr ""
"N+1 セレクト問題を避けるためのまったく違う方法は、第2レベルキャッシュを使うこ"
"とです。"

#. Tag: title
#, no-c-format
msgid "Single-ended association proxies"
msgstr "単一端関連プロキシ"

#. Tag: para
#, no-c-format
msgid ""
"Lazy fetching for collections is implemented using Hibernate's own "
"implementation of persistent collections. However, a different mechanism is "
"needed for lazy behavior in single-ended associations. The target entity of "
"the association must be proxied. Hibernate implements lazy initializing "
"proxies for persistent objects using runtime bytecode enhancement which is "
"accessed via the CGLIB library."
msgstr ""
"コレクションの遅延フェッチは、 Hibernate 自身の実装による永続コレクションを"
"使って実現しています。しかし、単一端関連における遅延処理では、違う仕組みが必"
"要です。対象の関連エンティティはプロキシでなければなりません。 Hibernate は"
"（すばらしい CGLIB ライブラリによる）実行時のバイトコード拡張を使って永続オブ"
"ジェクトの遅延初期化プロキシを実現しています。"

#. Tag: para
#, no-c-format
msgid ""
"At startup, Hibernate3 generates proxies by default for all persistent "
"classes and uses them to enable lazy fetching of <literal>many-to-one</"
"literal> and <literal>one-to-one</literal> associations."
msgstr ""
"デフォルトでは、 Hibernate3 は（開始時に）すべての永続クラスのプロキシを生成"
"し、それらを使って、 <literal>many-to-one</literal> や <literal>one-to-one</"
"literal> 関連の遅延フェッチを可能にしています。"

#. Tag: para
#, no-c-format
msgid ""
"The mapping file may declare an interface to use as the proxy interface for "
"that class, with the <literal>proxy</literal> attribute. By default, "
"Hibernate uses a subclass of the class. <emphasis>The proxied class must "
"implement a default constructor with at least package visibility. This "
"constructor is recommended for all persistent classes</emphasis>."
msgstr ""
"マッピングファイルで <literal>proxy</literal> 属性によって、クラスのプロキシ"
"インターフェースとして使うインターフェースを宣言できます。デフォルトでは、 "
"Hibernate はそのクラスのサブクラスを使います。 <emphasis>プロキシクラスは少な"
"くともパッケージ可視でデフォルトコンストラクタを実装しなければならないことに"
"注意してください。すべての永続クラスにこのコンストラクタを推奨します。</"
"emphasis>"

#. Tag: para
#, no-c-format
msgid ""
"There are potential problems to note when extending this approach to "
"polymorphic classes.For example:"
msgstr ""
"ポリモーフィズムのクラスに対してこの方法を適用するときにいくつか考慮すること"
"があります。例："

#. Tag: para
#, no-c-format
msgid ""
"Firstly, instances of <literal>Cat</literal> will never be castable to "
"<literal>DomesticCat</literal>, even if the underlying instance is an "
"instance of <literal>DomesticCat</literal>:"
msgstr ""
"第一に、 <literal>Cat</literal> のインスタンスは <literal>DomesticCat</"
"literal> にキャストできません。たとえ基となるインスタンスが "
"<literal>DomesticCat</literal> であったとしてもです:"

#. Tag: para
#, no-c-format
msgid "Secondly, it is possible to break proxy <literal>==</literal>:"
msgstr "第二に、プロキシの <literal>==</literal> は成立しないことがあります。"

#. Tag: para
#, no-c-format
msgid ""
"However, the situation is not quite as bad as it looks. Even though we now "
"have two references to different proxy objects, the underlying instance will "
"still be the same object:"
msgstr ""
"しかし、これは見かけほど悪い状況というわけではありません。たとえ異なったプロ"
"キシオブジェクトへの二つの参照があったとしても、基となるインスタンスは同じオ"
"ブジェクトです:"

#. Tag: para
#, no-c-format
msgid ""
"Third, you cannot use a CGLIB proxy for a <literal>final</literal> class or "
"a class with any <literal>final</literal> methods."
msgstr ""
"第三に、 <literal>final</literal> クラスや <literal>final</literal> メソッド"
"を持つクラスに CGLIB プロキシを使えません。"

#. Tag: para
#, no-c-format
msgid ""
"Finally, if your persistent object acquires any resources upon instantiation "
"(e.g. in initializers or default constructor), then those resources will "
"also be acquired by the proxy. The proxy class is an actual subclass of the "
"persistent class."
msgstr ""
"最後に、もし永続オブジェクトのインスタンス化時 (例えば、初期化処理やデフォル"
"トコンストラクタの中で) になんらかのリソースが必要となるなら、そのリソースも"
"またプロキシを通して取得されます。実際には、プロキシクラスは永続クラスのサブ"
"クラスです。"

#. Tag: para
#, no-c-format
msgid ""
"These problems are all due to fundamental limitations in Java's single "
"inheritance model. To avoid these problems your persistent classes must each "
"implement an interface that declares its business methods. You should "
"specify these interfaces in the mapping file where <literal>CatImpl</"
"literal> implements the interface <literal>Cat</literal> and "
"<literal>DomesticCatImpl</literal> implements the interface "
"<literal>DomesticCat</literal>. For example:"
msgstr ""
"これらの問題は Java の単一継承モデルの原理上の制限のためです。もしこれらの問"
"題を避けたいのなら、ビジネスメソッドを宣言したインターフェースをそれぞれ永続"
"クラスで実装しなければなりません。マッピングファイルでこれらのインターフェー"
"スを指定する必要があります。例："

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Then proxies for instances of <literal>Cat</literal> and "
"<literal>DomesticCat</literal> can be returned by <literal>load()</literal> "
"or <literal>iterate()</literal>."
msgstr ""
"第一に、 <literal>Cat</literal> のインスタンスは <literal>DomesticCat</"
"literal> にキャストできません。たとえ基となるインスタンスが "
"<literal>DomesticCat</literal> であったとしてもです:"

#. Tag: title
#, no-c-format
msgid "Note"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>list()</literal> does not usually return proxies."
msgstr "<literal>full join</literal> (たいていの場合使いづらい)"

#. Tag: para
#, no-c-format
msgid ""
"Relationships are also lazily initialized. This means you must declare any "
"properties to be of type <literal>Cat</literal>, not <literal>CatImpl</"
"literal>."
msgstr ""
"関連も遅延初期化されます。これはプロパティを <literal>Cat</literal> 型で宣言"
"しなければならないことを意味します。 <literal>CatImpl</literal> ではありませ"
"ん。"

#. Tag: para
#, no-c-format
msgid ""
"Certain operations do <emphasis>not</emphasis> require proxy initialization:"
msgstr ""
"プロキシの初期化を <emphasis>必要としない</emphasis> 操作も存在します。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>equals()</literal>: if the persistent class does not override "
"<literal>equals()</literal>"
msgstr ""
"<literal>equals()</literal> （永続クラスが <literal>equals()</literal> をオー"
"バーライドしないとき）"

#. Tag: para
#, no-c-format
msgid ""
"<literal>hashCode()</literal>: if the persistent class does not override "
"<literal>hashCode()</literal>"
msgstr ""
"<literal>hashCode()</literal> （永続クラスが <literal>hashCode()</literal> を"
"オーバーライドしないとき）"

#. Tag: para
#, no-c-format
msgid "The identifier getter method"
msgstr "識別子の getter メソッド"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate will detect persistent classes that override <literal>equals()</"
"literal> or <literal>hashCode()</literal>."
msgstr ""
"Hibernate は <literal>equals()</literal> や <literal>hashCode()</literal> を"
"オーバーライドした永続クラスを検出します。"

#. Tag: para
#, no-c-format
msgid ""
"By choosing <literal>lazy=\"no-proxy\"</literal> instead of the default "
"<literal>lazy=\"proxy\"</literal>, you can avoid problems associated with "
"typecasting. However, buildtime bytecode instrumentation is required, and "
"all operations will result in immediate proxy initialization."
msgstr ""
"デフォルトの <literal>lazy=\"proxy\"</literal> の代わりに、 <literal>lazy="
"\"no-proxy\"</literal> を選んだことで、型変換に関連する問題を回避することが出"
"来ます。しかし、ビルド時のバイトコード組み込みが必要になり、どのような操作で"
"あっても、ただちにプロキシの初期化を行うことになるでしょう。"

#. Tag: title
#, no-c-format
msgid "Initializing collections and proxies"
msgstr "コレクションとプロキシの初期化"

#. Tag: para
#, no-c-format
msgid ""
"A <literal>LazyInitializationException</literal> will be thrown by Hibernate "
"if an uninitialized collection or proxy is accessed outside of the scope of "
"the <literal>Session</literal>, i.e., when the entity owning the collection "
"or having the reference to the proxy is in the detached state."
msgstr ""
"<literal>LazyInitializationException</literal> は、 <literal>Session</"
"literal> のスコープ外から初期化していないコレクションやプロキシにアクセスされ"
"たときに、 Hibernate によってスローされます。すなわち、コレクションやプロキシ"
"への参照を持つエンティティが分離された状態の時です。"

#. Tag: para
#, no-c-format
msgid ""
"Sometimes a proxy or collection needs to be initialized before closing the "
"<literal>Session</literal>. You can force initialization by calling "
"<literal>cat.getSex()</literal> or <literal>cat.getKittens().size()</"
"literal>, for example. However, this can be confusing to readers of the code "
"and it is not convenient for generic code."
msgstr ""
"<literal>Session</literal> をクローズする前にプロキシやコレクションの初期化を"
"確実に行いたいときがあります。もちろん、 <literal>cat.getSex()</literal> や "
"<literal>cat.getKittens().size()</literal> などを常に呼び出すことで初期化を強"
"制することはできます。しかしこれはコードを読む人を混乱させ、汎用的なコードと"
"いう点からも不便です。"

#. Tag: para
#, no-c-format
msgid ""
"The static methods <literal>Hibernate.initialize()</literal> and "
"<literal>Hibernate.isInitialized()</literal>, provide the application with a "
"convenient way of working with lazily initialized collections or proxies. "
"<literal>Hibernate.initialize(cat)</literal> will force the initialization "
"of a proxy, <literal>cat</literal>, as long as its <literal>Session</"
"literal> is still open. <literal>Hibernate.initialize( cat.getKittens() )</"
"literal> has a similar effect for the collection of kittens."
msgstr ""
"static メソッドの <literal>Hibernate.initialize()</literal> や "
"<literal>Hibernate.isInitialized()</literal> は遅延初期化のコレクションやプロ"
"キシを扱うときに便利な方法をアプリケーションに提供します。 "
"<literal>Hibernate.initialize(cat)</literal> は、 <literal>Session</literal> "
"がオープンしている限りは <literal>cat</literal> プロキシを強制的に初期化しま"
"す。 <literal>Hibernate.initialize( cat.getKittens() )</literal> は kittens "
"コレクションに対して同様の効果があります。"

#. Tag: para
#, no-c-format
msgid ""
"Another option is to keep the <literal>Session</literal> open until all "
"required collections and proxies have been loaded. In some application "
"architectures, particularly where the code that accesses data using "
"Hibernate, and the code that uses it are in different application layers or "
"different physical processes, it can be a problem to ensure that the "
"<literal>Session</literal> is open when a collection is initialized. There "
"are two basic ways to deal with this issue:"
msgstr ""
"別の選択肢として、必要なすべてのコレクションやプロキシがロードされるまで "
"<literal>Session</literal> をオープンにしておく方法があります。いくつかのアプ"
"リケーションのアーキテクチャでは、特に Hibernate によるデータアクセスを行う"
"コードと、それを使うコードが異なるアプリケーションのレイヤーや、物理的に異な"
"るプロセッサのときには、コレクションが初期化されるときに <literal>Session</"
"literal> がオープンしていることを保証する問題があります。この問題に対しては2"
"つの基本的な方法があります:"

#. Tag: para
#, no-c-format
msgid ""
"In a web-based application, a servlet filter can be used to close the "
"<literal>Session</literal> only at the end of a user request, once the "
"rendering of the view is complete (the <emphasis>Open Session in View</"
"emphasis> pattern). Of course, this places heavy demands on the correctness "
"of the exception handling of your application infrastructure. It is vitally "
"important that the <literal>Session</literal> is closed and the transaction "
"ended before returning to the user, even when an exception occurs during "
"rendering of the view. See the Hibernate Wiki for examples of this \"Open "
"Session in View\" pattern."
msgstr ""
"Web ベースのアプリケーションでは、ビューのレンダリングが完了し、リクエストが"
"終わる一番最後で <literal>Session</literal> をクローズするために、サーブレッ"
"トフィルタを使うことができます（ <emphasis>Open Session in View</emphasis> パ"
"ターンです）。もちろん、アプリケーション基盤の例外処理の正確性が非常に重要に"
"なります。ビューのレンダリング中に例外が発生したときでさえ、ユーザーに処理が"
"戻る前に <literal>Session</literal> のクローズとトランザクションの終了を行う"
"ことが不可欠になります。 Hibernate の Wiki に載っている \"Open Session in "
"View\" パターンの例を参照してください。"

#. Tag: para
#, no-c-format
msgid ""
"In an application with a separate business tier, the business logic must "
"\"prepare\" all collections that the web tier needs before returning. This "
"means that the business tier should load all the data and return all the "
"data already initialized to the presentation/web tier that is required for a "
"particular use case. Usually, the application calls <literal>Hibernate."
"initialize()</literal> for each collection that will be needed in the web "
"tier (this call must occur before the session is closed) or retrieves the "
"collection eagerly using a Hibernate query with a <literal>FETCH</literal> "
"clause or a <literal>FetchMode.JOIN</literal> in <literal>Criteria</"
"literal>. This is usually easier if you adopt the <emphasis>Command</"
"emphasis> pattern instead of a <emphasis>Session Facade</emphasis>."
msgstr ""
"ビジネス層が分離しているアプリケーションでは、ビジネスロジックは Web 層で必要"
"になるすべてのコレクションを事前に「準備」する必要があります。これは特定の"
"ユースケースで必要となるプレゼンテーション/ Web 層に対し、ビジネス層がすべて"
"のデータをロードし、すべてのデータを初期化して返すべきということを意味してい"
"ます。通常は、アプリケーションは Web 層で必要なコレクションそれぞれに対して "
"<literal>Hibernate.initialize()</literal> を呼び出すか（この呼び出しはセッ"
"ションをクローズする前に行う必要があります）、 Hibernate クエリの "
"<literal>FETCH</literal> 節や <literal>Criteria</literal> の "
"<literal>FetchMode.JOIN</literal> を使ってコレクションを先に復元します。普通"
"は <emphasis>Session Facade</emphasis> パターンの代わりに <emphasis>Command</"
"emphasis> パターンを採用するほうがより簡単です。"

#. Tag: para
#, no-c-format
msgid ""
"You can also attach a previously loaded object to a new <literal>Session</"
"literal> with <literal>merge()</literal> or <literal>lock()</literal> before "
"accessing uninitialized collections or other proxies. Hibernate does not, "
"and certainly <emphasis>should</emphasis> not, do this automatically since "
"it would introduce impromptu transaction semantics."
msgstr ""
"初期化されていないコレクション（もしくは他のプロキシ）にアクセスする前に、 "
"<literal>merge()</literal> や <literal>lock()</literal> を使って新しい "
"<literal>Session</literal> に以前にロードされたオブジェクトを追加することも出"
"来ます。アドホックなトランザクションのセマンティクスを導入したので、 "
"Hibernate はこれを自動的に行わず、 <emphasis>行うべきでもありません</"
"emphasis> 。"

#. Tag: para
#, no-c-format
msgid ""
"Sometimes you do not want to initialize a large collection, but still need "
"some information about it, like its size, for example, or a subset of the "
"data."
msgstr ""
"大きなコレクションを初期化したくはないが、コレクションについてのなんらかの情"
"報（サイズのような）やデータのサブセットを必要とすることがあります。"

#. Tag: para
#, no-c-format
msgid ""
"You can use a collection filter to get the size of a collection without "
"initializing it:"
msgstr ""
"コレクションフィルタを使うことで、初期化せずにコレクションのサイズを取得する"
"ことが出来ます："

#. Tag: para
#, no-c-format
msgid ""
"The <literal>createFilter()</literal> method is also used to efficiently "
"retrieve subsets of a collection without needing to initialize the whole "
"collection:"
msgstr ""
"<literal>createFilter()</literal> メソッドは、コレクション全体を初期化する必"
"要なしに、コレクションのサブセットを復元するために効果的に使えます:"

#. Tag: title
#, no-c-format
msgid "Using batch fetching"
msgstr "バッチフェッチの使用"

#. Tag: para
#, no-c-format
msgid ""
"Using batch fetching, Hibernate can load several uninitialized proxies if "
"one proxy is accessed. Batch fetching is an optimization of the lazy select "
"fetching strategy. There are two ways you can configure batch fetching: on "
"the class level and the collection level."
msgstr ""
"Hibernate はバッチフェッチを効率的に使用できます。一つのプロキシ（もしくはコ"
"レクション）がアクセスされると、 Hibernate はいくつかの初期化していないプロキ"
"シをロードすることができます。バッチフェッチは遅延セレクトフェッチ戦略に対す"
"る最適化です。バッチフェッチの調整には２つの方法があります。クラスレベルとコ"
"レクションレベルです。"

#. Tag: para
#, no-c-format
msgid ""
"Batch fetching for classes/entities is easier to understand. Consider the "
"following example: at runtime you have 25 <literal>Cat</literal> instances "
"loaded in a <literal>Session</literal>, and each <literal>Cat</literal> has "
"a reference to its <literal>owner</literal>, a <literal>Person</literal>. "
"The <literal>Person</literal> class is mapped with a proxy, <literal>lazy="
"\"true\"</literal>. If you now iterate through all cats and call "
"<literal>getOwner()</literal> on each, Hibernate will, by default, execute "
"25 <literal>SELECT</literal> statements to retrieve the proxied owners. You "
"can tune this behavior by specifying a <literal>batch-size</literal> in the "
"mapping of <literal>Person</literal>:"
msgstr ""
"クラス、要素のバッチフェッチは理解が簡単です。実行時の次の場面を想像してくだ"
"さい。 <literal>Session</literal> にロードされた25個の <literal>Cat</"
"literal> インスタンスが存在し、それぞれの <literal>Cat</literal> は "
"<literal>owner</literal> である <literal>Person</literal> への関連を持ちま"
"す。 <literal>Person</literal> クラスは <literal>lazy=\"true\"</literal> のプ"
"ロキシでマッピングされています。もし今すべての Cat に対して繰り返し "
"<literal>getOwner()</literal> を呼び出すと、 Hibernate はデフォルトでは25回"
"の <literal>SELECT</literal> を実し、 owner プロキシの復元をします。この振る"
"舞いを <literal>Person</literal> のマッピングの <literal>batch-size</"
"literal> の指定で調整できます。"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate will now execute only three queries: the pattern is 10, 10, 5."
msgstr ""
"Hibernate はクエリを３回だけを実行するようになります。パターンは 10, 10, 5 で"
"す。"

#. Tag: para
#, no-c-format
msgid ""
"You can also enable batch fetching of collections. For example, if each "
"<literal>Person</literal> has a lazy collection of <literal>Cat</literal>s, "
"and 10 persons are currently loaded in the <literal>Session</literal>, "
"iterating through all persons will generate 10 <literal>SELECT</literal>s, "
"one for every call to <literal>getCats()</literal>. If you enable batch "
"fetching for the <literal>cats</literal> collection in the mapping of "
"<literal>Person</literal>, Hibernate can pre-fetch collections:"
msgstr ""
"コレクションのバッチフェッチも有効にすることが出来ます。例として、それぞれの "
"<literal>Person</literal> が <literal>Cat</literal> の遅延コレクションを持っ"
"ており、 10 個の Person が <literal>Sesssion</literal> にロードされたとする"
"と、すべての Person に対して繰り返し <literal>getCats()</literal> を呼び出す"
"ことで、計10回の <literal>SELECT</literal> が発生します。もし "
"<literal>Person</literal> のマッピングで <literal>cats</literal> コレクション"
"のバッチフェッチを有効にすれば、 Hibernate はコレクションの事前フェッチが出来"
"ます。"

#. Tag: para
#, no-c-format
msgid ""
"With a <literal>batch-size</literal> of 3, Hibernate will load 3, 3, 3, 1 "
"collections in four <literal>SELECT</literal>s. Again, the value of the "
"attribute depends on the expected number of uninitialized collections in a "
"particular <literal>Session</literal>."
msgstr ""
"<literal>batch-size</literal> が 3 なので、 Hibernate は 4 回の "
"<literal>SELECT</literal> で 3 個、 3 個、 3 個、 1 個をロードします。繰り返"
"すと、属性の値は特定の <literal>Session</literal> の中の初期化されていないコ"
"レクションの期待数に依存します。"

#. Tag: para
#, no-c-format
msgid ""
"Batch fetching of collections is particularly useful if you have a nested "
"tree of items, i.e. the typical bill-of-materials pattern. However, a "
"<emphasis>nested set</emphasis> or a <emphasis>materialized path</emphasis> "
"might be a better option for read-mostly trees."
msgstr ""
"コレクションのバッチフェッチはアイテムのネストしたツリー、すなわち、代表的な"
"部品表のパターンがある場合に特に有用です。（しかし、読み込みが多いツリーでは "
"<emphasis>ネストした set</emphasis> や <emphasis>具体化したパス</emphasis> が"
"よりよい選択になります。）"

#. Tag: title
#, no-c-format
msgid "Using subselect fetching"
msgstr "サブセレクトフェッチの使用"

#. Tag: para
#, no-c-format
msgid ""
"If one lazy collection or single-valued proxy has to be fetched, Hibernate "
"will load all of them, re-running the original query in a subselect. This "
"works in the same way as batch-fetching but without the piecemeal loading."
msgstr ""
"一つの遅延コレクションや単一値プロキシがフェッチされなければいけないとき、 "
"Hibernate はそれらすべてをロードし、サブセレクトのオリジナルクエリが再度実行"
"されます。これはバッチフェッチと同じ方法で動き、少しずつのロードは行いませ"
"ん。"

#. Tag: title
#, fuzzy, no-c-format
msgid "Fetch profiles"
msgstr "フェッチ戦略"

#. Tag: para
#, no-c-format
msgid ""
"Another way to affect the fetching strategy for loading associated objects "
"is through something called a fetch profile, which is a named configuration "
"associated with the <interfacename>org.hibernate.SessionFactory</"
"interfacename> but enabled, by name, on the <interfacename>org.hibernate."
"Session</interfacename>. Once enabled on a <interfacename>org.hibernate."
"Session</interfacename>, the fetch profile wull be in affect for that "
"<interfacename>org.hibernate.Session</interfacename> until it is explicitly "
"disabled."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"So what does that mean? Well lets explain that by way of an example. Say we "
"have the following mappings:"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Now normally when you get a reference to a particular customer, that "
"customer's set of orders will be lazy meaning we will not yet have loaded "
"those orders from the database. Normally this is a good thing. Now lets say "
"that you have a certain use case where it is more efficient to load the "
"customer and their orders together. One way certainly is to use \"dynamic "
"fetching\" strategies via an HQL or criteria queries. But another option is "
"to use a fetch profile to achieve that. Just add the following to your "
"mapping:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "or even:"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Now the following code will actually load both the customer <emphasis>and "
"their orders</emphasis>:"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Currently only join style fetch profiles are supported, but they plan is to "
"support additional styles. See <ulink url=\"http://opensource.atlassian.com/"
"projects/hibernate/browse/HHH-3414\">HHH-3414</ulink> for details."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Using lazy property fetching"
msgstr "遅延プロパティフェッチの使用"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate3 supports the lazy fetching of individual properties. This "
"optimization technique is also known as <emphasis>fetch groups</emphasis>. "
"Please note that this is mostly a marketing feature; optimizing row reads is "
"much more important than optimization of column reads. However, only loading "
"some properties of a class could be useful in extreme cases. For example, "
"when legacy tables have hundreds of columns and the data model cannot be "
"improved."
msgstr ""
"Hibernate3 はプロパティごとの遅延フェッチをサポートしています。この最適化手法"
"は <emphasis>グループのフェッチ</emphasis> としても知られています。これはほと"
"んど要望から出た機能であることに注意してください。実際には列読み込みの最適化"
"よりも、行読み込みの最適化が非常に重要です。しかし、クラスのいくつかのプロパ"
"ティだけを読み込むことは、既存のテーブルが何百もの列を持ち、データモデルを改"
"善できないなどの極端な場合には有用です。"

#. Tag: para
#, no-c-format
msgid ""
"To enable lazy property loading, set the <literal>lazy</literal> attribute "
"on your particular property mappings:"
msgstr ""
"遅延プロパティ読み込みを有効にするには、対象のプロパティのマッピングで "
"<literal>lazy</literal> 属性をセットしてください:"

#. Tag: para
#, no-c-format
msgid ""
"Lazy property loading requires buildtime bytecode instrumentation. If your "
"persistent classes are not enhanced, Hibernate will ignore lazy property "
"settings and return to immediate fetching."
msgstr ""
"遅延プロパティ読み込みはビルド時のバイトコード組み込みを必要とします。もし永"
"続クラスに組み込みがされていないなら、 Hibernate は黙って遅延プロパティの設定"
"を無視して、即時フェッチに戻します。"

#. Tag: para
#, no-c-format
msgid "For bytecode instrumentation, use the following Ant task:"
msgstr "バイトコード組み込みは以下の Ant タスクを使ってください: "

#. Tag: para
#, no-c-format
msgid ""
"A different way of avoiding unnecessary column reads, at least for read-only "
"transactions, is to use the projection features of HQL or Criteria queries. "
"This avoids the need for buildtime bytecode processing and is certainly a "
"preferred solution."
msgstr ""
"不要な列を読み込まないための、別の（よりよい？）方法は、少なくとも読み込みの"
"みのトランザクションにおいては、 HQL や Criteria クエリの射影機能を使うことで"
"す。この方法はビルド時のバイトコード組み込みが不要になり、より良い解決方法で"
"す。"

#. Tag: para
#, no-c-format
msgid ""
"You can force the usual eager fetching of properties using <literal>fetch "
"all properties</literal> in HQL."
msgstr ""
"HQL で <literal>fetch all properties</literal> を使うことで、普通どおりのプロ"
"パティの即時フェッチングを強制することが出来ます。"

#. Tag: title
#, no-c-format
msgid "The Second Level Cache"
msgstr "第2レベルキャッシュ"

#. Tag: para
#, no-c-format
msgid ""
"A Hibernate <literal>Session</literal> is a transaction-level cache of "
"persistent data. It is possible to configure a cluster or JVM-level "
"(<literal>SessionFactory</literal>-level) cache on a class-by-class and "
"collection-by-collection basis. You can even plug in a clustered cache. Be "
"aware that caches are not aware of changes made to the persistent store by "
"another application. They can, however, be configured to regularly expire "
"cached data."
msgstr ""
"Hibernate の <literal>Session</literal> は永続データのトランザクションレベル"
"のキャッシュです。 class-by-class と collection-by-collection ごとの、クラス"
"タレベルや JVM レベル （ <literal>SessionFactory</literal> レベル）のキャッ"
"シュを設定することが出来ます。クラスタ化されたキャッシュにつなぐことさえ出来"
"ます。しかし注意してください。キャッシュは他のアプリケーションによる永続層の"
"変更を考慮しません（キャッシュデータを定期的に期限切れにする設定は出来ま"
"す）。"

#. Tag: para
#, no-c-format
msgid ""
"You have the option to tell Hibernate which caching implementation to use by "
"specifying the name of a class that implements <literal>org.hibernate.cache."
"CacheProvider</literal> using the property <literal>hibernate.cache."
"provider_class</literal>. Hibernate is bundled with a number of built-in "
"integrations with the open-source cache providers that are listed below. You "
"can also implement your own and plug it in as outlined above. Note that "
"versions prior to 3.2 use EhCache as the default cache provider."
msgstr ""
"Hibernate が使用するキャッシュ実装は、 <literal>hibernate.cache."
"provider_class</literal> プロパティに <literal>org.hibernate.cache."
"CacheProvider</literal> を実装したクラス名を指定することで変更できます。 "
"Hibernate は多くのオープンソースのキャッシュプロバイダをビルトイン実装で持っ"
"ています（後にリストがあります）。加えて、前に説明したように、あなた自身が独"
"自の実装をして、それを組み込むことも出来ます。バージョン3.2より前では "
"EhCache がデフォルトのキャッシュプロバイダであることに注意してください。バー"
"ジョン3.2ではこれは当てはまりません。"

#. Tag: title
#, no-c-format
msgid "Cache Providers"
msgstr "キャッシュプロバイダ"

#. Tag: entry
#, no-c-format
msgid "Cache"
msgstr "キャッシュ"

#. Tag: entry
#, no-c-format
msgid "Provider class"
msgstr "プロバイダクラス"

#. Tag: entry
#, no-c-format
msgid "Type"
msgstr "タイプ"

#. Tag: entry
#, no-c-format
msgid "Cluster Safe"
msgstr "クラスタセーフ"

#. Tag: entry
#, no-c-format
msgid "Query Cache Supported"
msgstr "クエリキャッシュのサポート"

#. Tag: entry
#, no-c-format
msgid "Hashtable (not intended for production use)"
msgstr "Hashtable（製品用として意図していません）"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache.HashtableCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.HashtableCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "memory"
msgstr "メモリ"

#. Tag: entry
#, no-c-format
msgid "yes"
msgstr ""

#. Tag: entry
#, no-c-format
msgid "EHCache"
msgstr "EHCache"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache.EhCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.EhCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "memory, disk"
msgstr "メモリ、ディスク"

#. Tag: entry
#, no-c-format
msgid "OSCache"
msgstr "OSCache"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache.OSCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.OSCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "SwarmCache"
msgstr "SwarmCache"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache.SwarmCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.SwarmCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "clustered (ip multicast)"
msgstr "クラスタ（ip マルチキャスト）"

#. Tag: entry
#, no-c-format
msgid "yes (clustered invalidation)"
msgstr "yes（クラスタ無効化）"

#. Tag: entry
#, no-c-format
msgid "JBoss Cache 1.x"
msgstr ""

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache.TreeCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.TreeCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "clustered (ip multicast), transactional"
msgstr "クラスタ（ip マルチキャスト）、トランザクショナル"

#. Tag: entry
#, no-c-format
msgid "yes (replication)"
msgstr "yes（複製）"

#. Tag: entry
#, no-c-format
msgid "yes (clock sync req.)"
msgstr "yes（時刻同期が必要）"

#. Tag: entry
#, no-c-format
msgid "JBoss Cache 2"
msgstr ""

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache.jbc.JBossCacheRegionFactory</literal>"
msgstr "<literal>org.hibernate.cache.jbc2.JBossCacheRegionFactory</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "yes (replication or invalidation)"
msgstr "yes（クラスタ無効化）"

#. Tag: title
#, no-c-format
msgid "Cache mappings"
msgstr "キャッシュのマッピング"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>&lt;cache&gt;</literal> element of a class or collection "
"mapping has the following form:"
msgstr ""
"クラスやコレクションのマッピングの <literal>&lt;cache&gt;</literal> 要素は以"
"下の形式です。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>usage</literal> (required) specifies the caching strategy: "
"<literal>transactional</literal>, <literal>read-write</literal>, "
"<literal>nonstrict-read-write</literal> or <literal>read-only</literal>"
msgstr ""
"<literal>usage</literal> (必須) キャッシング戦略を指定します： "
"<literal>transactional</literal>、 <literal>read-write</literal>、 "
"<literal>nonstrict-read-write</literal> または <literal>read-only</literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>region</literal> (optional: defaults to the class or collection "
"role name): specifies the name of the second level cache region"
msgstr ""
"<literal>region</literal> (オプション、クラスまたはコレクションのロールネーム"
"のデフォルト) 2次レベルのキャッシュ領域の名前を指定します"

#. Tag: para
#, no-c-format
msgid ""
"<literal>include</literal> (optional: defaults to <literal>all</literal>) "
"<literal>non-lazy</literal>: specifies that properties of the entity mapped "
"with <literal>lazy=\"true\"</literal> cannot be cached when attribute-level "
"lazy fetching is enabled"
msgstr ""
"<literal>include</literal> (オプション、 <literal>all</literal> に対してデ"
"フォルト) <literal>non-lazy</literal> は、 属性レベルの lazy フェチが有効に"
"なっている場合 <literal>lazy=\"true\"</literal> でマッピングされるエンティ"
"ティのプロパティはキャッシュされなくてもよいことを指定します。"

#. Tag: para
#, no-c-format
msgid ""
"Alternatively, you can specify <literal>&lt;class-cache&gt;</literal> and "
"<literal>&lt;collection-cache&gt;</literal> elements in <literal>hibernate."
"cfg.xml</literal>."
msgstr ""
"または（よりよい方法として？）、 <literal>hibernate.cfg.xml</literal> に "
"<literal>&lt;class-cache&gt;</literal> と <literal>&lt;collection-cache&gt;</"
"literal> 要素を指定することも出来ます。"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>usage</literal> attribute specifies a <emphasis>cache "
"concurrency strategy</emphasis>."
msgstr ""
"<literal>usage</literal> 属性は <emphasis>キャッシュの並列性戦略</emphasis> "
"を指定します。"

#. Tag: title
#, no-c-format
msgid "Strategy: read only"
msgstr "read only 戦略"

#. Tag: para
#, no-c-format
msgid ""
"If your application needs to read, but not modify, instances of a persistent "
"class, a <literal>read-only</literal> cache can be used. This is the "
"simplest and optimal performing strategy. It is even safe for use in a "
"cluster."
msgstr ""
"もしアプリケーションが読み込みのみ必要で、永続クラスのインスタンスを変更しな"
"いなら、 <literal>read-only</literal> キャッシュを使うことが出来ます。これは"
"もっとも単純でもっともパフォーマンスの良い戦略です。クラスタでの使用も完全に"
"安全です。"

#. Tag: title
#, no-c-format
msgid "Strategy: read/write"
msgstr "read/write 戦略"

#. Tag: para
#, no-c-format
msgid ""
"If the application needs to update data, a <literal>read-write</literal> "
"cache might be appropriate. This cache strategy should never be used if "
"serializable transaction isolation level is required. If the cache is used "
"in a JTA environment, you must specify the property <literal>hibernate."
"transaction.manager_lookup_class</literal> and naming a strategy for "
"obtaining the JTA <literal>TransactionManager</literal>. In other "
"environments, you should ensure that the transaction is completed when "
"<literal>Session.close()</literal> or <literal>Session.disconnect()</"
"literal> is called. If you want to use this strategy in a cluster, you "
"should ensure that the underlying cache implementation supports locking. The "
"built-in cache providers <emphasis>do not</emphasis> support locking."
msgstr ""
"アプリケーションがデータを更新する必要があるなら、 <literal>read-write</"
"literal> キャッシュが適当かもしれません。このキャッシュ戦略は、シリアライザブ"
"ルなトランザクション分離レベルが要求されるなら、決して使うべきではありませ"
"ん。もしキャッシュが JTA 環境で使われるなら、 JTA "
"<literal>TransactionManager</literal> を取得するための方法を示す "
"<literal>hibernate.transaction.manager_lookup_class</literal> プロパティを指"
"定しなければなりません。他の環境では、 <literal>Session.close()</literal> や "
"<literal>Session.disconnect()</literal> が呼ばれたときに、確実にトランザク"
"ションが完了していなければなりません。もしクラスタでこの戦略を使いたいなら、"
"基となるキャッシュの実装がロックをサポートしていることを保証しなければなりま"
"せん。組み込みのキャッシュプロバイダは <emphasis>サポートしていません</"
"emphasis> 。"

#. Tag: title
#, no-c-format
msgid "Strategy: nonstrict read/write"
msgstr "厳密ではない read/write 戦略"

#. Tag: para
#, no-c-format
msgid ""
"If the application only occasionally needs to update data (i.e. if it is "
"extremely unlikely that two transactions would try to update the same item "
"simultaneously), and strict transaction isolation is not required, a "
"<literal>nonstrict-read-write</literal> cache might be appropriate. If the "
"cache is used in a JTA environment, you must specify <literal>hibernate."
"transaction.manager_lookup_class</literal>. In other environments, you "
"should ensure that the transaction is completed when <literal>Session.close()"
"</literal> or <literal>Session.disconnect()</literal> is called."
msgstr ""
"アプリケーションがたまにしかデータを更新する必要はなく（すなわち二つのトラン"
"ザクションが同時に同じアイテムを更新しようとすることはほとんど起こらない）、"
"厳密なトランザクション分離が要求されないなら、 <literal>nonstrict-read-"
"write</literal> キャッシュが適当かもしれません。もしキャッシュが JTA 環境で使"
"われるなら、 <literal>hibernate.transaction.manager_lookup_class</literal> を"
"指定しなければなりません。他の環境では、 <literal>Session.close()</literal> "
"や <literal>Session.disconnect()</literal> が呼ばれたときに、確実にトランザク"
"ションが完了していなければなりません。"

#. Tag: title
#, no-c-format
msgid "Strategy: transactional"
msgstr "transactional 戦略"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>transactional</literal> cache strategy provides support for "
"fully transactional cache providers such as JBoss TreeCache. Such a cache "
"can only be used in a JTA environment and you must specify "
"<literal>hibernate.transaction.manager_lookup_class</literal>."
msgstr ""
"<literal>transactional</literal> キャッシュ戦略は JBoss TreeCache のような完"
"全なトランザクショナルキャッシュプロバイダのサポートを提供します。このような"
"キャッシュは JTA 環境でのみ使用可能で、 <literal>hibernate.transaction."
"manager_lookup_class</literal> を指定しなければなりません。"

#. Tag: title
#, fuzzy, no-c-format
msgid "Cache-provider/concurrency-strategy compatibility"
msgstr "同時並行性キャッシュ戦略のサポート"

#. Tag: para
#, no-c-format
msgid ""
"None of the cache providers support all of the cache concurrency strategies."
msgstr ""
"すべての同時並行性キャッシュ戦略をサポートしているキャッシュプロバイダはあり"
"ません。"

#. Tag: para
#, no-c-format
msgid ""
"The following table shows which providers are compatible with which "
"concurrency strategies."
msgstr ""
"以下の表はどのプロバイダがどの同時並列性戦略に対応するかを表しています。"

#. Tag: title
#, no-c-format
msgid "Cache Concurrency Strategy Support"
msgstr "同時並行性キャッシュ戦略のサポート"

#. Tag: entry
#, no-c-format
msgid "read-only"
msgstr "read-only"

#. Tag: entry
#, no-c-format
msgid "nonstrict-read-write"
msgstr "厳密ではない read-write"

#. Tag: entry
#, no-c-format
msgid "read-write"
msgstr "read-write"

#. Tag: entry
#, no-c-format
msgid "transactional"
msgstr "transactional"

#. Tag: title
#, no-c-format
msgid "Managing the caches"
msgstr "キャッシュの管理"

#. Tag: para
#, no-c-format
msgid ""
"Whenever you pass an object to <literal>save()</literal>, <literal>update()</"
"literal> or <literal>saveOrUpdate()</literal>, and whenever you retrieve an "
"object using <literal>load()</literal>, <literal>get()</literal>, "
"<literal>list()</literal>, <literal>iterate()</literal> or <literal>scroll()"
"</literal>, that object is added to the internal cache of the "
"<literal>Session</literal>."
msgstr ""
"オブジェクトを <literal>save()</literal> 、 <literal>update()</literal> 、 "
"<literal>saveOrUpdate()</literal> に渡すとき、そして <literal>load()</"
"literal> 、 <literal>get()</literal> 、 <literal>list()</literal> 、 "
"<literal>iterate()</literal> 、 <literal>scroll()</literal> を使ってオブジェ"
"クトを復元するときには常に、そのオブジェクトは <literal>Session</literal> の"
"内部キャッシュに追加されます。"

#. Tag: para
#, no-c-format
msgid ""
"When <literal>flush()</literal> is subsequently called, the state of that "
"object will be synchronized with the database. If you do not want this "
"synchronization to occur, or if you are processing a huge number of objects "
"and need to manage memory efficiently, the <literal>evict()</literal> method "
"can be used to remove the object and its collections from the first-level "
"cache."
msgstr ""
"次に <literal>flush()</literal> が呼ばれると、オブジェクトの状態はデータベー"
"スと同期化されます。もしこの同期が起こることを望まないときや、膨大な数のオブ"
"ジェクトを処理していてメモリを効率的に扱う必要があるときは、 <literal>evict()"
"</literal> メソッドを使って一次キャッシュからオブジェクトやコレクションを削除"
"することが出来ます。"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>Session</literal> also provides a <literal>contains()</literal> "
"method to determine if an instance belongs to the session cache."
msgstr ""
"<literal>Session</literal> はインスタンスがセッションキャッシュに含まれるかど"
"うかを判断するための <literal>contains()</literal> メソッドも提供します。"

#. Tag: para
#, no-c-format
msgid ""
"To evict all objects from the session cache, call <literal>Session.clear()</"
"literal>"
msgstr ""
"すべてのオブジェクトをセッションキャッシュから完全に取り除くには、 "
"<literal>Session.clear()</literal> を呼び出してください。"

#. Tag: para
#, no-c-format
msgid ""
"For the second-level cache, there are methods defined on "
"<literal>SessionFactory</literal> for evicting the cached state of an "
"instance, entire class, collection instance or entire collection role."
msgstr ""
"二次キャッシュのために、 <literal>SessionFactory</literal> にはインスタンス、"
"クラス全体、コレクションのインスタンス、コレクション全体をキャッシュから削除"
"するためのメソッドがそれぞれ定義されています。"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>CacheMode</literal> controls how a particular session interacts "
"with the second-level cache:"
msgstr ""
"<literal>CacheMode</literal> は特定のセッションが二次キャッシュとどのように相"
"互作用するかを指定します。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.NORMAL</literal>: will read items from and write items to "
"the second-level cache"
msgstr ""
"<literal>CacheMode.NORMAL</literal> - アイテムの読み込みと書き込みで二次"
"キャッシュを使います"

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.GET</literal>: will read items from the second-level "
"cache. Do not write to the second-level cache except when updating data"
msgstr ""
"<literal>CacheMode.GET</literal> - 読み込みは二次キャッシュから行いますが、"
"データを更新した場合を除いて二次キャッシュに書き込みをしません。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.PUT</literal>: will write items to the second-level "
"cache. Do not read from the second-level cache"
msgstr ""
"<literal>CacheMode.PUT</literal> - 二次キャッシュにアイテムを書き込みますが、"
"読み込みには二次キャッシュを使いません。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.REFRESH</literal>: will write items to the second-level "
"cache. Do not read from the second-level cache. Bypass the effect of "
"<literal>hibernate.cache.use_minimal_puts</literal> forcing a refresh of the "
"second-level cache for all items read from the database"
msgstr ""
"<literal>CacheMode.REFRESH</literal> - 二次キャッシュにアイテムを書き込みます"
"が、読み込みには二次キャッシュを使わず、 <literal>hibernate.cache."
"use_minimal_puts</literal> の影響を受けずに、データベースから読み込むすべての"
"アイテムの二次キャッシュを強制的にリフレッシュします。"

#. Tag: para
#, no-c-format
msgid ""
"To browse the contents of a second-level or query cache region, use the "
"<literal>Statistics</literal> API:"
msgstr ""
"二次キャッシュの内容やクエリキャッシュ領域を見るために、 "
"<literal>Statistics</literal> API を使ってください:"

#. Tag: para
#, no-c-format
msgid ""
"You will need to enable statistics and, optionally, force Hibernate to keep "
"the cache entries in a more readable format:"
msgstr ""
"統計情報を有効にして、さらにオプションとして、キャッシュエントリを人がより理"
"解可能な形式で保持することを Hibernate に強制します:"

#. Tag: title
#, no-c-format
msgid "The Query Cache"
msgstr "クエリキャッシュ"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Query result sets can also be cached. This is only useful for queries that "
"are run frequently with the same parameters."
msgstr ""
"クエリのリザルトセットもキャッシュ出来ます。これは同じパラメータで何度も実行"
"されるクエリに対してのみ有用です。クエリキャッシュを使うには、まず設定で有効"
"にしなくてはなりません:"

#. Tag: title
#, no-c-format
msgid "Enabling query caching"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Caching of query results introduces some overhead in terms of your "
"applications normal transactional processing. For example, if you cache "
"results of a query against Person Hibernate will need to keep track of when "
"those results should be invalidated because changes have been committed "
"against Person. That, coupled with the fact that most applications simply "
"gain no benefit from caching query results, leads Hibernate to disable "
"caching of query results by default. To use query caching, you will first "
"need to enable the query cache:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "This setting creates two new cache regions:"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"<classname>org.hibernate.cache.StandardQueryCache</classname>, holding the "
"cached query results"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"<classname>org.hibernate.cache.UpdateTimestampsCache</classname>, holding "
"timestamps of the most recent updates to queryable tables. These are used to "
"validate the results as they are served from the query cache."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"If you configure your underlying cache implementation to use expiry or "
"timeouts is is very important that the cache timeout of the underlying cache "
"region for the UpdateTimestampsCache be set to a higher value than the "
"timeouts of any of the query caches. In fact, we recommend that the the "
"UpdateTimestampsCache region not be configured for expiry at all. Note, in "
"particular, that an LRU cache expiry policy is never appropriate."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"As mentioned above, most queries do not benefit from caching or their "
"results. So by default, individual queries are not cached even after "
"enabling query caching. To enable results caching for a particular query, "
"call <literal>org.hibernate.Query.setCacheable(true)</literal>. This call "
"allows the query to look for existing cache results or add its results to "
"the cache when it is executed."
msgstr ""
"ほとんどのクエリはキャッシュの恩恵を受けないので、デフォルトではクエリは"
"キャッシュされません。キャッシュを有効にするには、 <literal>Query."
"setCacheable(true)</literal> を呼び出してください。そうすればクエリが既存の"
"キャッシュ結果を探し、クエリ実行時にその結果をキャッシュに追加するようになり"
"ます。"

#. Tag: para
#, no-c-format
msgid ""
"The query cache does not cache the state of the actual entities in the "
"cache; it caches only identifier values and results of value type. For this "
"reaso, the query cache should always be used in conjunction with the second-"
"level cache for those entities expected to be cached as part of a query "
"result cache (just as with collection caching)."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Query cache regions"
msgstr "クエリキャッシュのサポート"

#. Tag: para
#, no-c-format
msgid ""
"If you require fine-grained control over query cache expiration policies, "
"you can specify a named cache region for a particular query by calling "
"<literal>Query.setCacheRegion()</literal>."
msgstr ""
"クエリキャッシュの破棄ポリシーを細かく制御したいときは、 <literal>Query."
"setCacheRegion()</literal> を呼び出して特定のクエリに対するキャッシュ領域を指"
"定することが出来ます。"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you want to force the query cache to refresh one of its regions "
"(disregard any cached results it finds there) you can use <literal>org."
"hibernate.Query.setCacheMode(CacheMode.REFRESH)</literal>. In conjunction "
"with the region you have defined for the given query, Hibernate will "
"selectively force the results cached in that particular region to be "
"refreshed. This is particularly useful in cases where underlying data may "
"have been updated via a separate process and is a far more efficient "
"alternative to bulk eviction of the region via <literal>org.hibernate."
"SessionFactory.evictQueries()</literal>."
msgstr ""
"クエリが自身のクエリキャッシュ領域のリフレッシュを強制しなければならないな"
"ら、 <literal>Query.setCacheMode(CacheMode.REFRESH)</literal> を呼び出すべき"
"です。これは元となるデータが別のプロセスによって更新されたり（すなわち "
"Hibernate を通じて更新されない）、アプリケーションに特定のクエリリザルトセッ"
"トを選択してリフレッシュさせる場合に特に有用です。さらに有用なもう一つの方法"
"は、 <literal>SessionFactory.evictQueries()</literal> によってクエリキャッ"
"シュ領域を消去することです。"

#. Tag: title
#, no-c-format
msgid "Understanding Collection performance"
msgstr "コレクションのパフォーマンスの理解"

#. Tag: para
#, no-c-format
msgid ""
"In the previous sections we have covered collections and their applications. "
"In this section we explore some more issues in relation to collections at "
"runtime."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Taxonomy"
msgstr "分類"

#. Tag: para
#, no-c-format
msgid "Hibernate defines three basic kinds of collections:"
msgstr "Hibernate は3つの基本的なコレクションの種類を定義しています:"

#. Tag: para
#, no-c-format
msgid "collections of values"
msgstr "値のコレクション"

#. Tag: para
#, no-c-format
msgid "one-to-many associations"
msgstr "一対多関連"

#. Tag: para
#, no-c-format
msgid "many-to-many associations"
msgstr "多対多関連"

#. Tag: para
#, no-c-format
msgid ""
"This classification distinguishes the various table and foreign key "
"relationships but does not tell us quite everything we need to know about "
"the relational model. To fully understand the relational structure and "
"performance characteristics, we must also consider the structure of the "
"primary key that is used by Hibernate to update or delete collection rows. "
"This suggests the following classification:"
msgstr ""
"この分類はさまざまなテーブルや外部キー関連を区別しますが、私たちが知る必要の"
"ある関連モデルについてほとんどなにも教えてくれません。関連構造やパフォーマン"
"スの特徴を完全に理解するには、 Hibernate がコレクションの行を更新、削除するた"
"めに使う主キーの構造もまた考えなければなりません。これは以下の分類を提示しま"
"す。"

#. Tag: para
#, no-c-format
msgid "indexed collections"
msgstr "インデックス付きコレクション"

#. Tag: para
#, no-c-format
msgid "sets"
msgstr "set"

#. Tag: para
#, no-c-format
msgid "bags"
msgstr "bag"

#. Tag: para
#, no-c-format
msgid ""
"All indexed collections (maps, lists, and arrays) have a primary key "
"consisting of the <literal>&lt;key&gt;</literal> and <literal>&lt;index&gt;</"
"literal> columns. In this case, collection updates are extremely efficient. "
"The primary key can be efficiently indexed and a particular row can be "
"efficiently located when Hibernate tries to update or delete it."
msgstr ""
"すべてのインデックス付きコレクション （マップ、リスト、配列） は "
"<literal>&lt;key&gt;</literal> と <literal>&lt;index&gt;</literal> カラムから"
"なる主キーを持っています。この場合はコレクションの更新は非常に効率的です。主"
"キーは有用なインデックスになり、 Hibernate が特定の行を更新または削除するとき"
"に、その行を効率的に見つけることができます。"

#. Tag: para
#, no-c-format
msgid ""
"Sets have a primary key consisting of <literal>&lt;key&gt;</literal> and "
"element columns. This can be less efficient for some types of collection "
"element, particularly composite elements or large text or binary fields, as "
"the database may not be able to index a complex primary key as efficiently. "
"However, for one-to-many or many-to-many associations, particularly in the "
"case of synthetic identifiers, it is likely to be just as efficient. If you "
"want <literal>SchemaExport</literal> to actually create the primary key of a "
"<literal>&lt;set&gt;</literal>, you must declare all columns as <literal>not-"
"null=\"true\"</literal>."
msgstr ""
"set は <literal>&lt;key&gt;</literal> からなる主キーと要素のカラムを持ってい"
"ます。これはコレクション要素のいくつかの型については効率的ではないかもしれま"
"せん。特に複合要素、大きなテキスト、バイナリフィールドでは非効率です。データ"
"ベースは複合主キーに効率的にインデックスを付けることができないからです。一"
"方、一対多や多対多関連において、特に人工識別子の場合は同じぐらい効率的です。"
"（余談： <literal>SchemaExport</literal> で実際に <literal>&lt;set&gt;</"
"literal> の主キーを作りたいなら、すべてのカラムで <literal>not-null=\"true"
"\"</literal> を宣言しなければなりません。）"

#. Tag: para
#, no-c-format
msgid ""
"<literal>&lt;idbag&gt;</literal> mappings define a surrogate key, so they "
"are efficient to update. In fact, they are the best case."
msgstr ""
"<literal>&lt;idbag&gt;</literal> マッピングは代理キーを定義します。そのため更"
"新は常に非常に効率的です。事実上、これは最善のケースです。"

#. Tag: para
#, no-c-format
msgid ""
"Bags are the worst case since they permit duplicate element values and, as "
"they have no index column, no primary key can be defined. Hibernate has no "
"way of distinguishing between duplicate rows. Hibernate resolves this "
"problem by completely removing in a single <literal>DELETE</literal> and "
"recreating the collection whenever it changes. This can be inefficient."
msgstr ""
"bag は最悪のケースです。 bag は要素の値の重複が可能で、インデックスカラムを持"
"たないため、主キーは定義されないかもしれません。 Hibernate には重複した行を区"
"別する方法がありません。 Hibernate はこの問題の解決のために、変更があったとき"
"には常に完全な削除（一つの <literal>DELETE</literal> による）を行い、コレク"
"ションの再作成を行います。これは非常に非効率的かもしれません。"

#. Tag: para
#, no-c-format
msgid ""
"For a one-to-many association, the \"primary key\" may not be the physical "
"primary key of the database table. Even in this case, the above "
"classification is still useful. It reflects how Hibernate \"locates\" "
"individual rows of the collection."
msgstr ""
"一対多関連では、「主キー」はデータベースのテーブルの物理的な主キーではないか"
"もしれないことに注意してください。しかしこの場合でさえ、上記の分類はまだ有用"
"です。（Hibernateがコレクションの個々の行をどうやって「見つけるか」を表してい"
"ます。）"

#. Tag: title
#, no-c-format
msgid ""
"Lists, maps, idbags and sets are the most efficient collections to update"
msgstr "更新にもっとも効率的なコレクション list、map、idbag、set"

#. Tag: para
#, no-c-format
msgid ""
"From the discussion above, it should be clear that indexed collections and "
"sets allow the most efficient operation in terms of adding, removing and "
"updating elements."
msgstr ""
"上での議論から、インデックス付きコレクションと（普通の） set は要素の追加、削"
"除、更新でもっとも効率的な操作が出来ることは明らかです。"

#. Tag: para
#, no-c-format
msgid ""
"There is, arguably, one more advantage that indexed collections have over "
"sets for many-to-many associations or collections of values. Because of the "
"structure of a <literal>Set</literal>, Hibernate does not <literal>UPDATE</"
"literal> a row when an element is \"changed\". Changes to a <literal>Set</"
"literal> always work via <literal>INSERT</literal> and <literal>DELETE</"
"literal> of individual rows. Once again, this consideration does not apply "
"to one-to-many associations."
msgstr ""
"ほぼ間違いなく、多対多関連や値のコレクションにおいて、インデックス付きコレク"
"ションが set よりも優れている点が一つ以上あります。 <literal>Set</literal> は"
"その構造のために、 Hibernate は要素が「変更」されたときに行を決して "
"<literal>UPDATE</literal> しません。 <literal>Set</literal> への変更は常に"
"（個々の行の） <literal>INSERT</literal> と <literal>DELETE</literal> によっ"
"て行います。繰り返しますが、これは一対多関連には当てはまりません。"

#. Tag: para
#, no-c-format
msgid ""
"After observing that arrays cannot be lazy, you can conclude that lists, "
"maps and idbags are the most performant (non-inverse) collection types, with "
"sets not far behind. You can expect sets to be the most common kind of "
"collection in Hibernate applications. This is because the \"set\" semantics "
"are most natural in the relational model."
msgstr ""
"配列は遅延処理ができないという決まりなので、結論として、list、map、idbag が"
"もっともパフォーマンスの良い（inverse ではない）コレクションタイプとなりま"
"す。 set もそれほど違いはありません。 Hibernate のアプリケーションでは、 set "
"はコレクションのもっとも共通の種類として期待されます。 \"set\" の表現は関連モ"
"デルではもっとも自然だからです。"

#. Tag: para
#, no-c-format
msgid ""
"However, in well-designed Hibernate domain models, most collections are in "
"fact one-to-many associations with <literal>inverse=\"true\"</literal>. For "
"these associations, the update is handled by the many-to-one end of the "
"association, and so considerations of collection update performance simply "
"do not apply."
msgstr ""
"しかし、よくデザインされた Hibernate のドメインモデルでは、通常もっとも多いコ"
"レクションは事実上 <literal>inverse=\"true\"</literal> を指定した一対多関連で"
"す。これらの関連では、更新は多対一の関連端で扱われ、コレクションの更新パ"
"フォーマンスの問題は当てはまりません。"

#. Tag: title
#, no-c-format
msgid "Bags and lists are the most efficient inverse collections"
msgstr "inverse コレクションにもっとも最適な bag と list"

#. Tag: para
#, no-c-format
msgid ""
"There is a particular case, however, in which bags, and also lists, are much "
"more performant than sets. For a collection with <literal>inverse=\"true\"</"
"literal>, the standard bidirectional one-to-many relationship idiom, for "
"example, we can add elements to a bag or list without needing to initialize "
"(fetch) the bag elements. This is because, unlike a <literal>set</literal>, "
"<literal>Collection.add()</literal> or <literal>Collection.addAll()</"
"literal> must always return true for a bag or <literal>List</literal>. This "
"can make the following common code much faster:"
msgstr ""
"bag を見放してしまう前に、 bag （そして list も）が set よりもずっとパフォー"
"マンスが良い特別なケースを紹介します。 <literal>inverse=\"true\"</literal> の"
"コレクション（一般的な一対多関連の使い方など）で、 bag の要素を初期化（フェッ"
"チ）する必要なく bag や list に要素を追加できます。これは "
"<literal>Collection.add()</literal> や <literal>Collection.addAll()</"
"literal> は bag や <literal>List</literal> では常に true を返さなければならな"
"いからです （ <literal>Set</literal> とは異なります）。これは以下の共通処理を"
"より速くすることができます。"

#. Tag: title
#, no-c-format
msgid "One shot delete"
msgstr "一括削除"

#. Tag: para
#, no-c-format
msgid ""
"Deleting collection elements one by one can sometimes be extremely "
"inefficient. Hibernate knows not to do that in the case of an newly-empty "
"collection (if you called <literal>list.clear()</literal>, for example). In "
"this case, Hibernate will issue a single <literal>DELETE</literal>."
msgstr ""
"時々、コレクションの要素を一つ一つ削除することは極めて非効率的になることがあ"
"ります。 Hibernate は愚かではないので、新しい空のコレクションの場合"
"（ <literal>list.clear()</literal> を呼び出した場合など）ではこれをすべきでな"
"いことを知っています。この場合は、 Hibernate は <literal>DELETE</literal> を"
"一回発行して、それですべて終わります。"

#. Tag: para
#, no-c-format
msgid ""
"Suppose you added a single element to a collection of size twenty and then "
"remove two elements. Hibernate will issue one <literal>INSERT</literal> "
"statement and two <literal>DELETE</literal> statements, unless the "
"collection is a bag. This is certainly desirable."
msgstr ""
"サイズ20のコレクションに一つの要素を追加し、それから二つの要素を削除するとし"
"ます。 Hibernate は一つの <literal>INSERT</literal> 文と二つの "
"<literal>DELETE</literal> 文を発行します （コレクションが bag でなければ）。"
"これは確かに望ましい動作です。"

#. Tag: para
#, no-c-format
msgid ""
"However, suppose that we remove eighteen elements, leaving two and then add "
"thee new elements. There are two possible ways to proceed"
msgstr ""
"しかし、18個の要素を削除して2つを残し、それから3つ新しい要素を追加するとしま"
"す。このとき二つの方法があります。"

#. Tag: para
#, no-c-format
msgid "delete eighteen rows one by one and then insert three rows"
msgstr "18行を一つ一つ削除して、3行を追加する"

#. Tag: para
#, no-c-format
msgid ""
"remove the whole collection in one SQL <literal>DELETE</literal> and insert "
"all five current elements one by one"
msgstr ""
"コレクション全体を削除（ <literal>DELETE</literal> の SQL を一回）し、そして5"
"つの要素すべてを（一つずつ）追加する"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate cannot know that the second option is probably quicker. It would "
"probably be undesirable for Hibernate to be that intuitive as such behavior "
"might confuse database triggers, etc."
msgstr ""
"Hibernate はこの場合に2番目の方法がより速いだろうとわかるほど賢くはありませ"
"ん。（そして Hibernate がこのように賢いことも望ましくないでしょう。このような"
"振る舞いはデータベースのトリガなどを混乱させるかもしれません。）"

#. Tag: para
#, no-c-format
msgid ""
"Fortunately, you can force this behavior (i.e. the second strategy) at any "
"time by discarding (i.e. dereferencing) the original collection and "
"returning a newly instantiated collection with all the current elements."
msgstr ""
"幸いにも、元のコレクションを捨て（つまり参照をやめて）、現在の要素をすべて持"
"つ新しいコレクションのインスタンスを返すことで、いつでもこの振る舞い（2番目の"
"戦略）を強制することが出来ます。時にこれはとても便利で強力です。"

#. Tag: para
#, no-c-format
msgid ""
"One-shot-delete does not apply to collections mapped <literal>inverse=\"true"
"\"</literal>."
msgstr ""
"もちろん、一括削除は <literal>inverse=\"true\"</literal> を指定したコレクショ"
"ンには行いません。"

#. Tag: title
#, no-c-format
msgid "Monitoring performance"
msgstr "パフォーマンスのモニタリング"

#. Tag: para
#, no-c-format
msgid ""
"Optimization is not much use without monitoring and access to performance "
"numbers. Hibernate provides a full range of figures about its internal "
"operations. Statistics in Hibernate are available per "
"<literal>SessionFactory</literal>."
msgstr ""
"最適化はモニタリングやパフォーマンスを示す数値がなければ十分に行えません。 "
"Hibernate は内部処理のすべての範囲の数値を提供します。 Hibernate の統計情報"
"は <literal>SessionFactory</literal> 単位で取得可能です。"

#. Tag: title
#, no-c-format
msgid "Monitoring a SessionFactory"
msgstr "SessionFactory のモニタリング"

#. Tag: para
#, no-c-format
msgid ""
"You can access <literal>SessionFactory</literal> metrics in two ways. Your "
"first option is to call <literal>sessionFactory.getStatistics()</literal> "
"and read or display the <literal>Statistics</literal> yourself."
msgstr ""
"<literal>SessionFactory</literal> のメトリクスにアクセスするには2つの方法があ"
"ります。最初の方法は、 <literal>sessionFactory.getStatistics()</literal> を呼"
"び出し、自分で <literal>Statistics</literal> の読み込みや表示を行います。"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate can also use JMX to publish metrics if you enable the "
"<literal>StatisticsService</literal> MBean. You can enable a single MBean "
"for all your <literal>SessionFactory</literal> or one per factory. See the "
"following code for minimalistic configuration examples:"
msgstr ""
"<literal>StatisticsService</literal> MBean を有効にしていれば、 Hibernate は "
"JMX を使ってメトリクスを発行することもできます。1つの MBean をすべての "
"<literal>SessionFactory</literal> に対して有効にするか、 SessionFactory ごと"
"に一つの MBean を有効にすることが出来ます。最小限の設定例である以下のコードを"
"見てください:"

#. Tag: para
#, no-c-format
msgid ""
"You can activate and deactivate the monitoring for a "
"<literal>SessionFactory</literal>:"
msgstr ""
"<literal>SessionFactory</literal> に対してモニタリングの開始（終了）を行うこ"
"とが出来ます。"

#. Tag: para
#, no-c-format
msgid ""
"at configuration time, set <literal>hibernate.generate_statistics</literal> "
"to <literal>false</literal>"
msgstr ""
"設定時には、 <literal>hibernate.generate_statistics</literal> を "
"<literal>false</literal> にします"

#. Tag: para
#, no-c-format
msgid ""
"at runtime: <literal>sf.getStatistics().setStatisticsEnabled(true)</literal> "
"or <literal>hibernateStatsBean.setStatisticsEnabled(true)</literal>"
msgstr ""
"実行時に、 <literal>sf.getStatistics().setStatisticsEnabled(true)</literal> "
"または <literal>hibernateStatsBean.setStatisticsEnabled(true)</literal> を呼"
"び出します"

#. Tag: para
#, no-c-format
msgid ""
"Statistics can be reset programmatically using the <literal>clear()</"
"literal> method. A summary can be sent to a logger (info level) using the "
"<literal>logSummary()</literal> method."
msgstr ""
"統計は <literal>clear()</literal> メソッドを使って手動でリセットすることが出"
"来ます。サマリは <literal>logSummary()</literal> メソッドを使って logger に送"
"ることが出来ます（info レベルです）。"

#. Tag: title
#, no-c-format
msgid "Metrics"
msgstr "メトリクス"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate provides a number of metrics, from basic information to more "
"specialized information that is only relevant in certain scenarios. All "
"available counters are described in the <literal>Statistics</literal> "
"interface API, in three categories:"
msgstr ""
"多くのものがあります。すべての使用可能なカウンタは <literal>Statistics</"
"literal> インターフェースの API に書かれており、3つの分類があります:"

#. Tag: para
#, no-c-format
msgid ""
"Metrics related to the general <literal>Session</literal> usage, such as "
"number of open sessions, retrieved JDBC connections, etc."
msgstr ""
"メトリクスは一般的な <literal>Session</literal> の使い方と関係しています。"
"オープンしたセッションの数が JDBC コネクションと関連しているのと同じです。"

#. Tag: para
#, no-c-format
msgid ""
"Metrics related to the entities, collections, queries, and caches as a whole "
"(aka global metrics)."
msgstr ""
"メトリクスは要素、コレクション、クエリやキャッシュなど全体に関係しています"
"（別名はグローバルメトリクスです）。"

#. Tag: para
#, no-c-format
msgid ""
"Detailed metrics related to a particular entity, collection, query or cache "
"region."
msgstr ""
"メトリクスの詳細は特定のエンティティ、コレクション、クエリ、キャッシュ領域に"
"関係しています。"

#. Tag: para
#, no-c-format
msgid ""
"For example, you can check the cache hit, miss, and put ratio of entities, "
"collections and queries, and the average time a query needs. Be aware that "
"the number of milliseconds is subject to approximation in Java. Hibernate is "
"tied to the JVM precision and on some platforms this might only be accurate "
"to 10 seconds."
msgstr ""
"例として、キャッシュのヒット、ヒットミスや、要素、コレクション、クエリの割"
"合、クエリの実行に必要な平均時間を確認できます。ミリ秒の数値は Java の近似を"
"受けることに注意してください。 Hibernate は JVM の精度に制限され、プラット"
"フォームによっては10秒単位でしか正確でないかもしれません。"

#. Tag: para
#, no-c-format
msgid ""
"Simple getters are used to access the global metrics (i.e. not tied to a "
"particular entity, collection, cache region, etc.). You can access the "
"metrics of a particular entity, collection or cache region through its name, "
"and through its HQL or SQL representation for queries. Please refer to the "
"<literal>Statistics</literal>, <literal>EntityStatistics</literal>, "
"<literal>CollectionStatistics</literal>, "
"<literal>SecondLevelCacheStatistics</literal>, and <literal>QueryStatistics</"
"literal> API Javadoc for more information. The following code is a simple "
"example:"
msgstr ""
"単純な getter はグローバルメトリクス（すなわち特定のエンティティ、コレクショ"
"ン、キャッシュ領域などに縛られない）にアクセスするために使います。特定のエン"
"ティティ、コレクション、キャッシュ領域のメトリクスは、それらの名前や、クエリ"
"の HQL 、 SQL 表現によってアクセスすることが出来ます。さらに詳しい情報は、 "
"<literal>Statistics</literal> 、 <literal>EntityStatistics</literal> 、 "
"<literal>CollectionStatistics</literal> 、 "
"<literal>SecondLevelCacheStatistics</literal> 、 <literal>QueryStatistics</"
"literal> API の javadoc を参照してください。以下のコードは簡単な例です:"

#. Tag: para
#, no-c-format
msgid ""
"You can work on all entities, collections, queries and region caches, by "
"retrieving the list of names of entities, collections, queries and region "
"caches using the following methods: <literal>getQueries()</literal>, "
"<literal>getEntityNames()</literal>, <literal>getCollectionRoleNames()</"
"literal>, and <literal>getSecondLevelCacheRegionNames()</literal>."
msgstr ""
"すべてのエンティティ、コレクション、クエリ、キャッシュ領域に対して行う場合"
"は、 <literal>getQueries()</literal> 、 <literal>getEntityNames()</"
"literal>、 <literal>getCollectionRoleNames()</literal> 、 "
"<literal>getSecondLevelCacheRegionNames()</literal> メソッドでそれぞれの名前"
"のリストを取得することが出来ます。"

#~ msgid ""
#~ "This setting creates two new cache regions: one holding cached query "
#~ "result sets (<literal>org.hibernate.cache.StandardQueryCache</literal>), "
#~ "the other holding timestamps of the most recent updates to queryable "
#~ "tables (<literal>org.hibernate.cache.UpdateTimestampsCache</literal>). "
#~ "Note that the query cache does not cache the state of the actual entities "
#~ "in the result set; it caches only identifier values and results of value "
#~ "type. The query cache should always be used in conjunction with the "
#~ "second-level cache."
#~ msgstr ""
#~ "この設定は新たに二つのキャッシュ領域の作成を行います。一つはクエリのリザル"
#~ "トセットのキャッシュ（ <literal>org.hibernate.cache.StandardQueryCache</"
#~ "literal> ）を保持し、もう1つはクエリ可能なテーブルへの最新の更新タイムスタ"
#~ "ンプ （ <literal>org.hibernate.cache.UpdateTimestampsCache</literal> ）を"
#~ "保持します。クエリキャッシュはリザルトセットの実際の要素の状態はキャッシュ"
#~ "しないことに注意してください。キャッシュするのは識別子の値と、値型の結果の"
#~ "みです。そのため、クエリキャッシュは常に二次キャッシュと一緒に使うべきで"
#~ "す。"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[s = sessions.openSession();\n"
#~ "Transaction tx = s.beginTransaction();\n"
#~ "            \n"
#~ "User u = (User) s.createQuery(\"from User u where u.name=:userName\")\n"
#~ "    .setString(\"userName\", userName).uniqueResult();\n"
#~ "Map permissions = u.getPermissions();\n"
#~ "\n"
#~ "tx.commit();\n"
#~ "s.close();\n"
#~ "\n"
#~ "Integer accessLevel = (Integer) permissions.get(\"accounts\");  // "
#~ "Error!]]>"
#~ msgstr ""
#~ "s = sessions.openSession();\n"
#~ "Transaction tx = s.beginTransaction();\n"
#~ "            \n"
#~ "User u = (User) s.createQuery(\"from User u where u.name=:userName\")\n"
#~ "    .setString(\"userName\", userName).uniqueResult();\n"
#~ "Map permissions = u.getPermissions();\n"
#~ "\n"
#~ "tx.commit();\n"
#~ "s.close();\n"
#~ "\n"
#~ "Integer accessLevel = (Integer) permissions.get(\"accounts\");  // Error!"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<set name=\"permissions\" \n"
#~ "            fetch=\"join\">\n"
#~ "    <key column=\"userId\"/>\n"
#~ "    <one-to-many class=\"Permission\"/>\n"
#~ "</set]]>"
#~ msgstr ""
#~ "&lt;set name=\"permissions\" \n"
#~ "            fetch=\"join\"&gt;\n"
#~ "    &lt;key column=\"userId\"/&gt;\n"
#~ "    &lt;one-to-many class=\"Permission\"/&gt;\n"
#~ "&lt;/set"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<many-to-one name=\"mother\" class=\"Cat\" fetch=\"join\"/>]]>"
#~ msgstr "&lt;many-to-one name=\"mother\" class=\"Cat\" fetch=\"join\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[User user = (User) session.createCriteria(User.class)\n"
#~ "                .setFetchMode(\"permissions\", FetchMode.JOIN)\n"
#~ "                .add( Restrictions.idEq(userId) )\n"
#~ "                .uniqueResult();]]>"
#~ msgstr ""
#~ "User user = (User) session.createCriteria(User.class)\n"
#~ "                .setFetchMode(\"permissions\", FetchMode.JOIN)\n"
#~ "                .add( Restrictions.idEq(userId) )\n"
#~ "                .uniqueResult();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Cat\" proxy=\"Cat\">\n"
#~ "    ......\n"
#~ "    <subclass name=\"DomesticCat\">\n"
#~ "        .....\n"
#~ "    </subclass>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"Cat\" proxy=\"Cat\"&gt;\n"
#~ "    ......\n"
#~ "    &lt;subclass name=\"DomesticCat\"&gt;\n"
#~ "        .....\n"
#~ "    &lt;/subclass&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a "
#~ "proxy (does not hit the db)\n"
#~ "if ( cat.isDomesticCat() ) {                  // hit the db to initialize "
#~ "the proxy\n"
#~ "    DomesticCat dc = (DomesticCat) cat;       // Error!\n"
#~ "    ....\n"
#~ "}]]>"
#~ msgstr ""
#~ "Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy "
#~ "(does not hit the db)\n"
#~ "if ( cat.isDomesticCat() ) {                  // hit the db to initialize "
#~ "the proxy\n"
#~ "    DomesticCat dc = (DomesticCat) cat;       // Error!\n"
#~ "    ....\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Cat cat = (Cat) session.load(Cat.class, id);            // "
#~ "instantiate a Cat proxy\n"
#~ "DomesticCat dc = \n"
#~ "        (DomesticCat) session.load(DomesticCat.class, id);  // acquire "
#~ "new DomesticCat proxy!\n"
#~ "System.out.println(cat==dc);                            // false]]>"
#~ msgstr ""
#~ "Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a "
#~ "Cat proxy\n"
#~ "DomesticCat dc = \n"
#~ "        (DomesticCat) session.load(DomesticCat.class, id);  // acquire "
#~ "new DomesticCat proxy!\n"
#~ "System.out.println(cat==dc);                            // false"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[cat.setWeight(11.0);  // hit the db to initialize the proxy\n"
#~ "System.out.println( dc.getWeight() );  // 11.0]]>"
#~ msgstr ""
#~ "cat.setWeight(11.0);  // hit the db to initialize the proxy\n"
#~ "System.out.println( dc.getWeight() );  // 11.0"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"CatImpl\" proxy=\"Cat\">\n"
#~ "    ......\n"
#~ "    <subclass name=\"DomesticCatImpl\" proxy=\"DomesticCat\">\n"
#~ "        .....\n"
#~ "    </subclass>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"CatImpl\" proxy=\"Cat\"&gt;\n"
#~ "    ......\n"
#~ "    &lt;subclass name=\"DomesticCatImpl\" proxy=\"DomesticCat\"&gt;\n"
#~ "        .....\n"
#~ "    &lt;/subclass&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Cat cat = (Cat) session.load(CatImpl.class, catid);\n"
#~ "Iterator iter = session.createQuery(\"from CatImpl as cat where cat."
#~ "name='fritz'\").iterate();\n"
#~ "Cat fritz = (Cat) iter.next();]]>"
#~ msgstr ""
#~ "Cat cat = (Cat) session.load(CatImpl.class, catid);\n"
#~ "Iterator iter = session.iterate(\"from CatImpl as cat where cat."
#~ "name='fritz'\");\n"
#~ "Cat fritz = (Cat) iter.next();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[( (Integer) s.createFilter( collection, \"select count(*)\" )."
#~ "list().get(0) ).intValue()]]>"
#~ msgstr ""
#~ "( (Integer) s.createFilter( collection, \"select count(*)\" ).list().get"
#~ "(0) ).intValue()"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[s.createFilter( lazyCollection, \"\").setFirstResult(0)."
#~ "setMaxResults(10).list();]]>"
#~ msgstr ""
#~ "s.createFilter( lazyCollection, \"\").setFirstResult(0).setMaxResults(10)."
#~ "list();"

#, fuzzy
#~ msgid "<![CDATA[<class name=\"Person\" batch-size=\"10\">...</class>]]>"
#~ msgstr "&lt;class name=\"Person\" batch-size=\"10\"&gt;...&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Person\">\n"
#~ "    <set name=\"cats\" batch-size=\"3\">\n"
#~ "        ...\n"
#~ "    </set>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"Person\"&gt;\n"
#~ "    &lt;set name=\"cats\" batch-size=\"3\"&gt;\n"
#~ "        ...\n"
#~ "    &lt;/set&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Document\">\n"
#~ "       <id name=\"id\">\n"
#~ "        <generator class=\"native\"/>\n"
#~ "    </id>\n"
#~ "    <property name=\"name\" not-null=\"true\" length=\"50\"/>\n"
#~ "    <property name=\"summary\" not-null=\"true\" length=\"200\" lazy="
#~ "\"true\"/>\n"
#~ "    <property name=\"text\" not-null=\"true\" length=\"2000\" lazy=\"true"
#~ "\"/>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"Document\"&gt;\n"
#~ "       &lt;id name=\"id\"&gt;\n"
#~ "        &lt;generator class=\"native\"/&gt;\n"
#~ "    &lt;/id&gt;\n"
#~ "    &lt;property name=\"name\" not-null=\"true\" length=\"50\"/&gt;\n"
#~ "    &lt;property name=\"summary\" not-null=\"true\" length=\"200\" lazy="
#~ "\"true\"/&gt;\n"
#~ "    &lt;property name=\"text\" not-null=\"true\" length=\"2000\" lazy="
#~ "\"true\"/&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<target name=\"instrument\" depends=\"compile\">\n"
#~ "    <taskdef name=\"instrument\" classname=\"org.hibernate.tool."
#~ "instrument.InstrumentTask\">\n"
#~ "        <classpath path=\"${jar.path}\"/>\n"
#~ "        <classpath path=\"${classes.dir}\"/>\n"
#~ "        <classpath refid=\"lib.class.path\"/>\n"
#~ "    </taskdef>\n"
#~ "\n"
#~ "    <instrument verbose=\"true\">\n"
#~ "        <fileset dir=\"${testclasses.dir}/org/hibernate/auction/model\">\n"
#~ "            <include name=\"*.class\"/>\n"
#~ "        </fileset>\n"
#~ "    </instrument>\n"
#~ "</target>]]>"
#~ msgstr ""
#~ "&lt;target name=\"instrument\" depends=\"compile\"&gt;\n"
#~ "    &lt;taskdef name=\"instrument\" classname=\"org.hibernate.tool."
#~ "instrument.InstrumentTask\"&gt;\n"
#~ "        &lt;classpath path=\"&#36;{jar.path}\"/&gt;\n"
#~ "        &lt;classpath path=\"&#36;{classes.dir}\"/&gt;\n"
#~ "        &lt;classpath refid=\"lib.class.path\"/&gt;\n"
#~ "    &lt;/taskdef&gt;\n"
#~ "\n"
#~ "    &lt;instrument verbose=\"true\"&gt;\n"
#~ "        &lt;fileset dir=\"&#36;{testclasses.dir}/org/hibernate/auction/"
#~ "model\"&gt;\n"
#~ "            &lt;include name=\"*.class\"/&gt;\n"
#~ "        &lt;/fileset&gt;\n"
#~ "    &lt;/instrument&gt;\n"
#~ "&lt;/target&gt;"

#~ msgid "<entry>yes</entry>"
#~ msgstr "<entry>yes</entry>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<cache \n"
#~ "    usage=\"transactional|read-write|nonstrict-read-write|read-only\"\n"
#~ "    region=\"RegionName\"\n"
#~ "    include=\"all|non-lazy\"\n"
#~ "/>]]>"
#~ msgstr ""
#~ "&lt;cache \n"
#~ "    usage=\"transactional|read-write|nonstrict-read-write|read-only\"\n"
#~ "    region=\"RegionName\"\n"
#~ "    include=\"all|non-lazy\"\n"
#~ "/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"eg.Immutable\" mutable=\"false\">\n"
#~ "    <cache usage=\"read-only\"/>\n"
#~ "    ....\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"eg.Immutable\" mutable=\"false\"&gt;\n"
#~ "    &lt;cache usage=\"read-only\"/&gt;\n"
#~ "    ....\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"eg.Cat\" .... >\n"
#~ "    <cache usage=\"read-write\"/>\n"
#~ "    ....\n"
#~ "    <set name=\"kittens\" ... >\n"
#~ "        <cache usage=\"read-write\"/>\n"
#~ "        ....\n"
#~ "    </set>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"eg.Cat\" .... &gt;\n"
#~ "    &lt;cache usage=\"read-write\"/&gt;\n"
#~ "    ....\n"
#~ "    &lt;set name=\"kittens\" ... &gt;\n"
#~ "        &lt;cache usage=\"read-write\"/&gt;\n"
#~ "        ....\n"
#~ "    &lt;/set&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[ScrollableResult cats = sess.createQuery(\"from Cat as cat\")."
#~ "scroll(); //a huge result set\n"
#~ "while ( cats.next() ) {\n"
#~ "    Cat cat = (Cat) cats.get(0);\n"
#~ "    doSomethingWithACat(cat);\n"
#~ "    sess.evict(cat);\n"
#~ "}]]>"
#~ msgstr ""
#~ "ScrollableResult cats = sess.createQuery(\"from Cat as cat\").scroll(); //"
#~ "a huge result set\n"
#~ "while ( cats.next() ) {\n"
#~ "    Cat cat = (Cat) cats.get(0);\n"
#~ "    doSomethingWithACat(cat);\n"
#~ "    sess.evict(cat);\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sessionFactory.evict(Cat.class, catId); //evict a particular "
#~ "Cat\n"
#~ "sessionFactory.evict(Cat.class);  //evict all Cats\n"
#~ "sessionFactory.evictCollection(\"Cat.kittens\", catId); //evict a "
#~ "particular collection of kittens\n"
#~ "sessionFactory.evictCollection(\"Cat.kittens\"); //evict all kitten "
#~ "collections]]>"
#~ msgstr ""
#~ "sessionFactory.evict(Cat.class, catId); //evict a particular Cat\n"
#~ "sessionFactory.evict(Cat.class);  //evict all Cats\n"
#~ "sessionFactory.evictCollection(\"Cat.kittens\", catId); //evict a "
#~ "particular collection of kittens\n"
#~ "sessionFactory.evictCollection(\"Cat.kittens\"); //evict all kitten "
#~ "collections"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Map cacheEntries = sessionFactory.getStatistics()\n"
#~ "        .getSecondLevelCacheStatistics(regionName)\n"
#~ "        .getEntries();]]>"
#~ msgstr ""
#~ "Map cacheEntries = sessionFactory.getStatistics()\n"
#~ "        .getSecondLevelCacheStatistics(regionName)\n"
#~ "        .getEntries();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[hibernate.generate_statistics true\n"
#~ "hibernate.cache.use_structured_entries true]]>"
#~ msgstr ""
#~ "hibernate.generate_statistics true\n"
#~ "hibernate.cache.use_structured_entries true"

#, fuzzy
#~ msgid "<![CDATA[hibernate.cache.use_query_cache true]]>"
#~ msgstr "hibernate.cache.use_query_cache true"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[List blogs = sess.createQuery(\"from Blog blog where blog."
#~ "blogger = :blogger\")\n"
#~ "    .setEntity(\"blogger\", blogger)\n"
#~ "    .setMaxResults(15)\n"
#~ "    .setCacheable(true)\n"
#~ "    .setCacheRegion(\"frontpages\")\n"
#~ "    .list();]]>"
#~ msgstr ""
#~ "List blogs = sess.createQuery(\"from Blog blog where blog.blogger = :"
#~ "blogger\")\n"
#~ "    .setEntity(\"blogger\", blogger)\n"
#~ "    .setMaxResults(15)\n"
#~ "    .setCacheable(true)\n"
#~ "    .setCacheRegion(\"frontpages\")\n"
#~ "    .list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Parent p = (Parent) sess.load(Parent.class, id);\n"
#~ "Child c = new Child();\n"
#~ "c.setParent(p);\n"
#~ "p.getChildren().add(c);  //no need to fetch the collection!\n"
#~ "sess.flush();]]>"
#~ msgstr ""
#~ "Parent p = (Parent) sess.load(Parent.class, id);\n"
#~ "Child c = new Child();\n"
#~ "c.setParent(p);\n"
#~ "p.getChildren().add(c);  //no need to fetch the collection!\n"
#~ "sess.flush();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[// MBean service registration for a specific SessionFactory\n"
#~ "Hashtable tb = new Hashtable();\n"
#~ "tb.put(\"type\", \"statistics\");\n"
#~ "tb.put(\"sessionFactory\", \"myFinancialApp\");\n"
#~ "ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
#~ "\n"
#~ "StatisticsService stats = new StatisticsService(); // MBean "
#~ "implementation\n"
#~ "stats.setSessionFactory(sessionFactory); // Bind the stats to a "
#~ "SessionFactory\n"
#~ "server.registerMBean(stats, on); // Register the Mbean on the server]]>"
#~ msgstr ""
#~ "// MBean service registration for a specific SessionFactory\n"
#~ "Hashtable tb = new Hashtable();\n"
#~ "tb.put(\"type\", \"statistics\");\n"
#~ "tb.put(\"sessionFactory\", \"myFinancialApp\");\n"
#~ "ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
#~ "\n"
#~ "StatisticsService stats = new StatisticsService(); // MBean "
#~ "implementation\n"
#~ "stats.setSessionFactory(sessionFactory); // Bind the stats to a "
#~ "SessionFactory\n"
#~ "server.registerMBean(stats, on); // Register the Mbean on the server"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[// MBean service registration for all SessionFactory's\n"
#~ "Hashtable tb = new Hashtable();\n"
#~ "tb.put(\"type\", \"statistics\");\n"
#~ "tb.put(\"sessionFactory\", \"all\");\n"
#~ "ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
#~ "\n"
#~ "StatisticsService stats = new StatisticsService(); // MBean "
#~ "implementation\n"
#~ "server.registerMBean(stats, on); // Register the MBean on the server]]>"
#~ msgstr ""
#~ "// MBean service registration for all SessionFactory's\n"
#~ "Hashtable tb = new Hashtable();\n"
#~ "tb.put(\"type\", \"statistics\");\n"
#~ "tb.put(\"sessionFactory\", \"all\");\n"
#~ "ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
#~ "\n"
#~ "StatisticsService stats = new StatisticsService(); // MBean "
#~ "implementation\n"
#~ "server.registerMBean(stats, on); // Register the MBean on the server"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Statistics stats = HibernateUtil.sessionFactory.getStatistics"
#~ "();\n"
#~ "\n"
#~ "double queryCacheHitCount  = stats.getQueryCacheHitCount();\n"
#~ "double queryCacheMissCount = stats.getQueryCacheMissCount();\n"
#~ "double queryCacheHitRatio =\n"
#~ "  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);\n"
#~ "\n"
#~ "log.info(\"Query Hit ratio:\" + queryCacheHitRatio);\n"
#~ "\n"
#~ "EntityStatistics entityStats =\n"
#~ "  stats.getEntityStatistics( Cat.class.getName() );\n"
#~ "long changes =\n"
#~ "        entityStats.getInsertCount()\n"
#~ "        + entityStats.getUpdateCount()\n"
#~ "        + entityStats.getDeleteCount();\n"
#~ "log.info(Cat.class.getName() + \" changed \" + changes + \"times\"  );]]>"
#~ msgstr ""
#~ "Statistics stats = HibernateUtil.sessionFactory.getStatistics();\n"
#~ "\n"
#~ "double queryCacheHitCount  = stats.getQueryCacheHitCount();\n"
#~ "double queryCacheMissCount = stats.getQueryCacheMissCount();\n"
#~ "double queryCacheHitRatio =\n"
#~ "  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);\n"
#~ "\n"
#~ "log.info(\"Query Hit ratio:\" + queryCacheHitRatio);\n"
#~ "\n"
#~ "EntityStatistics entityStats =\n"
#~ "  stats.getEntityStatistics( Cat.class.getName() );\n"
#~ "long changes =\n"
#~ "        entityStats.getInsertCount()\n"
#~ "        + entityStats.getUpdateCount()\n"
#~ "        + entityStats.getDeleteCount();\n"
#~ "log.info(Cat.class.getName() + \" changed \" + changes + \"times\"  );"
