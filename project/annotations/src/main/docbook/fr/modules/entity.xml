<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="entity">
  <title>Entity Beans</title>

  <sect1 id="entity-overview" revision="1">
    <title>Introduction</title>

    <para>Cette section couvre les annotations entity bean EJB 3.0 (alias JPA)
    et les extensions spécifiques à Hibernate.</para>
  </sect1>

  <sect1 id="entity-mapping" revision="2">
    <title>Mapping avec les annotations EJB3/JPA</title>

    <para>Les entités EJB3 sont des POJOs ordinaires. En fait, ils
    représentent exactement le même concept que les entités de persistance
    Hibernate. Leur mapping est défini à travers les annotations du JDK 5.0
    (une syntaxe de descripteur XML pour la surcharge est définie dans la
    spécification EJB3). Les annotations peuvent être divisées en deux
    catégories, les annotations de mapping logique (vous permettant de décrire
    le modèle objet, les associations de classe, etc) et les annotations de
    mapping physique (décrivant le schéma physique, les tables, les colonnes,
    les index, etc). Nous mélangerons les annotations des deux catégories dans
    les exemples de code.</para>

    <para>Les annotations EJB3 sont dans le package
    <literal>javax.persistence.*</literal>. La plupart des IDE compatibles JDK 5
    (comme Eclipse, IntelliJ IDEA et Netbeans) peuvent auto-compléter les
    interfaces et les attributes d'annotation pour vous (même sans module "EJB3"
    spécifique, puisque les annotations EJB3 sont des annotations ordinaires de
    JDK 5).</para>

    <para>Pour plus d'exemples concrets, lisez le tutorial EJB 3.0 de JBoss ou
    parcourez la suite de tests d'Hibernate Annotations. La plupart des tests
    unitaires ont été conçus pour représenter un exemple concret et être une
    source d'inspiration.</para>

    <sect2>
      <title>Déclarer un entity bean</title>

      <para>Chaque classe POJO persistante liée est un entity bean et est
      déclarée en utilisant l'annotation <literal>@Entity</literal> (au niveau
      de la classe) :</para>

      <programlisting>
@Entity
public class Flight implements Serializable {
    Long id;

    @Id
    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }
}
</programlisting>

      <para><literal>@Entity</literal> déclare la classe comme un entity bean
      (ie une classe POJO persistante), <literal>@Id</literal> déclare la
      propriété identifiante de cet entity bean. Les autres déclarations de
      mapping sont implicites. Ce concept de déclaration par exception est
      un composant essentiel de la nouvelle spécification EJB3 et une
      amélioration majeure. La classe Flight est mappée sur la table Flight, en
      utilisant la colonne id comme colonne de la clef primaire.</para>

      <para>Selon que vous annotez des champs ou des méthodes, le type d'accès
      utilisé par Hibernate sera <literal>field</literal> ou
      <literal>property</literal>. La spécification EJB3 exige que vous
      déclariez les annotations sur le type d'élément qui sera accédé,
      c'est-à-dire le getter si vous utilisez l'accès
      <literal>property</literal>, le champ si vous utilisez l'accès
      <literal>field</literal>. Mélanger des EJB3 annotations dans les champs et
      les méthodes devrait être évité. Hibernate devinera le type d'accès de
      l'identifiant à partir de la position d'<literal>@Id</literal> ou
      d'<literal>@EmbeddedId</literal>.</para>

      <sect3>
        <title>Définir la table</title>

        <para><literal>@Table</literal> est positionnée au niveau de la classe ;
        cela vous permet de définir le nom de la table, du catalogue et du
        schéma pour le mapping de votre entity bean. Si aucune
        <literal>@Table</literal> n'est définie les valeurs par défaut sont
        utilisées : le nom de la classe de l'entité (sans le nom de
        package).</para>

        <programlisting>
@Entity
@Table(name="tbl_sky")
public class Sky implements Serializable {
...
            </programlisting>

        <para>L'élément <literal>@Table</literal> contient aussi un attribut
        <literal>schema</literal> et un attribut <literal>catalog</literal>,
        si vous avez besoin de les définir. Vous pouvez aussi définir des
        contraintes d'unicité sur la table en utilisant l'annotation
        <literal>@UniqueConstraint</literal> en conjonction avec
        <literal>@Table</literal> (pour une contrainte d'unicité n'impliquant
        qu'une seule colonne, référez-vous à <literal>@Column</literal>).</para>

        <programlisting>@Table(name="tbl_sky",
    <emphasis role="bold">uniqueConstraints = {@UniqueConstraint(columnNames={"month", "day"})}</emphasis>
)</programlisting>

        <para>Une contrainte d'unicité est appliquée au tuple {month, day}.
        Notez que le tableau <literal>columnNames</literal> fait référence aux
        noms logiques des colonnes.</para>

        <remark>Le nom logique d'une colonne est défini par l'implémentation
        de NamingStrategy d'Hibernate. La stratégie de nommage EJB3 par défaut
        utilise le nom de colonne physique comme nom de colonne logique. Notez
        qu'il peut être différent du nom de la propriété (si le nom de colonne
        est explicite). A moins que vous surchargiez la stratégie de nommage,
        vous ne devriez pas vous soucier de ça.</remark>
      </sect3>

      <sect3>
        <title>Versionner pour un contrôle de concurrence optimiste</title>

        <para>Vous pouvez ajouter un contrôle de concurrence optimiste à un
        entity bean en utilisant l'annotation
        <literal>@Version</literal> :</para>

        <programlisting>
@Entity
public class Flight implements Serializable {
...
    @Version
    @Column(name="OPTLOCK")
    public Integer getVersion() { ... }
}           </programlisting>

        <para>La propriété de version sera mappée sur la colonne
        <literal>OPTLOCK</literal>, et le gestionnaire d'entités l'utilisera
        pour détecter des conflits lors des mises à jour (prévenant des pertes
        de données lors de mises à jours que vous pourriez voir avec la
        stratégie du last-commit-wins).</para>

        <para>La colonne de version peut être un numérique (solution
        recommandée) ou un timestamp comme pour la spécification EJB3. Hibernate
        prend en charge n'importe quel type fourni que vous définissez et
        implémentez avec la classe <classname>UserVersionType</classname>
        appropriée.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Mapping de simples propriétés</title>

      <sect3>
        <title>Déclarer des mappings de propriétés élémentaires</title>

        <para>Chaque propriété (champ ou méthode) non statique non transient
        d'un entity bean est considérée persistante, à moins que vous l'annotiez
        comme <literal>@Transient</literal>. Ne pas avoir d'annotation pour
        votre propriété est équivalent à l'annotation <literal>@Basic</literal>.
        L'annotation <literal>@Basic</literal> vous permet de déclarer la
        stratégie de récupération pour une propriété :</para>

        <programlisting>public transient int counter; // propriété transient

private String firstname; // propriété persistante

@Transient
String getLengthInMeter() { ... } // propriété transient

String getName() {... } // propriété persistante

@Basic
int getLength() { ... } // propriété persistante

@Basic(fetch = FetchType.LAZY)
String getDetailedComment() { ... } // propriété persistante

@Temporal(TemporalType.TIME)
java.util.Date getDepartureTime() { ... } // propriété persistante

@Enumerated(EnumType.STRING)
Starred getNote() { ... } // enum persistée en tant que String dans la base de données</programlisting>

        <para><literal>counter</literal>, un champ transient, et
        <literal>lengthInMeter</literal>, une méthode annotée comme
        <literal>@Transient</literal>, seront ignorés par le gestionnaire
        d'entités. Les propriétés <literal>name</literal>,
        <literal>length</literal>, et <literal>firstname</literal> sont mappées
        comme persistantes et à charger immédiatement (ce sont les valeurs
        par défaut pour les propriétés simples). La valeur de la propriété
        <literal>detailedComment</literal> sera chargée à partir de la base de
        données dès que la propriété de l'entité sera accédée pour la première
        fois. En général vous n'avez pas besoin de marquer de simples propriétés
        comme "à charger à la demande" (NdT: lazy) (à ne pas confondre avec la
        récupération d'association "lazy").</para>

        <note>
          <para>Pour activer la récupération à la demande au niveau de la
          propriété, vos classes doivent être instrumentées : du bytecode est
          ajouté au code original pour activer cette fonctionnalité, veuillez
          vous référer à la documentation de référence d'Hibernate. Si vos
          classes ne sont pas instrumentées, le chargement à la demande au
          niveau de la propriété est silencieusement ignoré.</para>
        </note>

        <para>L'alternative recommandée est d'utiliser la capacité de projection
        de JPA-QL ou des requêtes Criteria.</para>

        <para>EJB3 prend en charge le mapping de propriété de tous les types
        élémentaires pris en charge par Hibernate (tous les types de base Java,
        leur wrapper respectif et les classes sérialisables). Hibernate
        Annotations prend en charge le mapping des types Enum soit vers une
        colonne ordinale (en stockant le numéro ordinal de l'enum), soit vers
        une colonne de type chaîne de caractères (en stockant la chaîne de
        caractères représentant l'enum) : la représentation de la persistance,
        par défaut ordinale, peut être surchargée grâce à l'annotation
        <literal>@Enumerated</literal> comme montré avec la propriété
        <literal>note</literal> de l'exemple.</para>

        <para>Dans les APIs core de Java, la précision temporelle n'est pas
        définie. Lors du traitement de données temporelles vous pourriez vouloir
        décrire la précision attendue dans la base de données. Les données
        temporelles peuvent avoir une précision de type <literal>DATE</literal>,
        <literal>TIME</literal>, ou <literal>TIMESTAMP</literal> (c'est-à-dire
        seulement la date, seulement l'heure, ou les deux). Utilisez
        l'annotation <literal>@Temporal</literal> pour ajuster cela.</para>

        <para><literal>@Lob</literal> indique que la propriété devrait être
        persistée dans un Blob ou un Clob selon son type :
        <classname>java.sql.Clob</classname>,
        <classname>Character[]</classname>, <classname>char[]</classname> et
        java.lang.<classname>String</classname> seront persistés dans un Clob.
        <classname>java.sql.Blob</classname>, <classname>Byte[]</classname>,
        <classname>byte[] </classname> et les types sérialisables seront
        persistés dans un Blob.</para>

        <programlisting>
@Lob
public String getFullText() {
    return fullText;
}

@Lob
public byte[] getFullCode() {
    return fullCode;
}
 </programlisting>

        <para>Si le type de la propriété implémente
        <classname>java.io.Serializable</classname> et n'est pas un type de
        base, et si la propriété n'est pas annotée avec <literal>@Lob</literal>,
        alors le type Hibernate <literal>serializable</literal> est
        utilisé.</para>
      </sect3>

      <sect3>
        <title>Déclarer des attributs de colonne</title>

        <para>La(les) colonne(s) utilisée(s) pour mapper une propriété peuvent
        être définies en utilisant l'annotation <literal>@Column</literal>.
        Utilisez-la pour surcharger les valeurs par défaut (voir la
        spécification EJB3 pour plus d'informations sur les valeurs par défaut).
        Vous pouvez utilisez cette annotation au niveau de la propriété pour
        celles qui sont :</para>

        <itemizedlist>
          <listitem>
            <para>pas du tout annotées</para>
          </listitem>

          <listitem>
            <para>annotées avec <literal>@Basic</literal></para>
          </listitem>

          <listitem>
            <para>annotées avec <literal>@Version</literal></para>
          </listitem>

          <listitem>
            <para>annotées avec <literal>@Lob</literal></para>
          </listitem>

          <listitem>
            <para>annotées avec <literal>@Temporal</literal></para>
          </listitem>

          <listitem>
            <para>annotées avec
            <literal>@org.hibernate.annotations.CollectionOfElements</literal>
            (pour Hibernate uniquement)</para>
          </listitem>
        </itemizedlist>

        <programlisting>
@Entity
public class Flight implements Serializable {
...
@Column(updatable = false, name = "flight_name", nullable = false, length=50)
public String getName() { ... }
            </programlisting>

        <para>La propriété <literal>name</literal> est mappée sur la colonne
        <literal>flight_name</literal>, laquelle ne peut pas avoir de valeur
        nulle, a une longueur de 50 et ne peut pas être mise à jour (rendant
        la propriété immuable).</para>

        <para>Cette annotation peut être appliquée aux propriétés habituelles
        ainsi qu'aux propriétés <literal>@Id</literal> ou
        <literal>@Version</literal>.</para>

        <programlistingco>
          <areaspec>
            <area coords="2" id="hm1" />

            <area coords="3" id="hm2" />

            <area coords="4" id="hm3" />

            <area coords="5" id="hm4" />

            <area coords="6" id="hm5" />

            <area coords="7" id="hm6" />

            <area coords="8" id="hm7" />

            <area coords="9" id="hm8" />

            <area coords="10" id="hm9" />

            <area coords="11" id="hm10" />
          </areaspec>

          <programlisting>@Column(
    name="columnName";
    boolean unique() default false;
    boolean nullable() default true;
    boolean insertable() default true;
    boolean updatable() default true;
    String columnDefinition() default "";
    String table() default "";
    int length() default 255;
    int precision() default 0; // decimal precision
    int scale() default 0; // decimal scale</programlisting>

          <calloutlist>
            <callout arearefs="hm1">
              <para><literal>name</literal> (optionnel) : le nom de la colonne
              (par défaut le nom de la propriété)</para>
            </callout>

            <callout arearefs="hm2">
              <para><literal>unique</literal> (optionnel) : indique si la colonne
              fait partie d'une contrainte d'unicité ou non (par défaut
              false)</para>
            </callout>

            <callout arearefs="hm3">
              <para><literal>nullable</literal> (optionnel) : indique si la
              colonne peut avoir une valeur nulle (par défaut false).</para>
            </callout>

            <callout arearefs="hm4">
              <para><literal>insertable</literal> (optionnel) : indique si la
              colonne fera partie de la commande insert (par défaut true)</para>
            </callout>

            <callout arearefs="hm5">
              <para><literal>updatable</literal> (optionnel) : indique si la
              colonne fera partie de la commande update (par défaut true)</para>
            </callout>

            <callout arearefs="hm6">
              <para><literal>columnDefinition</literal> (optionnel) : surcharge
              le fragment DDL sql pour cette colonne en particulier (non
              portable)</para>
            </callout>

            <callout arearefs="hm7">
              <para><literal>table</literal> (optionnel) : définit la table
              cible (par défaut la table principale)</para>
            </callout>

            <callout arearefs="hm8">
              <para><literal><literal>length</literal></literal> (optionnel) :
              longueur de la colonne (par défaut 255)</para>
            </callout>

            <callout arearefs="hm8">
              <para><literal><literal>precision</literal></literal>
              (optionnel) : précision décimale de la colonne (par défaut
              0)</para>
            </callout>

            <callout arearefs="hm10">
              <para><literal><literal>scale</literal></literal> (optionnel) :
              échelle décimale de la colonne si nécessaire (par défaut 0)</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </sect3>

      <sect3>
        <title>Objets embarqués (alias composants)</title>

        <para>Il est possible de déclarer un composant embarqué à l'intérieur
        d'une entité et même de surcharger le mapping de ses colonnes. Les
        classes de composant doivent être annotées au niveau de la classe avec
        l'annotation <literal>@Embeddable</literal>. Il est possible de
        surcharger le mapping de colonne d'un objet embarqué pour une entité
        particulière en utilisant les annotations
        <literal>@Embedded</literal> et <literal>@AttributeOverride</literal>
        sur la propriété associée :</para>

        <programlisting>
@Entity
public class Person implements Serializable {

    // Composant persistant utilisant les valeurs par défaut
    Address homeAddress;

    @Embedded
    @AttributeOverrides( {
            @AttributeOverride(name="iso2", column = @Column(name="bornIso2") ),
            @AttributeOverride(name="name", column = @Column(name="bornCountryName") )
    } )
    Country bornIn;
    ...
}
            </programlisting>

        <programlisting>
@Embeddable
public class Address implements Serializable {
    String city;
    Country nationality; // par de surcharge ici
}
            </programlisting>

        <programlisting>
@Embeddable
public class Country implements Serializable {
    private String iso2;
    @Column(name="countryName") private String name;

    public String getIso2() { return iso2; }
    public void setIso2(String iso2) { this.iso2 = iso2; }


    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    ...
}
            </programlisting>

        <para>Un objet embarquable hérite du type d'accès de son entité
        d'appartenance (notez que vous pouvez surcharger cela en utilisant les
        annotations spécifiques à Hibernate <literal>@AccessType</literal>,
        voir <xref linkend="entity-hibspec" />).</para>

        <para>L'entity bean <literal>Person</literal> a deux propriétés
        composant, <literal>homeAddress</literal> et
        <literal>bornIn</literal>. La propriété <literal>homeAddress</literal>
        n'a pas été annotée, mais Hibernate devinera que c'est un composant
        persistant en cherchant l'annotation <literal>@Embeddable</literal>
        dans la classe Address. Nous surchargeons aussi le mapping d'un nom de
        colonne (pour <literal>bornCountryName</literal>) avec les annotations
        <literal>@Embedded</literal> et <literal>@AttributeOverride</literal>
        pour chaque attribut mappé de <literal>Country</literal>. Comme vous
        pouvez le voir, <literal>Country</literal> est aussi un composant
        imbriqué de <literal>Address</literal>, utilisant de nouveau la
        détection automatique d'Hibernate et les valeurs par défaut EJB3.
        Surcharger des colonnes d'objets embarqués d'objets (eux-mêmes)
        embarqués n'est actuellement pas pris en charge par la spécification
        EJB3, cependant, Hibernate Annotations le prend en charge à travers des
        expressions séparées par des points.</para>

        <para><programlisting>    @Embedded
    @AttributeOverrides( {
            @AttributeOverride(name="city", column = @Column(name="fld_city") ),
            @AttributeOverride(name="<emphasis role="bold">nationality.iso2</emphasis>", column = @Column(name="nat_Iso2") ),
            @AttributeOverride(name="<emphasis role="bold">nationality.name</emphasis>", column = @Column(name="nat_CountryName") )
            // les colonnes de nationality dans homeAddress sont surchargées
    } )
    Address homeAddress;</programlisting>Hibernate Annotations prend en charge
        une fonctionnalité de plus qui n'est pas explicitement prise en charge
        par la spécification EJB3. Vous pouvez annoter un objet embarqué avec
        l'annotation
        <literal>@MappedSuperclass</literal> pour rendre les propriétés de la
        classe parente persistantes (voir <literal>@MappedSuperclass</literal>
        pour plus d'informations).</para>

        <para>Alors que ce n'est pas pris en charge par la spécification EJB3,
        Hibernate Annotations vous permet d'utiliser les annotations
        d'association dans un objet embarquable (ie <literal>@*ToOne</literal>
        ou <literal>@*ToMany</literal>). Pour surcharger les colonnes de
        l'association vous pouvez utiliser
        <literal>@AssociationOverride</literal>.</para>

        <para>Si vous voulez avoir le même type d'objet embarquable deux fois
        dans la même entité, le nom de colonne par défaut ne fonctionnera pas :
        au moins une des colonnes devra être explicitée. Hibernate va au-delà
        de la spécification EJB3 et vous permet d'améliorer le mécanisme par
        défaut avec <classname>NamingStrategy</classname>.
        <classname>DefaultComponentSafeNamingStrategy</classname> est une petite
        amélioration par rapport à la stratégie par défaut
        <classname>EJB3NamingStrategy</classname> qui permet aux objets
        embarqués de fonctionner avec leur valeur par défaut même s'ils sont
        utilisés deux fois dans la même entité.</para>
      </sect3>

      <sect3>
        <title>Valeurs par défaut des propriétés non annotées</title>

        <para>Si une propriété n'est pas annotée, les règles suivantes
        s'appliquent :</para>

        <itemizedlist>
          <listitem>
            Si la propriété est de type simple, elle est mappée comme @Basic
          </listitem>

          <listitem>
            Sinon, si le type de la propriété est annoté comme @Embeddable,
            elle est mappée comme @Embedded
          </listitem>

          <listitem>
            Sinon, si le type de la propriété est Serializable, elle est mappée
            comme @Basic vers une colonne contenant l'objet sous sa forme
            sérialisée
          </listitem>

          <listitem>
              Sinon, si le type de la propriété est java.sql.Clob ou
              java.sql.Blob, elle est mappée comme @Lob avec le LobType
              approprié
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>

    <sect2 id="entity-mapping-identifier"
           xreflabel="Mapper des propriétés identifiantes">
      <title>Mapper des propriétés identifiantes</title>

      <para>L'annotation <literal>@Id</literal> vous permet de définir quelle
      propriété identifie votre entity bean. Cette propriété peut être
      positionnée par l'application elle-même ou générée par Hibernate
      (préféré). Vous pouvez définir la stratégie de génération de l'identifiant
      grâce à l'annotation <literal>@GeneratedValue</literal> :</para>

      <itemizedlist>
        <listitem>
           AUTO - soit la colonne identity, soit la séquence, soit la table
           selon la base de données sous-jacente
        </listitem>

        <listitem>
           TABLE - table contenant l'id
        </listitem>

        <listitem>
           IDENTITY - colonne identity
        </listitem>

        <listitem>
           SEQUENCE - séquence
        </listitem>
      </itemizedlist>

      <para>Hibernate fournit plus de générateurs d'identifiant que les simples
      générateurs EJB3. Vérifiez <xref linkend="entity-hibspec" /> pour plus
      d'informations.</para>

      <para>L'exemple suivant montre un générateur par séquence utilisant la
      configuration SEQ_STORE (voir plus bas) :</para>

      <programlisting>
@Id @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="SEQ_STORE")
public Integer getId() { ... }
         </programlisting>

      <para>L'exemple suivant utilise le générateur identity :</para>

      <programlisting>
@Id @GeneratedValue(strategy=GenerationType.IDENTITY)
public Long getId() { ... }
         </programlisting>

      <para>Le générateur <literal>AUTO</literal> est le type préféré pour les
      applications portables (vers différentes base de données). La
      configuration de la génération d'identifiant peut être partagée par
      différents mappings <literal>@Id</literal> avec l'attribut du générateur.
      Il y a différentes configurations disponibles avec
      <literal>@SequenceGenerator</literal> et
      <literal>@TableGenerator</literal>. La portée d'un générateur peut être
      l'application ou la classe. Les générateurs définis dans les classes ne
      sont pas visibles à l'extérieur de la classe et peuvent surcharger les
      générateurs de niveau applicatif. Les générateurs de niveau applicatif
      sont définis au niveau XML (voir
      <xref linkend="xml-overriding" />) :</para>

      <programlisting>&lt;table-generator name="EMP_GEN"
            table="GENERATOR_TABLE"
            pk-column-name="key"
            value-column-name="hi"
            pk-column-value="EMP"
            allocation-size="20"/&gt;

// et l'annotation équivalente

@javax.persistence.TableGenerator(
    name="EMP_GEN",
    table="GENERATOR_TABLE",
    pkColumnName = "key",
    valueColumnName = "hi"
    pkColumnValue="EMP",
    allocationSize=20
)

&lt;sequence-generator name="SEQ_GEN"
    sequence-name="my_sequence"
    allocation-size="20"/&gt;

// et l'annotation équivalente

@javax.persistence.SequenceGenerator(
    name="SEQ_GEN",
    sequenceName="my_sequence",
    allocationSize=20
)
         </programlisting>

      <para>Si JPA XML (comme <filename>META-INF/orm.xml</filename>) est utilisé
      pour définir les générateurs, <literal>EMP_GEN</literal> et
      <literal>SEQ_GEN</literal> sont des générateurs de niveau applicatif.
      <literal>EMP_GEN</literal> définit un générateur d'identifiant basé sur
      une table utilisant l'algorithme hilo avec un <literal>max_lo</literal> de
      20. La valeur haute est conservée dans une <literal>table</literal>
      "<literal>GENERATOR_TABLE</literal>". L'information est gardée dans une
      ligne où la colonne <literal>pkColumnName</literal> ("clef") est égale à
      <literal>pkColumnValue</literal> "<literal>EMP</literal>" et une colonne
      <literal>valueColumnName</literal> "<literal>hi</literal>" contient la
      prochaine valeur haute utilisée.</para>

      <para><literal>SEQ_GEN</literal> définit un générateur par séquence
      utilisant une séquence nommée <literal>my_sequence</literal>. La taille
      d'allocation utilisée pour cet algorithme hilo basé sur une séquence est
      20. Notez que cette version d'Hibernate Annotations ne gère pas
      <literal>initialValue</literal> dans le générateur par séquence.
      La taille par défaut de l'allocation est 50, donc si vous voulez utiliser
      une séquence et récupérer la valeur chaque fois, vous devez positionner
      la taille de l'allocation à 1.</para>

      <note>
        <para>La définition au niveau package n'est plus prise en charge par la
        spécification EJB 3.0. Vous pouvez cependant utiliser
        <literal>@GenericGenerator</literal> au niveau du package (voir <xref
        linkend="entity-hibspec-identifier" />).</para>
      </note>

      <para>Le prochain exemple montre la définition d'un générateur par
      séquence dans la portée d'une classe :</para>

      <programlisting>
@Entity
@javax.persistence.SequenceGenerator(
    name="SEQ_STORE",
    sequenceName="my_sequence"
)
public class Store implements Serializable {
    private Long id;

    @Id @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="SEQ_STORE")
    public Long getId() { return id; }
}
         </programlisting>

      <para>Cette classe utilisera une séquence nommée my_sequence et le
      générateur SEQ_STORE n'est pas visible dans les autres classes. Notez que
      vous pouvez regarder les tests unitaires d'Hibernate Annotations dans le
      package org.hibernate.test.metadata.id pour plus d'exemples.</para>

      <para>Vous pouvez définir une clef primaire composée à travers différentes
      syntaxes :</para>

      <itemizedlist>
        <listitem>
           annote la propriété du composant comme @Id et rend la classe du
           composant @Embeddable
        </listitem>

        <listitem>
           annote la propriété du composant comme @EmbeddedId
        </listitem>

        <listitem>
           annote la classe comme @IdClass et annote chaque propriété de
           l'entité impliquée dans la clef primaire avec @Id
        </listitem>
      </itemizedlist>

      <para>Bien qu'assez commun pour le développeur EJB2,
      <literal>@IdClass</literal> est probablement nouveau pour les utilisateurs
      d'Hibernate. La classe de la clef primaire composée correspond aux
      multiples champs ou propriétés de l'entité ; de plus, les noms des champs
      ou propriétés de la clef primaire et ceux de l'entité doivent
      correspondre ; et enfin, leur type doit être le même. Regardons un
      exemple :</para>

      <programlisting>@Entity
<emphasis role="bold">@IdClass(FootballerPk.class)</emphasis>
public class Footballer {
    // partie de la clef
    <emphasis role="bold">@Id</emphasis> public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    // partie de la clef
    <emphasis role="bold">@Id</emphasis> public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }

    public String getClub() {
        return club;
    }

    public void setClub(String club) {
        this.club = club;
    }

    // implémentation appropriée de equals() et hashCode()
}

@Embeddable
public class FootballerPk implements Serializable {
    // même nom et même type que dans Footballer
    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    // même nom et même type que dans Footballer
    public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }

    // implémentation appropriée de equals() et hashCode()
}
</programlisting>

      <para>Comme vous pouvez le voir, <literal>@IdClass</literal> pointe vers
      la classe de la clef primaire correspondante.</para>

      <para>Bien que ce ne soit pas pris en charge par la spécification EJB3,
      Hibernate vous permet de définir des associations à l'intérieur d'un
      identifiant composé. Pour cela, utilisez simplement les annotations
      habituelles.</para>

      <programlisting>@Entity
@AssociationOverride( name="id.channel", joinColumns = @JoinColumn(name="chan_id") )
public class TvMagazin {
    @EmbeddedId public TvMagazinPk id;
    @Temporal(TemporalType.TIME) Date time;
}

@Embeddable
public class TvMagazinPk implements Serializable {
    @ManyToOne
    public Channel channel;
    public String name;
    @ManyToOne
    public Presenter presenter;
}
</programlisting>
    </sect2>

    <sect2>
      <title>Mapper l'héritage</title>

      <para>EJB3 prend en charge les trois types d'héritage :</para>

      <itemizedlist>
        <listitem>
           Stratégie d'une table par classe concrète : l'élément
           &lt;union-class&gt; dans Hibernate
        </listitem>

        <listitem>
            Stratégie d'une seule table par hiérarchie de classe : l'élément
            &lt;subclass&gt; dans Hibernate
        </listitem>

        <listitem>
           Stratégie d'une table par classe fille : l'élément
           &lt;joined-subclass&gt; dans Hibernate
        </listitem>
      </itemizedlist>

      <para>La stratégie choisie est déclarée au niveau de la classe de l'entité
      la plus haute dans la hiérarhie en utilisant l'annotation
      <literal>@Inheritance</literal>.</para>

      <note>
        <para>Annoter des interfaces n'est pour le moment pas pris en
        charge.</para>
      </note>

      <sect3>
        <title>Une table par classe concrète</title>

        <para>Cette stratégie a beaucoup d'inconvénients (surtout avec les
        requêtes polymorphiques et les associations) expliqués dans la
        spécification EJB3, la documentation de référence d'Hibernate, Hibernate
        in Action, et plusieurs autres endroits. Hibernate en contourne la
        plupart en implémentant cette stratégie en utilisant des requêtes
        <literal>SQL UNION</literal>. Elle est habituellement utilisée pour le
        niveau le plus haut d'une hiérarchie d'héritage :</para>

        <programlisting>
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public class Flight implements Serializable {
            </programlisting>

        <para>Cette stratégie prend en charge les associations de un vers
        plusieurs bidirectionnelles. Cette stratégie ne prend pas en charge
        la stratégie de générateur <literal>IDENTITY</literal> : l'identifiant
        doit être partagé par plusieurs tables. Par conséquent, lors de
        l'utilisation de cette stratégie, vous ne devriez pas utilisez
        <literal>AUTO</literal> ni <literal>IDENTITY</literal>.</para>
      </sect3>

      <sect3>
        <title>Une seule table par hiérarchie de classe</title>

        <para>Toutes les propriétés de toutes les classes parentes et classes
        filles sont mappées dans la même table, les instances sont différenciées
        par une colonne spéciale discriminante :</para>

        <programlisting>
@Entity
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(
    name="planetype",
    discriminatorType=DiscriminatorType.STRING
)
@DiscriminatorValue("Plane")
public class Plane { ... }

@Entity
@DiscriminatorValue("A320")
public class A320 extends Plane { ... }
            </programlisting>

        <para><classname>Plane</classname> est la classe parente, elle définit
        la stratégie d'héritage <literal>InheritanceType.SINGLE_TABLE</literal>.
        Elle définit aussi la colonne discriminante avec l'annotation
        <literal>@DiscriminatorColumn</literal>, une colonne discriminante peut
        aussi définir le type du discriminant. Finalement, l'annotation
        <literal>@DiscriminatorValue</literal> définit la valeur utilisée pour
        différencier une classe dans la hiérarchie. Tous ces attributs ont des
        valeurs par défaut sensées. Le nom par défaut de la colonne
        discriminante est <literal>DTYPE</literal>. La valeur discriminante par
        défaut est le nom de l'entité (comme défini dans
        <literal>@Entity.name</literal>) avec le type
        <literal>DiscriminatorType.STRING</literal>. <classname>A320</classname>
        est une classe fille ; vous devez seulement définir la valeur
        discriminante si vous ne voulez pas utiliser la valeur par défaut. La
        stratégie et le type du discriminant sont implicites.</para>

        <para><literal>@Inheritance</literal> et
        <literal>@DiscriminatorColumn</literal> devraient seulement être
        définies sur l'entité la plus haute de la hiérarchie.</para>
      </sect3>

      <sect3>
        <title>Une table par classe fille</title>

        <para>Les annotations <literal> @PrimaryKeyJoinColumn</literal> et
        <literal>@PrimaryKeyJoinColumns</literal> définissent la (les) clef(s)
        primaire(s) de la table de la classe fille jointe :</para>

        <programlisting>
@Entity
@Inheritance(strategy=InheritanceType.JOINED)
public class Boat implements Serializable { ... }

@Entity
public class Ferry extends Boat { ... }

@Entity
@PrimaryKeyJoinColumn(name="BOAT_ID")
public class AmericaCupClass  extends Boat { ... }
            </programlisting>

        <para>Toutes les entités ci-dessus utilisent la stratégie
        <literal>JOINED</literal>, la table <literal>Ferry</literal> est jointe
        avec la table <literal>Boat</literal> en utilisant les mêmes noms de
        clef primaire. La table <literal>AmericaCupClass</literal> est jointe
        avec <literal>Boat</literal> en utilisant la condition de jointure
        <code>Boat.id = AmericaCupClass.BOAT_ID</code>.</para>
      </sect3>

      <sect3>
        <title>Héritage de propriétés des classes parentes</title>

        <para>Il est parfois utile de partager des propriétés communes à travers
        une classe technique ou métier sans l'inclure comme une entité
        habituelle (c'est-à-dire aucune table spécifique pour cette entité).
        Pour cela, vous pouvez les mapper comme
        <literal>@MappedSuperclass</literal>.</para>

        <programlisting>@MappedSuperclass
public class BaseEntity {
    @Basic
    @Temporal(TemporalType.TIMESTAMP)
    public Date getLastUpdate() { ... }
    public String getLastUpdater() { ... }
    ...
}

@Entity class Order extends BaseEntity {
    @Id public Integer getId() { ... }
    ...
}</programlisting>

        <para>En base de données, cette hiérarchie sera représentée comme une
        table <literal>Order</literal> ayant les colonnes <literal>id</literal>,
        <literal>lastUpdate</literal> et <literal>lastUpdater</literal>.
        Les mappings de propriété de la classe parente embarquée sont copiés
        dans les classes filles de l'entité. Souvenez-vous que la classe parente
        embarquable n'est cependant pas la racine de la hiérarchie.</para>

        <note>
          <para>Les propriétés des classes parentes non mappées comme
          <literal>@MappedSuperclass</literal> sont ignorées.</para>
        </note>

        <note>
          <para>Le type d'accès (champ ou méthode) est hérité de l'entité
          racine, à moins que vous utilisiez l'annotation Hibernate
          <literal>@AccessType</literal>.</para>
        </note>

        <note>
          <para>La même notion peut être appliquée aux objets
          <literal>@Embeddable</literal> pour persister des propriétés de leurs
          classes parentes. Vous avez aussi besoin d'utiliser
          <literal>@MappedSuperclass</literal> pour faire ça (cependant cela ne
          devrait pas être considéré comme une fonctionnalité EJB3
          standard).</para>
        </note>

        <note>
          <para>Il est permis de marquer une classe comme
          <literal>@MappedSuperclass</literal> dans le milieu d'une hiérarchie
          d'héritage mappée.</para>
        </note>

        <note>
          <para>Toute classe de la hiérarchie non annotée avec
          <literal>@MappedSuperclass</literal> ou <literal>@Entity</literal>
          sera ignorée.</para>
        </note>

        <para>Vous pouvez surcharger des colonnes définies dans des entités
        parentes au niveau de l'entité racine en utilisant l'annotation
        <literal>@AttributeOverride</literal>.</para>

        <programlisting>@MappedSuperclass
public class FlyingObject implements Serializable {

    public int getAltitude() {
        return altitude;
    }

    @Transient
    public int getMetricAltitude() {
        return metricAltitude;
    }

    @ManyToOne
    public PropulsionType getPropulsion() {
        return metricAltitude;
    }
    ...
}

@Entity
@AttributeOverride( name="altitude", column = @Column(name="fld_altitude") )
@AssociationOverride( name="propulsion", joinColumns = @JoinColumn(name="fld_propulsion_fk") )
public class Plane extends FlyingObject {
    ...
}</programlisting>

        <para>La propriété <literal>altitude</literal> sera persistée dans la
        colonne <literal>fld_altitude</literal> de la table
        <literal>Plane</literal> et l'association <literal>propulsion</literal>
        sera matérialisée dans la colonne de clef étrangère
        <literal>fld_propulsion_fk</literal>.</para>

        <para>Vous pouvez définir <literal>@AttributeOverride</literal>(s) et
        <literal>@AssociationOverride</literal>(s) sur des classes
        <literal>@Entity</literal>, des classes
        <literal>@MappedSuperclass</literal> et des propriétés pointant vers un
        objet <literal>@Embeddable</literal>.</para>
      </sect3>
    </sect2>

    <sect2 id="entity-mapping-association">
      <title>Mapper des associations/relations d'entity beans</title>

      <sect3>
        <title>One-to-one</title>

        <para>Vous pouvez associer des entity beans avec une relation one-to-one
        en utilisant <literal>@OneToOne</literal>. Il y a trois cas pour les
        associations one-to-one : soit les entités associées partagent les mêmes
        valeurs de clef primaire, soit une clef étrangère est détenue par une
        des entités (notez que cette colonne de clef étrangère dans la base de
        données devrait être avoir une contrainte d'unicité pour simuler la
        cardinalité one-to-one), soit une table d'association est utilisée pour
        stocker le lien entre les 2 entités (une contrainte d'unicité doit être
        définie sur chaque clef étrangère pour assurer la cardinalité un à
        un).</para>

        <para>Tout d'abord, nous mappons une véritable association one-to-one en
        utilisant des clefs primaires partagées :</para>

        <programlisting>
@Entity
public class Body {
    @Id
    public Long getId() { return id; }

    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    public Heart getHeart() {
        return heart;
    }
    ...
}
            </programlisting>

        <programlisting>
@Entity
public class Heart {
    @Id
    public Long getId() { ...}
}
            </programlisting>

        <para>L'association un à un est activée en utilisant l'annotation
        <literal>@PrimaryKeyJoinColumn</literal>.</para>

        <para>Dans l'exemple suivant, les entités associées sont liées à travers
        une clef étrangère :</para>

        <programlisting>
@Entity
public class Customer implements Serializable {
    @OneToOne(cascade = CascadeType.ALL)
    <emphasis role="bold">@JoinColumn(name="passport_fk")</emphasis>
    public Passport getPassport() {
        ...
    }

@Entity
public class Passport implements Serializable {
    @OneToOne(<emphasis role="bold">mappedBy = "passport"</emphasis>)
    public Customer getOwner() {
    ...
}
            </programlisting>

        <para>Un <classname>Customer</classname> est lié à un
        <classname>Passport</classname>, avec une colonne de clef étrangère
        nommée <literal>passport_fk</literal> dans la table
        <literal>Customer</literal>. La colonne de jointure est déclarée avec
        l'annotation <literal>@JoinColumn</literal> qui ressemble à l'annotation
        <literal>@Column</literal>. Elle a un paramètre de plus nommé
        <literal>referencedColumnName</literal>. Ce paramètre déclare la colonne
        dans l'entité cible qui sera utilisée pour la jointure. Notez que lors
        de l'utilisation de <literal>referencedColumnName</literal> vers une
        colonne qui ne fait pas partie de la clef primaire, la classe associée
        doit être <classname>Serializable</classname>. Notez aussi que
        <literal>referencedColumnName</literal> doit être mappé sur une
        propriété ayant une seule colonne lorsqu'elle pointe vers une colonne
        qui ne fait pas partie de la clef primaire (d'autres cas pourraient ne
        pas fonctionnner).</para>

        <para>L'association peut être bidirectionnelle. Dans une relation
        bidirectionnelle, une des extrémités (et seulement une) doit être la
        propriétaire : la propriétaire est responsable de la mise à jour des
        colonnes de l'association. Pour déclarer une extrémité comme
        <emphasis>non</emphasis> responsable de la relation, l'attribut
        <literal>mappedBy</literal> est utilisé.
        <literal>mappedBy</literal> référence le nom de la propriété de
        l'association du côté du propriétaire. Dans notre cas, c'est
        <literal>passport</literal>. Comme vous pouvez le voir, vous ne devez
        (absolument) pas déclarer la colonne de jointure puisqu'elle a déjà été
        déclarée du côté du propriétaire.</para>

        <para>Si aucune <literal>@JoinColumn</literal> n'est déclarée du côté du
        propriétaire, les valeurs par défaut s'appliquent. Une(des) colonne(s)
        de jointure sera(ont) créée(s) dans la table propriétaire, et son(leur)
        nom sera la concaténation du nom de la relation du côté propriétaire,
        <keycap>_</keycap> (underscore), et le nom de la (des) colonne(s) de la
        clef primaire du propriétaire. Dans cet exemple
        <literal>passport_id</literal> parce que le nom de la propriété est
        <literal>passport</literal> et la colonne identifiante de
        <literal>Passport</literal> est <literal>id</literal>.</para>

        <para>La troisième possibilité (utilisant une table d'association) est
        très exotique.</para>

        <programlisting>
@Entity
public class Customer implements Serializable {
    @OneToOne(cascade = CascadeType.ALL)
    <emphasis role="bold">@JoinTable(name = "CustomerPassports",
        joinColumns = @JoinColumn(name="customer_fk"),
        inverseJoinColumns = @JoinColumn(name="passport_fk")</emphasis>
    )
    public Passport getPassport() {
        ...
    }

@Entity
public class Passport implements Serializable {
    @OneToOne(<emphasis role="bold">mappedBy = "passport"</emphasis>)
    public Customer getOwner() {
    ...
}
            </programlisting>

        <para>Un <classname>Customer</classname> est lié à un
        <classname>Passport</classname> à travers une table d'association
        nommée <literal>CustomerPassports</literal> ; cette table d'association
        a une colonne de clef étrangère nommée <literal>passport_fk</literal>
        pointant vers la table <literal>Passport</literal> (matérialisée par
        l'attribut <literal>inverseJoinColumn</literal>), et une colonne de clef
        étrangère nommée <literal>customer_fk</literal> pointant vers la table
        <literal>Customer</literal> (matérialisée par l'attribut
        <literal>joinColumns</literal>).</para>

        <para>Vous devez déclarer le nom de la table de jointure et les colonnes
        de jointure explicitement dans un tel mapping.</para>
      </sect3>

      <sect3>
        <title>Many-to-one</title>

        <para>Les associations Many-to-one sont déclarées au niveau de la
        propriété avec l'annotation <literal>@ManyToOne</literal> :</para>

        <programlisting>
@Entity()
public class Flight implements Serializable {
    <emphasis role="bold">@ManyToOne</emphasis>( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )
    @JoinColumn(name="COMP_ID")
    public Company getCompany() {
        return company;
    }
    ...
}
            </programlisting>

        <para>L'attribut <literal>@JoinColumn</literal> est optionnel, la valeur
        par défaut est comme l'association un à un, la concaténation du nom
        de la relation du côté propriétaire, <keycap>_</keycap>
        (underscore), et le nom de la colonne de la clef primaire du côté
        propriétaire. Dans cet exemple, <literal>company_id</literal> parce que
        le nom de la propriété est <literal>company</literal> et la colonne
        identifiante de Company est <literal>id</literal>.</para>

        <para><literal>@ManyToOne</literal> a un paramètre nommé
        <literal>targetEntity</literal> qui décrit le nom de l'entité cible.
        Généralement, vous ne devriez pas avoir besoin de ce paramètre puisque
        la valeur par défaut (le type de la propriété qui stocke l'association)
        est correcte dans la plupart des cas. Il est cependant utile lorsque
        vous souhaitez retourner une interface plutôt qu'une entité
        normale.</para>

        <programlisting>
@Entity()
public class Flight implements Serializable {
    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE}, <emphasis
            role="bold">targetEntity=CompanyImpl.class</emphasis> )
    @JoinColumn(name="COMP_ID")
    public Company getCompany() {
        return company;
    }
    ...
}

public interface Company {
    ...
            </programlisting>

        <para>Vous pouvez sinon mapper une association plusieurs à un avec une
        table d'association. Cette association décrite par l'annotation
        <literal>@JoinTable</literal> contiendra une clef étrangère référençant
        la table de l'entité (avec
        <literal>@JoinTable.joinColumns</literal>) et une clef étrangère
        référençant la table de l'entité cible (avec
        <literal>@JoinTable.inverseJoinColumns</literal>).</para>

        <programlisting>
@Entity()
public class Flight implements Serializable {
    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )
    <emphasis role="bold">@JoinTable(name="Flight_Company",
        joinColumns = @JoinColumn(name="FLIGHT_ID"),
        inverseJoinColumns = @JoinColumn(name="COMP_ID")
    )</emphasis>
    public Company getCompany() {
        return company;
    }
    ...
}
            </programlisting>
      </sect3>

      <sect3 id="entity-mapping-association-collections">
        <title>Collections</title>

        <sect4 id="entity-mapping-association-collections-overview"
               revision="1">
          <title>Vue d'ensemble</title>

          <para>Vous pouvez mapper des <classname>Collection</classname>s, des
          <literal>List</literal>s (ie des listes ordonnées, pas des listes
          indexées), des <literal>Map</literal>s et des
          <classname>Set</classname>s. La spécification EJB3 décrit comment
          mapper une liste ordonnée (ie une liste ordonnée au chargement) en
          utilisant l'annotation <literal>@javax.persistence.OrderBy</literal> :
          pour ordonner la collection, cette annotation prend en paramètre une
          liste de propriétés (de l'entité cible) séparées par des virgules
          (p. ex. <code>firstname asc, age desc</code>) ; si la chaîne de
          caractères est vide, la collection sera ordonnée par les identifiants.
          Pour le moment <literal>@OrderBy</literal> fonctionne seulement sur
          des collections n'ayant pas de table d'association. Pour les
          véritables collections indexées, veuillez vous référer à
          <xref linkend="entity-hibspec" />. EJB3 vous permet de mapper des
          <literal>Map</literal>s en utilisant comme clef une des propriétés de
          l'entité cible avec <literal>@MapKey(name="myProperty")</literal>
          (myProperty est un nom de propriété de l'entité cible). Lorsque vous
          utilisez <literal>@MapKey</literal> sans nom de propriété, la clef
          primaire de l'entité cible est utilisée. La clef de la map utilise la
          même colonne que celle pointée par la propriété : il n'y a pas de
          colonne supplémentaire définie pour la clef de la map, et c'est normal
          puisque la clef de la map représente en fait un propriété de la cible.
          Faites attention qu'une fois chargée, la clef n'est plus synchronisée
          avec la propriété, en d'autres mots, si vous modifiez la valeur de la
          propriété, la clef ne sera pas changée automatiquement dans votre
          modèle Java (pour une véritable prise en charge des maps veuillez vous
          référer à <xref linkend="entity-hibspec" />). Beaucoup de gens
          confondent les capacités de <literal>&lt;map&gt;</literal> et celles
          de <literal>@MapKey</literal>. Ce sont deux fonctionnalités
          différentes. <literal>@MapKey</literal> a encore quelques limitations,
          veuillez vous référer au forum ou au système de suivi de bogues JIRA
          pour plus d'informations.</para>

          <para>Hibernate a plusieurs notions de collections.</para>

          <para></para>

          <table>
            <title>Sémantique des collections</title>

            <tgroup cols="3">
              <colspec colname="c1" />

              <colspec colname="c2" />

              <colspec colname="c3" colnum="2" />

              <thead>
                <row>
                  <entry>Sémantique</entry>

                  <entry>Représentation Java</entry>

                  <entry>Annotations</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>Sémantique de Bag</entry>

                  <entry>java.util.List, java.util.Collection</entry>

                  <entry>@org.hibernate.annotations.CollectionOfElements ou
                  @OneToMany ou @ManyToMany</entry>
                </row>

                <row>
                  <entry>Sémantique de Bag avec une clef primaire (sans les
                  limitations de la sémantique de Bag)</entry>

                  <entry>java.util.List, java.util.Collection</entry>

                  <entry>(@org.hibernate.annotations.CollectionOfElements ou
                  @OneToMany ou @ManyToMany) et @CollectionId</entry>
                </row>

                <row>
                  <entry>Sémantique de List</entry>

                  <entry>java.util.List</entry>

                  <entry>(@org.hibernate.annotations.CollectionOfElements ou
                  @OneToMany ou @ManyToMany) et
                  @org.hibernate.annotations.IndexColumn</entry>
                </row>

                <row>
                  <entry>Sémantique de Set</entry>

                  <entry>java.util.Set</entry>

                  <entry>@org.hibernate.annotations.CollectionOfElements ou
                  @OneToMany ou @ManyToMany</entry>
                </row>

                <row>
                  <entry>Sémantique de Map</entry>

                  <entry>java.util.Map</entry>

                  <entry>(@org.hibernate.annotations.CollectionOfElements ou
                  @OneToMany ou @ManyToMany) et (rien ou
                  @org.hibernate.annotations.MapKey/MapKeyManyToMany pour une
                  véritable prise en charge des maps, ou
                  @javax.persistence.MapKey</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <remark>Donc spécifiquement, les collections java.util.List sans
          @org.hibernate.annotations.IndexColumn vont être considérées commes
          des bags.</remark>

          <para>Les collections de types primitifs, de types core ou d'objets
          embarqués ne sont pas prises en charge par la spécification EJB3.
          Cependant Hibernate Annotations les autorise
          (voir <xref linkend="entity-hibspec" />).</para>

          <programlisting>@Entity public class City {
    @OneToMany(mappedBy="city")
    <emphasis role="bold">@OrderBy("streetName")</emphasis>
    public List&lt;Street&gt; getStreets() {
        return streets;
    }
...
}

@Entity public class Street {
    <emphasis role="bold">public String getStreetName()</emphasis> {
        return streetName;
    }

    @ManyToOne
    public City getCity() {
        return city;
    }
    ...
}


@Entity
public class Software {
    @OneToMany(mappedBy="software")
    <emphasis role="bold">@MapKey(name="codeName")</emphasis>
    public Map&lt;String, Version&gt; getVersions() {
        return versions;
    }
...
}

@Entity
@Table(name="tbl_version")
public class Version {
    <emphasis role="bold">public String getCodeName()</emphasis> {...}

    @ManyToOne
    public Software getSoftware() { ... }
...
}</programlisting>

          <para>Donc <literal>City</literal> a une collection de
          <literal>Street</literal>s qui sont ordonnées par
          <literal>streetName</literal> (de <literal>Street</literal>) lorsque
          la collection est chargée. <literal>Software</literal> a une map de
          <literal>Version</literal>s dont la clef est
          <literal>codeName</literal> de <literal>Version</literal>.</para>

          <para>A moins que la collection soit une "generic", vous devrez
          définir <literal>targetEntity</literal>. C'est un attribut de
          l'annotation qui prend comme valeur la classe de l'entité
          cible.</para>
        </sect4>

        <sect4 id="entity-mapping-association-collection-onetomany"
               revision="2">
          <title>One-to-many</title>

          <para>Les associations one-to-many sont déclarées au niveau propriété
          avec l'annotation <literal>@OneToMany</literal>. Les associations un
          à plusieurs peuvent être bidirectionnelles.</para>

          <sect5>
            <title>Relation bidirectionnelle</title>

            <para>Puisque les associations plusieurs à un sont (presque)
            toujours l'extrémité propriétaire de la relation bidirectionnelle
            dans la spécification EJB3, l'association un à plusieurs est
            annotée par <literal>@OneToMany(mappedBy=...)</literal>.</para>

            <programlisting>@Entity
public class Troop {
    @OneToMany(mappedBy="troop")
    public Set&lt;Soldier&gt; getSoldiers() {
    ...
}

@Entity
public class Soldier {
    @ManyToOne
    @JoinColumn(name="troop_fk")
    public Troop getTroop() {
    ...
}              </programlisting>

            <para><classname>Troop</classname> a une relation bidirectionnelle
            un à plusieurs avec <literal>Soldier</literal> à travers la
            propriété <literal>troop</literal>. Vous ne devez pas définir
            de mapping physique à l'extrémité de
            <literal>mappedBy</literal>.</para>

            <para>Pour mapper une relation bidirectionnelle un à plusieurs, avec
            l'extrémité one-to-many comme extrémité propriétaire, vous devez
            enlever l'élément <literal>mappedBy</literal> et marquer
            l'annotation <literal>@JoinColumn</literal> de l'extrémité plusieurs
            à un comme ne pouvant pas être insérée et ni mise à jour. Cette
            solution n'est certainement pas optimisée et produira quelques
            commandes UPDATE supplémentaires.</para>

            <programlisting>@Entity
public class Troop {
    @OneToMany
    @JoinColumn(name="troop_fk") // nous avons besoin de dupliquer l'information physique
    public Set&lt;Soldier&gt; getSoldiers() {
    ...
}

@Entity
public class Soldier {
    @ManyToOne
    @JoinColumn(name="troop_fk", insertable=false, updatable=false)
    public Troop getTroop() {
    ...
}</programlisting>
          </sect5>

          <sect5>
            <title>Relation unidirectionnelle</title>

            <para>Une relation un à plusieurs unidirectionnelle utilisant une
            colonne de clef étrangère de l'entité propriétaire n'est pas si
            commune, réellement recommandée. Nous vous conseillons
            fortement d'utiliser une table de jointure pour cette sorte
            d'association (comme expliqué dans la prochaine section). Cette
            sorte d'association est décrite à travers
            <literal>@JoinColumn</literal>.</para>

            <programlisting>
@Entity
public class Customer implements Serializable {
    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @JoinColumn(name="CUST_ID")
    public Set&lt;Ticket&gt; getTickets() {
    ...
}

@Entity
public class Ticket implements Serializable {
    ... // pas de relation bidirectionnelle
}
               </programlisting>

            <para><literal>Customer</literal> décrit une relation
            unidirectionnelle avec <literal>Ticket</literal> en utilisant la
            colonne de jointure <literal>CUST_ID</literal>.</para>
          </sect5>

          <sect5>
            <title>Relation unidirectionnel avec une table de jointure</title>

            <para>Une relation unidirectionnelle un à plusieurs avec une table
            de jointure est largement préférée. Cette association est décrite
            à travers l'annotation <literal>@JoinTable</literal>.</para>

            <programlisting>
@Entity
public class Trainer {
    @OneToMany
    @JoinTable(
            name="TrainedMonkeys",
            joinColumns = @JoinColumn( name="trainer_id"),
            inverseJoinColumns = @JoinColumn( name="monkey_id")
    )
    public Set&lt;Monkey&gt; getTrainedMonkeys() {
    ...
}

@Entity
public class Monkey {
    ... // pas de relation bidirectionnelle
}
               </programlisting>

            <para><literal>Trainer</literal> décrit une relation
            unidirectionelle avec <classname>Monkey</classname> en utilisant la
            table de jointure <classname>TrainedMonkeys</classname>, avec une
            clef étrangère <literal>trainer_id</literal> vers
            <literal>Trainer</literal> (<literal>joinColumns</literal>) et une
            clef étrangère <literal>monkey_id</literal> vers
            <literal>Monkey</literal>
            (<literal>inversejoinColumns</literal>).</para>
          </sect5>

          <sect5 id="entity-mapping-association-collection-manytomany-default"
                 revision="1">
            <title>Valeurs par défaut</title>

            <para>Si aucun mapping physique n'est déclaré, une relation
            unidirectionnelle un vers plusieurs utilise une table de jointure.
            Le nom de la table est la concaténation du nom de la table
            propriétaire, <keycap>_</keycap>, et le nom de la table de l'autre
            extrémité. Le nom des colonnes de la clef étrangère référençant la
            table propriétaire est la concaténation de la table propriétaire,
            <keycap>_</keycap>, et le nom des colonnes de la clef primaire. Le
            nom des colonnes de la clef étrangère référençant l'autre extrémité
            est la concaténation du nom de la propriété du propriétaire,
            <keycap>_</keycap>, et le nom des colonnes de la clef primaire de
            l'autre extrémité. Une contrainte d'unicité est ajoutée sur la
            clef étrangère référençant la table de l'autre extrémité pour
            réfléter le un à plusieurs.</para>

            <programlisting>
@Entity
public class Trainer {
    @OneToMany
    public Set&lt;Tiger&gt; getTrainedTigers() {
    ...
}

@Entity
public class Tiger {
    ... // non bidirectionnelle
}
               </programlisting>

            <para><classname>Trainer</classname> décrit une relation
            unidirectionnelle avec <classname>Tiger</classname> utilisant la
            table de jointure <literal>Trainer_Tiger</literal>, avec une clef
            étrangère <literal>trainer_id</literal> vers
            <literal>Trainer</literal> (nom de la table, <keycap>_</keycap>,
            identifiant de trainer) et une clef étrangère
            <literal>trainedTigers_id</literal> vers <literal>Monkey</literal>
            (nom de la propriété, <keycap>_</keycap>, colonne de la clef
            primaire de Tiger).</para>
          </sect5>
        </sect4>

        <sect4 id="eentity-mapping-association-collection-manytomany"
               revision="">
          <title>Many-to-many</title>

          <sect5>
            <title>Définition</title>

            <para>Une association many-to-many est définie logiquement en
            utilisant l'annotation <literal>@ManyToMany</literal>. Vous devez
            aussi décrire la table d'association et les conditions de jointure
            en utilisant l'annotation <literal>@JoinTable</literal>. Si
            l'association est bidirectionnelle, une extrémité doit être la
            propriétaire et l'autre doit être marquée comme "inverse" (ie
            qu'elle sera ignorée lors de la mise à jour des valeurs de la
            relation dans la table d'association) :</para>

            <programlisting>
@Entity
public class Employer implements Serializable {
    @ManyToMany(
        targetEntity=org.hibernate.test.metadata.manytomany.Employee.class,
        cascade={CascadeType.PERSIST, CascadeType.MERGE}
    )
    @JoinTable(
        name="EMPLOYER_EMPLOYEE",
        joinColumns=@JoinColumn(name="EMPER_ID"),
        inverseJoinColumns=@JoinColumn(name="EMPEE_ID")
    )
    public Collection getEmployees() {
        return employees;
    }
    ...
}
               </programlisting>

            <programlisting>
@Entity
public class Employee implements Serializable {
    @ManyToMany(
        cascade = {CascadeType.PERSIST, CascadeType.MERGE},
        mappedBy = "employees",
        targetEntity = Employer.class
    )
    public Collection getEmployers() {
        return employers;
    }
}
               </programlisting>

            <para>Nous avons déjà montré les déclarations des relations
            "many" et détaillé les attributs de ces associations. Allons
            plus en profondeur dans la description de
            <literal>@JoinTable</literal> ; elle définit un
            <literal>name</literal>, un tableau de colonnes de jointure (un
            tableau dans une annotation est défini par {A, B, C}), et un tableau
            de colonnes de jointure inverse. Ces dernières sont les colonnes
            de la table d'association qui référencent la clef primaire de
            <classname>Employee</classname> ("l'autre extrémité").</para>

            <para>Comme vu précédemment, l'autre extrémité ne doit pas décrire
            le mapping physique : un simple argument
            <literal>mappedBy</literal> contenant le nom de la propriété de
            l'extrémité propriétaire suffit à relier les deux.</para>
          </sect5>

          <sect5>
            <title>Valeurs par défaut</title>

            <para>Comme d'autres annotations, la plupart des valeurs d'une
            relation plusieurs à plusieurs sont inférées. Si aucun mapping
            physique n'est décrit dans une relation plusieurs à plusieurs
            unidirectionnelle, alors les règles suivantes s'appliquent. Le nom
            de la table est la concaténation du nom de la table propriétaire,
            <keycap>_</keycap> et le nom de la table de l'autre extrémité. Le
            nom des colonnes de la clef étrangère référençant la table
            propriétaire est la concaténation du nom de la table propriétaire,
            <keycap>_</keycap> et le nom des colonnes de la clef primaire
            de cette table. Le nom des colonnes de la clef étrangère référençant
            l'autre extrémité est la concaténation du nom de la propriété du
            propriétaire, <keycap>_</keycap> et le nom des colonnes de la
            clef primaire de l'autre extrémité. Ce sont les mêmes règles que
            celles utilisées pour une relation un à plusieurs
            unidirectionnelle.</para>

            <programlisting>
@Entity
public class Store {
    @ManyToMany(cascade = CascadeType.PERSIST)
    public Set&lt;City&gt; getImplantedIn() {
        ...
    }
}

@Entity
public class City {
    ... // pas de relation bidirectionnelle
}
               </programlisting>

            <para>La table <literal>Store_City</literal> est utilisée comme
            table de jointure. La colonne <literal>Store_id</literal> est
            une clef étrangère vers la table <literal>Store</literal>. La
            colonne <literal>implantedIn_id</literal> est une clef étrangère
            vers la table <literal>City</literal>.</para>

            <para>Si aucun mapping physique n'est décrit dans une relation
            plusieurs à plusieurs bidirectionnelle, alors les règles suivantes
            s'appliquent. Le nom de la table est la concaténation du nom de la
            table propriétaire, <keycap>_</keycap> et le nom de la table de
            l'autre extrémité. Le nom des colonnes de la clef étrangère
            référençant la table propriétaire est la concaténation du nom de la
            propriété de l'autre extrémité, <keycap>_</keycap> et le nom des
            colonnes de la clef primaire du propriétaire. Le nom des colonnes de
            la clef étrangère référençant l'autre extrémité est la concaténation
            du nom de la propriété du propriétaire, <keycap>_</keycap> et le nom
            des colonnes de la clef primaire de l'autre extrémité. Ce sont les
            mêmes règles que celles utilisées pour une relation un à plusieurs
            unidirectionnelle.</para>

            <programlisting>
@Entity
public class Store {
    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    public Set&lt;Customer&gt; getCustomers() {
        ...
    }
}

@Entity
public class Customer {
    @ManyToMany(mappedBy="customers")
    public Set&lt;Store&gt; getStores() {
        ...
    }
}
               </programlisting>

            <para>La table <literal>Store_Customer</literal> est utilisée comme
            table de jointure. La colonne <literal>stores_id</literal> est une
            clef étrangère vers la table <literal>Store</literal>. La colonne
            <literal>customers_id</literal> est une clef étrangère vers la table
            <literal>Customer</literal>.</para>
          </sect5>
        </sect4>
      </sect3>

      <sect3>
        <title>Persistance transitive avec les opérations en cascade</title>

        <para>Vous avez probablement remarqué l'attribut
        <literal>cascade</literal> prenant comme valeur un tableau de
        <classname>CascadeType</classname>s. Le concept de cascade dans EJB3 est
        similaire à la persistance transitive et les opérations en cascade dans
        Hibernate, mais avec une sémantique légèrement différente et les types
        de cascade suivants :</para>

        <itemizedlist>
          <listitem>
             CascadeType.PERSIST : effectue en cascade l'opération de
             persistance (création) sur les entités associées si persist() est
             appelée ou si l'entité est supervisée (par le gestionnaire
             d'entités)
          </listitem>

          <listitem>
             CascadeType.MERGE : effectue en cascade l'opération de fusion sur
             les entités associées si merge() est appélée ou si l'entité est
             supervisée
          </listitem>

          <listitem>
             CascadeType.REMOVE : effectue en cascade l'opération de
             suppression sur les entités associées si delete() est appelée
          </listitem>

          <listitem>
             CascadeType.REFRESH : effectue en cascade l'opération de
             rafraîchissement sur les entités associées si refresh() est appelée
          </listitem>

          <listitem>
             CascadeType.ALL : tous ceux du dessus
          </listitem>
        </itemizedlist>

        <para>Veullez vous référer au chapitre 6.3 de la spécification EJB3 pour
        plus d'informations sur les opérations en cascade et la sémantique des
        opérations de création/fusion.</para>
      </sect3>

      <sect3>
        <title>Récupération d'associations</title>

        <para>Vous avez la possibilité de récupérer les entités associées soit
        immédiatement ("eager"), soit à la demande ("lazy"). Le paramètre
        <literal>fetch</literal> peut être positionné à
        <literal>FetchType.LAZY</literal> ou à
        <literal>FetchType.EAGER</literal>. <literal>EAGER</literal> essaiera
        d'utiliser une jointure externe pour rappatrier l'objet associé,
        alors que <literal>LAZY</literal> est la valeur par défaut et rapportera
        les données lorsque l'objet associé sera accédé pour la première fois.
        JPA-QL a aussi un mot clef <literal>fetch</literal> qui vous permet de
        surcharger le type de récupération pour une requête particulière. C'est
        très utile pour améliorer les performances et décider au cas par
        cas.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Mapper des clefs primaires et étrangères composées</title>

      <para>Les clefs primaires composées utilisent une classe embarquée comme
      représentation de la clef primaire, donc vous devriez utiliser les
      annotations <literal>@Id</literal> et <literal>@Embeddable</literal>.
      Alternativement, vous pouvez utiliser l'annotation
      <literal>@EmbeddedId</literal>. Notez que la classe dépendante doit être
      sérialisable et implementer
      <methodname>equals()</methodname>/<methodname>hashCode()</methodname>.
      Vous pouvez aussi utiliser <literal>@IdClass</literal> comme décrit dans
      <xref linkend="entity-mapping-identifier" />.</para>

      <programlisting>
@Entity
public class RegionalArticle implements Serializable {

    @Id
    public RegionalArticlePk getPk() { ... }
}

@Embeddable
public class RegionalArticlePk implements Serializable { ... }
         </programlisting>

      <para>ou alternativement</para>

      <programlisting>
@Entity
public class RegionalArticle implements Serializable {

    @EmbeddedId
    public RegionalArticlePk getPk() { ... }
}

public class RegionalArticlePk implements Serializable { ... }
         </programlisting>

      <para><literal>@Embeddable</literal> hérite le type d'accès de son entité
      d'appartenance à moins que l'annotation spécifique Hibernate
      <literal>@AccessType</literal> soit utilisée. Les clefs étrangères
      composées (si les valeurs par défaut ne sont pas utilisées) sont définies
      sur les associations en utilisant l'élément
      <literal>@JoinColumns</literal>, lequel est simplement un tableau de
      <literal>@JoinColumn</literal>s. Il est considéré comme une bonne pratique
      d'exprimer <literal>referencedColumnNames</literal> explicitement. Sinon,
      Hibernate supposera que vous utilisez le même ordre de colonnes que dans
      la déclaration de la clef primaire.</para>

      <programlisting>
@Entity
public class Parent implements Serializable {
    @Id
    public ParentPk id;
    public int age;

    @OneToMany(cascade=CascadeType.ALL)
    @JoinColumns ({
        @JoinColumn(name="parentCivility", referencedColumnName = "isMale"),
        @JoinColumn(name="parentLastName", referencedColumnName = "lastName"),
        @JoinColumn(name="parentFirstName", referencedColumnName = "firstName")
    })
    public Set&lt;Child&gt; children; //unidirectionnelle
    ...
}
         </programlisting>

      <programlisting>
@Entity
public class Child implements Serializable {
    @Id @GeneratedValue
    public Integer id;

    @ManyToOne
    @JoinColumns ({
        @JoinColumn(name="parentCivility", referencedColumnName = "isMale"),
        @JoinColumn(name="parentLastName", referencedColumnName = "lastName"),
        @JoinColumn(name="parentFirstName", referencedColumnName = "firstName")
    })
    public Parent parent; // unidirectionnelle
}
         </programlisting>

      <programlisting>
@Embeddable
public class ParentPk implements Serializable {
    String firstName;
    String lastName;
    ...
}
         </programlisting>

      <para>Notez l'usage explicite de
      <literal>referencedColumnName</literal>.</para>
    </sect2>

    <sect2>
      <title>Mapper des tables secondaires</title>

      <para>Vous pouvez mapper un simple entity bean vers plusieurs tables en
      utilisant les annotations de niveau classe
      <literal>@SecondaryTable</literal> ou
      <literal>@SecondaryTables</literal>. Pour dire qu'une colonne est dans
      une table particulière, utlisez le paramètre <literal>table</literal> de
      <literal>@Column</literal> ou <literal>@JoinColumn</literal>.</para>

      <programlisting>
@Entity
@Table(name="MainCat")
<emphasis role="bold">@SecondaryTables({
    @SecondaryTable(name="Cat1", pkJoinColumns={
        @PrimaryKeyJoinColumn(name="cat_id", referencedColumnName="id")
    ),
    @SecondaryTable(name="Cat2", uniqueConstraints={@UniqueConstraint(columnNames={"storyPart2"})})
})</emphasis>
public class Cat implements Serializable {

    private Integer id;
    private String name;
    private String storyPart1;
    private String storyPart2;

    @Id @GeneratedValue
    public Integer getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    <emphasis role="bold">@Column(table="Cat1")</emphasis>
    public String getStoryPart1() {
        return storyPart1;
    }

    <emphasis role="bold">@Column(table="Cat2")</emphasis>
    public String getStoryPart2() {
        return storyPart2;
    }
</programlisting>

      <para>Dans cet exemple, <literal>name</literal> sera dans
      <literal>MainCat</literal>. <literal>storyPart1</literal> sera dans
      <literal>Cat1</literal> et <literal>storyPart2</literal> sera dans
      <literal>Cat2</literal>. <literal>Cat1</literal> sera joint à
      <literal>MainCat</literal> avec <literal>cat_id</literal> comme clef
      étrangère, et <literal>Cat2</literal> avec <literal>id</literal> (ie
      le même nom de colonne que la colonne identifiante de
      <literal>MainCat</literal>). De plus, une contrainte d'unicité sur
      <literal>storyPart2</literal> a été renseignée.</para>

      <para>Regardez le tutoriel EJB3 de JBoss ou la suite de tests
      unitaires d'Hibernate Annotations pour plus d'exemples.</para>
    </sect2>
  </sect1>

  <sect1 id="entity-mapping-query">
    <title>Mapper des requêtes</title>

    <sect2 id="entity-mapping-query-hql"
           revision="1">
      <title>Mapper des requêtes JPAQL/HQL</title>

      <para>Vous pouvez mapper des requêtes JPA-QL/HQL en utilisant les
      annotations. <literal>@NamedQuery</literal> et
      <literal>@NamedQueries</literal> peuvent être définies au niveau de la
      classe ou dans un fichier JPA XML. Cependant, leurs définitions sont
      globales au scope de la session factory/entity manager factory. Une
      requête nommée est définie par son nom et la chaîne de caractères de la
      requête réelle.</para>

      <programlisting>&lt;entity-mappings&gt;
    &lt;named-query name="plane.getAll"&gt;
        &lt;query&gt;select p from Plane p&lt;/query&gt;
    &lt;/named-query&gt;
    ...
&lt;/entity-mappings&gt;
...

@Entity
@NamedQuery(name="night.moreRecentThan", query="select n from Night n where n.date &gt;= :date")
public class Night {
    ...
}

public class MyDao {
    doStuff() {
        Query q = s.getNamedQuery("night.moreRecentThan");
        q.setDate( "date", aMonthAgo );
        List results = q.list();
        ...
    }
    ...
}
        </programlisting>

      <para>Vous pouvez aussi fournir des indications de fonctionnement à une
      requête à travers un tableau de <literal>QueryHint</literal>s avec
      l'attribut <literal>hints</literal>.</para>

      <para>Les indications de fonctionnement Hibernate disponibles
      sont :</para>

      <para></para>

      <table>
        <title>Indications de fonctionnement d'une requête</title>

        <tgroup cols="2">
          <thead>
            <colspec colname="c1" />

            <colspec colname="c2" colnum="2" />

            <row>
              <entry>Indication</entry>

              <entry colname="c2">description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>org.hibernate.cacheable</entry>

              <entry>Indique si la requête devrait interagir avec le cache de
              second niveau (par défaut à false)</entry>
            </row>

            <row>
              <entry>org.hibernate.cacheRegion</entry>

              <entry>Nom de la région du cache (si indéfinie, la valeur par
              défaut est utilisée)</entry>
            </row>

            <row>
              <entry>org.hibernate.timeout</entry>

              <entry>Timeout des requêtes</entry>
            </row>

            <row>
              <entry>org.hibernate.fetchSize</entry>

              <entry>Taille des result sets par fetch</entry>
            </row>

            <row>
              <entry>org.hibernate.flushMode</entry>

              <entry>Mode de flush utilisé pour cette requête</entry>
            </row>

            <row>
              <entry>org.hibernate.cacheMode</entry>

              <entry>Mode de cache utilisé pour cette requête</entry>
            </row>

            <row>
              <entry>org.hibernate.readOnly</entry>

              <entry>Indique si les entités chargées par cette requête devraient
              être en lecture seule ou pas (par défaut à false)</entry>
            </row>

            <row>
              <entry>org.hibernate.comment</entry>

              <entry>Commentaire de la requête, ajouté au SQL généré</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2 id="entity-mapping-query-native" revision="2">
      <title>Mapper des requêtes natives</title>

      <para>Vous pouvez aussi mapper une requête native (ie une requête SQL).
      Pour ce faire, vous devez décrire la structure de l'ensemble de résultat
      SQL en utilisant <literal>@SqlResultSetMapping</literal> (ou
      <literal>@SqlResultSetMappings</literal> si vous prévoyez de définir
      plusieurs mappings de résultats). Comme <literal>@NamedQuery</literal>, un
      <literal>@SqlResultSetMapping</literal> peut être défini au niveau de la
      classe ou dans un fichier XML JPA. Cependant sa portée est globale à
      l'application.</para>

      <para>Comme vous le verrez, un paramètre de
      <literal>resultSetMapping</literal> est défini dans
      <literal>@NamedNativeQuery</literal>, il représente le nom du
      <literal>@SqlResultSetMapping</literal> défini. Le mapping de l'ensemble
      des résultats déclare les entités récupérées par cette requête native.
      Chaque champ de l'entité est lié à un alias SQL (nom de colonne). Tous les
      champs de l'entité (dont ceux des classes filles) et les colonnes des
      clefs étrangères relatives aux entités doivent être présents dans la
      requête SQL. Les définitions des champs sont optionnelles, si elles ne
      sont pas fournies, elles mappent le même nom de colonne que celui déclaré
      sur la propriété de la classe.</para>

      <para><programlisting>@NamedNativeQuery(name="night&amp;area", query="select night.id nid, night.night_duration, "
    + " night.night_date, area.id aid, night.area_id, area.name "
    + "from Night night, Area area where night.area_id = area.id", <emphasis
            role="bold">resultSetMapping="joinMapping"</emphasis>)
@SqlResultSetMapping(name="joinMapping", entities={
    @EntityResult(entityClass=org.hibernate.test.annotations.query.Night.class, fields = {
        @FieldResult(name="id", column="nid"),
        @FieldResult(name="duration", column="night_duration"),
        @FieldResult(name="date", column="night_date"),
        @FieldResult(name="area", column="area_id"),
        discriminatorColumn="disc"
    }),
    @EntityResult(entityClass=org.hibernate.test.annotations.query.Area.class, fields = {
        @FieldResult(name="id", column="aid"),
        @FieldResult(name="name", column="name")
    })
    }
)</programlisting></para>

      <para>Dans l'exemple ci-dessus, la requête nommée
      <literal>night&amp;area</literal> utilise le mapping de résultats
      <literal>joinMapping</literal>. Ce mapping retourne 2 entités,
      <literal>Night</literal> et <literal>Area</literal>, chaque propriété est
      déclarée et associée à un nom de colonne, en fait le nom de colonne
      récupéré par la requête. Voyons maintenant une déclaration implicite de
      mapping propriété/colonne.</para>

      <programlisting>@Entity
<emphasis role="bold">@SqlResultSetMapping(name="implicit", entities=@EntityResult(entityClass=org.hibernate.test.annotations.query.SpaceShip.class))
@NamedNativeQuery(name="implicitSample", query="select * from SpaceShip", resultSetMapping="implicit")</emphasis>
public class SpaceShip {
    private String name;
    private String model;
    private double speed;

    @Id
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Column(name="model_txt")
    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }
}</programlisting>

      <para>Dans cet exemple, nous décrivons seulement le membre de l'entité du
      mapping de résultats. Le mapping de propriété/colonne est fait en
      utilisant les valeurs de mapping de l'entité. Dans ce cas, la propriété
      <literal>model</literal> est liée à la colonne
      <literal>model_txt</literal>. Si l'association à une entité concernée
      implique une clef primaire composée, un élément
      <literal>@FieldResult</literal> devrait être utilisé pour chaque colonne
      de la clef étrangère. Le nom de <literal>@FieldResult</literal> est
      composé du nom de la propriété pour la relation, suivi par un point ("."),
      suivi par le nom ou le champ ou la propriété de la clef primaire.</para>

      <programlisting>@Entity
@SqlResultSetMapping(name="compositekey",
        entities=@EntityResult(entityClass=org.hibernate.test.annotations.query.SpaceShip.class,
            fields = {
                    @FieldResult(name="name", column = "name"),
                    @FieldResult(name="model", column = "model"),
                    @FieldResult(name="speed", column = "speed"),
<emphasis role="bold">                    @FieldResult(name="captain.firstname", column = "firstn"),
                    @FieldResult(name="captain.lastname", column = "lastn"),</emphasis>
                    @FieldResult(name="dimensions.length", column = "length"),
                    @FieldResult(name="dimensions.width", column = "width")
                    }),
        columns = { @ColumnResult(name = "surface"),
                    @ColumnResult(name = "volume") } )

@NamedNativeQuery(name="compositekey",
    query="select name, model, speed, lname as lastn, fname as firstn, length, width, length * width as surface from SpaceShip",
    resultSetMapping="compositekey")
} )
public class SpaceShip {
    private String name;
    private String model;
    private double speed;
    private Captain captain;
    private Dimensions dimensions;

    @Id
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @ManyToOne(fetch= FetchType.LAZY)
    @JoinColumns( {
            @JoinColumn(name="fname", referencedColumnName = "firstname"),
            @JoinColumn(name="lname", referencedColumnName = "lastname")
            } )
    public Captain getCaptain() {
        return captain;
    }

    public void setCaptain(Captain captain) {
        this.captain = captain;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }

    public Dimensions getDimensions() {
        return dimensions;
    }

    public void setDimensions(Dimensions dimensions) {
        this.dimensions = dimensions;
    }
}

@Entity
@IdClass(Identity.class)
public class Captain implements Serializable {
    private String firstname;
    private String lastname;

    @Id
    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    @Id
    public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }
}
</programlisting>

      <note>
        <para>Si vous regardez la propriété dimension, vous verrez qu'Hibernate
        prend en charge la notation avec les points pour les objets embarqués
        (vous pouvez même avoir des objets embarqués imbriqués). Les
        implémentations EJB3 n'ont pas à prendre en charge cette fonctionnalité,
        mais nous le faisons :-)</para>
      </note>

      <para>Si vous récupérez une simple entité et si vous utilisez le mapping
      par défaut, vous pouvez utiliser l'attribut <literal>resultClass</literal>
      à la place de <literal>resultSetMapping</literal> :</para>

      <programlisting><emphasis role="bold">@NamedNativeQuery(name="implicitSample", query="select * from SpaceShip",
    resultClass=SpaceShip.class)</emphasis>
public class SpaceShip {</programlisting>

      <para>Dans certaines de vos requêtes natives, vous devrez retourner des
      valeurs scalaires, par exemple lors de la construction de requêtes de
      rapport. Vous pouvez les mapper dans
      <literal>@SqlResultsetMapping</literal> avec
      <literal>@ColumnResult</literal>. En fait, vous pouvez même mélanger des
      retours d'entités et de valeurs scalaires dans la même requête native (ce
      n'est cependant probablement pas commun).</para>

      <programlisting><emphasis role="bold">@SqlResultSetMapping(name="scalar", columns=@ColumnResult(name="dimension"))
@NamedNativeQuery(name="scalar", query="select length*width as dimension from SpaceShip", resultSetMapping="scalar")</emphasis></programlisting>

      <para>Une autre indication de fonctionnement spécifique aux requêtes
      natives a été présentée : <literal>org.hibernate.callable</literal>
      laquelle peut être à true ou à false fausse selon que la requête est une
      procédure stockée ou pas.</para>
    </sect2>
  </sect1>

  <sect1 id="entity-hibspec" xreflabel="Extensions d'Hibernate Annotation">
    <title>Extensions d'Hibernate Annotation</title>

    <para>Hibernate 3.1 offre une variété d'annotations supplémentaires que vous
    pouvez mélanger/faire correspondre avec des entités EJB3. Elles ont été
    conçues comme une extension naturelle aux annotations EJB3.</para>

    <para>Pour aller plus loin que les capacités d'EJB3, Hibernate fournit des
    annotations spécifiques qui correspondent aux fonctionnalités d'Hibernate.
    Le package <classname>org.hibernate.annotations</classname> contient toutes
    ces extensions d'annotations.</para>

    <sect2 id="entity-hibspec-entity" revision="2">
      <title>Entité</title>

      <para>Vous pouvez finement paramétrer certaines des actions faites par
      Hibernate sur les entités au-delà de ce qu'offre la spécification
      EJB3.</para>

      <para><classname>@org.hibernate.annotations.Entity</classname> ajoute des
      méta-données supplémentaires qui peuvent être nécessaires au-delà de ce
      qui est défini dans l'annotation <literal>@Entity</literal>
      standard :<itemizedlist>
          <listitem>
             mutable : indique si l'entité est modifiable ou non
          </listitem>

          <listitem>
             dynamicInsert : autorise le SQL dynamique pour les insertions
          </listitem>

          <listitem>
             dynamicUpdate : autorise le SQL dynamique pour les mise à jour
          </listitem>

          <listitem>
             selectBeforeUpdate : spécifie qu'Hibernate ne devrait jamais
             exécuter un UPDATE SQL à moins qu'il ne soit certain qu'un objet
             est réellement modifié
          </listitem>

          <listitem>
             polymorphism : indique si le polymorphisme d'entité est de type
             PolymorphismType.IMPLICIT (valeur par défaut) ou
             PolymorphismType.EXPLICIT
          </listitem>

          <listitem>
             persister : autorise la surcharge de l'implémentation de
             persistance fournie par défaut
          </listitem>

          <listitem>
             optimisticLock : stratégie de verrouillage optmiste
             (OptimisticLockType.VERSION,
             OptimisticLockType.NONE, OptimisticLockType.DIRTY ou
             OptimisticLockType.ALL)
          </listitem>
        </itemizedlist></para>

      <para><note>
          <para>@javax.persistence.Entity est encore obligatoire,
          @org.hibernate.annotations.Entity ne la remplace pas.</para>
        </note></para>

      <para>Voici quelques extensions d'annotations Hibernate
      supplémentaires.</para>

      <para><literal>@org.hibernate.annotations.BatchSize</literal> vous permet
      de définir la taille du batch lors de la récupération d'instances de
      cette entité (p. ex. <literal>@BatchSize(size=4)</literal>). Lors du
      chargement d'une entité donnée, Hibernate chargera alors toutes les
      entités non initialisées du même type dans le contexte de la persistance
      jusqu'à la taille du batch.</para>

      <para><literal>@org.hibernate.annotations.Proxy</literal> définit les
      attributs de chargement de l'entité. lazy (valeur par défaut) définit si
      la classe est chargée à la demande ou non. proxyClassName est l'interface
      utilisée pour générer le proxy (par défaut, la classe elle-même).</para>

      <para><literal>@org.hibernate.annotations.Where</literal> définit une
      clause WHERE SQL optionnelle utilisée lorsque des instances de cette
      classe sont récupérées.</para>

      <para><literal>@org.hibernate.annotations.Check</literal> déclare une
      contrainte de vérification optionnelle définie dans l'expression
      DDL.</para>

      <para><literal>@OnDelete(action=OnDeleteAction.CASCADE)</literal> sur des
      classes filles jointes : utilise une commande SQL DELETE en cascade lors
      de la suppression plutôt que le mécanisme habituel d'Hibernate.</para>

      <para><literal>@Table(appliesTo="tableName", indexes = {
      @Index(name="index1", columnNames={"column1", "column2"} ) } )</literal>
      crée les index définis sur les colonnes de la table
      <literal>tableName</literal>. Cela peut s'appliquer sur une table primaire
      ou une table secondaire. L'annotation <literal>@Tables</literal> vous
      permet d'avoir des index sur des tables différentes. Cette annotation est
      attendue là où <literal>@javax.persistence.Table</literal> ou
      <literal>@javax.persistence.SecondaryTable</literal>(s) sont
      déclarées.</para>

      <note>
        <para><literal>@org.hibernate.annotations.Table</literal> est un
        complément, pas un remplacement de
        <literal>@javax.persistence.Table</literal>. Surtout, si vous souhaitez
        changer le nom par défaut d'une table, vous devez utiliser
        <literal>@javax.persistence.Table</literal>, pas
        <literal>@org.hibernate.annotations.Table</literal>.</para>
      </note>

      <para><programlisting>@Entity
@BatchSize(size=5)
@org.hibernate.annotations.Entity(
        selectBeforeUpdate = true,
        dynamicInsert = true, dynamicUpdate = true,
        optimisticLock = OptimisticLockType.ALL,
        polymorphism = PolymorphismType.EXPLICIT)
@Where(clause="1=1")
@org.hibernate.annotations.Table(name="Forest", indexes = { @Index(name="idx", columnNames = { "name", "length" } ) } )
public class Forest { ... }</programlisting><programlisting>@Entity
@Inheritance(
    strategy=InheritanceType.JOINED
)
public class Vegetable { ... }

@Entity
@OnDelete(action=OnDeleteAction.CASCADE)
public class Carrot extends Vegetable { ... }</programlisting></para>
    </sect2>

    <sect2 id="entity-hibspec-identifier" revision="1">
      <title>Identifiant</title>

      <para><literal>@org.hibernate.annotations.GenericGenerator</literal> vous
      permet de définir un générateur d'identifiants Hibernate
      spécifique.</para>

      <para><programlisting>@Id @GeneratedValue(generator="system-uuid")
@GenericGenerator(name="system-uuid", strategy = "uuid")
public String getId() {

@Id @GeneratedValue(generator="hibseq")
@GenericGenerator(name="hibseq", strategy = "seqhilo",
    parameters = {
        @Parameter(name="max_lo", value = "5"),
        @Parameter(name="sequence", value="heybabyhey")
    }
)
public Integer getId() {</programlisting></para>

      <para><literal>strategy</literal> est le nom court de la stratégie du
      générateur Hibernate3 ou le nom pleinement qualifié de la classe d'une
      implémentation de <classname>IdentifierGenerator</classname>. Vous pouvez
      ajouter des paramètres avec l'attribut
      <literal>parameters</literal>.</para>

      <para>Contrairement à son pendant standard,
      <literal>@GenericGenerator</literal> peut ête utilisée dans les
      annotations au niveau du package, en faisant ainsi un générateur de niveau
      applicatif (comme s'il était dans un fichier JPA XML).</para>

      <programlisting>@GenericGenerator(name="hibseq", strategy = "seqhilo",
    parameters = {
        @Parameter(name="max_lo", value = "5"),
        @Parameter(name="sequence", value="heybabyhey")
    }
)
package org.hibernate.test.model</programlisting>
    </sect2>

    <sect2 id="entity-hibspec-property" revision="2">
      <title>Propriété</title>

      <sect3>
        <title>Type d'accès</title>

        <para>Le type d'accès est déduit de la position de
        <literal>@Id</literal> ou de <literal>@EmbeddedId</literal> dans la
        hiérarchie de l'entité. Les entités filles, les objets embarqués et les
        entités parentes mappés héritent du type d'accès de l'entité
        racine.</para>

        <para>Dans Hibernate, vous pouvez surcharger le type d'accès
        pour :</para>

        <itemizedlist>
          <listitem>
            <para>utiliser une stratégie d'accès personnalisée</para>
          </listitem>

          <listitem>
            <para>paramétrer finement le type d'accès au niveau de la classe ou
            au niveau de la propriété</para>
          </listitem>
        </itemizedlist>

        <para>Une annocation @AccessType a été présentée pour prendre en charge
        ce comportement. Vous pouvez définir le type d'accès sur :</para>

        <itemizedlist>
          <listitem>
            <para>une entité</para>
          </listitem>

          <listitem>
            <para>une classe parente</para>
          </listitem>

          <listitem>
            <para>un objet embarqué</para>
          </listitem>

          <listitem>
            <para>une propriété</para>
          </listitem>
        </itemizedlist>

        <para>Le type d'accès est surchargé pour l'élément annoté, si surchargé
        sur une classe, toutes les propriétés de la classe donnée héritent du
        type d'accès. Pour les entités racines, le type d'accès est considéré
        par défaut comme celui de la hiérarchie entière (surchargeable au niveau
        de la classe ou de la propriété).</para>

        <para>Si le type d'accès est marqué comme "propriété", les getters sont
        parcourus pour examiner les annotations, si le type d'accès est marqué
        comme "champ", ce sont les champs qui sont parcourus pour les
        annotations. Sinon les éléments marqués avec @Id ou @embeddedId sont
        scannés.</para>

        <para>Vous pouvez surcharger une type d'accès pour une propriété, mais
        l'élément annoté ne sera pas influencé : par exemple, une entité ayant
        un type d'accès <literal>field</literal>, peut annoter un champ avec
        <literal>@AccessType("property")</literal>, le type d'accès sera alors
        "property" pour cet attribut, des annotations devront encore être
        portées sur les champs.</para>

        <para>Si une classe parente ou un objet embarquable n'est pas annoté, le
        type d'accès de l'entité racine est utilisé (même si un type d'accès a
        été défini sur une classe parente ou un objet embarquable
        intermédiaire). Le principe de la poupée russe ne s'applique pas.</para>

        <programlisting>@Entity
public class Person implements Serializable {
    @Id  @GeneratedValue // type d'accès "champ"
    Integer id;

    @Embedded
    @AttributeOverrides({
    @AttributeOverride(name = "iso2", column = @Column(name = "bornIso2")),
    @AttributeOverride(name = "name", column = @Column(name = "bornCountryName"))
            })
    Country bornIn;
}

@Embeddable
<emphasis role="bold">@AccessType("property")</emphasis> // surcharge le type d'accès pour toutes les propriétés dans Country
public class Country implements Serializable {
    private String iso2;
    private String name;

    public String getIso2() {
        return iso2;
    }

    public void setIso2(String iso2) {
        this.iso2 = iso2;
    }

    @Column(name = "countryName")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</programlisting>
      </sect3>

      <sect3>
        <title>Formule</title>

        <para>Parfois, vous voulez effectuer certains calculs par la base de
        données plutôt que par la JVM, ou vous pourriez aussi vouloir créer une
        sorte de colonne virtuelle. Vous pouvez utilisez un fragment SQL (alias
        une formule) plutôt que de mapper un propriété sur une colonne. Cette
        sorte de propriété est en lecture seule (sa valeur est calculée par
        votre formule).</para>

        <programlisting>@Formula("obj_length * obj_height * obj_width")
public long getObjectVolume()</programlisting>

        <para>Le fragment SQL peut être aussi complexe que vous le souhaitez,
        même avec des sous-selects inclus.</para>
      </sect3>

      <sect3>
        <title>Type</title>

        <para><literal>@org.hibernate.annotations.Type</literal> surcharge le
        type Hibernate utilisé par défaut : ce n'est généralement pas nécessaire
        puisque le type est correctement inféré par Hibernate. Veuillez vous
        référer au guide de référence Hibernate pour plus d'informations sur les
        types Hibernate.</para>

        <para><literal>@org.hibernate.annotations.TypeDef</literal> et
        <literal>@org.hibernate.annotations.TypeDefs</literal> vous permettent
        de déclarer des définitions de type. Ces annotations sont placées au
        niveau de la classe ou du package. Notez que ces définitions seront
        globales pour la session factory (même au niveau de la classe) et que la
        définition du type doit être définie avant n'importe quelle
        utilisation.</para>

        <programlisting>@TypeDefs(
    {
    @TypeDef(
        name="caster",
        typeClass = CasterStringType.class,
        parameters = {
            @Parameter(name="cast", value="lower")
        }
    )
    }
)
package org.hibernate.test.annotations.entity;

...
public class Forest {
    @Type(type="caster")
    public String getSmallText() {
    ...
}
         </programlisting>

        <para>Lors de l'utilisation d'un type utilisateur composé, vous devrez
        exprimer les définitions des colonnes. L'annotation
        <literal>@Columns</literal> a été mise en place dans ce but.</para>

        <programlisting>@Type(type="org.hibernate.test.annotations.entity.MonetaryAmountUserType")
@Columns(columns = {
    @Column(name="r_amount"),
    @Column(name="r_currency")
})
public MonetaryAmount getAmount() {
    return amount;
}


public class MonetaryAmount implements Serializable {
    private BigDecimal amount;
    private Currency currency;
    ...
}</programlisting>
      </sect3>

      <sect3>
        <title>Index</title>

        <para>Vous pouvez définir un index sur une colonne particulière en
        utilisant l'annotation <literal>@Index</literal> sur une propriété d'une
        colonne, l'attribut columnNames sera ignoré.</para>

        <programlisting>@Column(secondaryTable="Cat1")
@Index(name="story1index")
public String getStoryPart1() {
    return storyPart1;
}</programlisting>
      </sect3>

      <sect3>
        <title>@Parent</title>

        <para>A l'intérieur d'un objet embarquable, vous pouvez définir
        une des propriétés comme un pointeur vers l'élément
        propriétaire.</para>

        <programlisting>@Entity
public class Person {
    @Embeddable public Address address;
    ...
}

@Embeddable
public class Address {
    @Parent public Person owner;
    ...
}


person == person.address.owner</programlisting>
      </sect3>

      <sect3>
        <title>Propriétés générées</title>

        <para>Certaines propriétés sont générées au moment de l'insertion ou de
        la mise à jour par votre base de données. Hibernate peut traiter de
        telles propriétés et déclencher un select subséquent pour lire ces
        propriétés.</para>

        <programlisting>@Entity
public class Antenna {
    @Id public Integer id;
    @Generated(GenerationTime.ALWAYS) @Column(insertable = false, updatable = false)
    public String longitude;

    @Generated(GenerationTime.INSERT) @Column(insertable = false)
    public String latitude;
}</programlisting>

        <para>Quand vous annotez votre propriété avec
        <literal>@Generated</literal>, vous devez vous assurer que l'insertion
        et la mise à jour n'entreront pas en conflit avec la stratégie de
        génération que vous avez choisie. Lorsque GenerationTime.INSERT est
        choisi, la propriété ne doit pas contenir de colonnes insérables ;
        lorsque GenerationTime.ALWAYS est choisi, la propriété ne doit pas
        contenir de colonnes qui puissent être insérées ou mises à jour.</para>

        <para>Les propriétés <literal>@Version</literal> ne peuvent pas (par
        conception) être <literal>@Generated(INSERT)</literal>, elles doivent
        être <literal>NEVER</literal> ou <literal>ALWAYS</literal>.</para>
      </sect3>
    </sect2>

    <sect2 id="entity-hibspec-inheritance" revision="1">
      <title>Héritage</title>

      <para>SINGLE_TABLE est une stratégie très puissante mais parfois, et
      surtout pour des systèmes pré-existants, vous ne pouvez pas ajouter une
      colonne discriminante supplémentaire. Pour cela Hibernate a mis en place
      la notion de formule discriminante :
      <literal>@DiscriminatorFormula</literal> est une remplaçcant de
      <literal>@DiscriminatorColumn</literal> et utilise un fragment SQL en tant
      que formule pour la résolution du discriminant (pas besoin d'avoir une
      colonne dédiée).</para>

      <programlisting>@Entity
@DiscriminatorForumla("case when forest_type is null then 0 else forest_type end")
public class Forest { ... }</programlisting>

      <para>Par défaut, lors du requêtage sur les entités les plus hautes,
      Hibernate ne met pas de restriction sur la colonne discriminante. Ceci
      peut être un inconvénient si cette colonne contient des valeurs qui ne sont
      pas mappées dans votre hiérarchie (avec
      <literal>@DiscriminatorValue</literal>). Pour contourner ca, vous pouvez
      utilser <literal>@ForceDiscriminator</literal> (au niveau de la classe,
      à côté de <literal>@DiscriminatorColumn</literal>). Hibernate listera
      alors les valeurs disponibles lors du chargement des entités.</para>
    </sect2>

    <sect2 id="entity-hibspec-singleassoc">
      <title>Annotations concernant les simples associations</title>

      <para>Par défaut, lorsqu'Hibernate ne peut pas résoudre l'association
      parce que l'élément associé attendu n'est pas dans la base de données
      (mauvais identifiant sur la colonne de l'association), une exception est
      levée par Hibernate. Cela pourrait être un inconvénient pour des schémas
      pré-existants et mal maintenus. Vous pouvez demander à Hibernate d'ignorer
      de tels éléments plutôt que de lever une exception en utilisant
      l'annotation <literal>@NotFound</literal>. Cette annotation peut être
      utilisée sur une association <literal>@OneToOne</literal> (avec une clef
      étrangère), <literal>@ManyToOne</literal>, <literal>@OneToMany</literal>
      ou <literal>@ManyToMany</literal>.</para>

      <programlisting>@Entity
public class Child {
    ...
    @ManyToOne
    @NotFound(action=NotFoundAction.IGNORE)
    public Parent getParent() { ... }
    ...
}</programlisting>

      <para>Parfois vous voulez déléguer à votre base de données la suppression
      en cascade lorsqu'une entité donnée est supprimée.</para>

      <programlisting>@Entity
public class Child {
    ...
    @ManyToOne
    @OnDelete(action=OnDeleteAction.CASCADE)
    public Parent getParent() { ... }
    ...
}</programlisting>

      <para>Dans ce cas, Hibernate génère une contrainte de suppression en
      cascade au niveau de la base de données.</para>

      <para>Les contraintes de clef étrangère, bien que générées par Hibernate,
      ont un nom justement illisible. Vous pouvez surcharger le nom de la
      contrainte par l'utilisation de <literal>@ForeignKey</literal>.</para>

      <programlisting>@Entity
public class Child {
    ...
    @ManyToOne
    <emphasis role="bold">@ForeignKey(name="FK_PARENT")</emphasis>
    public Parent getParent() { ... }
    ...
}

alter table Child add constraint FK_PARENT foreign key (parent_id) references Parent</programlisting>

      <sect3>
        <title>Options de chargement et modes de récupération</title>

        <para>EJB3 arrive avec l'option <literal>fetch</literal> pour définir
        le chargement à la demande et les modes de récupération, cependant
        Hibernate a beaucoup plus d'options dans ce domaine. Pour finement
        paramétrer le chargement à la demande et les stratégies de récupération,
        quelques annotations supplémentaires ont été mises en place :</para>

        <itemizedlist>
          <listitem>
            <para><literal>@LazyToOne</literal> : définit l'option de chargement
            à la demande sur les associations <literal>@ManyToOne</literal> et
            <literal>@OneToOne</literal>. <literal>LazyToOneOption</literal>
            peut être <literal>PROXY</literal> (ie utiliser un chargement à la
            demande basé sur un proxy), <literal>NO_PROXY</literal> (utilise
            un chargement à la demande sur l'ajout de bytecode - notez qu'un
            temps de construction du bytecode est nécessaire) et
            <literal>FALSE</literal> (association sans chargement à la
            demande) ;</para>
          </listitem>

          <listitem>
            <para><literal>@LazyCollection</literal> : définit l'option de
            chargement à la demande sur les associations
            <literal>@ManyToMany</literal> et <literal>@OneToMany</literal>.
            LazyCollectionOption peut être <literal>TRUE</literal> (la
            collection est chargée à la demande lorsque son état est accédé),
            <literal>EXTRA</literal> (la collection est chargée à la demande et
            toutes les opérations essaieront d'éviter le chargement de la
            collection, c'est surtout utile pour de grosses collections lorsque
            le chargement de tous les éléments n'est pas nécessaire) et
            <literal>FALSE</literal> (association sans chargement à la
            demande) ;</para>
          </listitem>

          <listitem>
            <para><literal>@Fetch</literal> : définit une stratégie de
            récupération utilisée pour charger l'association.
            <literal>FetchMode</literal> peut être
            <literal>SELECT</literal> (un select est déclenché lorsque
            l'association a besoin d'être chargée), <literal>SUBSELECT</literal>
            (disponible uniquement pour des collections, utilise une stratégie
            de sous select - veuillez vous référer à la documentation de
            référence d'Hibernate pour plus d'informations) ou
            <literal>JOIN</literal> (utilise un JOIN SQL pour charger
            l'association lors du chargement de l'entité propriétaire).
            <literal>JOIN</literal> surcharge n'importe quel attribut de
            chargement à la demande (une association chargée avec la stratégie
            <literal>JOIN</literal> ne peut pas être chargée à la
            demande).</para>
          </listitem>
        </itemizedlist>

        <para>Les annotations Hibernate surchargent les options de récupération
        EJB3.</para>

        <table>
          <title>Chargement à la demande et options de récupération
          équivalentes</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry>Annotations</entry>

                <entry>Chargement à la demande</entry>

                <entry>Récupération</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>@[One|Many]ToOne](fetch=FetchType.LAZY)</entry>

                <entry>@LazyToOne(PROXY)</entry>

                <entry>@Fetch(SELECT)</entry>
              </row>

              <row>
                <entry>@[One|Many]ToOne](fetch=FetchType.EAGER)</entry>

                <entry>@LazyToOne(FALSE)</entry>

                <entry>@Fetch(JOIN)</entry>
              </row>

              <row>
                <entry>@ManyTo[One|Many](fetch=FetchType.LAZY)</entry>

                <entry>@LazyCollection(TRUE)</entry>

                <entry>@Fetch(SELECT)</entry>
              </row>

              <row>
                <entry>@ManyTo[One|Many](fetch=FetchType.EAGER)</entry>

                <entry>@LazyCollection(FALSE)</entry>

                <entry>@Fetch(JOIN)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect3>
    </sect2>

    <sect2 id="entity-hibspec-collection" revision="2">
      <title>Annotations concernant les collections</title>

      <sect3 id="entity-hibspec-collection-enhance" revision="2">
        <title>Améliorer les configurations des collections</title>

        <para>Il est possible de configurer :<itemizedlist>
            <listitem>
               la taille des batchs pour les collections en utilisant @BatchSize
            </listitem>

            <listitem>
               la clause where, en utilisant @Where (appliquée à l'entité cible)
               ou @WhereJoinTable (appliquée à la table de l'association)
            </listitem>

            <listitem>
               la clause de vérification, en utilsant @Check
            </listitem>

            <listitem>
               la clause SQL order by, en utilisant @OrderBy
            </listitem>

            <listitem>
               la stratégie de suppression en cascade avec
               @OnDelete(action=OnDeleteAction.CASCADE)
            </listitem>
          </itemizedlist></para>

        <para>Vous pouvez aussi déclarer un comparateur de tri, utilisez
        l'annotation <literal>@Sort</literal>. Exprimez le type de comparateur
        que vous voulez entre "non trié" (NdT : unsorted), "ordre naturel"
        (NdT : natural) ou un comparateur personnalisé. Si vous voulez utilisez
        votre propre implémentation de comparateur, vous devrez indiquer la
        classe d'implémentation en utilisant l'attribut
        <literal>comparator</literal>. Notez que vous avez besoin d'utiliser
        l'interface <classname>SortedSet</classname> ou
        <classname>SortedMap</classname>.</para>

        <programlisting>    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @JoinColumn(name="CUST_ID")
    @Sort(type = SortType.COMPARATOR, comparator = TicketComparator.class)
    @Where(clause="1=1")
    @OnDelete(action=OnDeleteAction.CASCADE)
    public SortedSet&lt;Ticket&gt; getTickets() {
        return tickets;
    }</programlisting>

        <para>Veuillez vous référer aux descriptions précédentes de ces
        annotations pour plus d'informations.</para>

        <para>Les contraintes de clef étrangère, bien que générées par
        Hibernate, ont un nom illisible. Vous pouvez surcharger le nom de la
        contrainte en utilisant <literal>@ForeignKey</literal>. Notez que cette
        annotation doit être placée du côté possédant la relation,
        <literal>inverseName</literal> référençant la contrainte de l'autre
        côté.</para>

        <programlisting>@Entity
public class Woman {
    ...
    @ManyToMany(cascade = {CascadeType.ALL})
    <emphasis role="bold">@ForeignKey(name = "TO_WOMAN_FK", inverseName = "TO_MAN_FK")</emphasis>
    public Set&lt;Man&gt; getMens() {
        return mens;
    }
}

alter table Man_Woman add constraint TO_WOMAN_FK foreign key (woman_id) references Woman
alter table Man_Woman add constraint TO_MAN_FK foreign key (man_id) references Man</programlisting>
      </sect3>

      <sect3 id="entity-hibspec-collection-extratype" revision="1">
        <title>Types de collection extra</title>

        <sect4>
          <title>List</title>

          <para>Outre EJB3, Hibernate Annotations prend en charge les véritables
          <classname>List</classname> et <classname>Array</classname>. Mappez
          votre collection de la même manière que d'habitude et ajoutez
          l'annotation @<literal>IndexColumn</literal>. Cette annotation vous
          permet de décrire la colonne qui contiendra l'index. Vous pouvez aussi
          déclarer la valeur de l'index en base de données qui représente le
          premier élément (alias index de base). La valeur habituelle est
          <literal>0</literal> ou <literal>1</literal>.</para>

          <programlisting>@OneToMany(cascade = CascadeType.ALL)
@IndexColumn(name = "drawer_position", base=1)
public List&lt;Drawer&gt; getDrawers() {
    return drawers;
}</programlisting>

          <note>
            <para>Si vous oubliez de positionner
            <literal>@IndexColumn</literal>, la sémantique du bag est appliquée.
            Si vous voulez la sémantique du bag sans ses limitations, considérez
            l'utilisation de <literal>@CollectionId</literal>.</para>
          </note>
        </sect4>

        <sect4>
          <title>Map</title>

          <para>Hibernate Annotations prend aussi en charge le mapping de
          véritables Maps, si <literal>@javax.persistence.MapKey</literal> n'est
          pas positionnée, Hibernate mappera l'élément clef ou l'objet
          embarquable dans ses propres colonnes. Pour surcharger les colonnes
          par défaut, vous pouvez utiliser
          <literal>@org.hibernate.annotations.MapKey</literal> si votre clef est
          un type de base (par défaut à <literal>mapkey</literal>) ou un objet
          embarquable, ou vous pouvez utiliser
          <literal>@org.hibernate.annotations.MapKeyManyToMany</literal> si
          votre clef est une entité.</para>
        </sect4>

        <sect4 id="entity-hibspec-collection-extratype-indexbidir">
          <title>Associations bidirectionnelle avec des collections indexées</title>

          <para>Une association bidirectionnelle où une extrémité est
          représentée comme une <literal>@IndexColumn</literal> ou une
          <literal>@org.hibernate.annotations.MapKey[ManyToMany]</literal>
          requiert une considération spéciale. S'il y a une propriété de la
          classe enfante qui mappe la colonne de l'index, pas de problème, nous
          pouvons continuer en utilisant <literal>mappedBy</literal> sur le
          mapping de la collection :</para>

          <programlisting>@Entity
public class Parent {
    @OneToMany(mappedBy="parent")
    @org.hibernate.annotations.MapKey(columns=@Column(name="name"))
    private Map&lt;String, Child&gt; children;
    ...
}

@Entity
public class Child {
    ...
    @Basic
    private String name;

    @ManyToOne
    @JoinColumn(name="parent_id", nullable=false)
    private Parent parent;
    ...
}</programlisting>

          <para>Mais s'il n'y a pas de telle propriété sur la classe enfante,
          nous ne pouvons pas penser que l'association est vraiment
          bidirectionnelle (il y a des informations disponibles à une extrémité
          qui ne sont pas disponibles à l'autre). Dans ce cas, nous ne pouvons
          pas mapper la collection avec <literal>mappedBy</literal>. A la place,
          nous pourrions utiliser le mapping suivant :</para>

          <programlisting>@Entity
public class Parent {
    @OneToMany
    @org.hibernate.annotations.MapKey(columns=@Column(name="name"))
    @JoinColumn(name="parent_id", nullable=false)
    private Map&lt;String, Child&gt; children;
    ...
}

@Entity
public class Child {
    ...
    @ManyToOne
    @JoinColumn(name="parent_id", insertable=false, updatable=false, nullable=false)
    private Parent parent;
    ...
}</programlisting>

          <para>Notez que dans ce mapping, l'extrémité de l'association dont la
          valeur est une collection est responsable des mises à jour pour la
          clef étrangère.</para>
        </sect4>

        <sect4>
          <title>Bag avec une clef primaire</title>

          <para>Une autre fonctionnalité intéressante est la possibilité de
          définir une clef primaire subrogée à une collection bag. Ceci enlève
          pas mal d'inconvénients des bags : mise à jour et suppression
          sont efficaces, plus d'un bag <literal>EAGER</literal> par requête ou
          par entité. Cette clef primaire sera contenue dans une colonne
          supplémentaire de votre table de collection mais ne sea pas visible
          par l'application Java. @CollectionId est utilisée pour marquer une
          collection comme "id bag", ca permet aussi de surcharger les colonnes
          de la clef primaire, le type de la clef primaire et la stratégie du
          générateur. La stratégie peut être <literal>identity</literal>, ou
          n'importe quel nom de générateur défini de votre application.</para>

          <programlisting>@Entity
@TableGenerator(name="ids_generator", table="IDS")
public class Passport {
    ...

    @ManyToMany(cascade = CascadeType.ALL)
    @JoinTable(name="PASSPORT_VISASTAMP")
    <emphasis role="bold">@CollectionId(
        columns = @Column(name="COLLECTION_ID"),
        type=@Type(type="long"),
        generator = "ids_generator"
    )</emphasis>
    private Collection&lt;Stamp&gt; visaStamp = new ArrayList();
    ...
}</programlisting>
        </sect4>

        <sect4>
          <title>Collection d'éléments ou d'éléments composés</title>

          <para>Hibernate Annotations prend aussi en charge les collections de
          types core (Integer, String, Enums, ...), les collections d'objets
          embarquables et même les tableaux de types primitifs. Ce sont des
          collections d'éléments.</para>

          <para>Une collection d'éléments doit être annotée comme
          <literal>@CollectionOfElements</literal> (en tant que remplaçant de
          <literal>@OneToMany</literal>). Pour définir la table de la
          collection, l'annotation <literal>@JoinTable</literal> est utilisée
          sur la propriété de l'association, <literal>joinColumns</literal>
          définit les colonnes de jointure entre la table de l'entité primaire
          et la table de la collection (inverseJoincolumn est inutile et
          devrait être laissé à vide). Pour une collection de types core ou un
          tableau de types primitifs, vous pouvez surcharger la définition de la
          colonne de l'élément en utilisant <literal>@Column</literal> sur la
          propriété de l'association. Vous pouvez aussi surcharger les colonnes
          d'une collection d'objets embarquables en utilisant
          <literal>@AttributeOverride</literal>. Pour atteindre l'élément de la
          collection, vous avez besoin d'ajouter "element" au nom de l'attribut
          surchargé (p. ex. "element" pour les types core, ou "element.serial"
          pour la propriété serial d'un élément embarqué). Pour atteindre
          l'index/clef d'une collection, ajoutez "key" à la place.</para>

          <programlisting>@Entity
public class Boy {
    private Integer id;
    private Set&lt;String&gt; nickNames = new HashSet&lt;String&gt;();
    private int[] favoriteNumbers;
    private Set&lt;Toy&gt; favoriteToys = new HashSet&lt;Toy&gt;();
    private Set&lt;Character&gt; characters = new HashSet&lt;Character&gt;();

    @Id @GeneratedValue
    public Integer getId() {
        return id;
    }

    <emphasis role="bold">@CollectionOfElements
    public Set&lt;String&gt;</emphasis> getNickNames() {
        return nickNames;
    }

    <emphasis role="bold">@CollectionOfElements
    @JoinTable(
            table=@Table(name="BoyFavoriteNumbers"),
            joinColumns = @JoinColumn(name="BoyId")
    )
    @Column(name="favoriteNumber", nullable=false)</emphasis>
    @IndexColumn(name="nbr_index")
    public int[] getFavoriteNumbers() {
        return favoriteNumbers;
    }

    <emphasis role="bold">@CollectionOfElements
    @AttributeOverride( name="element.serial", column=@Column(name="serial_nbr") )</emphasis>
    public Set&lt;Toy&gt; getFavoriteToys() {
        return favoriteToys;
    }

    <emphasis role="bold">@CollectionOfElements
    public Set&lt;Character&gt;</emphasis> getCharacters() {
        return characters;
    }
    ...
}

public enum Character {
    GENTLE,
    NORMAL,
    AGGRESSIVE,
    ATTENTIVE,
    VIOLENT,
    CRAFTY
}

@Embeddable
public class Toy {
    public String name;
    public String serial;
    public Boy owner;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSerial() {
        return serial;
    }

    public void setSerial(String serial) {
        this.serial = serial;
    }

    <emphasis role="bold">@Parent</emphasis>
    public Boy getOwner() {
        return owner;
    }

    public void setOwner(Boy owner) {
        this.owner = owner;
    }

    public boolean equals(Object o) {
        if ( this == o ) return true;
        if ( o == null || getClass() != o.getClass() ) return false;

        final Toy toy = (Toy) o;

        if ( !name.equals( toy.name ) ) return false;
        if ( !serial.equals( toy.serial ) ) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = name.hashCode();
        result = 29 * result + serial.hashCode();
        return result;
    }
}</programlisting>

          <para>Sur une collection d'objets embarquables, l'objet embarquable
          peut avoir une propriété annotée avec <literal>@Parent</literal>.
          Cette propriété pointera alors vers l'entité contenant la
          collection.</para>

          <note>
            <para>Les versions précédentes d'Hibernate Annotations utilisaient
            <literal>@OneToMany</literal> pour marquer une collection
            d'éléments. Suite à des incohérences sémantiques, nous avons mis en
            place l'annotation <literal>@CollectionOfElements</literal>. Pour
            marquer des collections d'éléments, l'ancienne façon fonctionne
            encore mais elle est considérée comme "deprecated" et ne sera plus
            prise en charge dans les futures versions.</para>
          </note>
        </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Cache</title>

      <para>Pour optimiser vos accès à la base de données, vous pouvez activer
      le cache de second niveau d'Hibernate. Ce cache est configurable par
      entité et par collection.</para>

      <para><literal>@org.hibernate.annotations.Cache</literal> définit la
      stratégie de cache et la région du cache de second niveau donné. Cette
      annotation peut être appliquée à une entité racine (pas les entités
      filles), et sur les collections.</para>

      <programlisting>@Entity
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public class Forest { ... }</programlisting>

      <programlisting>    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @JoinColumn(name="CUST_ID")
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    public SortedSet&lt;Ticket&gt; getTickets() {
        return tickets;
    }</programlisting>

      <para></para>

      <programlistingco>
        <areaspec>
          <area coords="2" id="hm1" />

          <area coords="3" id="hm2" />

          <area coords="4" id="hm3" />
        </areaspec>

        <programlisting>@Cache(
    CacheConcurrencyStrategy usage();
    String region() default "";
    String include() default "all";
)</programlisting>

        <calloutlist>
          <callout arearefs="hm1">
            <para>usage : la stratégie de concurrence du cache donné (NONE,
            READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL) ;</para>
          </callout>

          <callout arearefs="hm2">
            <para>region (optionnel) : la région du cache (par défaut le nom
            complet de la classe avec le nom du package, ou le nom complet du
            rôle de la collection) ;</para>
          </callout>

          <callout arearefs="hm3">
            <para><literal>include</literal> (optionnel) : "all" pour inclure
            toutes les propriétés, "non-lazy" pour inclure seulement les
            propriétés qui ne sont pas chargées à la demande (valeur par
            défaut : all).</para>
          </callout>
        </calloutlist>
      </programlistingco>
    </sect2>

    <sect2 id="entity-hibspec-filters">
      <title>Filtres</title>

      <para>Hibernate a la capacité d'appliquer des filtres arbitraires à la
      partie supérieure de vos données. Ces filtres sont appliqués au moment de
      l'exécution sur une session donnée. Vous avez tout d'abord besoin de les
      définir.</para>

      <para><literal>@org.hibernate.annotations.FilterDef</literal> ou
      <literal>@FilterDefs</literal> déclarent des définitions de filtre
      utilisées par les filtres ayant le même nom. Une définition de filtre a
      un name() et un tableau de parameters(). Un paramètre vous permettra
      d'ajuster le comportement du filtre au moment de l'exécution. Chaque
      paramètre est défini par une <literal>@ParamDef</literal> qui a un nom et
      un type. Vous pouvez aussi définir un paramètre defaultCondition() pour
      une <literal>@ParamDef</literal> donnée pour positionner la condition par
      défaut à utiliser lorsqu'aucune n'est définie dans chaque
      <literal>@Filter</literal> individuelle. Une <literal>@FilterDef</literal>
      peut être définie au niveau de la classe ou du package.</para>

      <para>Nous avons besoin de définir la clause du filtre SQL appliqué au
      chargement de l'entité ou au chargement de la collection.
      <literal>@Filter</literal> est utilisée et placée sur l'entité ou
      l'élément de la collection.</para>

      <para><programlisting>@Entity
@FilterDef(name="minLength", parameters=@ParamDef( name="minLength", type="integer" ) )
@Filters( {
    @Filter(name="betweenLength", condition=":minLength &lt;= length and :maxLength &gt;= length"),
    @Filter(name="minLength", condition=":minLength &lt;= length")
} )
public class Forest { ... }</programlisting></para>

      <para>Lorsque la collection utilise une table d'association comme
      représentation relationnelle, vous pourriez vouloir appliquer la condition
      du filtre à la table de l'association elle-même ou à la table de l'entité
      cible. Pour appliquer la contrainte sur l'entité cible, utilisez
      l'annotation habituelle <literal>@Filter</literal>. Cependant, si vous
      voulez ciblez la table d'association, utilisez l'annotation
      <literal>@FilterJoinTable</literal>.</para>

      <programlisting>    @OneToMany
    @JoinTable
    // filtre sur la table de l'entité cible
    @Filter(name="betweenLength", condition=":minLength &lt;= length and :maxLength &gt;= length")
    // filtre sur la table d'association
    @FilterJoinTable(name="security", condition=":userlevel &gt;= requredLevel")
    public Set&lt;Forest&gt; getForests() { ... }</programlisting>
    </sect2>

    <sect2 id="entity-hibspec-query">
      <title>Requête</title>

      <para>Puisqu'Hibernate a plus de fonctionnalités sur les requêtes nommées
      que définies dans la spécification EJB3,
      <literal>@org.hibernate.annotations.NamedQuery</literal>,
      <literal>@org.hibernate.annotations.NamedQueries</literal>,
      <literal>@org.hibernate.annotations.NamedNativeQuery</literal> et
      <literal>@org.hibernate.annotations.NamedNativeQueries</literal> ont été
      mis en place. Elles ajoutent des attributs à la version standard et
      peuvent être utilisées comme remplaçant :</para>

      <itemizedlist>
        <listitem>
          <para>flushMode : définit le mode de flush de la requête (Always,
          Auto, Commit ou Manual)</para>
        </listitem>

        <listitem>
          <para>cacheable : indique si la requête devrait être cachée ou
          non</para>
        </listitem>

        <listitem>
          <para>cacheRegion : région du cache utilisée si la requête est
          cachée</para>
        </listitem>

        <listitem>
          <para>fetchSize : taille de l'expression de récupération JDBC pour
          cette requête</para>
        </listitem>

        <listitem>
          <para>timeout : timeout de la requête</para>
        </listitem>

        <listitem>
          <para>callable : pour les requêtes natives seulement, mettre à true
          pour les procédures stockées</para>
        </listitem>

        <listitem>
          <para>comment : si les commentaires sont activés, le commentaire vu
          lorsque la requête est envoyée vers la base de données</para>
        </listitem>

        <listitem>
          <para>cacheMode : mode d'intéraction du cache (get, ignore, normal,
          put ou refresh)</para>
        </listitem>

        <listitem>
          <para>readOnly : indique si les éléments récupérés à partir de la
          requête sont en lecture seule ou pas</para>
        </listitem>
      </itemizedlist>

      <para>Ces indications de fonctionnement peuvent être positionnées sur
      les annotations standards <literal>@javax.persistence.NamedQuery</literal>
      avec l'annotation <literal>@QueryHint</literal>. Un autre avantage clef
      est la possibilité de positionner ces annotations au niveau du
      package.</para>
    </sect2>
  </sect1>
</chapter>
