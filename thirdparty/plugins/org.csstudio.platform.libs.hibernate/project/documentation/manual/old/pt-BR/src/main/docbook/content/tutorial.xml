<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="tutorial">
    <title>Introdu&#x00E7;&#x00E3;o ao Hibernate</title>
    
    <sect1 id="tutorial-intro" revision="1">
        <title>Prefácio</title>
        
        <para>
            Este cap&#x00ED;tulo &#x00E9; um tutorial introdut&#x00F3;rio para novos usuários do Hibernate. N&#x00F3;s iniciaremos com uma simples linha de comando em uma aplica&#x00E7;&#x00E3;o usando uma base de dados em mem&#x00F3;ria tornando isto um passo de fácil de compreender.
        </para>

        <para>
            Este tutorial &#x00E9; voltado para novos usuários do Hibernate, mas requer um conhecimento de Java e SQL. Este tutorial &#x00E9; baseado no tutorial de Michael Gloegl, as bibliotecas Third Party foram nomeadas para JDK 1.4 e 5.0. Você pode precisar de outras bibliotecas para JDK 1.3.
        </para>

        <para>
            O código fonte para o tutorial está incluído no diretório da distribuição 
            <literal>doc/reference/tutorial/</literal>. 
        </para>

    </sect1>
    
    <sect1 id="tutorial-firstapp" revision="2">
        <title>Parte 1 – A primeira aplicação Hibernate</title>

        <para>
            Primeiro, iremos criar uma simples aplica&#x00E7;&#x00E3;o Hibernate baseada em console. Usaremos uma base de dados Java (HSQL DB), ent&#x00E3;o n&#x00E3;o teremos que instalar nenhum servidor de base de dados.
        </para>

        <para>
            Vamos supor que precisemos de uma aplica&#x00E7;&#x00E3;o com um banco de dados pequeno que possa armazenar e atender os eventos que queremos, e as informa&#x00E7;&#x00E7;es sobre os hosts destes eventos. 
        </para>
            
        <para>
            A primeira coisa que devemos fazer &#x00E9; configurar nosso diret&#x00F3;rio de desenvolvimento, 
            e colocar todas as bibliotecas Java que precisamos dentro dele. Fa&#x00E7;a o download da 
            distribui&#x00E7;&#x00E3;o do Hibernate no site do Hibernate. Descompacte o pacote e coloque todas 
            as bibliotecas necessárias encontradas no diret&#x00F3;rio <literal>/lib</literal>, dentro do 
            diret&#x00F3;rio <literal>/lib</literal> do seu novo projeto. Você deverá ter algo parecido
            com isso:
        </para>
            
        <programlisting><![CDATA[.
+lib
  antlr.jar
  cglib.jar
  asm.jar
  asm-attrs.jars
  commons-collections.jar
  commons-logging.jar
  hibernate3.jar
  jta.jar
  dom4j.jar
  log4j.jar ]]></programlisting>

        <para>
            Esta &#x00E9; a configura&#x00E7;&#x00E3;o m&#x00ED;nima requerida das bibliotecas (observe que tamb&#x00E9;m foi copiado 
            o hibernate3.jar da pasta principal do Hibernate) para o Hibernate <emphasis>na hora do desenvolvimento</emphasis>. O Hibernate permite que você utilize mais ou menos bibliotecas. 
            Veja o arquivo <literal>README.txt</literal>  no diret&#x00F3;rio <literal>lib/</literal> da distribui&#x00E7;&#x00E3;o 
            do Hibernate para maiores informa&#x00E7;&#x00E7;es sobre bibliotecas requeridas e opcionais. 
            (Atualmente, a biblioteca Log4j n&#x00E3;o &#x00E9; requerida, mas &#x00E9; preferida por muitos desenvolvedores.)
        </para>

        <para>
            Agora, iremos criar uma classe que representa o evento que queremos armazenar na base de dados..
        </para>
      
        <sect2 id="tutorial-firstapp-firstclass" revision="1">
            <title>A primeira Classe</title>
            
            <para>
                Nossa primeira classe de persistência é uma simples classe JavaBean com algumas propriedades:
            </para>

            <programlisting><![CDATA[package events;

import java.util.Date;

public class Event {
    private Long id;

    private String title;
    private Date date;

    public Event() {}

    public Long getId() {
        return id;
    }

    private void setId(Long id) {
        this.id = id;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}]]></programlisting>

            <para>
                Você pode ver que esta classe usa o padrão JavaBean para o nomeamento convencional da propriedade getter e dos métodos setter, como também a visibilidade private dos campos. Este é um padrão de projeto recomendado, mas não requerido. O Hibernate pode também acessar campos diretamente, o benefício para os métodos de acesso é a robustez para o Refactoring. O construtor sem argumento é requerido para instanciar um objeto desta classe com a reflexão.
            </para>

            <para>
                A propriedade  <literal>id</literal> mantém um único valor de identificação para um evento 
                particular. Todas as classes persistentes da entidade (bem como aquelas classes dependentes 
                de menos importância) precisam de uma propriedade de identificação, caso nós queiramos usar o 
                conjunto completo de características do Hibernate. De fato, a maioria das aplicações 
                (esp. aplicações web)  precisam destinguir os objetos pelo identificador, então você deverá 
                considerar esta, uma característica em lugar de uma limitação. Porém, nós normalmente não 
                manipulamos a identidade de um objeto, consequentemente o método setter deverá ser privado. 
                O Hibernate somente nomeará os identificadores quando um objeto for salvo. Você pode ver como 
                o Hibernate pode acessar métodos públicos, privados, e protegidos, como também campos 
                (públicos, privados, protegidos) diretamente. A escolha está até você, e você pode combinar 
                isso para adaptar seu projeto de aplicação
            </para>

            <para>
                O construtor sem argumentos é um requerimento para todas as classes persistentes; 
                O Hibernate tem que criar para você os objetos usando Java Reflection.  O construtor 
                pode ser privado, porém, a visibilidade do pacote é requerida para a procuração da 
                geração em tempo de execução e recuperação eficiente dos dados sem a instrumentação 
                de bytecode 
            </para>

            <para>
                Coloque este fonte Java no diretório chamado <literal>src</literal> na pasta de desenvolvimento, 
                e em seu pacote correto. O diretório deverá ser parecido como este:
            </para>

            <programlisting><![CDATA[.
+lib
  <Hibernate and third-party libraries>
+src
  +events
    Event.java]]></programlisting>

            <para>
                No próximo passo, iremos falar sobre as classes de persistência do Hibernate..
            </para>
                
        </sect2>

        <sect2 id="tutorial-firstapp-mapping" revision="1">
            <title>O mapeamento do arquivo</title>

            <para>
                O Hibernate precisa saber como carregar e armazenar objetos da classe de 
                persistência. Isto será onde o mapeamento do arquivo do Hibernate entrará em 
                jogo. O arquivo mapeado informa ao Hibernate, qual tabela no banco de dados 
                ele deverá acessar, e quais as colunas na tabela ele deverá usar.
            </para>

            <para>
                A estrutura básica de um arquivo de mapeamento é parecida com:
            </para>

            <programlisting><![CDATA[<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping>
[...]
</hibernate-mapping>]]></programlisting>

            <para>
                Note que o Hibernate DTD é muito sofisticado. Você pode usar isso para auto-conclusão 
                no mapeamento XML dos elementos e atributos no seu editor ou IDE. Você também pode 
                abrir o arquivo DTD no seu editor – é a maneira mais fácil de ter uma visão geral 
                de todos os elementos e atributos e dos padrões, como também alguns comentários. 
                Note que o Hibernate não irá carregar o arquivo DTD da web, e sim do diretório 
                da aplicação (classpath). O arquivo DTD está incluído no  <literal>hibernate3.jar</literal> como 
                também no diretório <literal>src/</literal> da distribuição do Hibernate. 
            </para>

            <para>
                Nós omitiremos a declaração do DTD nos exemplos futuros para encurtar o código. Isto, é claro, não é opcional.
            </para>

            <para>
                Entre os dois tags <literal>hibernate-mapping</literal>, inclua um elemento <literal>class</literal>. 
                Todas as classes persistentes da entidade (novamente, poderá haver 
                mais tarde, dependências sobre as classes que não são classes-primárias 
                de entidades) necessitam do tal mapeamento, para uma tabela na base 
                de dados SQL
            </para>

            <programlisting><![CDATA[<hibernate-mapping>

    <class name="events.Event" table="EVENTS">

    </class>

</hibernate-mapping>]]></programlisting>

            <para>
                Mais adiante iremos dizer ao Hibernate como fazer para persistir e carregar objetos da classe 
                <literal>Event</literal> da tabela <literal>EVENTS</literal>, cada instancia representada por 
                uma coluna na tabela. Agora, continuaremos com o mapeamento de uma única propriedade identificadora 
                para as chaves primárias da tabela. Além disso, nós não iremos se importar com esta propriedade 
                identificadora, nós iremos configurar uma estratégia de geração de id’s para uma chave primária 
                de uma surrogate key: 
            </para>

            <programlisting><![CDATA[<hibernate-mapping>

    <class name="events.Event" table="EVENTS">
        <id name="id" column="EVENT_ID">
            <generator class="native"/>
        </id>
    </class>

</hibernate-mapping>]]></programlisting>

            <para>
                O elemento <literal>id</literal> é a declaração da propriedade identificadora, 
                o <literal>name="id"</literal> declara o nome da propriedade Java – 
                o Hibernate irá usar os métodos getter e setter para acessar a propriedade.
                O atributo da coluna informa ao Hibernate qual coluna da tabela  <literal>EVENTS</literal> nós 
                iremos usar como chave primária. O elemento <literal>generator</literal> especifica 
                a estratégia de geração do identificador, neste caso usaremos <literal>native</literal>, que 
                escolhe a melhor estratégia dependendo da base de dados (dialeto) configurada. 
                O Hibernate suporta a base de dados gerada, globalmente única, bem como a atribuição 
                aos identificadores da aplicação (ou toda estratégia escrita para uma extensão).
            </para>

            <para>
                Finalmente incluiremos as declarações para as propriedades persistentes da classe 
                no arquivo mapeado. Por default, nenhuma das propriedades da classe é considerada persistente:
            </para>
            
            <programlisting><![CDATA[
<hibernate-mapping>

    <class name="events.Event" table="EVENTS">
        <id name="id" column="EVENT_ID">
            <generator class="native"/>
        </id>
        <property name="date" type="timestamp" column="EVENT_DATE"/>
        <property name="title"/>
    </class>

</hibernate-mapping>]]></programlisting>
            
            <para>
                Da mesma maneira que com o elemento  <literal>id</literal>, o atributo <literal>name</literal> do elemento 
                <literal>property</literal> informa ao Hibernate qual método getter e setter deverá usar. 
                Assim, neste caso, o Hibernate irá procurar pelo <literal>getDate()/setDate()</literal>, 
                como também pelo <literal>getTitle()/setTitle()</literal>.
            </para>

            <para>
                Porque fazer o mapeamento da propriedade  <literal>date</literal> incluído no 
                atributo <literal>column</literal>, e no title não fazer? 
                Sem o atributo <literal>column</literal> o Hibernate por padrão usa o nome 
                da propriedade como o nome da coluna. Isto trabalha muito 
                bem para o  <literal>title</literal>. Entretanto o <literal>date</literal> é uma palavra-chave reservada 
                na maioria dos bancos de dados, assim nós melhoramos o mapeamentos 
                disto com um nome diferente.
            </para>

            <para>
                A próxima coisa interessante é que mapemanto do <literal>title</literal> 
                também falta o atributo <literal>type</literal>. O tipo que declaramos e o uso nos 
                arquivos mapeados, não são como você pôde esperar, atributos de dados Java. 
                Eles não são como os tipos de base de dados SQL. 
                Esses tipos podem ser chamados de <emphasis>Tipos de mapeamento Hibernate</emphasis>, que são conversores 
                que podem traduzir tipos de dados do Java para os tipos de dados SQL e vice-versa. 
                Novamente, o Hibernate irá tentar determinar a conversão correta e mapeará o <literal>type</literal> 
                próprio, caso o tipo do atributo não estiver presente no mapeamento. 
                Em alguns casos, esta detecção automática (que usa Reflection sobre as classes Java) 
                poderá não ter padrão que você espera ou necessita. 
                Este é o caso com a propriedade <literal>date</literal>. O Hibernate não pode saber se a propriedade 
                (que é do <literal>java.util.Date</literal>) pode mapear para uma coluna do tipo <literal>date</literal> 
                do SQL, <literal>timestamp</literal>, ou <literal>time</literal> . 
                Nós preservamos a informação cheia de datas e horas pelo mapeamento da propriedade com um conversor 
                 <literal>timestamp</literal>.
            </para>

            <para>
                Este arquivo de mapeamento deve ser salvo como <literal>Event.hbm.xml</literal>, 
                corretamente no diretório próximo ao arquivo fonte da Classe Java <literal>Event</literal>. 
                O nomeamento dos arquivos de mapeamento podem ser arbitrários, porém o sufixo 
                <literal>hbm.xml</literal> é uma convenção da comunidade dos desenvolvedores do Hibernate. 
                Esta estrutura do diretório deve agora se parecer com isso:
            </para>

            <programlisting><![CDATA[.
+lib
  <Hibernate and third-party libraries>
+src
  +events
    Event.java
    Event.hbm.xml]]></programlisting>

             <para>
                 Nós iremos continuar com a configuração principal do Hibernate.
             </para>

        </sect2>

        <sect2 id="tutorial-firstapp-configuration" revision="2">
            <title>Configuração do Hibernate</title>

            <para>
                Agora nós temos uma classe persistente e este arquivo de mapeamento no lugar. 
                Está na hora de configurar o Hibernate. Antes de fazermos isso, iremos precisar de uma base de dados. 
                O HSQL DB, um SQL DBMS feito em java, pode ser baixado através do site do HSQL DB(http://hsqldb.org/). 
                Atualmente, você só precisa baixar o <literal>hsqldb.jar</literal>. 
                Coloque este arquivo no diretório da pasta de desenvolvimento <literal>lib/</literal>.
            </para>

            <para>
                Crie um diretório chamado  <literal>data</literal> no diretório root de desenvolvimento – 
                Isto será onde o HSQL DB irá armazenar arquivos de dados. Agora iremos iniciar o banco de dados 
                executando  <literal>java -classpath ../lib/hsqldb.jar org.hsqldb.Server</literal> neste diretório de dados. 
                Você pode ver ele iniciando e conectando ao socket TCP/IP, isto será onde nossa aplicação irá se 
                conectar depois. Se você deseja iniciar uma nova base de dados durante este tutorial, 
                finalize o HSQL DB(pressionando o <literal>CTRL + C</literal> na janela), delete todos os 
                arquivos no diretório <literal>data/</literal>, e inicie o HSQL BD novamente.
            </para>

            <para>
                O Hibernate é uma camada na sua aplicação na qual se conecta com a base de dados, para isso
                necessita de informação da conexão. As conexões são feitas através de um pool de conexão JDBC, 
                na qual teremos que configurar. A distribuição do Hibernate contém diversas ferramentas de pooling 
                da conexão JDBC de fonte aberta, mas iremos usar o pool de conexão interna para este tutorial. 
                Note que você tem que copiar a biblioteca necessária em seu classpath e use configurações 
                diferentes para pooling de conexão caso você deseje utilizar um software de pooling JDBC terceirizado 
                para qualidade de produção.
            </para>

            <para>
                Para as configurações do Hibernate, nós podemos usar um arquivo simples <literal>hibernate.properties</literal>, 
                um arquivo mais ligeiramente sofisticado <literal>hibernate.cfg.xml</literal> ou até mesmo uma 
                instalação programática completa. A maioria dos usuários preferem utilizar o arquivo de configuração XML
            </para>

            <programlisting><![CDATA[<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>

    <session-factory>

        <!-- Database connection settings -->
        <property name="connection.driver_class">org.hsqldb.jdbcDriver</property>
        <property name="connection.url">jdbc:hsqldb:hsql://localhost</property>
        <property name="connection.username">sa</property>
        <property name="connection.password"></property>

        <!-- JDBC connection pool (use the built-in) -->
        <property name="connection.pool_size">1</property>

        <!-- SQL dialect -->
        <property name="dialect">org.hibernate.dialect.HSQLDialect</property>

        <!-- Enable Hibernate's automatic session context management -->
        <property name="current_session_context_class">thread</property>

        <!-- Disable the second-level cache  -->
        <property name="cache.provider_class">org.hibernate.cache.NoCacheProvider</property>

        <!-- Echo all executed SQL to stdout -->
        <property name="show_sql">true</property>

        <!-- Drop and re-create the database schema on startup -->
        <property name="hbm2ddl.auto">create</property>

        <mapping resource="events/Event.hbm.xml"/>

    </session-factory>

</hibernate-configuration>]]></programlisting>

            <para>
                Note que esta configuração XML usa um diferente DTD. Nós configuraremos 
                as <literal>SessionFactory</literal> do Hibernate – uma factory global responsável 
                por uma base de dedados particular. Se você tiver diversas bases de dados, 
                use diversas configurações <literal>&lt;session-factory&gt;</literal>, geralmente 
                em diversos arquivos de configuração (para uma partida mais fácil). 
            </para>

            <para>
                As primeiras quatro <literal>propriedades</literal> do elemento contém a configuração 
                necessária para a conexão ao JDBC. A propriedade <literal>propriedade</literal> dialect 
                do elemento especifica a variante particular do SQL que o Hibernate gera. 
                O gerenciamento automático de sessão do Hibernate para contextos de persistência 
                estará disponível em breve. A opção <literal>hbm2ddl.auto</literal> habilita a geração 
                automática de schemas da base de dados – diretamente na base de dados. 
                Isto também pode ser naturalmente desligado (removendo a opção de configuração) ou redirecionando
                para um arquivo com ajuda do <literal>SchemaExport</literal> nas tarefas do Ant. 
                Finalmente, iremos adicionar os arquivos das classes de persistência mapeadas na configuração.
            </para>

            <para>
                Copie este arquivo no diretório fonte, assim isto irá terminar na raiz (root) do 
                classpath. O Hibernate automaticamente procura por um arquivo chamado 
                <literal>hibernate.cfg.xml</literal> na raiz do classpath, no startup.
            </para>

        </sect2>

        <sect2 id="tutorial-firstapp-ant" revision="1">
            <title>Construindo com o Ant</title>

            <para>
                Nos iremos, agora, construir o tutorial com Ant. Você ira precisar o Ant instalado – 
                se encontra disponível  <ulink url="http://ant.apache.org/bindownload.cgi">na página de download do Ant</ulink>. 
                Como instalar o Ant, não será abordado aqui. Caso tenha alguma dúvida, por favor, 
                vá ao <ulink url="http://ant.apache.org/manual/index.html">Ant manual</ulink>.
                Depois que tiver instalado o Ant, podemos começar a criar o arquivo de construção <literal>build.xml</literal>. 
                Este arquivo será chamado de <literal>build.xml</literal> e posto diretamente no diretório de desenvolvimento.
            </para>

            <para>
                Um arquivo básico de build, se parece com isto:
            </para>

            <programlisting><![CDATA[<project name="hibernate-tutorial" default="compile">

    <property name="sourcedir" value="${basedir}/src"/>
    <property name="targetdir" value="${basedir}/bin"/>
    <property name="librarydir" value="${basedir}/lib"/>

    <path id="libraries">
        <fileset dir="${librarydir}">
            <include name="*.jar"/>
        </fileset>
    </path>

    <target name="clean">
        <delete dir="${targetdir}"/>
        <mkdir dir="${targetdir}"/>
    </target>

    <target name="compile" depends="clean, copy-resources">
      <javac srcdir="${sourcedir}"
             destdir="${targetdir}"
             classpathref="libraries"/>
    </target>

    <target name="copy-resources">
        <copy todir="${targetdir}">
            <fileset dir="${sourcedir}">
                <exclude name="**/*.java"/>
            </fileset>
        </copy>
    </target>

</project>]]></programlisting>

            <para>
                Isto irá avisar ao Ant para adicionar todos os arquivos no diretório lib terminando com 
                <literal>.jar</literal>, para o classpath usado para compilação. Irá também copiar todos os 
                arquivos não-java para o diretório alvo (arquivos de configuração, mapeamento). Se você rodar 
                o ant agora, deverá ter esta saída.              
            </para>

            <programlisting><![CDATA[C:\hibernateTutorial\>ant
Buildfile: build.xml

copy-resources:
     [copy] Copying 2 files to C:\hibernateTutorial\bin

compile:
    [javac] Compiling 1 source file to C:\hibernateTutorial\bin

BUILD SUCCESSFUL
Total time: 1 second ]]></programlisting>

        </sect2>

        <sect2 id="tutorial-firstapp-helpers" revision="3">
            <title>Startup and helpers</title>

            <para>
                É hora de carregar e arquivar alguns objetos <literal>Event</literal>, mas primeiro 
                nós temos de completar o setup com algum código de infraestrutura. Este startup 
                inclui a construção de um objeto  <literal>SessionFactory</literal>  global e  armazenar
                isto em algum lugar de fácil acesso para o código da aplicação.
                Uma <literal>SessionFactory</literal> pode abrir novas <literal>Session</literal>'s. 
                Uma <literal>Session</literal> representa uma unidade single-theaded do trabalho, a 
                <literal>SessionFactory</literal> é um objeto global thread-safe, instanciado uma vez.
            </para>

            <para>
                Nos iremos criar uma classe de ajuda <literal>HibernateUtil</literal>, que toma 
                conta do startup e faz acesso a uma <literal>SessionFactory</literal> conveniente. 
                Vamos dar uma olhada na implementação:
            </para>

            <programlisting><![CDATA[package util;

import org.hibernate.*;
import org.hibernate.cfg.*;

public class HibernateUtil {

    private static final SessionFactory sessionFactory;

    static {
        try {
            // Create the SessionFactory from hibernate.cfg.xml
            sessionFactory = new Configuration().configure().buildSessionFactory();
        } catch (Throwable ex) {
            // Make sure you log the exception, as it might be swallowed
            System.err.println("Initial SessionFactory creation failed." + ex);
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }

}]]></programlisting>

            <para>
                Esta classe não só produz a global <literal>SessionFactory</literal> no seu static initializer
                (chamado uma vez pela JVM quando a classe é carregada), mas também esconde o fato 
                de que isto usa um static singleton. Ela pode muito bem, enxergar a 
                <literal>SessionFactory</literal> do JNDI em um application server.
            </para>

            <para>
                Se você der à <literal>SessionFactory</literal> um nome, no seu arquivo de configuração. 
                O Hibernate irá, de fato, tentar uni-lo ao JNDI depois que estiver construído. 
                Para evitar este completamente este código, você também poderia usar JMX deployment 
                e deixar o contêiner JMX capaz, instanciar e unir um <literal>HibernateService</literal> 
                no JNDI. Essas opções avançadas são discutidas no documento de referência do Hibernate.
            </para>

            <para>
                Coloque o <literal>HibernateUtil.java</literal> no diretório de arquivos 
                de desenvolvimento(source), em um pacote após o <literal>events</literal>:
            </para>

            <programlisting><![CDATA[.
+lib
  <Hibernate and third-party libraries>
+src
  +events
    Event.java
    Event.hbm.xml
  +util
    HibernateUtil.java
  hibernate.cfg.xml
+data
build.xml]]></programlisting>

            <para>
                Novamente, isto deve compilar sem problemas. Finalmente, nós precisamos configurar 
                um sistema de logging – o Hibernate usa commons logging e deixa você escolher entre o 
                Log4j e o logging do JDK 1.4 . A maioria dos desenvolvedores preferem o Log4j: copie 
                <literal>log4j.properties</literal> da distribuição do Hibernate (está no diretório 
                <literal>etc/</literal>), para seu diretório  <literal>src</literal>, 
                depois vá em hibernate.cfg.xml. Dê uma olhada no exemplo de configuração e mude as
                configurações se você quizer ter uma saída mais detalhada. Por default, apenas as
                mensagems de startup  e shwwn do Hibernate é mostrada no stdout.
            </para>

            <para>
                O tutorial de infra-estrutura está completo - e nós já estamos preparados para algum 
                trabalho de verdade com o Hibernate.
            </para>

        </sect2>

        <sect2 id="tutorial-firstapp-workingpersistence" revision="4">
            <title>Carregando e salvando objetos</title>

            <para>
                Finalmente, nós podemos usar o Hibernate para carregar e armazenar objetos. 
                Nós escrevemos uma classe <literal>EventManager</literal> com um método main():
            </para>

            <programlisting><![CDATA[package events;
import org.hibernate.Session;

import java.util.Date;

import util.HibernateUtil;

public class EventManager {

    public static void main(String[] args) {
        EventManager mgr = new EventManager();

        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }

        HibernateUtil.getSessionFactory().close();
    }

    private void createAndStoreEvent(String title, Date theDate) {

        Session session = HibernateUtil.getSessionFactory().getCurrentSession();

        session.beginTransaction();

        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);

        session.save(theEvent);

        session.getTransaction().commit();
    }

}]]></programlisting>

            <para>
                Nós criamos um novo objeto <literal>Event</literal>, e passamos para o Hibernate. 
                O Hibernate sabe como tomar conta do SQL e executa <literal>INSERT</literal>s 
                no banco de dados. Vamos dar uma olhada na <literal>Session</literal> e no 
                código <literal>Transaction</literal>-handling antes de executarmos.
            </para>

            <para>
                Um <literal>Session</literal> é uma unidade simples de trabalho. Por agora nós 
                iremos pegar coisas simples e assumir uma granularidade de um-pra-um entre uma 
                <literal>Session</literal> do Hibernate e uma transação de banco de dados. 
                Para proteger nosso código de um atual sistema subjacente de transação (nesse 
                caso puro JDBC, mas também poderia rodar com JTA), nos usamos a API 
                <literal>Transaction</literal>, que está disponível na <literal>Session</literal> do Hibernate.
            </para>

            <para>
                O que a <literal>sessionFactory.getCurrentSession()</literal> faz? Primeiro, você pode 
                chamar quantas vezes e de onde quiser, uma vez você recebe sua <literal>SessionFactory</literal>
                (fácil graças ao <literal>HibernateUtil</literal>). O método <literal>getCurrentSession()</literal>
                sempre retorna a unidade de trabalho "corrente". Lembra de que nós mudamos a opção 
                de configuração desse mecanismo para thread no <literal>hibernate.cfg.xml</literal>? Daqui em
                diante, o escopo da unidade de trabalho corrente é a thread Java 
                corrente que executa nossa aplicação. Entretanto, esta não é toda a verdade. Uma 
	</para>
	
            <para>
		<literal>Session</literal> começa quando é primeiramente necessária, quando é feita a 
                primeira chamada à <literal>getCurrentSession()</literal>. É então limitado pelo Hibernate 
                para thread corrente. Quando a transação termina, tanto com commit quanto rollback, 
                o Hibernate também desune a <literal>Session</literal> da thread e fecha isso pra você. 
                Se você chamar <literal>getCurrentSession()</literal> novamente, você receberá uma nova 
                <literal>Session</literal> e pode começar uma nova unidade de trabalho. Esse modelo de 
                programação de limite de thread  <emphasis>thread-bound</emphasis>, é o modo mais popular 
                de se usar o Hibernate.
           </para>
	   <para>
		   Related to the unit of work scope, should the Hibernate <literal>Session</literal> be used to
		   execute one or several database operations? The above example uses one <literal>Session</literal>
		   for one operation. This is pure coincidence, the example is just not complex enough to show any
		   other approach. The scope of a Hibernate <literal>Session</literal> is flexible but you should
		   never design your application to use a new Hibernate <literal>Session</literal> for
		   <emphasis>every</emphasis> database operation. So even if you see it a few more times in
		   the following (very trivial) examples, consider <emphasis>session-per-operation</emphasis>
		   an anti-pattern. A real (web) application is shown later in this tutorial.
            </para>
            <para>
               Dê uma olhada no <xref linkend="transactions"/>  para mais informações a 
               respeito de manipulação de transação e demarcação. Nós também pulamos qualquer 
               manipulação de erro e rollback no exemplo anterior.
            </para>

            <para>
               Para executar esta primeira rotina, nos teremos que adicionar um ponto de chamada 
               para o arquivo de build do Ant:
            </para>

            <programlisting><![CDATA[<target name="run" depends="compile">
    <java fork="true" classname="events.EventManager" classpathref="libraries">
        <classpath path="${targetdir}"/>
        <arg value="${action}"/>
    </java>
</target>]]></programlisting>

            <para>
                O valor do argumento <literal>action</literal>, é setado na linha de comando quando chamando esse ponto:
            </para>

            <programlisting><![CDATA[C:\hibernateTutorial\>ant run -Daction=store]]></programlisting>

            <para>
                Você deverá ver, após a compilação, o startup do Hibernate e, dependendo da sua 
                configuração, muito log de saída. No final você verá a seguinte linha:
            </para>

            <programlisting><![CDATA[[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)]]></programlisting>

            <para>
                Este é o <literal>INSERT</literal> executado pelo Hibernate, os pontos de interrogação 
                representam parêmetros de união do JDBC. Para ver os valores substituídos, ou para diminuir a 
                verbalidade do log, check seu l<literal>log4j.properties</literal>.
            </para>

            <para>
              Agora nós gostaríamos de listar os eventos arquivados, então nós adicionamos uma 
              opção para o método main:
            </para>

            <programlisting><![CDATA[if (args[0].equals("store")) {
    mgr.createAndStoreEvent("My Event", new Date());
}
else if (args[0].equals("list")) {
    List events = mgr.listEvents();
    for (int i = 0; i < events.size(); i++) {
        Event theEvent = (Event) events.get(i);
        System.out.println("Event: " + theEvent.getTitle() +
                           " Time: " + theEvent.getDate());
    }
}]]></programlisting>

            <para>
                Nos também adicionamos um novo <literal>método listEvents()</literal>:
            </para>

            <programlisting><![CDATA[private List listEvents() {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();

    session.beginTransaction();

    List result = session.createQuery("from Event").list();

    session.getTransaction().commit();

    return result;
}]]></programlisting>

            <para>
                O que nós fazemos aqui, é usar uma query HQL (Hibernate Query Language), 
                para carregar todos os objetos <literal>Event</literal>  exitentes no banco de dados. 
                O Hibernate irá gerar o SQL apropriado, enviar para o banco de dados e popular objetos 
                <literal>Event</literal> com os dados. Você pode criar queries mais complexas com 
                HQL, claro.
            </para>

            <para>
                Agora, para executar e testar tudo isso, siga os passos a seguir:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        Execute <literal>ant run -Daction=store</literal>  para armazenar algo no banco de dados 
                        e, claro, gerar o esquema do banco de dados antes pelo hbm2ddl.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Agora desabilite hbm2ddl comentando a propriedade no seu arquivo <literal>hibernate.cfg.xml</literal>. 
                        Normalmente só se deixa habilitado em teste unitários contínuos, mas outra carga de  hbm2ddl 
                        pode <emphasis>remover</emphasis> tudo que você já tenha arquivado. Sa configuração  
                        <literal>create</literal>, atualmente são traduzidas para "apague todas as tabelas do esquema, 
                        então recrie todas quando a SessionFactory estiver pronta".
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Se você agora chamar o Ant com <literal>-Daction=list</literal>, você deverá ver os 
                eventos que você acabou de criar. Você pode também chamar a ação <literal>store</literal> 
                mais algumas vezes. 
            </para>

            <para>
                Nota: A maioria dos novos usuários do Hibernate falha nesse ponto e nós regularmente, vemos 
                questões sobre mensagens de erro de <emphasis>tabela não encontrada </emphasis> . 
                Entretanto, se você seguir os passos marcados acima, você não terá esse problema, 
                com o hbm2ddl criando o esquema do banco de dados na primeira execução, e restarts
                subsequentes da aplicação irão usar este esquema. Se você mudar o mapeamento e/ou
                o esquema do banco de dados, terá de re-habilitar o hbm2ddl mais uma vez.
            </para>

        </sect2>

    </sect1>

    <sect1 id="tutorial-associations">
        <title>Part 2 - Mapeando associações</title>

        <para>
           Nós mapeamos uma classe de entidade de persistência para uma tabela. Agora vamos continuar
           e adicionar algumas associações de classe. Primeiro nos iremos adicionar pessoas a nossa aplicação, 
           e armazenar os eventos de que elas participam.
        </para>

        <sect2 id="tutorial-associations-mappinguser" revision="1">
            <title>Mapeando a classe Person</title>

            <para>
                O primeiro código da classe <literal>Person</literal> é simples:
            </para>

            <programlisting><![CDATA[package events;

public class Person {

    private Long id;
    private int age;
    private String firstname;
    private String lastname;

    public Person() {}

    // Accessor methods for all properties, private setter for 'id'

}]]></programlisting>

            <para>
                Crie um novo arquivo de mapeamento, chamado <literal>Person.hbm.xml</literal> (não 
                esqueça a referencia ao DTD no topo)
            </para>

            <programlisting><![CDATA[<hibernate-mapping>

    <class name="events.Person" table="PERSON">
        <id name="id" column="PERSON_ID">
            <generator class="native"/>
        </id>
        <property name="age"/>
        <property name="firstname"/>
        <property name="lastname"/>
    </class>

</hibernate-mapping>]]></programlisting>

            <para>
                Finalmente, adicione o novo mapeamento a configuração do Hibernate:
            </para>

            <programlisting><![CDATA[<mapping resource="events/Event.hbm.xml"/>
<mapping resource="events/Person.hbm.xml"/>]]></programlisting>

            <para>
                Nos iremos agora criar uma associação entre estas duas entidades. Obviamente, 
                pessoas (Person) podem participar de eventos, e eventos possuem participantes. 
                As questões de design com que teremos de lidar são: direcionalidade, multiplicidade e 
                comportamento de coleção.
              </para>

        </sect2>

        <sect2 id="tutorial-associations-unidirset" revision="3">
            <title>Uma associação Set-based unidirectional</title>

            <para>
                Nos iremos adicionar uma coleção de eventos na classe <literal>Person</literal>. Desse jeito 
                poderemos navegar pelos eventos de uma pessoa em particular, sem executar uma query explicitamente – 
                apenas chamando  <literal>aPerson.getEvents()</literal>. Nos usaremos uma coleção Java, um  
                <literal>Set</literal>, porquê a coleção não conterá elementos duplicados e a ordem não é 
                relevante para nós.
            </para>

            <para>
                Vamos escrever o código para isto nas classes Java e então mapear:
            </para>

            <programlisting><![CDATA[public class Person {

    private Set events = new HashSet();

    public Set getEvents() {
        return events;
    }

    public void setEvents(Set events) {
        this.events = events;
    }
}]]></programlisting>

            <para>
                Antes de mapearmos esta associação, pense no outro lado. Claramente, poderíamos apenas fazer isto de 
                forma unidirecional. Ou poderíamos criar outra coleção no  <literal>Event</literal>, se quisermos 
                ser capaz de navegar bidirecionalmente, i.e. um - <literal>anEvent.getParticipants()</literal>. 
                Isto não é necessário, de perspectiva funcional. Você poderia sempre executar uma query explicita 
                que retornasse os participantes de um evento em particular. Esta é uma escolha de design que cabe 
                a você, mas o que é claro nessa discussão é a multiplicidade da associação: "muitos" valores em ambos 
                os lados, nós chamamos isto uma associação <emphasis>muitos-para-muitos</emphasis>. Daqui pra frente, 
                nos usaremos o mapeamento muitos-para-muitos do Hibernate:
            </para>

            <programlisting><![CDATA[<class name="events.Person" table="PERSON">
    <id name="id" column="PERSON_ID">
        <generator class="native"/>
    </id>
    <property name="age"/>
    <property name="firstname"/>
    <property name="lastname"/>

    <set name="events" table="PERSON_EVENT">
        <key column="PERSON_ID"/>
        <many-to-many column="EVENT_ID" class="events.Event"/>
    </set>

</class>]]></programlisting>

            <para>
                O Hibernate suporta todo tipo de mapeamento de coleção , sendo um <literal>&lt;set&gt;</literal> mais comum. 
                Para uma associação muitos-para-muitos (ou relacionamento de entidade <emphasis>n:m</emphasis> ), 
                uma tabela de associação é necessária. Cada linha nessa tabela representa um link entre uma pessoa e um 
                evento. O nome da tabela é configurado com o atributo <literal>table</literal> do elemento 
                <literal>set</literal>. O nome da coluna identificadora na associção, peloo lado da pessoa, 
                é definido com o elemento <literal>&lt;key&gt;</literal> , o nome da coluna pelo lado dos eventos, 
                e definido com o atributo <literal>column</literal>  do  <literal>&lt;many-to-many&gt;</literal>. 
                Você também precisa dizer para o Hibernate a classe dos objetos na sua coleção (a classe do outro 
                lado das coleções de referência).
            </para>

            <para>
                O esquema de mapeamento para o banco de dados está a seguir:
            </para>

            <programlisting><![CDATA[
    _____________        __________________
   |             |      |                  |       _____________
   |   EVENTS    |      |   PERSON_EVENT   |      |             |
   |_____________|      |__________________|      |    PERSON   |
   |             |      |                  |      |_____________|
   | *EVENT_ID   | <--> | *EVENT_ID        |      |             |
   |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  |
   |  TITLE      |      |__________________|      |  AGE        |
   |_____________|                                |  FIRSTNAME  |
                                                  |  LASTNAME   |
                                                  |_____________|
 ]]></programlisting>

        </sect2>

        <sect2 id="tutorial-associations-working" revision="1">
            <title>Trabalhando a associação</title>

            <para>
                Vamos trazer juntos algumas pessoas e eventos em um novo método na classe <literal>EventManager</literal>::
            </para>

            <programlisting><![CDATA[private void addPersonToEvent(Long personId, Long eventId) {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();

    Person aPerson = (Person) session.load(Person.class, personId);
    Event anEvent = (Event) session.load(Event.class, eventId);

    aPerson.getEvents().add(anEvent);

    session.getTransaction().commit();
}]]></programlisting>

            <para>
                Após carregar um <literal>Person</literal> e um <literal>Event</literal>, simplesmente 
                modifique a coleção usando os métodos normais de uma coleção. Como você pode ver, não há chamada explícita 
                para <literal>update()</literal> ou <literal>save()</literal>,  o Hibernate detecta automaticamente 
                que a coleção foi modificada e necessita ser atualizada. Isso é chamado de <emphasis>checagem 
                suja automática</emphasis>, e você também pode usá-la modificando o nome ou a data de qualquer um dos 
                seus objetos. Assim que eles estiverem no estado <emphasis>persistent</emphasis>, ou seja, 
                limitado por uma <literal>Session</literal> do Hibernate em particular (i.e. eles foram carregados ou 
                salvos dentro de uma unidade de trabalho), o Hibernate monitora qualquer alteração e executa o SQL 
                em modo de escrita em segundo plano. O processo de sincronização do estado da memória com o banco de 
                dados, geralmente apenas no final de uma unidade de trabalho, é chamado de  <emphasis>flushing</emphasis>. 
                No nosso código, a unidade de trabalho termina com o commit da transação do banco de dados – 
                como definido pela opção de configuração da  <literal>thread</literal> da classe <literal>CurrentSessionContext</literal>.
            </para>

            <para>
                Você pode também querer carregar pessoas e eventos em diferentes unidades de trabalho. 
                Ou você modifica um objeto fora de uma <literal>Session</literal>, quando não se encontra no 
                estado persistent (se já esteve neste estado anteriormente, chamamos esse estado de 
                <emphasis>detached</emphasis>). Você pode até mesmo modificar uma coleção quando esta 
                se encontrar no estado detached.
            </para>

            <programlisting><![CDATA[private void addPersonToEvent(Long personId, Long eventId) {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();

    Person aPerson = (Person) session
            .createQuery("select p from Person p left join fetch p.events where p.id = :pid")
            .setParameter("pid", personId)
            .uniqueResult(); // Eager fetch the collection so we can use it detached

    Event anEvent = (Event) session.load(Event.class, eventId);

    session.getTransaction().commit();

    // End of first unit of work

    aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached

    // Begin second unit of work

    Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();
    session2.beginTransaction();

    session2.update(aPerson); // Reattachment of aPerson

    session2.getTransaction().commit();
}]]></programlisting>

            <para>
                A chamada <literal>update</literal> cria um objeto persistent novamente, você poderia 
                dizer que ele liga o objeto a uma nova unidade de trabalho, assim qualquer modificação 
                que você faça neste objeto enquanto estiver no estado detached pode ser salvo no banco de dados. 
                Isso inclui qualquer modificação (adição/exclusão) que você faça em uma coleção da entidade deste objeto.
            </para>

            <para>
                Bom, isso não foi muito usado na nossa situação, porém, é um importante conceito que você 
                pode aplicar em seus aplicativos. Agora, complete este exercício adicionando uma nova ação 
                ao método main( ) da classe  <literal>EventManager</literal> e chame-o pela linha de comando. 
                Se você precisar dos identificadores de uma pessoa ou evento – o método  <literal>save()</literal> 
                retorna estes identificadores (você poderá modificar alguns dos métodos anteriores para retornar aquele 
                identificador):
            </para>

            <programlisting><![CDATA[else if (args[0].equals("addpersontoevent")) {
    Long eventId = mgr.createAndStoreEvent("My Event", new Date());
    Long personId = mgr.createAndStorePerson("Foo", "Bar");
    mgr.addPersonToEvent(personId, eventId);
    System.out.println("Added person " + personId + " to event " + eventId);]]></programlisting>

            <para>
                Este foi um exemplo de uma associação entre duas classes igualmente importantes, duas entidades. 
                Como mencionado anteriormente, há outras classes e tipos dentro de um modelo típico, 
                geralmente "menos importante". Alguns você já viu, como um  <literal>int</literal> ou uma <literal>String</literal>.
                Nós chamamos essas classes de <emphasis>value types</emphasis>, e suas instâncias <emphasis>depend</emphasis>
                de uma entidade particular. As instâncias desses tipos não possuem sua própria identidade, nem são 
                compartilhados entre entidades (duas pessoas não referenciam o mesmo objeto  <literal>firstname</literal>
                mesmo se elas tiverem o mesmo objeto firstname). Naturalmente, os value types não são apenas encontrados 
                dentro da JDK (de fato, em um aplicativo Hibernate todas as classes JDK são consideradas como value types), 
                mas você pode também criar suas classes como, por exemplo,  <literal>Address</literal> ou  <literal>MonetaryAmount</literal>.

            </para>

            <para>
                Você também pode criar uma coleção de value types. Isso é conceitualmente muito diferente 
                de uma coleção de referências para outras entidades, mas em Java parece ser quase a mesma coisa.
            </para>

        </sect2>

        <sect2 id="tutorial-associations-valuecollections">
            <title>Coleção de valores</title>

            <para>
                Nós adicionamos uma coleção de objetos de tipo de valores à entidade <literal>Person</literal>. 
                Nós querermos armazenar endereços de e-mail, para isso utilizamos o tipo <literal>String</literal>, 
                e a coleção novamente será um <literal>Set</literal>:
            </para>
            <programlisting><![CDATA[private Set emailAddresses = new HashSet();

public Set getEmailAddresses() {
    return emailAddresses;
}

public void setEmailAddresses(Set emailAddresses) {
    this.emailAddresses = emailAddresses;
}]]></programlisting>

            <para>
                O mapeamento deste <literal>Set</literal>:
            </para>

            <programlisting><![CDATA[<set name="emailAddresses" table="PERSON_EMAIL_ADDR">
    <key column="PERSON_ID"/>
    <element type="string" column="EMAIL_ADDR"/>
</set>]]></programlisting>

            <para>
                A diferença comparada com o mapeamento anterior se encontra na parte <literal>element</literal>, 
                que indica ao Hibernate que a coleção não contém referências à outra entidade, mas uma coleção de 
                elementos do tipo <literal>String</literal> (a tag name em miniscula indica que se trata de um 
                mapeamento do Hibernate para conversão de tipos). Mais uma vez, o atributo  <literal>table</literal> 
                do elemento <literal>set</literal> determina o nome da tabela para a coleção. O elemento 
                <literal>key</literal> define o nome da coluna  de chave estrangeira na tabela de coleção. 
                O atributo <literal>column</literal> dentro do elemento <literal>element</literal> define o 
                nome da coluna onde os valores da <literal>String</literal> serão armazenados.
            </para>

            <para>
                Dê uma olhada no esquema atualizado:
            </para>

            <programlisting><![CDATA[
  _____________        __________________
 |             |      |                  |       _____________
 |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________
 |_____________|      |__________________|      |    PERSON   |      |                   |
 |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |
 | *EVENT_ID   | <--> | *EVENT_ID        |      |             |      |___________________|
 |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  | <--> |  *PERSON_ID       |
 |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |
 |_____________|                                |  FIRSTNAME  |      |___________________|
                                                |  LASTNAME   |
                                                |_____________|
 ]]></programlisting>

            <para>
                Você pode observar que a chave primária da tabela da coleção é de na verdade uma chave composta, 
                usando ambas colunas. Isso também implica que cada pessoa não pode ter endereços de e-mail 
                duplicados, o que é exatamente a semântica que precisamos para um set em Java.
            </para>

            <para>
                Você pode agora tentar adicionar elementos a essa coleção, do mesmo modo que fizemos 
                anteriormente ligando pessoas e eventos. È o mesmo código em Java:
            </para>

            <programlisting><![CDATA[private void addEmailToPerson(Long personId, String emailAddress) {

    Session session = HibernateUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();

    Person aPerson = (Person) session.load(Person.class, personId);

    // The getEmailAddresses() might trigger a lazy load of the collection
    aPerson.getEmailAddresses().add(emailAddress);

    session.getTransaction().commit();
}]]></programlisting>

            <para>
                This time we didnt' use a <emphasis>fetch</emphasis> query to initialize the collection.
                Hence, the call to its getter method will trigger an additional select to initialize
                it, so we can add an element to it. Monitor the SQL log and try to optimize this with
                an eager fetch.
            </para>

        </sect2>

        <sect2 id="tutorial-associations-bidirectional" revision="1">
            <title>Associações bidirecionais</title>

            <para>
                Agora iremos mapear uma associação bidirecional – fazendo a associação entre pessoas e 
                eventos, de ambos os lados, em Java. Logicamente, o esquema do banco de dados não muda, 
                nós continuamos tendo multiplicidades muitos-para-muitos. Um banco de dados é mais flexível do que 
                uma linguagem de programação para redes, ele não precisa de nenhuma direção de navegação – os 
                dados podem ser acessados em qualquer caminho possível.
            </para>

            <para>
                Primeiramente, adicione uma coleção de participantes à classe <literal>Event</literal>:
            </para>

            <programlisting><![CDATA[private Set participants = new HashSet();

public Set getParticipants() {
    return participants;
}

public void setParticipants(Set participants) {
    this.participants = participants;
}]]></programlisting>

            <para>
                Agora mapeie este lado da associação em <literal>Event.hbm.xml</literal>.
            </para>

            <programlisting><![CDATA[<set name="participants" table="PERSON_EVENT" inverse="true">
    <key column="EVENT_ID"/>
    <many-to-many column="PERSON_ID" class="events.Person"/>
</set>]]></programlisting>

            <para>
                Como você pode ver, esses é uma mapeamento normal usando <literal>set</literal> em ambos documenentos
                de mapeamento. Observe que o nome das colunas em  <literal>key</literal> e <literal>many-to-many</literal>
                estão trocados em ambos os documentos de mapeamento. A adição mais importante feita está no atributo 
                <literal>inverse="true"</literal> no elemento set do mapeamento da coleção da classe  <literal>Event</literal>.
            </para>

            <para>
                Isso significa que o Hibernate deve pegar o outro lado – a classe <literal>Person</literal> – 
                quando necessitar encontrar informação sobre a relação entre as duas entidades. Isso será muito 
                mais facilmente compreendido quando você analisar como a relação bidirecional entre as entidades é criada. 
            </para>

        </sect2>

        <sect2 id="tutorial-associations-usingbidir">
            <title>Trabalhando com links bidirecionais</title>

            <para>
                Primeiro tenha em mente que o Hibernate não afeta a semântica normal do Java. Como nós criamos 
                um link entre uma <literal>Person</literal> e um <literal>Event</literal> no exemplo unidirecional? 
                Nós adicionamos uma instância de <literal>Event</literal>, da coleção de referências de eventos, 
                a uma instância de <literal>Person</literal>. Então, obviamente, se nós queremos que este link funcione 
                bidirecionalmente, nós devemos fazer a mesma coisa para o outro lado – adicionando uma referência de 
                <literal>Person</literal> na coleção de um <literal>Event</literal>. Esse acerto de link de ambos 
                os lados é absolutamente necessário e você nunca deve esquecer de faze-lo.
            </para>

            <para>
                Muitos desenvolvedores programam de maneira defensiva e criam métodos
                gerenciador de associações que ajusta corretamente ambos os lados:
            </para>

            <programlisting><![CDATA[protected Set getEvents() {
    return events;
}

protected void setEvents(Set events) {
    this.events = events;
}

public void addToEvent(Event event) {
    this.getEvents().add(event);
    event.getParticipants().add(this);
}

public void removeFromEvent(Event event) {
    this.getEvents().remove(event);
    event.getParticipants().remove(this);
}]]></programlisting>

            <para>
                Observe que os métodos set e get da a coleção estão protegidos – isso permite que classes e 
                subclasses do mesmo pacote continuem acessando os métodos, mas previne que qualquer outra classe, 
                que não esteja no mesmo pacote, acesse a coleção diretamente. Você provavelmente deve fazer a mesma 
                coisa para a coleção do outro lado.
            </para>

            <para>
                E sobre o mapeamento do atributo <literal>inverse</literal>? Pra você, e para o Java, um link bidirecional 
                é simplesmente o fato de ajustar corretamente as referências de ambos os lados. O Hibernate, entretanto 
                não possui informação necessária para corretamente adaptar os estados <literal>INSERT</literal> e
                <literal>UPDATE</literal> do SQL, e precisa de ajuda para manipular as propriedades das associações 
                bidirecionais. Fazer um lado da associação com o atributo <literal>inverse</literal> instrui o Hibernate 
                para basicamente ignora-lo, considerando-o uma <emphasis>cópia</emphasis> do outro lado. Isso é todo o 
                necessário para o Hibernate trabalhar com todas as possibilidades quando transformando um modelo de 
                navegação bidirecional em esquema de banco de dados do SQL. As regras que você possui para lembrar são 
                diretas: Todas associações bidirecionais necessitam que um lado possua o atributo inverse. Em uma 
                associação de um-para-muitos, o lado de "muitos" deve conter o atributo <literal>inverse</literal>, 
                já em uma associação de muitos-para-muitos você pode pegar qualquer lado, não há diferença. 
            </para>

        </sect2>

        <para>
            Agora, vamos portar este exemplo para um pequeno aplicativo para internet.

        </para>

    </sect1>

    <sect1 id="tutorial-webapp">
        <title>EventManager um aplicativo para internet</title>

        <para>
            Um aplicativo para internet do Hibernate usa uma <literal>Session</literal> e uma <literal>Transaction</literal> 
            quase do mesmo modo que um aplicativo standalone. Entretanto, alguns patterns comuns são úteis. 
            Nós agora criaremos um <literal>EventManagerServlet</literal>. Esse servlet lista todos os eventos 
            salvos no banco de dados, e cria um formulário HTML para entrada de novos eventos.
        </para>

        <sect2 id="tutorial-webapp-servlet" revision="1">
            <title>Criando um servlet básico</title>

            <para>
                Crie uma nova classe no seu diretório fonte, no pacote <literal>events</literal>:
            </para>

            <programlisting><![CDATA[package events;

// Imports

public class EventManagerServlet extends HttpServlet {

    // Servlet code
}]]></programlisting>

            <para>
                O servlet manuseia somente requisições <literal>GET</literal> do HTTP, 
                portanto o método que iremos implementar é <literal>doGet()</literal>:
            </para>

            <programlisting><![CDATA[protected void doGet(HttpServletRequest request,
                     HttpServletResponse response)
        throws ServletException, IOException {

    SimpleDateFormat dateFormatter = new SimpleDateFormat("dd.MM.yyyy");

    try {
        // Begin unit of work
        HibernateUtil.getSessionFactory()
                .getCurrentSession().beginTransaction();

        // Process request and render page...

        // End unit of work
        HibernateUtil.getSessionFactory()
                .getCurrentSession().getTransaction().commit();

    } catch (Exception ex) {
        HibernateUtil.getSessionFactory()
                .getCurrentSession().getTransaction().rollback();
        throw new ServletException(ex);
    }

}]]></programlisting>

            <para>
                O pattern que estamos aplicando neste código é chamado <emphasis>session-per-request</emphasis>.
                Quando uma requisição chega ao servlet, uma nova <literal>Session</literal> do Hibernate é 
                aberta através da primeira chamada para <literal>getCurrentSession()</literal> em 
                <literal>SessionFactory</literal>. Então uma transação do banco de dados é inicializada - 
                todo acesso a dados deve ocorrer dentro de uma transação, não importando se o dado é de leitura ou escrita.
                (nós não devemos usar o modo auto-commit em aplicações).

            </para>
	    <para>
		    Do <emphasis>not</emphasis> use a new Hibernate <literal>Session</literal> for
		    every database operation. Use one Hibernate <literal>Session</literal> that is
		    scoped to the whole request. Use <literal>getCurrentSession()</literal>, so that
		    it is automatically bound to the current Java thread.
            </para>
            <para>
                Agora, as possibilidades de ações de uma requisição serão processadas e uma resposta HTML será renderizada. 
                Nós já iremos chegar nesta parte.
            </para>

            <para>
                Finalmente, a unidade de trabalho termina quando o processamento e a restituição são completados. 
                Se ocorrer algum erro durante o processamento ou a restituição, uma exceção será lançada e a 
                transação do banco de dados encerrada. Isso completa o pattern <literal>session-per-request</literal>. 
                Em vez de usar código de demarcação de transação em todo servlet você pode também criar um filtro servlet. 
                Dê uma olhada no site do Hibernate e do Wiki para maiores informações sobre esse pattern, 
                chamado <emphasis>Open Session in View</emphasis>.
            </para>

        </sect2>

        <sect2 id="tutorial-webapp-processing" revision="1">
            <title>Processando e renderizando</title>

            <para>
                Vamos implementar o processamento da requisição e a restituição da página HTML.
            </para>

<programlisting><![CDATA[// Write HTML header
PrintWriter out = response.getWriter();
out.println("<html><head><title>Event Manager</title></head><body>");

// Handle actions
if ( "store".equals(request.getParameter("action")) ) {

    String eventTitle = request.getParameter("eventTitle");
    String eventDate = request.getParameter("eventDate");

    if ( "".equals(eventTitle) || "".equals(eventDate) ) {
        out.println("<b><i>Please enter event title and date.</i></b>");
    } else {
        createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));
        out.println("<b><i>Added event.</i></b>");
    }
}

// Print page
printEventForm(out);
listEvents(out, dateFormatter);

// Write HTML footer
out.println("</body></html>");
out.flush();
out.close();]]></programlisting>

            <para>
                O estilo de código acima, misturando linguagem HTML e Java não será funcional em um aplicativo 
                mais complexo&mdash;tenha em mente que neste manual nós estamos apenas ilustrando conceitos 
                básicos do Hibernate. O código imprime um cabeçalho HTML e um rodapé. Dentro desta página, 
                é mostrado um formulário em HTML, para entrada de novos eventos, e uma lista de todos 
                os eventos contidos no banco de dados. O primeiro método é trivial e apenas imprime 
                uma página HTML:
            </para>

            <programlisting><![CDATA[private void printEventForm(PrintWriter out) {
    out.println("<h2>Add new event:</h2>");
    out.println("<form>");
    out.println("Title: <input name='eventTitle' length='50'/><br/>");
    out.println("Date (e.g. 24.12.2009): <input name='eventDate' length='10'/><br/>");
    out.println("<input type='submit' name='action' value='store'/>");
    out.println("</form>");
}]]></programlisting>

            <para>
                O método <literal>listEvents()</literal>  usa a <literal>Session</literal> do Hibernate  
                associada a thread atual para executar um query:
            </para>

            <programlisting><![CDATA[private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) {

    List result = HibernateUtil.getSessionFactory()
                    .getCurrentSession().createCriteria(Event.class).list();
    if (result.size() > 0) {
        out.println("<h2>Events in database:</h2>");
        out.println("<table border='1'>");
        out.println("<tr>");
        out.println("<th>Event title</th>");
        out.println("<th>Event date</th>");
        out.println("</tr>");
        for (Iterator it = result.iterator(); it.hasNext();) {
            Event event = (Event) it.next();
            out.println("<tr>");
            out.println("<td>" + event.getTitle() + "</td>");
            out.println("<td>" + dateFormatter.format(event.getDate()) + "</td>");
            out.println("</tr>");
        }
        out.println("</table>");
    }
}]]></programlisting>

            <para>
                Finalmente, a action <literal>store</literal> é passada pra o método 
                <literal>createAndStoreEvent()</literal>, que também usa a 
                <literal>Session</literal> da thread atual:
            </para>

            <programlisting><![CDATA[protected void createAndStoreEvent(String title, Date theDate) {
    Event theEvent = new Event();
    theEvent.setTitle(title);
    theEvent.setDate(theDate);

    HibernateUtil.getSessionFactory()
                    .getCurrentSession().save(theEvent);
}]]></programlisting>

            <para>
                Pronto, o servlet está completo. Uma requisição para o servlet será processada 
                em uma  <literal>Session</literal> e uma  <literal>Transaction</literal> simples. 
                Como anteriormente, no aplicativo standalone, o Hibernate pode automaticamente 
                associar esses objetos a thread atual em execução. Isso possibilita a liberdade 
                de você modelar seu código e acessar o método  <literal>SessionFactory</literal> 
                do jeito que achar melhor. Geralmente você irá usar um design mais sofisticado 
                e mover o código de acesso a dados para dentro de objetos de acesso a dados 
                (o patter DAO). Leia o Hibernate Wiki para maiores exemplos.
            </para>

        </sect2>

        <sect2 id="tutorial-webapp-deploy">
            <title>Instalando e testando</title>

            <para>
                Para fazer o deploy desta aplicação você tem que criar um arquivo para web, um WAR. 
                Adicione o alvo Ant abaixo em seu <literal>build.xml</literal>:
            </para>

<programlisting><![CDATA[<target name="war" depends="compile">
    <war destfile="hibernate-tutorial.war" webxml="web.xml">
        <lib dir="${librarydir}">
          <exclude name="jsdk*.jar"/>
        </lib>

        <classes dir="${targetdir}"/>
    </war>
</target>]]></programlisting>

            <para>
                Esta target cria um arquivo chamado <literal>hibernate-tutorial.war</literal> 
                no diretório do seu projeto. Ele empacota todas as bibliotecas e o arquivo de 
                descrição <literal>web.xml</literal>, o qual é esperado no diretório base do seu projeto:
            </para>

            <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">

    <servlet>
        <servlet-name>Event Manager</servlet-name>
        <servlet-class>events.EventManagerServlet</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>Event Manager</servlet-name>
        <url-pattern>/eventmanager</url-pattern>
    </servlet-mapping>
</web-app>]]></programlisting>

            <para>
                Antes de você compilar e fazer o deploy desta aplicação web, note que uma biblioteca 
                adicional é requerida: <literal>jsdk.jar</literal>. Esse é o Java servlet development kit, 
                se você não possui esta biblioteca, faça seu download na página da Sun e copie-a
                para seu diretório de bibliotecas. Entretanto, será usado somente para a compilação e 
                excluído do pacote WAR.
            </para>

            <para>
                Para compilar e instalar execute <literal>ant war</literal> no seu diretório do projeto 
                e copie o arquivo <literal>hibernate-tutorial.war</literal> para o diretório 
                <literal>webapp</literal> do Tomcat. Se você não possui o Tomcat instalado faça 
                o download e siga as instruções de instalação. Você não precisa modificar 
                nenhuma configuração do Tomcat para rodar este aplicativo.
            </para>

            <para>
                Uma vez feito o deploy e com Tomcat rodando, acesse o aplicativo em 
                <literal>http://localhost:8080/hibernate-tutorial/eventmanager</literal>. 
                Veja o log do Tomcat para observar a inicialização do Hibernate quando a 
                primeira requisição chega ao servlet (o inicializador estático dentro de 
                <literal>HibernateUtil</literal> é chamado) e para ter uma depuração 
                detalhada se ocorrer alguma exceção. 
            </para>

        </sect2>

    </sect1>

    <sect1 id="tutorial-summary" revision="1">
        <title>Sumário</title>

        <para>
            Este manual cobriu os princípios básicos para criação de uma aplicação simples do Hibernate 
            e uma pequena aplicação web. 
        </para>

        <para>
            Se você já se sente seguro com o Hibernate, continue navegando na documentação de referência 
            por tópicos que você acha interessante – os tópicos mais questionados são: 
            processo de transação (<xref linkend="transactions"/>), uso da API (<xref linkend="objectstate"/>) 
            e características de consulta (<xref linkend="objectstate-querying"/>).
        </para>

        <para>
            Não esqueça de visitar o site do Hibernate para obter mais tutoriais especializados.
        </para>

    </sect1>

</chapter>
