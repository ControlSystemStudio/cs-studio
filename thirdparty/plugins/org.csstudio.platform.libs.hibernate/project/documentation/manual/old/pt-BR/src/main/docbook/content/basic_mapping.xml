<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="mapping">
    <title>Mapeamento O/R Bassico</title>

    <sect1 id="mapping-declaration" revision="1">
        <title>Declaração de mapeamento</title>

        <para>
            Object/relational mappings are usually defined in an XML document. The mapping
            document is designed to be readable and hand-editable. The mapping language is
            Java-centric, meaning that mappings are constructed around persistent class
            declarations, not table declarations.
        </para>
        
        <para>
            Note that, even though many Hibernate users choose to write the XML by hand,
            a number of tools exist to generate the mapping document, including XDoclet,
            Middlegen and AndroMDA.
        </para>

        <para>
            Lets kick off with an example mapping:
        </para>

        <programlisting id="mapping-declaration-ex1" revision="1"><![CDATA[<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping package="eg">

        <class name="Cat" 
            table="cats"
            discriminator-value="C">
                
                <id name="id">
                        <generator class="native"/>
                </id>

                <discriminator column="subclass" 
                     type="character"/>

                <property name="weight"/>

                <property name="birthdate"
                    type="date" 
                    not-null="true" 
                    update="false"/>

                <property name="color"
                    type="eg.types.ColorUserType"
                    not-null="true"
                    update="false"/>

                <property name="sex"
                    not-null="true" 
                    update="false"/>

                <property name="litterId"
                    column="litterId"
                    update="false"/>

                <many-to-one name="mother"
                    column="mother_id"
                    update="false"/>

                <set name="kittens"
                    inverse="true"
                    order-by="litter_id">
                        <key column="mother_id"/>
                        <one-to-many class="Cat"/>
                </set>

                <subclass name="DomesticCat"
                    discriminator-value="D">

                        <property name="name" 
                            type="string"/>

                </subclass>

        </class>

        <class name="Dog">
                <!-- mapping for Dog could go here -->
        </class>

</hibernate-mapping>]]></programlisting>

        <para>
             Discutir agora o conteúdo deste documento de mapeamento. Iremos apenas descrever 
             os elementos do documento e atributos que são utilizados pelo Hibernate em tempo 
             de execução. O documento de mapeamento também contém alguns atributos adicionais 
             e opcionais além de elementos que afetam os esquemas de banco de dados exportados 
             pela ferramenta de exportação de esquemas. (Por exemplo, o atributo 
             <literal>not-null</literal>).
        </para>



        <sect2 id="mapping-declaration-doctype" revision="3">
            <title>Doctype</title>

            <para>
                Todos os mapeamentos de XML devem declarar o doctype exibido. O DTD atual pode 
                ser encontrado na URL abaixo, no diretório <literal>hibernate-x.x.x/src/org/
                hibernate </literal> ou no <literal>hibernate3.jar</literal>. O Hibernate sempre 
                irá procurar pelo DTD inicialmente no seu classpath. Se você tentar localizar
                o DTD usando uma conexão de internet, compare a declaração do seu DTD com o 
                conteúdo do seu classpath
            </para>

            <sect3 id="mapping-declaration-entity-resolution">
                <title>EntityResolver</title>
                <para>
                    As mentioned previously, Hibernate will first attempt to resolve DTDs in its classpath.  The
                    manner in which it does this is by registering a custom <literal>org.xml.sax.EntityResolver</literal>
                    implementation with the SAXReader it uses to read in the xml files.  This custom
                    <literal>EntityResolver</literal> recognizes two different systemId namespaces.
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            a <literal>hibernate namespace</literal> is recognized whenever the
                            resolver encounteres a systemId starting with
                            <literal>http://hibernate.sourceforge.net/</literal>; the resolver
                            attempts to resolve these entities via the classlaoder which loaded
                            the Hibernate classes.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            a <literal>user namespace</literal> is recognized whenever the
                            resolver encounteres a systemId using a <literal>classpath://</literal>
                            URL protocol; the resolver will attempt to resolve these entities
                            via (1) the current thread context classloader and (2) the
                            classloader which loaded the Hibernate classes.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    An example of utilizing user namespacing:
                </para>
                <programlisting><![CDATA[<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd" [
    <!ENTITY types SYSTEM "classpath://your/domain/types.xml">
]>

<hibernate-mapping package="your.domain">
    <class name="MyEntity">
        <id name="id" type="my-custom-id-type">
            ...
        </id>
    <class>
    &types;
</hibernate-mapping>]]></programlisting>
                <para>
                    Where <literal>types.xml</literal> is a resource in the <literal>your.domain</literal>
                    package and contains a custom <xref linkend="mapping-types-custom">typedef</xref>.
                </para>
            </sect3>
        </sect2>

        <sect2 id="mapping-declaration-mapping" revision="3">
            <title>hibernate-mapping</title>

            <para>
                Este elemento tem diversos atributos opcionais. Os atributos  
                <literal>schema</literal> e <literal>catalog</literal> especificam que tabelas 
                referenciadas neste mapeamento pertencem ao esquema e/ou ao catalogo nomeado. 
                Se especificados, os nomes das tabelas irão ser qualificados no schema ou catalog dado. 
                Se não, os nomes das tabelas não serão qualificados. O atributo <literal>default-cascade
                </literal> especifica qual estilo de cascata será assumido pelas propriedades e 
                coleções que não especificarm um atributo <literal>cascade</literal>. O atributo 
                <literal>auto-import</literal> nos deixa utilizar nomes de classes não qualificados 
                na linguagem de consulta, por default.
            </para>
 
             <programlistingco>
                 <areaspec>
                     <area id="hm1" coords="2 55"/>
                     <area id="hm2" coords="3 55"/>
                     <area id="hm3" coords="4 55"/>
                     <area id="hm4" coords="5 55"/>
                     <area id="hm5" coords="6 55"/>
                     <area id="hm6" coords="7 55"/>
                     <area id="hm7" coords="8 55"/>
                 </areaspec>
                 <programlisting><![CDATA[<hibernate-mapping
         schema="schemaName"
         catalog="catalogName"
         default-cascade="cascade_style"
         default-access="field|property|ClassName"
         default-lazy="true|false"
         auto-import="true|false"
         package="package.name"
 />]]></programlisting>
                 <calloutlist>
                     <callout arearefs="hm1">
                         <para>
                             <literal>schema</literal> (opcional): O nome do esquema do banco de dados.
                         </para>
                     </callout>
                     <callout arearefs="hm2">
                         <para>
                             <literal>catalog</literal> (opcional):  O nome do catálogo do banco de dados.
                         </para>
                     </callout>
                     <callout arearefs="hm3">
                         <para>
                             <literal>default-cascade</literal> (opcional – default é <literal>nenhum
                             </literal>): Um estilo cascata default.
                         </para>
                     </callout>
                     <callout arearefs="hm4">
                         <para>
                             <literal>default-access</literal> (opcional – default é <literal>property</literal>): 
                             A estratégia que o Hibernate deve utilizar para acessar todas as propridades. Pode 
                             ser uma implementação própria de <literal>PropertyAccessor</literal>.
                         </para>
                     </callout>
                     <callout arearefs="hm5">
                         <para>
                             <literal>default-lazy</literal> (opcional - default é <literal>true</literal>): 
                             O valor default para atributos <literal>lazy</literal> da classe e dos 
                             mapeamentos de coleções.
                         </para>
                     </callout>
                     <callout arearefs="hm6">
                         <para>
                             <literal>auto-import</literal> ((opcional - default é <literal>true</literal>):
                             Especifica se nós podemos usar nomes de classess não qualificados 
                             (das classes deste mapeamento) na linguagem de consulta.
                         </para>
                     </callout>
                     <callout arearefs="hm7">
                         <para>
                             <literal>package</literal> (opcional): Especifica um prefixo da package para 
                             assumir para nomes de classes não qualificadas no documento de mapeamento.
                         </para>
                     </callout>
                 </calloutlist>
             </programlistingco>
             
             <para>
                 Se voce tem duas classes persistentes com o mesmo nome (não qualificadas), você deve 
                 setar <literal>auto-import="false"</literal>. O Hibernate irá gerar uma exceção se 
                 você tentar setar duas classes para o mesmo nome "importado".
             </para>

             <para>
                  Observe que o elemento <literal>hibernate-mapping</literal> permite a você 
                 aninhar diversos mapeamentos de <literal>&lt;class&gt;</literal> persistentes, 
                 como mostrado abaixo. Entretanto, é uma boa prática (e esperado por algumas 
                 ferramentas)o mapeamento de apenas uma classe persistente simples (ou uma 
                 hierarquia de classes simples) em um arquivo de mapeamento e nomea-la após 
                 a superclasse persistente, por exemplo: <literal>Cat.hbm.xml</literal>, 
                 <literal>Dog.hbm.xml</literal>,  ou se estiver usando herança,
                 <literal>Animal.hbm.xml</literal>.
             </para>
 
        </sect2>

        <sect2 id="mapping-declaration-class" revision="3">
            <title>class</title>

            <para>
                Você pode declarar uma classe persistente utilizando o elemento
                <literal>class</literal>:
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="class1" coords="2 55"/>
                    <area id="class2" coords="3 55" />
                    <area id="class3" coords="4 55"/>
                    <area id="class4" coords="5 55" />
                    <area id="class5" coords="6 55"/>
                    <area id="class6" coords="7 55" />
                    <area id="class7" coords="8 55"/>
                    <area id="class8" coords="9 55" />
                    <area id="class9" coords="10 55" />
                    <area id="class10" coords="11 55"/>
                    <area id="class11" coords="12 55"/>
                    <area id="class12" coords="13 55"/>
                    <area id="class13" coords="14 55"/>
                    <area id="class14" coords="15 55"/>
                    <area id="class15" coords="16 55"/>
                    <area id="class16" coords="17 55"/>
                    <area id="class17" coords="18 55"/>
                    <area id="class18" coords="19 55"/>
                    <area id="class19" coords="20 55"/>
                    <area id="class20" coords="21 55"/>
                    <area id="class21" coords="22 55"/>
                </areaspec>
                <programlisting><![CDATA[<class
        name="ClassName"
        table="tableName"
        discriminator-value="discriminator_value"
        mutable="true|false"
        schema="owner"
        catalog="catalog"
        proxy="ProxyInterface"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        select-before-update="true|false"
        polymorphism="implicit|explicit"
        where="arbitrary sql where condition"
        persister="PersisterClass"
        batch-size="N"
        optimistic-lock="none|version|dirty|all"
        lazy="true|false"
        entity-name="EntityName"
        check="arbitrary sql check condition"
        rowid="rowid"
        subselect="SQL expression"
        abstract="true|false"
        node="element-name"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="class1">
                        <para>
                            <literal>name</literal> (opcional): O nome da classe Java inteiramente qualificado
                            da classe persistente (ou interface); Se o atributo é ausente, assume-se que o 
                            mapeamento é para intidades não-POJO.
                        </para>
                    </callout>
                    <callout arearefs="class2">
                        <para>
                            <literal>table</literal> (opcional – default para nomes de classes não 
                            qualificadas) O nome da sua tabela do banco de dados.
                        </para>
                    </callout>
                    <callout arearefs="class3">
                        <para>
                            <literal>discriminator-value</literal> (opcional – default para o nome da classe):  
                            Um valor que distingue subclasses individuais, usadas para o comportamento polimorfico. 
                            Valores aceitos incluem <literal>null</literal> e <literal>not null</literal>
                        </para>
                    </callout>
                    <callout arearefs="class4">
                        <para>
                            <literal>mutable</literal> (opcional - valor default <literal>true</literal>): 
                            Especifica que instancias da classe são (ou não) mutáveis
                        </para>
                    </callout>    
                    <callout arearefs="class5">
                        <para>
                            <literal>schema</literal> (opcional): Sobrepõe o nome do esquema especificado 
                            pelo elemento root <literal>&lt;hibernate-mapping&gt;</literal>.
                        </para>
                    </callout>                
                    <callout arearefs="class6">
                        <para>
                            <literal>catalog</literal> (opcional): Sobrepõe o nome do catálogo especificado 
                            pelo elemento root  <literal>&lt;hibernate-mapping&gt;</literal>. 
                        </para>
                    </callout>                
                    <callout arearefs="class7">
                        <para>
                            <literal>proxy</literal> (opcional): Especifica um interface para ser 
                            utilizada pelos proxies de inicialização tardia. Você pode especificar o 
                            nome da própria classe.
                        </para>
                    </callout>    
                    <callout arearefs="class8">
                        <para>
                            <literal>dynamic-update</literal> (opcional, valor default <literal>false</literal>): 
                            Especifica que o SQL de <literal>UPDATE</literal> deve ser gerado em tempo de 
                            execução e conter apenas aquelas colunas cujos valores foram alterados.
                        </para>
                    </callout>    
                    <callout arearefs="class9">
                        <para>
                            <literal>dynamic-insert</literal> (opcional, valor default <literal>false</literal>): 
                            Especifica que o SQL de  <literal>INSERT</literal> deve ser gerado em tempo de 
                            execução e conter apenas aquelas colunas cujos valores não estão nulos.
                        </para>
                    </callout>    
                    <callout arearefs="class10">
                        <para>
                            <literal>select-before-update</literal>  (opcional, valor default <literal>false</literal>): 
                            Especifica que o Hibernate <emphasis>never</emphasis> deve executar um SQL de 
                            <literal>UPDATE</literal> a não ser que com certeza um objeto está atualmente modificado. 
                            Em certos casos (atualmente, apenas quando um objeto transiente foi associado com uma nova
                            sessão utilizando  <literal>update()</literal>), isto significa que o Hibernate ira executar 
                            uma instrução SQL de <literal>SELECT</literal> adicional para determinar se um 
                            <literal>UPDATE</literal> é necessário nesse momento.
                        </para>
                    </callout>    
                    <callout arearefs="class11">
                        <para>
                            <literal>polymorphism</literal> (opcional, default para <literal>implicit</literal>): 
                            Determina se deve ser utilizado a query polimorfica implicita ou explicitamente.
                        </para>
                    </callout>    
                    <callout arearefs="class12">
                        <para>
                            <literal>where</literal> (opicional) especifica um comando SQL <literal>WHERE</literal>
                            arbitrário para ser usado quando da recuperação de objetos desta classe.
                        </para>
                    </callout>                 
                    <callout arearefs="class13">
                        <para>
                            <literal>persister</literal> (opcional): Espeicifca uma <literal>ClassPersister</literal> 
                            customizada.
                        </para>
                    </callout>                 
                    <callout arearefs="class14">
                        <para>
                            <literal>batch-size</literal> (opcional, valor default <literal>1</literal>) especifica um  
                            "tamanho de lote" para a recuperação de instancias desta classe pelo identificador.
                        </para>
                    </callout>                 
                   <callout arearefs="class15">
                        <para>
                            <literal>optimistic-lock</literal> (octional, valor default <literal>version</literal>): 
                            Determina a estratégia de bloqueio.
                        </para>
                    </callout>    
                    <callout arearefs="class16">
                        <para>
                            <literal>lazy</literal> (opcional): A recuperação tardia pode ser completamente 
                            desabilitada, setando <literal>lazy="false"</literal>.
                        </para>
                    </callout>    
                    <callout arearefs="class17">
                        <para>
                            <literal>entity-name</literal> (opcional, default para o nome da classe): O 
                            Hibernate3 permite uma classe ser mapeada multiplas vezes, (potencialmente,para 
                            diferentes tabelas), e permite mapeamentos de entidades que são representadas 
                            por Maps ou XML no nível Java. Nestes casos, você deve especificar um nome 
                            arbitrário explicitamente para a entidade. Veja <xref linkend="persistent-classes-dynamicmodels"/> 
                            e <xref linkend="xml"/> para maiores informações.
                        </para>
                    </callout>
                    <callout arearefs="class18">
                        <para>
                            <literal>check</literal> (opcional): Uma expressão SQL utilizada para gerar uma 
                            constraint de <emphasis>verificação</emphasis> de múltiplas linhas para a geração 
                            automática do esquema.
                        </para>
                    </callout>
                    <callout arearefs="class19">
                        <para>
                            <literal>rowid</literal> (opcional): O Hibernate poder usar as assim chamadas 
                            ROWIDs em bancos de dados que a suportam. Por exemplo, no Oracle, o Hibernate 
                            pode utilizar a coluna extra rowid para atualizações mais rápidas se você 
                            configurar esta opção para <literal>rowid</literal>. Um ROWID é uma implementação 
                            que representa de maneira detalhada a localização física de uma determinada 
                            tupla armazenado.
                        </para>
                    </callout>
                    <callout arearefs="class20">
                        <para>
                            <literal>subselect</literal> (optional): Maps an immutable and read-only entity
                            to a database subselect. Useful if you want to have a view instead of a base table,
                            but don't. See below for more information.
                            <literal>subselect</literal> (opcional): Mapeia uma entidade imutavel e somente
                            de leitura para um  subconjunto do banco de dados. Útil se você quiser ter uma 
                            view em vez de uma tabela. Veja abaixo para mais informações.
                        </para>
                    </callout>
                    <callout arearefs="class21">
                        <para>
                            <literal>abstract</literal> (opcional): Utilizada para marcar superclasses 
                            abstratas em hierarquias <literal>&lt;union-subclass&gt;</literal>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
           
            <para>
                É perfeitamente aceitável para uma classe persitente nomeada ser uma interface. Você deverá 
                então declarar as classes implementadas desta interface utilizando o elemento  
                <literal>&lt;subclass&gt;</literal>. Você pode persistir qualquer classe de aninhada
                <emphasis>estatica</emphasis>. Você deverá especificar o nome da classe usando a forma 
                padrão, por exemplo:  <literal>eg.Foo$Bar</literal>.
            </para>

            <para>
                Classes imutáveis,  <literal>mutable="false"</literal>, não podem ser modificadas ou excluídas 
                pela aplicação. Isso permite ao Hibernate fazer alguns aperfeiçoamentos de performance.
            </para>
            
            <para>
                O atributo opcional <literal>proxy</literal> habilita a inicialização tardia das 
                instâncias persistentes da classe. O Hibernate irá retornar CGLIB proxies como implementado 
                na interface nomeada. O objeto persistente atual  será carregado quando um método do proxy 
                for invocado. Veja "Inicializando coleções e proxies" abaixo.
            </para>
            
            <para>Polimorfismo <emphasis>implícito</emphasis> significa que instâncias de uma classe 
                serão retornada por uma query que dá nome a qualquer superclasse ou interface implementada, 
                ou a classe e as instancias de qualquer subclasse da classe será retornada por umq query 
                que nomeia a classe por si. Polimorfismo <emphasis>explícito</emphasis> significa que 
                instancias da classe serão retornadas apenas por queries que explicitamente nomeiam a 
                classe e que queries que nomeiam as classes irão retornar apenas instancias de subclasses 
                mapeadas dentro da declaração <literal>&lt;class&gt;</literal> como uma 
                <literal>&lt;subclass&gt;</literal> ou <literal>&lt;joined-subclass&gt;</literal>.
                Para a maioria dos casos, o valor default <literal>polymorphism="implicit"</literal>, 
                é apropriado. Polimorfismo explicito é útil quando duas classes distintas estão mapeadas 
                para a mesma tabela (isso permite um classe "peso leve" que contem um subconjunto 
                de colunas da tabela).
            </para>
            
            <para>
                O atributo <literal>persister</literal> deixa você customizar a estratégia de persistência 
                utilizada para a classe. Você pode, por exemplo, especificar sua prórpia subclasse do 
                <literal>org.hibernate.persister.EntityPersister</literal> ou você pode criar 
                uma implementação completamente nova  da interface 
                <literal>org.hibernate.persister.ClassPersister</literal> que implementa a persistência 
                através de, por exemplo, chamadas a stored procedeures, serialização de arquivos flat ou 
                LDAP. Veja <literal>org.hibernate.test.CustomPersister</literal> para um exemplo 
                simples (de "persistencia" para uma <literal>Hashtable</literal>).
            </para>
            
            <para>
                Observe que as configurações <literal>dynamic-update</literal> e 
                <literal>dynamic-insert</literal> não sao herdadas pelas subclasses e assim podem tambem 
                ser especificadas em elementos <literal>&lt;subclass&gt;</literal> or 
                <literal>&lt;joined-subclass&gt;</literal>. Estas configurações podem incrementar a 
                performance em alguns casos, mas pode realmente diminuir a performance em outras. 
                Use-as de forma bastante criteriosa.
            </para>
            
            <para>
                O uso de <literal>select-before-update</literal> geralmente irá diminuir a performance. Ela é 
                muito útil para prevenir que uma trigger de atualização no banco de dados seja ativada 
                desnecessariamente, se você reconectar um nó de uma instancia desconectada em uma 
                <literal>Session</literal>.
            </para>
            
            <para>
                Se você ativar  <literal>dynamic-update</literal>, você terá de escolher 
                a estratégia de bloqueio otimista:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <literal>version</literal> verifica a versão e a hora das colunas
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>all</literal> cverifica todas as colunas
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>dirty</literal> verifica as colunas modificadas, permitindo 
                        alguns updates concorrentes
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>none</literal> não utiliza o bloqueio otimista
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Nós <emphasis>recomendamos</emphasis> com muita enfase que você utilize a 
                versão e a hora das colunas para o bloqueio otimista com o Hibernate. 
                Esta é a melhor estratégia com respeito a performance e é a única estratégia 
                que trata corretamente as modificações efetuadas em instancias desconectadas 
                (por exemplo, quando <literal>Session.merge()</literal> é utilizado).

            </para>

            <para>
                Não ha diferença entre uma view e uma tabela para o mapeamento do Hibernate, e como 
                esperado isto é transparente no nível do banco de dados (observe que alguns bancos de 
                dados não suportam views apropriadamente, especialmente com updates). Algumas vezes, 
                você quer utilizar uma view, ma snão pode cria-la no banco de dados (por exemplo, 
                com um esquema legado). Neste caso, você pode mapear uma entidade imutável e de 
                somente leitura, para uma dada expressão SQL, que representa um subselect:
            </para>

            <programlisting><![CDATA[<class name="Summary">
    <subselect>
        select item.name, max(bid.amount), count(*)
        from item
        join bid on bid.item_id = item.id
        group by item.name
    </subselect>
    <synchronize table="item"/>
    <synchronize table="bid"/>
    <id name="name"/>
    ...
</class>]]></programlisting>

            <para>
                Declare as tabelas para sincronizar com esta entidade, garantindo que o auto-flush 
                ocorra corretamente, e que as queries para esta entidade derivada não retornem dados 
                desatualizados. O <literal>&lt;subselect&gt;</literal> está disponível tanto como um 
                atributo como um elemento mapeado nested.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-id" revision="4">
            <title>id</title>

            <para>
                Classes mapeadas <emphasis>precisam</emphasis> declarar a coluna de chave primaria da 
                tabela do banco de dados. Muitas classes irão tambem ter uma propriedade ao estilo 
                Java-Beans declarando o identificador unico de uma instancia. O elemento 
                <literal>&lt;id&gt;</literal> define o mapeamento desta propriedade para a chave primária.
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="id1" coords="2 70"/>
                    <area id="id2" coords="3 70" />
                    <area id="id3" coords="4 70"/>
                    <area id="id4" coords="5 70" />
                    <area id="id5" coords="6 70" />
                </areaspec>
                <programlisting><![CDATA[<id
        name="propertyName"
        type="typename"
        column="column_name"
        unsaved-value="null|any|none|undefined|id_value"
        access="field|property|ClassName">
        node="element-name|@attribute-name|element/@attribute|."

        <generator class="generatorClass"/>
</id>]]></programlisting>
                <calloutlist>
                    <callout arearefs="id1">
                        <para>
                            <literal>name</literal> (opcional): O nome do identificador.
                        </para>
                    </callout>
                    <callout arearefs="id2">
                        <para>
                            <literal>type</literal> (opcional): Um nome que indica o tipo no Hibernate.
                        </para>
                    </callout>
                    <callout arearefs="id3">
                        <para>
                            <literal>column</literal> (opcional – default para o a propridade name): O 
                            nome coluna chave primaria.
                        </para>
                    </callout>
                    <callout arearefs="id4">
                        <para>
                            <literal>unsaved-value</literal> (opcional - default para um valor "sensível"): 
                            Uma propriedade de identificação que indica que a instancia foi novamente 
                            instanciada (unsaved), diferenciando de instancias desconectadas que foram 
                            salvas ou carregadas em uma sessão anterior.
                        </para>
                    </callout>            
                   <callout arearefs="id5">
                        <para>
                            <literal>access</literal> (opcional - valor default <literal>property</literal>): A 
                            estratégia que o Hiberante deve utilizar para acessar o valor da propriedade
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
            <para>
                Se o atributo <literal>name</literal> não for declarado, assume-se que a classe não tem 
                a propriedade de identificação.
            </para>
            
            <para>
                O atributo <literal>unsaved-value</literal> não é mais necessário no Hibernate 3.
            </para>

             <para>
                Há declaração alternativa  <literal>&lt;composite-id&gt;</literal> permite o acesso a 
                dados legados com chaves compostas. Nós desencorajamos fortemente o seu uso por 
                qualquer pessoa.
            </para>
            
            <sect3 id="mapping-declaration-id-generator" revision="2">
                <title>Generator</title>

                <para>
                    O elemento filho opcional <literal>&lt;generator&gt;</literal> nomeia uma classe Java 
                    usada para gerar identificadores unicos para instancias de uma classe persistente. 
                    Se algum parâmetro é requerido para configurar ou inicializar a instancia geradora, 
                    eles são passados utilizando o elemento <literal>&lt;param&gt;</literal>.
                </para>

                <programlisting><![CDATA[<id name="id" type="long" column="cat_id">
        <generator class="org.hibernate.id.TableHiLoGenerator">
                <param name="table">uid_table</param>
                <param name="column">next_hi_value_column</param>
        </generator>
</id>]]></programlisting>

                <para>
                    Todos os generators implementam a interface  <literal>org.hibernate.id.IdentifierGenerator</literal>. 
                    Esta é uma interface bem simples; algumas aplicações podem prover sua própria implementação 
                    esepecializada. Entretanto, o Hibernate disponibiliza um conjunto de implementações internamente. 
                    Há nomes de atalhos para estes generators próprios:
                    <variablelist>
                        <varlistentry>
                        <term><literal>increment</literal></term>
                        <listitem>
                            <para>
                                gera identificadores dos tipos <literal>long</literal>, <literal>short</literal> ou
                                <literal>int</literal> que são unicos apenas quando nenhum outro processo está 
                                inserindo dados na mesma tabela. <emphasis>Não utilize em ambientes 
                                de cluster.</emphasis>
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>identity</literal></term>
                        <listitem>
                            <para>
                                suporta colunas de identidade em  DB2, MySQL, MS SQL Server, Sybase e 
                                HypersonicSQL. O identificador retornado é do tipo <literal>long</literal>, 
                                <literal>short</literal> ou <literal>int</literal>.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>sequence</literal></term>
                        <listitem>
                            <para>
                                utiliza uma sequence em DB2, PostgreSQL, Oracle, SAP DB, McKoi ou um 
                                generator no Interbase. O identificador de retorno é do tipo <literal>
                                long</literal>, <literal>short</literal> ou <literal>int</literal>.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>hilo</literal></term>
                        <listitem>
                            <para id="mapping-declaration-id-hilodescription" revision="1">
                                utiliza um algoritmo hi/lo para gerar de forma eficiente identificadores do tipo 
                                <literal>long</literal>, <literal>short</literal> ou <literal>int</literal>,
                                a partir de uma tabela e coluna fornecida (por default 
                                <literal>hibernate_unique_key</literal> e <literal>next_hi</literal>) 
                                como fonte para os valores hi. O algoritmo hi/lo gera identificadores que são 
                                únicos apenas para um banco de dados particular. 
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>seqhilo</literal></term>
                        <listitem>
                            <para>
                                utiliza um algoritmo hi/lo para gerar de forma eficinete identificadores do tipo 
                                <literal>long</literal>, <literal>short</literal> ou <literal>int</literal>,
                                a partir de uma sequence de banco de dados fornecida.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>uuid</literal></term>
                        <listitem>
                            <para>
                                utiliza um algortimo UUID de 128-bits para gerar identificadores do 
                                tipo string, unicos em uma rede(o endereço IP é utilizado). O UUID é 
                                codificado como um string de digitos hexadecimais de tamanho 32.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>guid</literal></term>
                        <listitem>
                            <para>
                                utiliza um string GUID gerado pelo banco de dados no MS SQL Server 
                                e MySQL.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>native</literal></term>
                        <listitem>
                            <para>
                                seleciona entre <literal>identity</literal>, <literal>sequence</literal> 
                                ou <literal>hilo</literal> dependendo das capacidades do banco de dados 
                                utilizado.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>assigned</literal></term>
                        <listitem>
                            <para>
                                deixa a aplicação definir um identificador para o objeto antes que o 
                                <literal>save()</literal> seja chamado. Esta é a estratégia default 
                                se nenhum elemento <literal>&lt;generator&gt;</literal> é especificado.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>select</literal></term>
                        <listitem>
                            <para>
                                retorna a chave primaria recuperada por uma trigger do banco de 
                                dados, selecionado uma linha pela chave única e recuperando o valor 
                                da chave primária.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>foreign</literal></term>
                        <listitem>
                            <para>
                                utiliza o identificador de um outro objeto associado. Normalmente utilizado 
                                em conjunto com uma associaçõa de chave primária do tipo
                                <literal>&lt;one-to-one&gt;</literal>.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>sequence-identity</literal></term>
                        <listitem>
                            <para>
                                a specialized sequence generation strategy which utilizes a
                                database sequence for the actual value generation, but combines
                                this with JDBC3 getGeneratedKeys to actually return the generated
                                identifier value as part of the insert statement execution.  This
                                strategy is only known to be supported on Oracle 10g drivers
                                targetted for JDK 1.4.  Note comments on these insert statements
                                are disabled due to a bug in the Oracle drivers.
                            </para>
                        </listitem>
                        </varlistentry>
                    </variablelist>

                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-hilo" revision="1">
                <title>Algoritmo Hi/lo</title>
                <para>
                    Os geradores <literal>hilo</literal> e <literal>seqhilo</literal> fornecem duas 
                    implementações alternativas do algoritmo hi/lo, uma solução preferencial para a geração 
                    de identificadores. A primeira implementação requer uma tabela especial do banco de 
                    dados para manter o proximo valor "hi" disponível. A segunda utiliza uma seqüência 
                    do estilo Oracle (quando suportado). 
                </para>

                <programlisting><![CDATA[<id name="id" type="long" column="cat_id">
        <generator class="hilo">
                <param name="table">hi_value</param>
                <param name="column">next_value</param>
                <param name="max_lo">100</param>
        </generator>
</id>]]></programlisting>

                <programlisting><![CDATA[<id name="id" type="long" column="cat_id">
        <generator class="seqhilo">
                <param name="sequence">hi_value</param>
                <param name="max_lo">100</param>
        </generator>
</id>]]></programlisting>

                <para>
                    Infelizemente, voce não pode utilizar <literal>hilo</literal> quando estiver 
                    fornecendo sia propria  <literal>Connection</literal> para o Hibernate. Quando o 
                    Hibernate está usando um datasource do servidor de aplicações para obter conexões 
                    suportadas com JTA, você precisa configurar adequadamente o 
                    <literal>hibernate.transaction.manager_lookup_class</literal>.
                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-uuid">
                <title>UUID algorithm</title>
                <para>
                    O UUID contem: o endereço IP, hora de inicio da JVM (com precisão de um quarto 
                    de segundo), a hora do sistema e um valor contador (unico dentro da JVM). 
                    Não é possivel obter o endereço MAC ou um endereço de memória do código Java, 
                    assim este é o melhor que pode ser feito sem utilizar JNI.
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-sequences">
            <title>Colunas de identidade e sequencias</title>
                <para>
                    Para bancos de dados que suportam colunas de identidade (DB2, MySQL, Sybase, 
                    MS SQL), você pode utilizar uma geração de chave <literal>identity</literal>. 
                    Para bancos de dados que suportam sequencias (DB2, Oracle, PostgreSQL, Interbase, 
                    McKoi, SAP DB) voce pode utilizar a geração de chaves no estilo 
                    <literal>sequence</literal>. As duas estratégias requerem duas consultas SQL 
                    para inserir um novo objeto. 
                </para>

                <programlisting><![CDATA[<id name="id" type="long" column="person_id">
        <generator class="sequence">
                <param name="sequence">person_id_sequence</param>
        </generator>
</id>]]></programlisting>

                <programlisting><![CDATA[<id name="id" type="long" column="person_id" unsaved-value="0">
        <generator class="identity"/>
</id>]]></programlisting>
            
                <para>
                    Para desenvolvimento multi-plataforma, a estratégia <literal>native</literal> 
                    irá escolher entre as estratégias i <literal>identity</literal>, 
                    <literal>sequence</literal> e <literal>hilo</literal>, dependendo das 
                    capacidades do banco de dados utilizado.
                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-assigned">
                <title>Identificadores especificados</title>
                <para>
                    Se você quer que a aplicação especifique os identificadores 
                    (em vez do Hibernate gerá-los) você deve utilizar o gerador 
                    <literal>assigned</literal>. Este gerador especial irá utilizar o valor 
                    do identificador especificado para a propriedade de identificação do objeto. 
                    Este gerador é usado quando a chave primaria é a chave natural em vez de uma 
                    surrogate key. Este é o comportamento padrão se você não especificar 
                    um elemento  <literal>&lt;generator&gt;</literal>. 
                </para>
                
                <para>
                    Escolher o gerador <literal>assigned</literal> faz com que o Hibernate 
                    utilize <literal>unsaved-value="undefined"</literal>, forçando o Hibernate 
                    ir até o banco de dados para determinar se uma instância está transiente ou 
                    desasociada, a menos que haja uma versão ou uma propriedade timestamp, 
                    ou você pode definir <literal>Interceptor.isUnsaved()</literal>.
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-select">
                <title>Chaves primárias geradas por triggers</title>
                <para>
                    Apenas para sistemas legados (o Hibernate nao gera DDL com triggers).
                </para>

                <programlisting><![CDATA[<id name="id" type="long" column="person_id">
        <generator class="select">
                <param name="key">socialSecurityNumber</param>
        </generator>
</id>]]></programlisting>

                <para>
                    No exemplo acima, há uma única propriedade com valor nomeada 
                    <literal>socialSecurityNumber</literal>  definida pela classe, 
                    uma chave natural, e uma surrogate key nomeada 
                    <literal>person_id</literal> cujo valor é gerado pro uma trigger.
                </para>
                
            </sect3>

        </sect2>
	<sect2 id="mapping-declaration-id-enhanced">
		<title>Enhanced identifier generators</title>
		
		<para>
			Starting with release 3.2.3, there are 2 new generators which represent a re-thinking of 2 different
			aspects of identifier generation.  The first aspect is database portability; the second is optimization
			(not having to query the database for every request for a new identifier value).  These two new
			generators are intended to take the place of some of the named generators described above (starting
			in 3.3.x); however, they are included in the current releases and can be referenced by FQN.
		</para>
		
		<para>
			The first of these new generators is <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</literal>
			which is intended firstly as a replacement for the <literal>sequence</literal> generator and secondly as
			a better portability generator than <literal>native</literal> (because <literal>native</literal>
			(generally) chooses between <literal>identity</literal> and <literal>sequence</literal> which have
			largely different semantics which can cause subtle isssues in applications eyeing portability).
			<literal>org.hibernate.id.enhanced.SequenceStyleGenerator</literal> however achieves portability in
			a different manner.  It chooses between using a table or a sequence in the database to store its
			incrementing values depending on the capabilities of the dialect being used.  The difference between this
			and <literal>native</literal> is that table-based and sequence-based storage have the same exact
			semantic (in fact sequences are exactly what Hibernate tries to emmulate with its table-based
			generators).  This generator has a number of configuration parameters:
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						<literal>sequence_name</literal> (optional, defaults to <literal>hibernate_sequence</literal>):
						The name of the sequence (or table) to be used.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>initial_value</literal> (optional, defaults to <literal>1</literal>): The initial
						value to be retrieved from the sequence/table.  In sequence creation terms, this is analogous
						to the clause typical named "STARTS WITH".
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>increment_size</literal> (optional, defaults to <literal>1</literal>): The value by
						which subsequent calls to the sequence/table should differ.  In sequence creation terms, this
						is analogous to the clause typical named "INCREMENT BY".
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>force_table_use</literal> (optional, defaults to <literal>false</literal>): Should
						we force the use of a table as the backing structure even though the dialect might support
						sequence?
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>value_column</literal> (optional, defaults to <literal>next_val</literal>): Only
						relevant for table structures!  The name of the column on the table which is used to
						hold the value.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>optimizer</literal> (optional, defaults to <literal>none</literal>):
						See <xref linkend="mapping-declaration-id-enhanced-optimizers"/>
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			The second of these new generators is <literal>org.hibernate.id.enhanced.TableGenerator</literal> which
			is intended firstly as a replacement for the <literal>table</literal> generator (although it actually
			functions much more like <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal>) and secondly
			as a re-implementation of <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal> utilizing the
			notion of pluggable optimiziers.  Essentially this generator defines a table capable of holding
			a number of different increment values simultaneously by using multiple distinctly keyed rows.  This
			generator has a number of configuration parameters:
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						<literal>table_name</literal> (optional, defaults to <literal>hibernate_sequences</literal>):
						The name of the table to be used.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>value_column_name</literal> (optional, defaults to <literal>next_val</literal>):
						The name of the column on the table which is used to hold the value.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>segment_column_name</literal> (optional, defaults to <literal>sequence_name</literal>):
						The name of the column on the table which is used to hold the "segement key".  This is the
						value which distinctly identifies which increment value to use.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>segment_value</literal> (optional, defaults to <literal>default</literal>):
						The "segment key" value for the segment from which we want to pull increment values for
						this generator.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>segment_value_length</literal> (optional, defaults to <literal>255</literal>):
						Used for schema generation; the column size to create this segment key column.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>initial_value</literal> (optional, defaults to <literal>1</literal>):
						The initial value to be retrieved from the table.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>increment_size</literal> (optional, defaults to <literal>1</literal>):
						The value by which subsequent calls to the table should differ.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>optimizer</literal> (optional, defaults to <literal></literal>):
						See <xref linkend="mapping-declaration-id-enhanced-optimizers"/>
					</para>
				</listitem>
			</itemizedlist>
		</para>
	</sect2>
	
	<sect2 id="mapping-declaration-id-enhanced-optimizers">
		<title>Identifier generator optimization</title>
		<para>
			For identifier generators which store values in the database, it is inefficient for them to hit the
			database on each and every call to generate a new identifier value.  Instead, you'd ideally want to
			group a bunch of them in memory and only hit the database when you have exhausted your in-memory
			value group.  This is the role of the pluggable optimizers.  Currently only the two enhanced generators
			(<xref linkend="mapping-declaration-id-enhanced"/> support this notion.
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						<literal>none</literal> (generally this is the default if no optimizer was specified):  This
						says to not perform any optimizations, and hit the database each and every request.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>hilo</literal>: applies a hi/lo algorithm around the database retrieved values.  The
						values from the database for this optimizer are expected to be sequential.  The values
						retrieved from the database structure for this optimizer indicates the "group number"; the
						<literal>increment_size</literal> is multiplied by that value in memory to define a group
						"hi value".
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>pooled</literal>: like was discussed for <literal>hilo</literal>, this optimizers
						attempts to minimize the number of hits to the database.  Here, however, we simply store
						the starting value for the "next group" into the database structure rather than a sequential
						value in combination with an in-memory grouping algorithm.  <literal>increment_size</literal>
						here refers to the values coming from the database.
					</para>
				</listitem>
			</itemizedlist>
		</para>
	</sect2>
	

        <sect2 id="mapping-declaration-compositeid" revision="3">
            <title>composite-id</title>

            <programlisting><![CDATA[<composite-id
        name="propertyName"
        class="ClassName"
        mapped="true|false"
        access="field|property|ClassName">
        node="element-name|."

        <key-property name="propertyName" type="typename" column="column_name"/>
        <key-many-to-one name="propertyName class="ClassName" column="column_name"/>
        ......
</composite-id>]]></programlisting>

            <para>
                Para tabelas com uma chave composta, você pode mapear múltiplas propriedades 
                da classe como propriedades de identificação. O elemento 
                <literal>&lt;composite-id&gt;</literal> aceita o mapeamento da propriedade  
                <literal>&lt;key-property&gt;</literal> e mapeamentos 
                <literal>&lt;key-many-to-one&gt;</literal>como elements filhos.
            </para>
            
            <programlisting><![CDATA[<composite-id>
        <key-property name="medicareNumber"/>
        <key-property name="dependent"/>
</composite-id>]]></programlisting>

            <para>
                Sua classe persistente <emphasis>precisa</emphasis> sobre escrever 
                <literal>equals()</literal> e <literal>hashCode()</literal> para implementar 
                identificadores compostos igualmente. E precisa também implementar 
                <literal>Serializable</literal>.
            </para>

            <para>
                Infelizmente, esta solução para um identificador composto significa que um objeto 
                persistente é seu próprio identificador. Não há outro "handle" que o próprio objeto. 
                Você mesmo precisa instanciar uma instância de outra classe persistente e preencher 
                suas propriedades de identificação antes que você possa dar um  <literal>load()</literal>
                para o estado persistente associado com uma chave composta. Nos chamamos esta 
                solução de identificador composto <emphasis>embedded</emphasis> e não aconselhamos 
                para aplicações sérias. 
            </para>
            
            <para>
                Uma segunda solução é o que podemos chamar de identificador composto 
                <emphasis>mapped</emphasis> quando a propriedades de identificação nomeadas dentro do 
                elemento <literal>&lt;composite-id&gt;</literal> estão duplicadas tando na classe 
                persistente como em uma classe de identificação separada. 
            </para>
                
            <programlisting><![CDATA[<composite-id class="MedicareId" mapped="true">
        <key-property name="medicareNumber"/>
        <key-property name="dependent"/>
</composite-id>]]></programlisting>

            <para>
                No exemplo, ambas as classes de identificação compostas, <literal>MedicareId</literal>, 
                e a própria classe entidade tem propriedades nomeadas <literal>medicareNumber</literal> 
                e <literal>dependent</literal>. A classe identificadora precisa sobrepor 
                <literal>equals()</literal> e <literal>hashCode()</literal> e implementar 
                <literal>Serializable</literal>. A desvantagem desta solução é obvia – 
                duplicação de código.
            </para>
            
            <para>
                Os seguintes atributos ão utilizados para especificar o mapeamento de 
                um identificador composto:
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>mapped</literal> mapped (opcional, valor default <literal>false
                        </literal>): indica que um identificar composto mapeado é usado, e que as 
                        propriedades de mapeamento contidas refere-se tanto a classe entidade e 
                        a classe de identificação composta.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>class</literal> (opcional, mas requerida para um identificar composto 
                        mapeado): A classe usada como um identificador composto. 
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Nós iremos descrever uma terceira e as vezes mais conveniente solução, onde o 
                identificador composto é implementado como uma classe componente na 
                <xref linkend="components-compositeid"/>. Os atributos descritos abaixo aplicam-se 
                apenas para esta solução:
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>name</literal> (opcional, requerida para esta solução): Uma 
                        propriedade do tipo componente que armazena o identificador composto 
                        (veja capítulo 9) 
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>access</literal> (opcional - valor default <literal>property</literal>): 
                        A estartégia Hibernate que deve ser utilizada para acessar o valor da propriedade.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>class</literal> (opcional - valor default para o tipo de propriedade 
                        determiando por reflexão) : A classe componente utilizada como um identificador 
                        composto (veja a próxima sessão).
                    </para>
                </listitem>
            </itemizedlist>
            
            <para>
                Esta terceira solução, um <emphasis>componente de identificação</emphasis>, é o que nós 
                recomendamos para a maioria das aplicações.
            </para>
            
        </sect2>
        
        <sect2 id="mapping-declaration-discriminator" revision="3">
            <title>discriminator</title>

            <para>
                O  elemento <literal>&lt;discriminator&gt;</literal> é necessário para persistência 
                polimórfica utilizando a estratégia de mapeamento table-per-class-hierarchy e declara 
                uma coluna discriminadora da tabela. A coluna discriminadora contem valores de marcação 
                que dizem a camada de persistência qual subclasse instanciar para uma linha particular. 
                Um restrito conjunto de tipos que podem ser utilizados: <literal>string</literal>, 
                <literal>character</literal>, <literal>integer</literal>, <literal>byte</literal>, 
                <literal>short</literal>, <literal>boolean</literal>, 
                <literal>yes_no</literal>, <literal>true_false</literal>.
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="discriminator1" coords="2 60"/>
                    <area id="discriminator2" coords="3 60" />
                    <area id="discriminator3" coords="4 60" />
                    <area id="discriminator4" coords="5 60" />
                    <area id="discriminator5" coords="6 60" />
                </areaspec>
                <programlisting><![CDATA[<discriminator
        column="discriminator_column"
        type="discriminator_type"
        force="true|false"
        insert="true|false"
        formula="arbitrary sql expression"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="discriminator1">
                        <para>
                            <literal>column</literal> (opcional - valor default <literal>class</literal>) 
                            o nome da coluna discriminadora
                        </para>
                    </callout>
                    <callout arearefs="discriminator2">
                        <para>
                            <literal>type</literal> (opcional - valor default  <literal>string</literal>) 
                            o nome que indica o tipo Hibernate
                        </para>
                    </callout>          
                    <callout arearefs="discriminator3">
                        <para>
                            <literal>force</literal> (opcional - valor default <literal>false</literal>) 
                            "força" o Hibernate a especificar valores discriminadores permitidos mesmo 
                            quando recuperando todas as instancias da classe root.
                        </para>
                    </callout>          
                    <callout arearefs="discriminator4">
                        <para>
                            <literal>insert</literal> (opcional - valor default para  <literal>true</literal>) 
                            sete isto para <literal>false</literal> se sua coluna discriminadora é também 
                            parte do identificador composto mapeado. (Diz ao Hibernate para não incluir a 
                            coluna em comandos SQL <literal>INSERT</literal>s). 
                        </para>
                    </callout>
                    <callout arearefs="discriminator5">
                        <para>
                            <literal>formula</literal> (opcional) uma expressão SQL arbitraria que é e
                            xecutada quando um tipo tem que ser avaliado. Permite discriminação baseada 
                            em conteúdo.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                Valores atuais de uma coluna discriminada são especificados pelo atributo 
                <literal>discriminator-value</literal> da <literal>&lt;class&gt;</literal> 
                e elementos da <literal>&lt;subclass&gt;</literal>.
            </para>
            
            <para>
                O atributo  <literal>force</literal> é util (apenas) em tabelas contendo linhas com 
                valores discriminadores "extras" que não estão mapeados para uma classe persistente. 
                Este não é geralmente o caso.
            </para>

            <para>
                Usando o atributo <literal>formula</literal> voce pode declarar uma expressão SQL 
                arbitrária que sera utilizada para avaliar o tipo de uma linha :
            </para>

            <programlisting><![CDATA[<discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="integer"/>]]></programlisting>

        </sect2>

        <sect2 id="mapping-declaration-version" revision="4">
            <title>version (optional)</title>
            
            <para>
                O elemento <literal>&lt;version&gt;</literal> é opcional e indica que a tabela 
                possui dados versionados. Isto é particularmente útil se você planeja utilizar 
                <emphasis>transações longas</emphasis> (veja abaixo):
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="version1" coords="2 70"/>
                    <area id="version2" coords="3 70"/>
                    <area id="version3" coords="4 70"/>
                    <area id="version4" coords="5 70"/>
                    <area id="version5" coords="6 70"/>
                    <area id="version6" coords="7 70"/>
                    <area id="version7" coords="8 70"/>
                </areaspec>
                <programlisting><![CDATA[<version
        column="version_column"
        name="propertyName"
        type="typename"
        access="field|property|ClassName"
        unsaved-value="null|negative|undefined"
        generated="never|always"
        insert="true|false"
        node="element-name|@attribute-name|element/@attribute|."
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="version1">
                        <para>
                            <literal>column</literal> (opcional - default a a propriedade name): O nome da 
                            coluna mantendo o numero da versão 
                        </para>
                    </callout>          
                    <callout arearefs="version2">
                        <para>
                            <literal>name</literal>: O nome da propriedade da classe persistente.
                        </para>
                    </callout>
                    <callout arearefs="version3">
                        <para>
                            <literal>type</literal> (opcional - valor default para <literal>integer</literal>): 
                            O tipo do numero da versão
                        </para>
                    </callout>          
                   <callout arearefs="version4">
                        <para>
                            <literal>access</literal> (opcional - valor default <literal>property</literal>): 
                            A estratégia Hibernate que deve ser usada para acessar o valor da propriedade.
                        </para>
                    </callout>
                   <callout arearefs="version5">
                        <para>
                            <literal>unsaved-value</literal>  (opcional – valor default para <literal>undefined
                            </literal>): Um valor para a propriedade versão que indica que uma instancia é 
                            uma nova instanciada (unsaved), distinguindo de instancias desconectadas que foram 
                            salvas ou carregadas em sessões anteriores. ((<literal>undefined</literal> especifica 
                            que o valor da propriedade de identificação deve ser utilizado).
                        </para>
                    </callout>
                    <callout arearefs="version6">
                        <para>
                            <literal>generated</literal> (optional - defaults to <literal>never</literal>):
                            Specifies that this version property value is actually generated by the database.
                            See the discussion of <xref linkend="mapping-generated">generated properties</xref>.
                            <literal>generated</literal> (opcional - valor default <literal>never</literal>): 
                            Especifica que valor para a propriedade versão é na verdade gerado pelo banco de 
                            dados. Veja a discussão da Seção 
                            <xref linkend="mapping-generated">generated properties</xref>. 
                        </para>
                    </callout>
                    <callout arearefs="version7">
                        <para>
                            <literal>insert</literal> (opcional - valor default para <literal>true</literal>): 
                            Especifica se a coluna de versão deve ser incluída no comando SQL de insert. 
                            Pode ser configurado como <literal>false</literal> se a coluna do banco de dados 
                            está definida com um valor default de <literal>0</literal>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
            <para>
                Números de versão podem ser dos tipos Hibernate <literal>long</literal>, 
                <literal>integer</literal>, <literal>short</literal>, <literal>timestamp</literal> ou
                <literal>calendar</literal>.
            </para>
            
            <para>
                A versão de uma propriedade timestamp nunca deve ser nula para uma instancia 
                desconectada, assim o Hibernate irá identificar qualquer instância com uma versão 
                nula ou timestamp como transiente, não importando qual estratégia para foi 
                especificada para <literal>unsaved-value</literal>. <emphasis>Declarando uma versão 
                nula ou a propriedade timestamp é um caminho fácil para tratar problemas com 
                reconexões transitivas no Hibernate, especialmente úteis para pessoas utilizando 
                identificadores assinaldados ou chaves compostas!</emphasis>
            </para>
        </sect2>
        
        <sect2 id="mapping-declaration-timestamp" revision="4" >
            <title>timestamp (optional)</title>

            <para>
                O elemento opcional <literal>&lt;timestamp&gt;</literal> indica que uma tabela contém 
                dados timestamped. Isso tem por objetivo dar uma alternativa para versionamento. Timestamps 
                são por natureza uma implementação menos segura do locking otimista. Entretanto, algumas 
                vezes a aplicação pode usar timestamps em outros caminhos.
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="timestamp1" coords="2 70"/>
                    <area id="timestamp2" coords="3 70" />
                    <area id="timestamp3" coords="4 70" />
                    <area id="timestamp4" coords="5 70" />
                    <area id="timestamp5" coords="6 70" />
                    <area id="timestamp6" coords="7 70" />
                </areaspec>            
                <programlisting><![CDATA[<timestamp
        column="timestamp_column"
        name="propertyName"
        access="field|property|ClassName"
        unsaved-value="null|undefined"
        source="vm|db"
        generated="never|always"
        node="element-name|@attribute-name|element/@attribute|."
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="timestamp1">
                        <para>
                            <literal>column</literal> (opcional - valor default para a propriedade name): 
                            O nome da coluna que mantem o timestamp.
                        </para>
                    </callout>                   
                    <callout arearefs="timestamp2">
                        <para>
                            <literal>name</literal>: O nome da propriedade no estilo JavaBeans do 
                            tipo <literal>Date</literal> ou <literal>Timestamp</literal> da classe 
                            persistente Java.
                        </para>
                    </callout>
                   <callout arearefs="timestamp3">
                        <para>
                            <literal>access</literal> (opcional - valor default para <literal>property</literal>): 
                            A estretagia Hibernate que deve ser utilizada para acessar o valor da propriedade.
                        </para>
                    </callout>
                   <callout arearefs="timestamp4">
                        <para>
                            <literal>unsaved-value</literal> (opcional - valor default <literal>null</literal>): 
                            Uma propriedade para a versão de que indica que uma instância é uma nova instanciada 
                            (unsaved), distinguindo-a de instancias desconectadas que foram salvas ou carregadas 
                            em sessões previas. (<literal>undefined</literal> especifica que um valor de 
                            propriedade de identificação deve ser utilizado)
                        </para>
                    </callout>
                   <callout arearefs="timestamp5">
                        <para>
                            <literal>source</literal>  (opcional - valor default para <literal>vm</literal>): 
                            De onde o Hibernate deve recuperar o valor timestamp? Do banco de dados ou da JVM 
                            corrente? Timestamps baseados em banco de dados levam a um overhead porque o 
                            Hibernate precisa acessar o banco de dados para determinar o "próximo valor", mas é 
                            mais seguro para uso em ambientes de "cluster". Observe também, que nem todos 
                            <literal>Dialect</literal>s suportam a recuperação do timestamp corrente do banco 
                            de dados, enquando outros podem não ser seguros para utilização em bloqueios 
                            pela falta de precisão (Oracle 8 por exemplo)
                        </para>
                    </callout>
                    <callout arearefs="timestamp6">
                        <para>
                            <literal>generated</literal> (opcional - valor default <literal>never</literal>): 
                            Especifica que o valor da propriedade timestamp é gerado pelo banco de dados. 
                            Veja a discussão <xref linkend="mapping-generated">generated properties</xref>. 
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
            <para>
                Observe que <literal>&lt;timestamp&gt;</literal> é equivalente a  
                <literal>&lt;version type="timestamp"&gt;</literal>. E 
                <literal>&lt;timestamp source="db"&gt;</literal> é equivalente a 
                <literal>&lt;version type="dbtimestamp"&gt;</literal>.
            </para>
        </sect2>


        <sect2 id="mapping-declaration-property" revision="4">
            <title>property</title>

            <para>
                O elemento <literal>&lt;property&gt;</literal> declara uma propriedade 
                persistente de uma classe, no estilo JavaBean. 
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="property1" coords="2 70"/>
                    <area id="property2" coords="3 70"/>
                    <area id="property3" coords="4 70"/>
                    <areaset id="property4-5" coords="">
                        <area id="property4" coords='5 70'/>
                        <area id="property5" coords='6 70'/>
                    </areaset>
                    <area id="property6" coords="7 70"/>
                    <area id="property7" coords="8 70"/>
                    <area id="property8" coords="9 70"/>
                    <area id="property9" coords="10 70"/>
                    <area id="property10" coords="11 70"/>
                    <area id="property11" coords="12 70"/>
                    <area id="property12" coords="13 70"/>
                </areaspec>            
                <programlisting><![CDATA[<property
        name="propertyName"
        column="column_name"
        type="typename"
        update="true|false"
        insert="true|false"
        formula="arbitrary SQL expression"
        access="field|property|ClassName"
        lazy="true|false"
        unique="true|false"
        not-null="true|false"
        optimistic-lock="true|false"
        generated="never|insert|always"
        node="element-name|@attribute-name|element/@attribute|."
        index="index_name"
        unique_key="unique_key_id"
        length="L"
        precision="P"
        scale="S"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="property1">
                        <para>
                            <literal>name</literal>: o nome da propriedade, iniciando com letra minúscula.
                        </para>
                    </callout>                   
                    <callout arearefs="property2">
                        <para>
                            <literal>column</literal> (opcional - default para a propriedade name): o nome 
                            da coluna mapeada do banco de dados, Isto pode também ser especificado pelo(s) 
                            elemento(s) <literal>&lt;column&gt;</literal> aninhados.

                        </para>
                    </callout>
                    <callout arearefs="property3">
                        <para>
                            <literal>type</literal> (opcional): um nome que indica o tipo Hibernate.
                        </para>
                    </callout>
                    <callout arearefs="property4-5">
                        <para>
                            <literal>update, insert</literal> (opcional - valor default <literal>true</literal>):
                            especifica que as colunas mapeadas devem ser incluidas nas instruções SQL de 
                            <literal>UPDATE</literal> e/ou <literal>INSERT</literal> . Setar ambas para to 
                            <literal>false</literal> permite uma propridade "derivada" pura cujo valor é 
                            inicializado de outra propriedade que mapeie a mesma coluna(s) ou por uma trigger 
                            ou outra aplicação.
                        </para>
                    </callout>
                    <callout arearefs="property6">
                        <para>
                            <literal>formula</literal>  (opcional): uma expressão SQL que definie o valor para 
                            uma propriedade <emphasis>calculada</emphasis>. Propriedades calculadas nao tem 
                            uma coluna de mapeamento para elas.
                        </para>
                    </callout>
                    <callout arearefs="property7">
                        <para>
                            <literal>access</literal> (opcional – valor default <literal>property</literal>): 
                            A estratégia que o Hibernate deve utilizar para acessar o valor da propriedade
                        </para>
                    </callout>
                    <callout arearefs="property8">
                        <para>
                            <literal>lazy</literal> (opcional - valor default para <literal>false</literal>): 
                            Especifica que esta propriedade deve ser trazida de forma "lazy" quando a 
                            instancia da variável é acessada pela primeira vez (requer instrumentação 
                            bytecode em tempo de criação).
                        </para>
                    </callout>
                    <callout arearefs="property9">
                        <para>
                            <literal>unique</literal> (opcional): Habilita a geração de DDL de uma 
                            unica constraint para as colunas. Assim, permite que isto seja o 
                            alvo de uma <literal>property-ref</literal>.
                        </para>
                    </callout>
                    <callout arearefs="property10">
                        <para>
                            <literal>not-null</literal> (opcional): Habilita a geração de DDL de uma 
                            constraint de nulidade para as colunas.
                        </para>
                    </callout>
                    <callout arearefs="property11">
                        <para>
                            <literal>optimistic-lock</literal> (opcional - valor default <literal>true</literal>):
                            Especifica se mudanças para esta propriedade requerem ou não bloqueio otimista. 
                            Em outras palavras, determina se um incremento de versão deve ocorrer quando 
                            esta propriedade está suja.
                        </para>
                    </callout>
                    <callout arearefs="property12">
                        <para>
                            <literal>generated</literal> (opcional - valor default <literal>never</literal>): 
                            Especifica que o valor da propriedade é na verdade gerado pelo banco de dados.
                            Veja a discussão da seção 
                            <xref linkend="mapping-generated">generated properties</xref>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                <emphasis>typename</emphasis> pode ser:
            </para>

            <orderedlist spacing="compact">
                <listitem>
                    <para>
                        The name of a Hibernate basic type (eg. <literal>integer, string, character,
                        date, timestamp, float, binary, serializable, object, blob</literal>).
                        O nome do tipo basico do Hibernate (ex., <literal>integer, string, character,
                        date, timestamp, float, binary, serializable, object, blob</literal>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        O nome da classe Java com um tipo básico default (ex.  <literal>int, float,
                        char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</literal>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        O nome da classe Java serializable
                    </para>
                </listitem>
                <listitem>
                    <para>
                        O nome da classe de um tipo customizado (ex. <literal>com.illflow.type.MyCustomType</literal>).
                    </para>
                </listitem>
            </orderedlist>

            <para>
                Se você não especificar um tipo, o Hibernate ira utilizar reflexão sobre  a 
                propriedade nomeada para ter uma idéia do tipo Hibernate correto. O Hibernate ira 
                tentar interpretar o nome da classe retornada, usando as regras 2, 3 e 4 nesta ordem. 
                Entretanto, isto não é sempre suficiente Em certos casos, você ainda irá necessitar
                do atributo <literal>type</literal>. (Por exemplo, para distinguir entre 
                <literal>Hibernate.DATE</literal> ou <literal>Hibernate.TIMESTAMP</literal>, 
                ou para espcificar uma tipo ciustomizado.)
            </para>
            
            <para>
                O atributo <literal>access</literal> permite voce controlar como o Hibernate irá 
                acessar a propriedade em tempo de execução. Por default, o Hibernate irá chamar os 
                métodos get/set da propriedades. Se voce especificar <literal>access="field"</literal>, 
                o Hibernate ira bipassar os metodos get/set, acessnado o campo diretamente, 
                usando reflexão. Voc epode especificar sua própria estratégia para acesso da 
                propriedade criando uma classe que implemente a interface 
                <literal>org.hibernate.property.PropertyAccessor</literal>.
            </para>

            <para>
                Um recurso especialmente poderoso é o de propriedades derivadas. Estas propriedades 
                são por definição read-only, e o valor da propriedade é calculado em tempo de execução. 
                Você declara este calculo como uma expressão SQL, que traduz para clausula 
                <literal>SELECT</literal> de uma subquery daquery SQL que carrega a instancia: 
            </para>

        <programlisting><![CDATA[
<property name="totalPrice"
    formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                WHERE li.productId = p.productId
                AND li.customerId = customerId
                AND li.orderNumber = orderNumber )"/>]]></programlisting>

            <para>
                Observe que você pode referenciar as entidades da própria tabela, 
                através da não declaração de um alias para uma coluna particular (
                <literal>customerId</literal> no exemplo dado). Observe tambem que voce pode usar o 
                mapeamento de elemento aninhado <literal>&lt;formula&gt;</literal>, se você não 
                gostar de usar o atributo.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-manytoone" revision="5">
            <title>many-to-one</title>

            <para>
                Uma associação ordinária para outra classe persistente é declarada usando o 
                elemento <literal>many-to-one</literal>. O modelo relacional é uma 
                associação many-to-one: a uma chave estrangeira de uma tabela referenciando
                a chave primaria da tabela destino.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="manytoone1" coords="2 70"/>
                    <area id="manytoone2" coords="3 70"/>
                    <area id="manytoone3" coords="4 70"/>
                    <area id="manytoone4" coords="5 70"/>
                    <area id="manytoone5" coords="6 70"/>
                    <areaset id="manytoone6-7" coords="">
                        <area id="manytoone6" coords='7 70'/>
                        <area id="manytoone7" coords='8 70'/>
                    </areaset>
                    <area id="manytoone8" coords="9 70"/>
                    <area id="manytoone9" coords="10 70"/>
                    <area id="manytoone10" coords="11 70"/>
                    <area id="manytoone11" coords="12 70"/>
                    <area id="manytoone12" coords="13 70"/>
                    <area id="manytoone13" coords="14 70"/>
                    <area id="manytoone14" coords="15 70"/>
                    <area id="manytoone15" coords="16 70"/>
                    <area id="manytoone16" coords="17 70"/>
                </areaspec>
                <programlisting><![CDATA[<many-to-one
        name="propertyName"
        column="column_name"
        class="ClassName"
        cascade="cascade_style"
        fetch="join|select"
        update="true|false"
        insert="true|false"
        property-ref="propertyNameFromAssociatedClass"
        access="field|property|ClassName"
        unique="true|false"
        not-null="true|false"
        optimistic-lock="true|false"
        lazy="proxy|no-proxy|false"
        not-found="ignore|exception"
        entity-name="EntityName"
        formula="arbitrary SQL expression"
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        index="index_name"
        unique_key="unique_key_id"
        foreign-key="foreign_key_name"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="manytoone1">
                        <para>
                            <literal>name</literal>: O nome da propriedade.
                        </para>                    
                    </callout>                   
                    <callout arearefs="manytoone2">
                        <para>
                            <literal>column</literal> (opcional): O nome da coluna foreign key. Isto 
                            pode também ser especificado através de elementos aninhados 
                            <literal>&lt;column&gt;</literal>.
                        </para>
                    </callout>
                    <callout arearefs="manytoone3">
                        <para>
                            <literal>class</literal> (opcional – default para o tipo de propriedade 
                            determinado pela reflexão). O nome da classe associada. 
                        </para>
                    </callout>
                    <callout arearefs="manytoone4">
                        <para>
                            <literal>cascade</literal> (opcional): Especifica quais operações dever 
                            ser em cascata do objeto pai para o objeto associado. 
                        </para>                    
                    </callout>
                    <callout arearefs="manytoone5">
                        <para>
                            <literal>fetch</literal> (opcional - default para <literal>select</literal>): 
                            Escolhe entre recuperação outer-join ou recuperação seqüencial.
                         </para>                    
                    </callout>
                    <callout arearefs="manytoone6-7">
                        <para>
                            <literal>update, insert</literal> (opcional - valor default <literal>true</literal>):
                            especifica que as colunas mapeadas dever ser incluidas em instruções SQL de 
                            <literal>UPDATE</literal> e/ou <literal>INSERT</literal>. Setando ambas para 
                            <literal>false</literal> você permite uma associação "derivada" pura cujos valores 
                            são inicializados de algumas outras propriedades que mapeiam a mesma coluna ou 
                            por uma trigger ou outra aplicação. 
                         </para>                    
                    </callout>
                    <callout arearefs="manytoone8">
                        <para>
                            <literal>property-ref</literal>: (opcional) O nome da propriedade da classe associada 
                            que faz a junção desta foreign key. Se não especificada, a chave primaria da 
                            classe associada será utilizada. 
                         </para>                
                    </callout>                   
                    <callout arearefs="manytoone9">
                        <para>
                            <literal>access</literal> (opcional - valor default <literal>property</literal>): A 
                            estrategia que o Hibernate deve utilizar para acessar o valor da propriedade.
                         </para>
                    </callout>
                    <callout arearefs="manytoone10">
                        <para>
                            <literal>unique</literal> (opcional): Habilita a geração DDL de uma constraint 
                            unique para a coluna foreign-key. Alem disso, permite ser o alvo de uma 
                            <literal>property-ref</literal>. Isso torna a associação multipla 
                            efetivamente um para um. 
                         </para>
                    </callout>
                    <callout arearefs="manytoone11">
                        <para>
                            <literal>not-null</literal> (opcional): Habilita a geração DDL de uma constraint de 
                            nulidade para as foreign keys.
                         </para>
                    </callout>
                    <callout arearefs="manytoone12">
                        <para>
                            <literal>optimistic-lock</literal> (opcional - valor default <literal>true</literal>): 
                            Especifica se mudanças desta propriedade requerem ou não travamento otimista. 
                            Em outras palavras, determina se um incremento de versão deve ocorrer quando 
                            esta propriedade está suja.
                         </para>
                    </callout>
                    <callout arearefs="manytoone13">
                        <para>
                            <literal>lazy</literal>(opcional – valor default  <literal>proxy</literal>): 
                            Por default, associações de ponto unico são envoltas em um proxie. 
                            <literal>lazy="no-proxy"</literal> especifica que a propriedade deve ser 
                            trazida de forma tardia quando a instancia da variável é acessada pela 
                            primeira vez (requer instrumentação bytecode em tempo de criação) 
                            <literal>lazy="false"</literal> especifica que a associação será 
                            sempre recuperada fortemente. 
                         </para>
                    </callout>
                    <callout arearefs="manytoone14">
                        <para>
                            <literal>not-found</literal> (opcional - valor default <literal>exception</literal>): 
                            Especifica como as foreign keys que referenciam linhas ausentes serão tratadas:
                            <literal>ignore</literal> irá tratar a linha ausente como ama associaççao de null
                         </para>
                    </callout>
                    <callout arearefs="manytoone15">
                        <para>
                            <literal>entity-name</literal> (opcional): O nome da entidade da classe associada. 
                         </para>                   
                    </callout>
                </calloutlist>
                    <callout arearefs="manytoone16">
                        <para>
                            <literal>formula</literal> (optional): Uma expressão SQL que define um valor
                            para um foreign key <emphasis>computed</emphasis>.
                        </para>
                    </callout>
            </programlistingco>

            <para>
                Setar o valor do atributo  <literal>cascade</literal> para qualquer valor 
                significativo diferente de  <literal>none</literal> irá propagar certas operações 
                ao objeto associado. Os valores significativos são os nomes das operações básicas 
                do Hibernate, <literal>persist, merge, delete, save-update, evict, replicate, lock,
                refresh</literal>, assim como os valores especiais  <literal>delete-orphan</literal> 
                e <literal>all</literal> e combinações de nomes de operações separadas por vírgula, 
                como por exemplo, <literal>cascade="persist,merge,evict"</literal> ou
                <literal>cascade="all,delete-orphan"</literal>. Veja a seção 
                <xref linkend="objectstate-transitive"/> para uma explicação completa. Note que 
                associações valoradas simples (associações muitos-pra-um, e um-pra-um) não suportam 
                orphan delete.
            </para>
            
            <para>
                Uma típica declaração <literal>muitos-pra-um</literal> se parece com esta:
            </para>

            <programlisting><![CDATA[<many-to-one name="product" class="Product" column="PRODUCT_ID"/>]]></programlisting>
            
            <para>
                O atributo <literal>property-ref</literal> deve apenas ser usado para mapear dados 
                legados onde uma chave estrangeira se referencia a uma chave exclusiva da tabela 
                associada que não seja à chave primária. Este é um modelo relacional desagradável. 
                Por exemplo, suponha que a classe  <literal>Product</literal> tenha um número 
                seqüencial exclusivo, que não é a chave primária. (O atributo <literal>unique</literal> 
                controla a geração de DDL do Hibernate com a ferramenta SchemaExport.)
            </para>
            
            <programlisting><![CDATA[<property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/>]]></programlisting>
            
            <para>
                Então o mapeamento para <literal>OrderItem</literal> poderia usar:
            </para>
            
            <programlisting><![CDATA[<many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/>]]></programlisting>
            
            <para>
                Porém, isto obviamente não é indicado, nunca.
            </para>
            
            <para>
                Se a chave exclusiva referenciada engloba múltiplas propriedades da entidade associada, 
                você deve mapear as propriedades referenciadas dentro de um elemento chamado 
                <literal>&lt;properties&gt;</literal>

            </para>
            
            <para>
            	Se a chave exclusiva referenciada é a propriedade de um componente, você pode especificar 
            	um caminho para a propriedade. 
            </para>
            
           <programlisting><![CDATA[<many-to-one name="owner" property-ref="identity.ssn" column="OWNER_SSN"/>]]></programlisting>           
            
        </sect2>

        <sect2 id="mapping-declaration-onetoone" revision="3">
            <title>one-to-one (um-pra-um)</title>

            <para>
                Uma associação um-pra-um para outra classe persistente é declarada usando 
                um elemento <literal>one-to-one </literal>.
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="onetoone1" coords="2 70"/>
                    <area id="onetoone2" coords="3 70"/>
                    <area id="onetoone3" coords="4 70"/>
                    <area id="onetoone4" coords="5 70"/>
                    <area id="onetoone5" coords="6 70"/>
                    <area id="onetoone6" coords="7 70"/>
                    <area id="onetoone7" coords="8 70"/>
                    <area id="onetoone8" coords="9 70"/>
                    <area id="onetoone9" coords="10 70"/>
                    <area id="onetoone10" coords="11 70"/>
                </areaspec>
                <programlisting><![CDATA[<one-to-one
        name="propertyName"
        class="ClassName"
        cascade="cascade_style"
        constrained="true|false"
        fetch="join|select"
        property-ref="propertyNameFromAssociatedClass"
        access="field|property|ClassName"
        formula="any SQL expression"
        lazy="proxy|no-proxy|false"
        entity-name="EntityName"
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        foreign-key="foreign_key_name"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="onetoone1">
                        <para>
                            <literal>name</literal>: O nome da propriedade.
                        </para>                
                    </callout>                   
                    <callout arearefs="onetoone2">
                        <para>
                            <literal>class</literal> (opcional – default para o tipo da propriedade 
                            definido via reflection): O nome da classe associada.
                         </para>                   
                    </callout>
                    <callout arearefs="onetoone3">
                        <para>
                            <literal>cascade</literal> (opcional): Especifica qual operação deve 
                            ser cascateada do objeto pai para o objeto associado.
                         </para>
                    </callout>
                    <callout arearefs="onetoone4">
                        <para>
                            <literal>constrained</literal> (opcional): Especifica que uma chave estrangeira 
                            constraint na chave primária da tabela mapeada referencia a tabela da classe 
                            associada, Esta opção afeta a ordem em queh <literal>save()</literal> e
                            <literal>delete()</literal> são cascateadas, e determina se a associação 
                            pode ser substituída (isto também é usado pela ferramenta schema export).
                         </para>                  
                    </callout>
                    <callout arearefs="onetoone5">
                        <para>
                            <literal>fetch</literal> ((opcional – valor default <literal>select</literal>): 
                            Escolhe entre outer-join fetching ou sequential select fetching.
                         </para>              
                    </callout>
                    <callout arearefs="onetoone6">
                        <para>
                            <literal>property-ref</literal>(opcional): O nome da propriedade da classe associada 
                            que é ligada a chave primária desta classe. Se não for especificada, a chave primária 
                            da classe associada é utilizada.
                         </para>                
                    </callout>                   
                    <callout arearefs="onetoone7">
                        <para>
                            <literal>access</literal> (opcional - valor default padrão <literal>property</literal>): 
                            A estratégia que o Hibernate pode usar para acessar o valor da propriedade.
                         </para>
                    </callout>
                    <callout arearefs="onetoone8">
                        <para>
                            <literal>formula</literal> (opcional): Quase todas associações um-pra-um mapeiam 
                            para a chave primária da entidade dona. No caso raro, que não é o caso, você 
                            pode especificar uma outra coluna, colunas ou expressões para juntar utilizando 
                            uma formula SQL. (Veja <literal>org.hibernate.test.onetooneformula</literal> 
                            para exemplo).
                         </para>
                    </callout>
                    <callout arearefs="onetoone9">
                        <para>
                            <literal>lazy</literal> (opcional – valor default <literal>proxy</literal>): 
                            Por default, associações single point são proxied. <literal>lazy="no-proxy"</literal> 
                            especifica que a propriedade deve ser fetched lazily quando o atributo é acessado 
                            pela primeira vez (requer build-time bytecode instrumentation). 
                            <literal>lazy="false"</literal> especifica que a associação vai sempre ser 
                            avidamente fetched. <emphasis>Note que se <literal>constrained="false"</literal>, 
                            proxing é impossível e o Hibernate vai ávido fetch a associação!</emphasis>
                         </para>
                    </callout>
                    <callout arearefs="onetoone10">
                        <para>
                            <literal>entity-name</literal> (opcional): O nome da entidade da classe associada.
                         </para>                   
                    </callout>
                </calloutlist>
            </programlistingco>
        
            <para>
                Existem duas variedades de associações um-pra-um:
            </para>
            <itemizedlist>
            <listitem><para>
                associações de chave primária
            </para></listitem>
            <listitem><para>
                associações de chave estrangeira exclusiva
            </para></listitem>
            </itemizedlist>
            
            <para>
                Associações de chave primária não necessitam de uma coluna extra de tabela; se duas 
                linhas são relacionadas pela associação então as duas linhas da tabela dividem a mesmo 
                valor da chave primária. Assim, se você quer que dois objetos sejam relacionados por 
                uma associação de chave primária, você deve ter certeza que eles são assinados com o 
                mesmo valor identificador!
            </para>
            
            <para>
                Para uma associação de chave primária, adicione os seguintes mapeamentos em 
                <literal>Employee</literal> e <literal>Person</literal>, respectivamente.
            </para>

            <programlisting><![CDATA[<one-to-one name="person" class="Person"/>]]></programlisting>
            <programlisting><![CDATA[<one-to-one name="employee" class="Employee" constrained="true"/>]]></programlisting>

            <para>
                Agora nós devemos assegurar que as chaves primárias de linhas relacionadas nas 
                tabelas PERSON e EMPLOYEE são iguais. Nós usamos uma estratégia especial de geração 
                de identificador do Hibernate chamada <literal>foreign</literal>:
            </para>

            <programlisting><![CDATA[<class name="person" table="PERSON">
    <id name="id" column="PERSON_ID">
        <generator class="foreign">
            <param name="property">employee</param>
        </generator>
    </id>
    ...
    <one-to-one name="employee"
        class="Employee"
        constrained="true"/>
</class>]]></programlisting>

            <para>
                Uma nova instância de <literal>Person</literal> salva recentemente é então assinada 
                com o mesmo valor da chave primária da instância de <literal>employee</literal> referenciada 
                com a propriedade <literal>employee</literal> daquela <literal>Person</literal>.
            </para>

            <para>
                Alternativamente, uma chave estrangeira com uma unique constraint, de 
                <literal>Employee</literal> para <literal>Person</literal>, pode ser expressa como:
            </para>
            
            <programlisting><![CDATA[<many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/>]]></programlisting>
            
            <para>
                E esta associação pode ser feita de forma bi-direcional adicionando o seguinte 
                no mapeamento de <literal>Person</literal>:
            </para>
            
           <programlisting><![CDATA[<one-to-one name="employee" class="Employee" property-ref="person"/>]]></programlisting>

        </sect2>

        <sect2 id="mapping-declaration-naturalid">
            <title>natural-id</title>

            <programlisting><![CDATA[<natural-id mutable="true|false"/>
        <property ... />
        <many-to-one ... />
        ......
</natural-id>]]></programlisting>

            <para>
                Embora nós recomendemos o uso de surrogate keys como chaves primárias, você deve 
                ainda identificar chaves naturais para todas as entidades. Uma chave natural é 
                uma propriedade ou combinação de propriedades que é exclusiva e não nula. Se não 
                pude ser modificada, melhor ainda. Mapeie as propriedades da chave natural dentro do 
                elemento <literal>&lt;natural-id&gt;</literal>. O Hibernate irá gerar a chave 
                exclusiva necessária e as constraints de nullability , e seu mapeamento será 
                apropriadamente auto documentado.
            </para>
            
            <para>
                Nós recomendamos com enfase que você implemente <literal>equals()</literal> e 
                <literal>hashCode()</literal> para comparar as propriedades da chave natural da 
                entidade.
            </para>

            <para>
                Este mapeamento não tem o objetivo de uso com entidades com natural chaves primárias.
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>mutable</literal>  mutable (opcional, valor default<literal>false</literal>): 
                        Por default, propriedades naturais identificadoras são consideradas imutáveis (constante).
                    </para>
                </listitem>
            </itemizedlist>
            
        </sect2>
        
        <sect2 id="mapping-declaration-component" revision="2">
            <title>componente, componente dinâmico</title>

            <para>
                O elemento<literal>&lt;component&gt;</literal> mapeia propriedades de um 
                objeto filho para colunas da tabela de uma classe pai. Componentes podem, 
                um após o outro, declarar suas próprias propriedades, componentes ou coleções. 
                Veja "Components" abaixo.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="component1" coords="2 45"/>
                    <area id="component2" coords="3 45"/>
                    <area id="component3" coords="4 45"/>
                    <area id="component4" coords="5 45"/>
                    <area id="component5" coords="6 45"/>
                    <area id="component6" coords="7 45"/>
                    <area id="component7" coords="8 45"/>
                    <area id="component8" coords="9 45"/>
                </areaspec>            
                <programlisting><![CDATA[<component 
        name="propertyName" 
        class="className"
        insert="true|false"
        update="true|false"
        access="field|property|ClassName"
        lazy="true|false"
        optimistic-lock="true|false"
        unique="true|false"
        node="element-name|."
>
        
        <property ...../>
        <many-to-one .... />
        ........
</component>]]></programlisting>
                <calloutlist>
                    <callout arearefs="component1">
                        <para>
                            <literal>name</literal>: O nome da propriedade.
                        </para>               
                    </callout>                   
                    <callout arearefs="component2">
                        <para>
                            <literal>class</literal> (opcional – valor default para o tipo de 
                            propriedade determinada por reflection): O nome da classe (filha) do 
                            componente.
                         </para>                 
                    </callout>
                    <callout arearefs="component3">
                        <para>
                            <literal>insert</literal>: As colunas mapeadas aparecem nos 
                            SQL de <literal>INSERT</literal>s?
                         </para>               
                    </callout>                   
                    <callout arearefs="component4">
                        <para>
                            <literal>update</literal>: As colunas mapeadas aparecem nos 
                            SQL de <literal>UPDATE</literal>s?
                         </para>               
                    </callout>                   
                    <callout arearefs="component5">
                        <para>
                            <literal>access</literal> (opcional – valor default <literal>property</literal>): 
                            A estratégia que o Hibernate pode usar para acessar o valor da propriedade.
                         </para>
                    </callout>
                   <callout arearefs="component6">
                        <para>
                            <literal>lazy</literal> (opcional - valor default <literal>false</literal>): 
                            Especifica que este componente deve ser fetched lazily quando o atributo for 
                            acessado pela primeira vez (requer build-time bytecode instrumentation).
                         </para>
                    </callout>
                    <callout arearefs="component7">
                            <para>
                                <literal>optimistic-lock</literal> (opcional – valor default <literal>true</literal>): 
                                Especifica que atualizações para este componente requerem ou não aquisição 
                                de um lock otimista. Em outras palavras, determina se uma versão de incremento deve 
                                ocorrer quando esta propriedade estiver modificada.
                             </para>
                    </callout>
                    <callout arearefs="component8">
                            <para>
                                <literal>unique</literal> (opcional – valor default <literal>false</literal>): 
                                Especifica que existe uma unique constraint em todas as colunas mapeadas do 
                                componente.
                             </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                A tag filha <literal>&lt;property&gt;</literal> acrescenta a propriedade
                de mapeamento da classe filha para colunas de uma tabela.
            </para>

            <para>
                O elemento <literal>&lt;component&gt;</literal> permite um sub-elemento 
                <literal>&lt;parent&gt;</literal> mapeie uma propriedade da classe do componente 
                como uma referencia de volta para a entidade que o contém.
            </para>

            <para>
                O elemento  <literal>&lt;dynamic-component&gt;</literal> permite que um 
                <literal>Map</literal> possa ser mapeado como um componente onde os nomes das 
                propriedades referem-se para as chaves no mapa, veja 
                <xref linkend="components-dynamic"/>.
            </para>
            
        </sect2>

        <sect2 id="mapping-declaration-properties" revision="2">
            <title>propriedades</title>

            <para>
                O elemento <literal>&lt;properties&gt;</literal> permite a definição de um grupo 
                com nome, lógico de propriedades de uma classe. O uso mais importante do construtor 
                é que este permite uma combinação de propriedades para ser o objetivo de uma 
                <literal>property-ref</literal>. É também um modo conveninente para definir uma 
                unique constraint de múltiplas colunas.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="properties1" coords="2 45"/>
                    <area id="properties2" coords="3 45"/>
                    <area id="properties3" coords="4 45"/>
                    <area id="properties4" coords="5 45"/>
                    <area id="properties5" coords="6 45"/>
                </areaspec>            
                <programlisting><![CDATA[<properties 
        name="logicalName" 
        insert="true|false"
        update="true|false"
        optimistic-lock="true|false"
        unique="true|false"
>
        
        <property ...../>
        <many-to-one .... />
        ........
</properties>]]></programlisting>
                <calloutlist>
                    <callout arearefs="properties1">
                        <para>
                            <literal>name</literal>:: O nome lógico do agrupamento – 
                            <emphasis>não </emphasis> é o nome atual de propriedade.
                        </para>               
                    </callout>                   
                    <callout arearefs="properties2">
                        <para>
                            <literal>insert</literal>: As colunas mapeadas aparecem nos 
                            SQL de <literal>INSERT</literal>s?
                         </para>               
                    </callout>                   
                    <callout arearefs="properties3">
                        <para>
                            <literal>update</literal>: As colunas mapeadas aparecem nos 
                            SQL de <literal>UPDATE</literal>s?
                         </para>               
                    </callout>                   
                    <callout arearefs="properties4">
                            <para>
                                <literal>optimistic-lock</literal> (opcional – valor default <literal>true</literal>): 
                                Especifica que atualizações para estes componentes requerem ou não aquisição de um
                                lock otimista. Em outras palavras, determina se uma versão de incremento deve ocorrer 
                                quando estas propriedades estiverem modificadas.
                             </para>
                    </callout>
                    <callout arearefs="properties5">
                            <para>
                                <literal>unique</literal> (opcional – valor defautl <literal>false</literal>): 
                                Especifica que uma unique constraint existe em todas as colunas mapeadas do componente.
                            </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
            <para>
                Por exemplo, se nós temos o seguinte mapeamento de <literal>&lt;properties&gt;</literal>:
            </para>
            
            <programlisting><![CDATA[<class name="Person">
    <id name="personNumber"/>
    ...
    <properties name="name" 
            unique="true" update="false">
        <property name="firstName"/>
        <property name="initial"/>
        <property name="lastName"/>
    </properties>
</class>]]></programlisting>

            <para>
                Então nós podemos ter uma  associação de dados herdados que referem a esta chave 
                exclusiva da tabela <literal>Person</literal>, ao invés de se referirem a chave 
                primária:
            </para>

            <programlisting><![CDATA[<many-to-one name="person" 
         class="Person" property-ref="name">
    <column name="firstName"/>
    <column name="initial"/>
    <column name="lastName"/>
</many-to-one>]]></programlisting>
            
            <para>
                Nós não recomendamos o uso deste tipo de coisa fora do contexto de mapeamento de 
                dados herdados.
            </para>
            
        </sect2>

        <sect2 id="mapping-declaration-subclass" revision="4">
            <title>subclass (subclasse)</title>

            <para>
                Finalmente, a persistência polimórfica requer a declaração de cada subclasse 
                da classe de persistência raiz. Para a estratégia de mapeamento 
                table-per-class-hierarchy, a declaração <literal>&lt;subclass&gt;</literal>
                deve ser usada.                
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="subclass1" coords="2 55"/>
                    <area id="subclass2" coords="3 55"/>
                    <area id="subclass3" coords="4 55"/>
                    <area id="subclass4" coords="5 55"/>
                </areaspec>
                <programlisting><![CDATA[<subclass
        name="ClassName"
        discriminator-value="discriminator_value"
        proxy="ProxyInterface"
        lazy="true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        entity-name="EntityName"
        node="element-name"
        extends="SuperclassName">

        <property .... />
        .....
</subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="subclass1">
                        <para>
                            <literal>name</literal>:  O nome de classe completamente qualificada da subclasse.                            
                        </para>              
                    </callout>                   
                    <callout arearefs="subclass2">
                        <para>
                            <literal>discriminator-value</literal> (opcional – valor default o nome da classe): 
                            Um valor que distingue subclasses individuais.
                        </para>               
                    </callout>
                    <callout arearefs="subclass3">
                        <para>
                            <literal>proxy</literal> (opcional): Especifica a classe ou interface que 
                            usará os proxies de inicialização atrasada.
                        </para>               
                    </callout>
                    <callout arearefs="subclass4">
                        <para>
                            <literal>lazy</literal> (opcional, valor default <literal>true</literal>): 
                            Configurar <literal>lazy="false"</literal> desabilitará o uso de 
                            inicialização atrasada.
                        </para>
                    </callout>    
                </calloutlist>
            </programlistingco>
            <para>
                Cada subclasse deve declarar suas próprias propriedades persistentes e subclasses. 
                As propriedades <literal>&lt;version&gt;</literal> e <literal>&lt;id&gt;</literal>  
                são configuradas para serem herdades da classe raiz. Cada subclasse numa hierarquia 
                deve definir um único <literal>discriminator-value</literal>. Se nenhum for 
                especificado, o nome da classe Java completamente qualificada será usada.
            </para>
            
            <para>
                Para informações sobre mapeamento de heranças, veja o <xref linkend="inheritance"/>.
            </para>

        </sect2>

         <sect2 id="mapping-declaration-joinedsubclass" revision="3">
            <title>joined-subclass</title>

            <para>
                Alternativamente, cada subclasse pode ser mapeada para sua própria tabela 
                (Estratégia de mapeamento table-per-subclass). O estado herdado é devolvido 
                por associação com a tabela da superclasse. Nós usamos o elemento 
                <literal>&lt;joined-subclass&gt;</literal>.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="joinedsubclass1" coords="2 45"/>
                    <area id="joinedsubclass2" coords="3 45"/>
                    <area id="joinedsubclass3" coords="4 45"/>
                    <area id="joinedsubclass4" coords="5 45"/>
                </areaspec>
                <programlisting><![CDATA[<joined-subclass
        name="ClassName"
        table="tablename"
        proxy="ProxyInterface"
        lazy="true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name">

        <key .... >

        <property .... />
        .....
</joined-subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="joinedsubclass1">
                        <para>
                            <literal>name</literal>: O nome da classe completamente qualificada da 
                            subclasse.
                        </para>            
                    </callout>                   
                    <callout arearefs="joinedsubclass2">
                        <para>
                            <literal>table</literal>: O nome da tabela da subclasse.
                         </para>            
                    </callout>                   
                    <callout arearefs="joinedsubclass3">
                        <para>
                            <literal>proxy</literal> (opcional): Especifica a classe ou interface 
                            para usar os proxies de recuperação atrasada.
                         </para>              
                    </callout>
                    <callout arearefs="joinedsubclass4">
                        <para>
                            <literal>lazy</literal> (opcional, valor default <literal>true</literal>): 
                            Fixanr <literal>lazy="false"</literal> desabilita o uso recuperação 
                            atrasada.
                          </para>
                    </callout>    
                </calloutlist>
            </programlistingco>

            <para>
                A coluna discriminator requerida para esta estratégia de mapeamento. Porém, 
                cada subclasse deve declarar uma coluna de tabela com o identificador do objeto 
                usando o elemento <literal>&lt;key&gt;</literal>. O mapeamento no início do 
                capítulo poderia ser re-escrito assim:
            </para>
            
        <programlisting><![CDATA[<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping package="eg">

        <class name="Cat" table="CATS">
                <id name="id" column="uid" type="long">
                        <generator class="hilo"/>
                </id>
                <property name="birthdate" type="date"/>
                <property name="color" not-null="true"/>
                <property name="sex" not-null="true"/>
                <property name="weight"/>
                <many-to-one name="mate"/>
                <set name="kittens">
                        <key column="MOTHER"/>
                        <one-to-many class="Cat"/>
                </set>
                <joined-subclass name="DomesticCat" table="DOMESTIC_CATS">
                    <key column="CAT"/>
                    <property name="name" type="string"/>
                </joined-subclass>
        </class>

        <class name="eg.Dog">
                <!-- mapping for Dog could go here -->
        </class>

</hibernate-mapping>]]></programlisting>

             <para>
                 Para informações de mapeamentos de herança, veja <xref linkend="inheritance"/>.
             </para>

        </sect2>

        <sect2 id="mapping-declaration-unionsubclass" revision="2">
           <title>union-subclass</title>

           <para>
               Uma terceira opção é mapear para tabelas apenas as classes concretas de uma 
               hierarquia de heranças, (a estratégia table-per-concrete-class) onde cada tabela 
               define todos os estados persistentes da classe, incluindo estados herdados. 
               No Hibernate, não é absolutamente necessário mapear explicitamente como hierarquia 
               de heranças. Você pode simplesmente mapear cada classe com uma declaração 
               <literal>&lt;class&gt;</literal> separada. Porém, se você deseja usar associações 
               polimórficas (por exemplo: uma associação para a superclasse de sua hierarquia), 
               você precisa usar o mapeamento <literal>&lt;union-subclass&gt;</literal>.

           </para>

            <programlistingco>
                <areaspec>
                    <area id="unionsubclass1" coords="2 45"/>
                    <area id="unionsubclass2" coords="3 45"/>
                    <area id="unionsubclass3" coords="4 45"/>
                    <area id="unionsubclass4" coords="5 45"/>
                </areaspec>
                <programlisting><![CDATA[<union-subclass
        name="ClassName"
        table="tablename"
        proxy="ProxyInterface"
        lazy="true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name">

        <property .... />
        .....
</union-subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="unionsubclass1">
                        <para>
                            <literal>name</literal>: O nome da subclasse completamente qualificada.
                        </para>            
                    </callout>                   
                    <callout arearefs="unionsubclass2">
                        <para>
                            <literal>table</literal>: O nome da tabela da subclasse.
                         </para>            
                    </callout>                   
                    <callout arearefs="unionsubclass3">
                        <para>
                            <literal>proxy</literal> (optional): Specifies a class or interface to use 
                            for lazy initializing proxies.
                            
                            <literal>proxy</literal> (opcional): Especifica a classe ou interface para usar 
                            os proxies de recuperação atrasada.
                         </para>              
                    </callout>
                    <callout arearefs="unionsubclass4">
                        <para>
                            <literal>lazy</literal> (optional, defaults to <literal>true</literal>): Setting 
                            <literal>lazy="false"</literal> disables the use of lazy fetching.
                            <literal>lazy</literal> (opcional, valor default p<literal>true</literal>): 
                            Fixando <literal>lazy="false"</literal> desabilita o uso da recuperação atrasada.
                          </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                A coluna discriminatõria não é requerida para esta estratégia de mapeamento.

         </para>

            <para>
                Para informações sobre mapeamentos de herança, veja <xref linkend="inheritance"/>.
            </para>

        </sect2>

   	<sect2 id="mapping-declaration-join" revision="3">
            <title>join</title>

            <para>
                Usando o elemento  <literal>&lt;join&gt;</literal>>, é possível mapear 
                propriedades de uma classe para várias tabelas.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="join1" coords="2 50"/>
                    <area id="join2" coords="3 50"/>
                    <area id="join3" coords="4 50"/>
                    <area id="join4" coords="5 50"/>
                    <area id="join5" coords="6 50"/>
                    <area id="join6" coords="7 50"/>
                </areaspec>
                <programlisting><![CDATA[<join
        table="tablename"
        schema="owner"
        catalog="catalog"
        fetch="join|select"
        inverse="true|false"
        optional="true|false">
        
        <key ... />
        
        <property ... />
        ...
</join>]]></programlisting>

                <calloutlist>
                    <callout arearefs="join1">
                        <para>
                            <literal>table</literal>: O nome da tabela associada.
                        </para>
                    </callout>
                    <callout arearefs="join2">
                        <para>
                            <literal>schema</literal> (opcional): Sobrepõe o nome do esquema 
                            especificado pelo elemento raiz <literal>&lt;hibernate-mapping&gt;</literal>.
                         </para>
                    </callout>
                    <callout arearefs="join3">
                        <para>
                            <literal>catalog</literal> (opcional): Sobrepõe o nome do catálogo
                            especificado pelo elemento raiz<literal>&lt;hibernate-mapping&gt;</literal>.
                         </para>
                    </callout>
                    <callout arearefs="join4">
                        <para>
                            <literal>fetch</literal>(opcional – valor default <literal>join</literal>): Se setado 
                            para <literal>join</literal>, o padrão, o Hibernate irá usar um inner join para 
                            restaurar um <literal>join</literal> definido por uma classe ou suas subclasses e 
                            uma outer join para um <literal>join</literal> definido por uma subclasse. 
                            Se setado para <literal>select</literal>, então o Hibernate irá usar uma seleção 
                            seqüencial para um <literal>&lt;join&gt;</literal> definida numa subclasse, que irá 
                            ser emitido apenas se uma linha se concentrar para representar uma instância 
                            da subclasse. Inner joins irá ainda ser usado para restaurar um 
                            <literal>&lt;join&gt;</literal> definido pela classe e suas superclasses.
                         </para>
                    </callout>
                    <callout arearefs="join5">
                        <para>
                            <literal>inverse</literal> (opcional – valor default <literal>false</literal>): 
                            Se habilitado, o Hibernate não irá tentar inserir ou atualizar as propriedades 
                            definidas por este join.
                         </para>
                    </callout>
                    <callout arearefs="join6">
                        <para>
                            <literal>optional</literal> (opcional – valor default <literal>false</literal>):
                            Se habilitado, o Hibernate irá inserir uma linha apenas se as propriedades definidas 
                            por esta junção não forem nulas e irá sempre usar uma outer join para 
                            recuperar as propriedades.
                         </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                Por exemplo, a informação de endereço para uma pessoa pode ser mapeada para uma 
                tabela separada (enquanto preservando o valor da semântica de tipos para 
                todas as propriedades):       
            </para>

            <programlisting><![CDATA[<class name="Person"
    table="PERSON">

    <id name="id" column="PERSON_ID">...</id>

    <join table="ADDRESS">
        <key column="ADDRESS_ID"/>
        <property name="address"/>
        <property name="zip"/>
        <property name="country"/>
    </join>
    ...]]></programlisting>

            <para>
                Esta característica é útil apenas para modelos de dados legados, nós recomendamos 
                menos tabelas do que classes e um modelo de domínio bem granulado. Porém, é 
                útil para ficar trocando entre estratégias de mapeamento de herança 
                numa hierarquia simples, como explicado mais a frente.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-key">
            <title>key</title>

            <para>
                Nós vimos que o elemento <literal>&lt;key&gt;</literal> surgiu algumas vezes
                até agora. Ele aparece em qualquer lugar que o elemento pai define uma junção 
                para a nova tabela, e define a chave estrangeira para a tabela associada, que 
                referencia a chave primária da tabela original.                
            </para>

            <programlistingco>
                <areaspec>
                    <area id="key1" coords="2 50"/>
                    <area id="key2" coords="3 50"/>
                    <area id="key3" coords="4 50"/>
                    <area id="key4" coords="5 50"/>
                    <area id="key5" coords="6 50"/>
                    <area id="key6" coords="7 50"/>
                </areaspec>
                <programlisting><![CDATA[<key
        column="columnname"
        on-delete="noaction|cascade"
        property-ref="propertyName"
        not-null="true|false"
        update="true|false"
        unique="true|false"
/>]]></programlisting>

                <calloutlist>
                    <callout arearefs="key1">
                        <para>.
                            <literal>column</literal> (opcional): O nome da coluna da chave estrangeira. 
                            Isto também pode ser especificado por aninhamento de elemento(s) 
                            <literal>&lt;column&gt;</literal>.
                        </para>
                    </callout>
                    <callout arearefs="key2">
                        <para>
                            <literal>on-delete</literal> (opcional, valor default <literal>noaction</literal>): 
                            Especifica se a constraint da chave estrangeira no banco de dados esta
                            habilitada para cascade delete .
                         </para>
                    </callout>
                    <callout arearefs="key3">
                        <para>
                            <literal>property-ref</literal> (opcional): Especifica que a chave estrangeira 
                            se refere a colunas que não são chave primária da tabela original. 
                            (Util para base de dados legadas.)
                         </para>
                    </callout>
                    <callout arearefs="key4">
                        <para>
                            <literal>not-null</literal> (opcional): Especifica que a coluna da chave 
                            estrangeira não aceita valores nulos (isto é implícito em qualquer momento 
                            que a chave estrangeira também fizer parte da chave primária).
                        </para>
                    </callout>
                    <callout arearefs="key5">
                        <para>
                            <literal>update</literal> (optional): Specifies that the foreign key should never
                            be updated (this is implied whenever the foreign key is also part of the primary 
                            key).
                            <literal>update</literal> (opcional): Especifica que a chave estrangeira nunca 
                            deve ser atualizada (isto é implícito em qualquer momento que a chave estrangeira 
                            também fizer parte da chave primária).
                        </para>
                    </callout>
                    <callout arearefs="key6">
                        <para>
                             <literal>unique</literal> (opcional): Especifica que a chave estrangeira deve ter 
                            uma constraint unique (sto é implícito em qualquer momento que a chave estrangeira 
                            também fizer parte da chave primária).
                         </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                Nós recomendamos que para sistemas que a performance de delete seja importante, todas as 
                chaves deve ser definida <literal>on-delete="cascade"</literal>, e o Hibernate irá usar 
                uma constraint a nível de banco de dados <literal>ON CASCADE DELETE</literal>, ao invés 
                de muitas instruções <literal>DELETE</literal>. Esteja ciente que esta característica é 
                um atalho da estratégia usual de optimistic locking do Hibernate para dados versionados.
            </para>
            
            <para>
                Os atributos <literal>not-null</literal> e <literal>update</literal> são úteis quando 
                estamos mapeamos uma associação unidirecional um para muitos. Se você mapear uma 
                asociação unidirecional um para muitos para uma chave estrangeira non-nullable, você 
                <emphasis>deve</emphasis> declarar a coluna chave usando 
                <literal>&lt;key not-null="true"&gt;</literal>.
            </para>

        </sect2>

        <sect2 id="mapping-column" revision="4">
           <title>elementos column e formula</title>
           <para>
               Qualquer elemento de mapeamente que aceita um atributo <literal>column</literal> irá 
               aceitar alternativamente um subelemento <literal>&lt;column&gt;</literal>. Da mesma forma, 
               <literal>formula</literal> é uma alternativa para o atributo <literal>formula</literal>.               
           </para>

           <programlisting><![CDATA[<column
        name="column_name"
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
        unique-key="multicolumn_unique_key_name"
        index="index_name"
        sql-type="sql_type_name"
        check="SQL expression"
        default="SQL expression"/>]]></programlisting>

            <programlisting><![CDATA[<formula>SQL expression</formula>]]></programlisting>
        
            <para>
                O atributo <literal>column</literal> e <literal>formula</literal> podem até ser combinados
                dentro da mesma propriedade ou associação mapeando para expressar, 
                por exemplo, associações exóticas.
            </para>

            <programlisting><![CDATA[<many-to-one name="homeAddress" class="Address"
        insert="false" update="false">
    <column name="person_id" not-null="true" length="10"/>
    <formula>'MAILING'</formula>
</many-to-one>]]></programlisting>

    </sect2>  
   	
        <sect2 id="mapping-declaration-import">
            <title>import</title>

            <para>
                Suponha que a sua aplicação tem duas classes persistentes com o mesmo nome, e você não quer 
                especificar o nome qualificado (do pacote) nas queries do Hibernate. As Classes devem 
                ser "importadas" explicitamente, de preferência contando com  <literal>auto-import="true"</literal>. 
                Você pode até importar classes e interfaces que não estão explicitamente mapeadas.
            </para>
            
            <programlisting><![CDATA[<import class="java.lang.Object" rename="Universe"/>]]></programlisting>
            
            <programlistingco>
                <areaspec>
                    <area id="import1" coords="2 40"/>
                    <area id="import2" coords="3 40"/>
                </areaspec>
                <programlisting><![CDATA[<import
        class="ClassName"
        rename="ShortName"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="import1">
                        <para>
                            <literal>class</literal>: O nome qualificado (do pacote) de qualquer classe Java.
                        </para>              
                    </callout>                   
                    <callout arearefs="import2">
                        <para>
                            <literal>rename</literal> (opcional – valor default, o nome da classe não 
                            qualificada): Um nome que pode ser usado numa linguagem de consulta.
                         </para>               
                    </callout>
                </calloutlist>
            </programlistingco>
            
        </sect2>
        
        <sect2 id="mapping-types-anymapping" revision="2">
            <title>any</title>
            
            <para>
                Existe mais um tipo de propriedade de mapeamento. O elemento de mapeamento 
                <literal>&lt;any&gt;</literal> define uma associação polimórfica para classes de múltiplas tabelas. 
                Este tipo de mapeamento sempre requer mais de uma coluna. A primeira coluna possui o tipo da entidade 
                associada. A outra coluna que ficou possui o identificador. É impossível especificar uma restrição 
                de chave estrangeira para este tipo de associação, assim isto claramente não é visto 
                como um caminho usual para associações (polimórficas) de mapeamento. Você deve usar este mapeamento
                apenas em casos muito especiais (exemplo: audit logs, dados de sessão do usuário, etc).

           </para>

            <para>
                 O atributo <literal>meta-type</literal> permite a aplicação especificar um tipo adaptado 
                 que mapeia valores de colunas de banco de dados para classes persistentes que tem propriedades 
                 identificadoras do tipo especificado através do <literal>id-type</literal>. Você deve especificar 
                 o mapeamento de valores do meta-type para nome de classes.
            </para>

            <programlisting><![CDATA[<any name="being" id-type="long" meta-type="string">
    <meta-value value="TBL_ANIMAL" class="Animal"/>
    <meta-value value="TBL_HUMAN" class="Human"/>
    <meta-value value="TBL_ALIEN" class="Alien"/>
    <column name="table_name"/>
    <column name="id"/>
</any>]]></programlisting>

            <programlistingco>
                <areaspec>
                    <area id="any1" coords="2 50"/>
                    <area id="any2" coords="3 50"/>
                    <area id="any3" coords="4 50"/>
                    <area id="any4" coords="5 50"/>
                    <area id="any5" coords="6 50"/>
                    <area id="any6" coords="7 50"/>
                </areaspec>
                <programlisting><![CDATA[<any
        name="propertyName"
        id-type="idtypename"
        meta-type="metatypename"
        cascade="cascade_style"
        access="field|property|ClassName"
        optimistic-lock="true|false"
>
        <meta-value ... />
        <meta-value ... />
        .....
        <column .... />
        <column .... />
        .....
</any>]]></programlisting>
                <calloutlist>
                    <callout arearefs="any1">
                        <para>
                            <literal>name</literal>: o nome da propriedade.
                        </para>            
                    </callout>                   
                    <callout arearefs="any2">
                        <para>
                            <literal>id-type</literal>: o tipo identificador.
                         </para>            
                    </callout>                   
                    <callout arearefs="any3">
                        <para>
                            <literal>meta-type</literal> (opcional – valor default <literal>string</literal>): 
                            Qualquer tipo que é permitido para um mapeamento discriminador.
                         </para>            
                    </callout>                   
                    <callout arearefs="any4">
                        <para>
                            <literal>cascade</literal> (opcional – valor default <literal>none</literal>): 
                            o estilo do cascade.
                         </para>            
                    </callout>                   
                    <callout arearefs="any5">
                        <para>
                            <literal>access</literal> (opcional – valor default <literal>property</literal>): 
                            A estratégia que o hibernate deve usar para acessar o valor da propriedade.
                         </para>
                    </callout>
                    <callout arearefs="any6">
                        <para>
                            <literal>optimistic-lock</literal> (opcional - valor default<literal>true</literal>): 
                            Especifica que as atualizações para esta propriedade requerem ou não aquisição da 
                            trava otimista. Em outras palavras, define se uma versão de incremento deve ocorrer 
                            se esta propriedade está modificada.
                    </para>
                    </callout>
                </calloutlist>
            </programlistingco>

      </sect2>

    </sect1>

    <sect1 id="mapping-types">
        <title>Tipos do Hibernate</title>

        <sect2 id="mapping-types-entitiesvalues" revision="1">
            <title>Entidades e valores</title>

            <para>
                Para entender o comportamento de vários objetos em nível de linguagem de Java a 
                respeito do serviço de persistência, nós precisamos classificá-los em dois grupos.
            </para>

            <para>
                Uma <emphasis>entidade </emphasis> existe independentemente de qualquer outro 
                objeto guardando referências para a entidade. Em contraste com o modelo usual de 
                Java que um objeto não referenciado é coletado pelo garbage collector. Entidades 
                devem ser explicitamente salvas ou deletada (exceto em operações de salvamento 
                ou deleção que possam ser executada em <emphasis>cascata</emphasis> de uma entidade 
                pai para seus filhos). Isto é diferente do modelo ODMG de persistência do objeto 
                por acessibilidade – e corresponde quase a como objetos de aplicações são 
                geralmente usados em grandes sistemas. Entidades suportam referências circulares 
                e comuns. Eles podem ser versionadas.
            </para>

            <para>
                Uma entidade em estado persistente consiste de referências para outras entidades 
                e instâncias de tipos de  <emphasis>valor</emphasis>. Valores são primitivos, 
                coleções (não o que tem dentro de uma coleção), componentes e certos objetos 
                imutáveis. Entidades distintas, valores (em coleções e componentes particulares)
                <emphasis>são </emphasis> persistidos e apagados por acessibilidade. Visto que 
                objetos value (e primitivos) são persistidos e apagados junto com as entidades 
                que os contém e não podem ser versionados independentemente. Valores têm 
                identidade não independente, assim eles não podem ser comuns para duas 
                entidades ou coleções.

            </para>

            <para>
                Até agora, nós estivemos usando o termo "classe persistente" para referir 
                a entidades. Nós iremos continuar a fazer isto. Falando a rigor, porém, nem todas 
                as classes definidas pelo usuário com estados persistentes são entidades. Um 
                <emphasis>componente</emphasis> é uma classe de usuário definida com valores 
                semânticos. Uma propriedade de Java de tipo <literal>java.lang.String</literal> 
                também tem um valor semêntico. Dada esta definição, nós podemos dizer que 
                todos os tipos (classes) fornecida pelo JDK tem tipo de valor semântico em Java, 
                enquanto que tipos definidos pelo usuário pode ser mapeados com entidade ou valor 
                de tipo semântico. Esta decisão pertence ao desenvolvedor da aplicação. Uma boa 
                dica para uma classe entidade em um modelo de domínio são referências comuns 
                para uma instância simples daquela classe, enquanto a composição ou agregação 
                geralmente se traduz para um valor de tipo.
            </para>

            <para>
                Nós iremos rever ambos os conceitos durante toda a documentação.

            </para>

            <para>
                O desafio pe mapear o sistema de tipo de Java (e a definição do desenvolvedor de 
                entidades e tipos de valor) para o sistema de tipo SQL/banco de dados. A ponte entre ambos 
                os sistemas é fornecido pelo Hibernate: para entidades que usam 
                <literal>&lt;class&gt;</literal>, <literal>&lt;subclass&gt;</literal> e assim por diante. 
                Para tipos de valores nós usamos <literal>&lt;property&gt;</literal>, 
                <literal>&lt;component&gt;</literal>, etc, geralmente com um atributo 
                <literal>type</literal>. O valor deste atributo é o nome de um  <emphasis>tipo de 
                mapeamento</emphasis> do Hibernate. O Hibernate fornece muitos mapeamentos 
                (para tipos de valores do JDK padrão) ut of the box. Você pode escrever os seus 
                próprios tipos de mapeamentos e implementar sua estratégia de conversão adaptada, 
                como você verá adiante.
            </para>

            <para>
                Todos os tipos internos do hibernate exceto coleções suportam semânticas nulas.

            </para>

        </sect2>

        <sect2 id="mapping-types-basictypes" revision="3">
            <title>Valores de tipos básicos</title>

            <para>
                O tipos internos de mapeamentos básicos podem ser a grosso modo categorizado como:
                <variablelist>
                    <varlistentry>
                        <term><literal>integer, long, short, float, double, character, byte,
                            boolean, yes_no, true_false</literal></term>
                        <listitem>
                            <para>
                                Tipos de mapeamentos de classes primitivas ou wrapper Java especificos
                               	(vendor-specific) para tipos de coluna SQL. Boolean, 
                               	<literal>boolean, yes_no</literal> são todas codificações alternativas 
                               	para um <literal>boolean</literal> ou <literal>java.lang.Boolean</literal>
                               	do Java.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>string</literal></term>
                        <listitem>
                            <para>
                                Um tipo de mapeamento de <literal>java.lang.String</literal> para
                                <literal>VARCHAR</literal> (ou <literal>VARCHAR2</literal> no Oracle).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>date, time, timestamp</literal></term>
                        <listitem>
                            <para>
                                Tipos de mapeamento de <literal>java.util.Date</literal> e suas 
                                subclasses para os tipos SQL <literal>DATE</literal>,
                                <literal>TIME</literal> e <literal>TIMESTAMP</literal> 
                                (ou equivalente).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>calendar, calendar_date</literal></term>
                        <listitem>
                            <para>
                                Tipo de mapeamento de <literal>java.util.Calendar</literal> para 
                                os tipos SQL <literal>TIMESTAMP</literal> e 
                                <literal>DATE</literal> (ou equivalente).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>big_decimal, big_integer</literal></term>
                        <listitem>
                            <para>
                                Tipo de mapeamento de <literal>java.math.BigDecimal</literal> and
                                <literal>java.math.BigInteger</literal> para  <literal>NUMERIC</literal>
                                (ou <literal>NUMBER</literal> no Oracle).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>locale, timezone, currency</literal></term>
                        <listitem>
                            <para>
                                Tipos de mapeamentos de <literal>java.util.Locale</literal>,
                                <literal>java.util.TimeZone</literal> e <literal>java.util.Currency</literal>
                                para <literal>VARCHAR</literal> (ou <literal>VARCHAR2</literal> no Oracle). 
                                Instâncias de f <literal>Locale</literal> e <literal>Currency</literal> 
                                são mapeados para seus códigos ISO. Instâncias de <literal>TimeZone</literal> 
                                são mapeados para seu <literal>ID</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>class</literal></term>
                        <listitem>
                            <para>
                                um tipo de mapeamento de <literal>java.lang.Class</literal> para 
                                <literal>VARCHAR</literal>  (ou <literal>VARCHAR2</literal>  no 
                                Oracle). Uma <literal>Class</literal> é mapeada pelo 
                                seu nome qualificado (completo).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>binary</literal></term>
                        <listitem>
                            <para>
                                Mapeia arrays de bytes para um tipo binário de SQL apropriado.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>text</literal></term>
                        <listitem>
                            <para>
                                Maps long Java strings to a SQL <literal>CLOB</literal> or 
                                <literal>TEXT</literal> type.
                                Mapeia strings longas de Java para um tipo SQL
                                <literal>CLOB</literal> ou <literal>TEXT</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>serializable</literal></term>
                        <listitem>
                            <para>
                                Mapeia tipos Java serializáveis para um tipo binário SQL apropriado. 
                                Você pode também indicar o tipo <literal>serializable</literal> do 
                                Hibernate com o nome da classe ou interface Java serializável que 
                                não é padrão para um tipo básico.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>clob, blob</literal></term>
                        <listitem>
                            <para>
                                Tipos de mapeamentos para as classes JDBC <literal>java.sql.Clob</literal> and
                                <literal>java.sql.Blob</literal>. Estes tipos podem ser inconveniente para 
                                algumas aplicações, visto que o objeto blob ou clob pode não ser reusado 
                                fora de uma transação. (Além disso, o suporte de driver é imcompleto e 
                                inconsistente.)
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <literal>imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date,
                            imm_serializable, imm_binary</literal>
                        </term>
                        <listitem>
                            <para>
                                Mapeando tipos para o que geralmente são consideradas tipos mutáveis de 
                                Java, onde o Hibernate faz determinadas otimizações apropriadas somente 
                                para tipos imutáveis de Java, e a aplicação trata o objeto como imutável. 
                                Por exemplo, você não deve chamar <literal>Date.setTime()</literal> para 
                                uma instância mapeada como  <literal>imm_timestamp</literal>. Para mudar 
                                o valor da propriedade, e ter a mudança feita persistente, a aplicação 
                                deve atribuir um novo objeto (nonidentical) à propriedade. 
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            
            </para>

            <para>
                Identificadores únicos das entidades e coleções podem ser de qualquer tipo 
                básico exceto <literal>binary</literal>, <literal>blob</literal> ou 
                <literal>clob</literal>. (Identificadores compostos também são permitidos, 
                veja abaixo.)
            </para>
            
            <para>
                Os tipos de valores básicos têm  suas constantes <literal>Type</literal> 
                correspondentes definidas em <literal>org.hibernate.Hibernate</literal>. Por exemplo,
                <literal>Hibernate.STRING</literal> representa o tipo  <literal>string</literal>.  
            </para>

        </sect2>

        <sect2 id="mapping-types-custom" revision="2">
            <title>Tipos de valores personalizados</title>

            <para>
                É relativamente fácil para desenvolvedores criar seus próprios tipos de valor. 
                Por exemplo, você pode querer persistir propriedades do tipo 
                <literal>java.lang.BigInteger</literal> para colunas <literal>VARCHAR</literal>. O 
                Hibernate não fornece um tipo correspondente para isso. Mas os tipos adaptados 
                não são limitados a mapeamento de uma propriedade (ou elemento de coleção) a uma 
                única coluna da tabela. Assim, por exemplo, você pôde ter uma propriedade Java 
                <literal>getName()</literal>/<literal>setName()</literal> do tipo 
                <literal>java.lang.String</literal> que é persistido para colunas 
                <literal>FIRST_NAME</literal>, <literal>INITIAL</literal>, <literal>SURNAME</literal>.  

            </para>
            
            <para>
                Para implementar um tipo personalizado, implemente <literal>org.hibernate.UserType</literal>
                or <literal>org.hibernate.CompositeUserType</literal> e declare propriedades usando o nome 
                qualificado da classe do tipo. Veja <literal>org.hibernate.test.DoubleStringType</literal> 
                para ver o tipo das coisas que são possíveis. 
            </para>

            <programlisting><![CDATA[<property name="twoStrings" type="org.hibernate.test.DoubleStringType">
    <column name="first_string"/>
    <column name="second_string"/>
</property>]]></programlisting>

            <para>
                Observe o uso da tag <literal>&lt;column&gt;</literal> para mapear uma propriedade 
                para colunas múltiplas.  
            </para>
            
            <para>
                As interfaces <literal>CompositeUserType</literal>, <literal>EnhancedUserType</literal>,
                <literal>UserCollectionType</literal>, e <literal>UserVersionType</literal>  
                fornecem suporte para usos mais especializados.
            </para>
            
            <para>
                Você pode mesmo fornecer parâmetros a um <literal>UserType</literal> no arquivo de mapeamento. 
                Para isto, seu <literal>UserType</literal> deve implementar a interface 
                <literal>org.hibernate.usertype.ParameterizedType</literal>. Para fornecer parâmetros a seu 
                tipo personalizado, você  pode usar o elemento <literal>&lt;type&gt;</literal> em seus 
                arquivos de mapeamento.  
            </para>
            
            <programlisting><![CDATA[<property name="priority">
    <type name="com.mycompany.usertypes.DefaultValueIntegerType">
        <param name="default">0</param>
    </type>
</property>]]></programlisting>

            <para>
                O <literal>UserType</literal> pode agora recuperar o valor para o parâmetro chamado 
                <literal>default</literal> da <literal>Propriedade</literal> do passado a ele.  
            </para>
            
            <para>
                Se você usar freqüentemente um determinado <literal>UserType</literal>, pode ser útil definir 
                um nome mais curto para ele. Você pode fazer isto usando o elemento 
                <literal>&lt;typedef&gt;</literal>. Typedefs atribui um nome a um tipo personalizado, e pode também 
                conter uma lista de valores default de parâmetro se o tipo for parametrizado.
            </para>
            
            <programlisting><![CDATA[<typedef class="com.mycompany.usertypes.DefaultValueIntegerType" name="default_zero">
    <param name="default">0</param>
</typedef>]]></programlisting>

            <programlisting><![CDATA[<property name="priority" type="default_zero"/>]]></programlisting>

            <para>
                It is also possible to override the parameters supplied in a typedef on a case-by-case basis
                by using type parameters on the property mapping.
            </para>
            
            <para>
                Even though Hibernate's rich range of built-in types and support for components means you
                will very rarely <emphasis>need</emphasis> to use a custom type, it is nevertheless
                considered good form to use custom types for (non-entity) classes that occur frequently
                in your application. For example, a <literal>MonetaryAmount</literal> class is a good
                candidate for a <literal>CompositeUserType</literal>, even though it could easily be mapped 
                as a component. One motivation for this is abstraction. With a custom type, your mapping 
                documents would be future-proofed against possible changes in your way of representing 
                monetary values.
            </para>

        </sect2>
        
    </sect1>

    <sect1 id="mapping-entityname">
        <title>Mapping a class more than once</title>
        <para>
            It is possible to provide more than one mapping for a particular persistent class. In this
            case you must specify an <emphasis>entity name</emphasis> do disambiguate between instances
            of the two mapped entities. (By default, the entity name is the same as the class name.)
            Hibernate lets you specify the entity name when working with persistent objects, when writing
            queries, or when mapping associations to the named entity.
        </para>
        
        <programlisting><![CDATA[<class name="Contract" table="Contracts" 
        entity-name="CurrentContract">
    ...
    <set name="history" inverse="true" 
            order-by="effectiveEndDate desc">
        <key column="currentContractId"/>
        <one-to-many entity-name="HistoricalContract"/>
    </set>
</class>

<class name="Contract" table="ContractHistory" 
        entity-name="HistoricalContract">
    ...
    <many-to-one name="currentContract" 
            column="currentContractId" 
            entity-name="CurrentContract"/>
</class>]]></programlisting>

        <para>
            Notice how associations are now specified using <literal>entity-name</literal> instead of
            <literal>class</literal>.
        </para>

    </sect1>

    <sect1 id="mapping-quotedidentifiers">
            <title>SQL quoted identifiers</title>
            <para>
                You may force Hibernate to quote an identifier in the generated SQL by enclosing the table or
                column name in backticks in the mapping document. Hibernate will use the correct quotation
                style for the SQL <literal>Dialect</literal> (usually double quotes, but brackets for SQL
                Server and backticks for MySQL).
            </para>

            <programlisting><![CDATA[<class name="LineItem" table="`Line Item`">
    <id name="id" column="`Item Id`"/><generator class="assigned"/></id>
    <property name="itemNumber" column="`Item #`"/>
    ...
</class>]]></programlisting>

    </sect1>

  	
   	<sect1 id="mapping-alternatives">
   	<title>Metadata alternatives</title>
   	
   	<para>
   	    XML isn't for everyone, and so there are some alternative ways to define O/R mapping metadata in Hibernate.
   	</para>

    <sect2 id="mapping-xdoclet">
        <title>Using XDoclet markup</title>

        <para>
            Many Hibernate users prefer to embed mapping information directly in sourcecode using
            XDoclet <literal>@hibernate.tags</literal>. We will not cover this approach in this
            document, since strictly it is considered part of XDoclet. However, we include the
            following example of the <literal>Cat</literal> class with XDoclet mappings.
        </para>

        <programlisting><![CDATA[package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mother;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /*
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="PARENT_ID"
     */
    public Cat getMother() {
        return mother;
    }
    void setMother(Cat mother) {
        this.mother = mother;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  inverse="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}]]></programlisting>

        <para>
            See the Hibernate web site for more examples of XDoclet and Hibernate.
        </para>

    </sect2>

    <sect2 id="mapping-annotations" revision="2">
        <title>Using JDK 5.0 Annotations</title>

        <para>
            JDK 5.0 introduced XDoclet-style annotations at the language level, type-safe and
            checked at compile time. This mechnism is more powerful than XDoclet annotations and
            better supported by tools and IDEs. IntelliJ IDEA, for example, supports auto-completion
            and syntax highlighting of JDK 5.0 annotations. The new revision of the EJB specification
            (JSR-220) uses JDK 5.0 annotations as the primary metadata mechanism for entity beans.
            Hibernate3 implements the <literal>EntityManager</literal> of JSR-220 (the persistence API),
            support for mapping metadata is available via the <emphasis>Hibernate Annotations</emphasis>
            package, as a separate download. Both EJB3 (JSR-220) and Hibernate3 metadata is supported.
        </para>

        <para>
            This is an example of a POJO class annotated as an EJB entity bean:
        </para>

        <programlisting><![CDATA[@Entity(access = AccessType.FIELD)
public class Customer implements Serializable {

    @Id;
    Long id;

    String firstName;
    String lastName;
    Date birthday;

    @Transient
    Integer age;

    @Embedded
    private Address homeAddress;

    @OneToMany(cascade=CascadeType.ALL)
    @JoinColumn(name="CUSTOMER_ID")
    Set<Order> orders;

    // Getter/setter and business methods
}]]></programlisting>

        <para>
            Note that support for JDK 5.0 Annotations (and JSR-220) is still work in progress and
            not completed. Please refer to the Hibernate Annotations module for more details.
        </para>
    
    </sect2>
    </sect1>

    <sect1 id="mapping-generated" revision="1">
        <title>Generated Properties</title>
        <para>
            Generated properties are properties which have their values generated by the
            database.  Typically, Hibernate applications needed to <literal>refresh</literal>
            objects which contain any properties for which the database was generating values.
            Marking properties as generated, however, lets the application delegate this
            responsibility to Hibernate.  Essentially, whenever Hibernate issues an SQL INSERT
            or UPDATE for an entity which has defined generated properties, it immediately
            issues a select afterwards to retrieve the generated values.
        </para>
        <para>
            Properties marked as generated must additionally be non-insertable and non-updateable.
            Only <xref linkend="mapping-declaration-version">versions</xref>,
            <xref linkend="mapping-declaration-timestamp">timestamps</xref>, and
            <xref linkend="mapping-declaration-property">simple properties</xref> can be marked as
            generated.
        </para>
	    <para>
		    <literal>never</literal> (the default) - means that the given property value
		    is not generated within the database.
	    </para>
	    <para>
		    <literal>insert</literal> - states that the given property value is generated on
		    insert, but is not regenerated on subsequent updates.  Things like created-date would
		    fall into this category.  Note that even thought
		    <xref linkend="mapping-declaration-version">version</xref> and
		    <xref linkend="mapping-declaration-timestamp">timestamp</xref> properties can
		    be marked as generated, this option is not available there...
	    </para>
	    <para>
		    <literal>always</literal> - states that the property value is generated both
		    on insert and on update.
	    </para>
    </sect1>

    <sect1 id="mapping-database-object">
        <title>Auxiliary Database Objects</title>
        <para>
            Allows CREATE and DROP of arbitrary database objects, in conjunction with
            Hibernate's schema evolution tools, to provide the ability to fully define
            a user schema within the Hibernate mapping files.  Although designed specifically
            for creating and dropping things like triggers or stored procedures, really any
            SQL command that can be run via a <literal>java.sql.Statement.execute()</literal>
            method is valid here (ALTERs, INSERTS, etc).  There are essentially two modes for
            defining auxiliary database objects...
        </para>
        <para>
            The first mode is to explicitly list the CREATE and DROP commands out in the mapping
            file:
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <create>CREATE TRIGGER my_trigger ...</create>
        <drop>DROP TRIGGER my_trigger</drop>
    </database-object>
</hibernate-mapping>]]></programlisting>
        <para>
            The second mode is to supply a custom class which knows how to construct the
            CREATE and DROP commands.  This custom class must implement the
            <literal>org.hibernate.mapping.AuxiliaryDatabaseObject</literal> interface.
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <definition class="MyTriggerDefinition"/>
    </database-object>
</hibernate-mapping>]]></programlisting>
        <para>
            Additionally, these database objects can be optionally scoped such that they only
            apply when certain dialects are used.
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <definition class="MyTriggerDefinition"/>
        <dialect-scope name="org.hibernate.dialect.Oracle9Dialect"/>
        <dialect-scope name="org.hibernate.dialect.OracleDialect"/>
    </database-object>
</hibernate-mapping>]]></programlisting>
    </sect1>
</chapter>

