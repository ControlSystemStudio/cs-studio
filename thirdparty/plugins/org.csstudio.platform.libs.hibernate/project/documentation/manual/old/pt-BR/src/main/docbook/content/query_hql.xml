<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="queryhql">
    <title>HQL: A linguagem de Queries do Hibernate</title>
    
    <para>
        O Hibernate vem com uma poderosa linguagem que é (intencionalmente) muito parecida 
        com o SQL. Mas não seja enganado pela sintaxe; a HQL é totalmente orientada à objetos, 
        requer conhecimentos de herança, polimorfismo e associações.        
    </para>

    <sect1 id="queryhql-casesensitivity">
        <title>Case Sensitíve</title>

        <para>
            As Queries não são case-sensitive, exceto pelo nomes das classes e propriedades Java. 
            <literal>sELEct</literal> e o mesmo que 
            <literal>SELECT</literal> mas
            <literal>org.hibernate.eg.FOO</literal> não é
            <literal>org.hibernate.eg.Foo</literal> e
            <literal>foo.barSet</literal> não é
            <literal>foo.BARSET</literal>.
           
        </para>
        
        <para>
            Esse manual usa as palavras chave HQL em letras minúsculas. Alguns usuários acham que 
            com letras maiúsculas as queries ficam mais legíveis, mas nós achamos essa convenção feia 
            dentro do código Java.
        </para>
        
    </sect1>

    <sect1 id="queryhql-from">
        <title>A clausula from</title>

        <para>
            A mais simples query possível do Hibernate é a assim:
        </para>
        
        <programlisting><![CDATA[from eg.Cat]]></programlisting>
        
        <para>
            Ela irá retornar todas as instancias da classe <literal>eg.Cat</literal>.
            Necessariamente não precisamos qualificar o nome da classe, pois é realizado 
            <literal>auto-import</literal> por padrão. Por isso na maior parte do tempos 
            nós simplesmente escrevemos:
        </para>
        
        <programlisting><![CDATA[from Cat]]></programlisting>
        
        <para>
            Na maior parte do tempo, você precisará atribuir um <emphasis>alias</emphasis>, 
            desde que você queira se referia ao <literal>Cat</literal> em outras partes da 
            query.
        </para>

        <programlisting><![CDATA[from Cat as cat]]></programlisting>

        <para>
            Essa query atribui um alias a <literal>cat</literal> para as instancias de 
            <literal>Cat</literal>, então nós podemos usar esse alias depois na query. 
            A palavra chave as é opcional; poderíamos escrever assim:
        </para>
        
        <programlisting><![CDATA[from Cat cat]]></programlisting>
        
        <para>
            Múltiplas classes pode ser envolvidas, resultando em um produto cartesiano ou "cross" join.
        </para>
        
        <programlisting><![CDATA[from Formula, Parameter]]></programlisting>
        <programlisting><![CDATA[from Formula as form, Parameter as param]]></programlisting>
        
        <para>
            É considerada uma boa prática os nomes dos aliases começarem com letra minúscula, 
            aderente com os padrões Java para variáveis locais (ex: <literal>domesticCat</literal>).
        </para>
        
    </sect1>

    <sect1 id="queryhql-joins" revision="2">
        <title>Associações e joins</title>

        <para>
            Nós também podemos querer atribuir aliases em uma entidade associada, ou mesmo 
            em elementos de uma coleção de valores, usando um <literal>join</literal>.
        </para>

        <programlisting><![CDATA[from Cat as cat 
    inner join cat.mate as mate
    left outer join cat.kittens as kitten]]></programlisting>

        <programlisting><![CDATA[from Cat as cat left join cat.mate.kittens as kittens]]></programlisting>

        <programlisting><![CDATA[from Formula form full join form.parameter param]]></programlisting>

        <para>
            Os tipos de joins suportados foram inspirados no SQL ANSI:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>inner join</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>left outer join</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>right outer join</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>full join</literal> (geralmente não é útil)
                </para>
            </listitem>
        </itemizedlist>
    
        <para>
            The <literal>inner join</literal>, <literal>left outer join</literal> and 
            <literal>right outer join</literal> constructs may be abbreviated.
            As construções <literal>inner join</literal>, <literal>left outer join</literal> e
            <literal>right outer join</literal> podem ser abreviadas.            
        </para>

        <programlisting><![CDATA[from Cat as cat 
    join cat.mate as mate
    left join cat.kittens as kitten]]></programlisting>
    
        <para>
            Você pode fornecer condições extras de join usando a palavra 
            chave do HQL <literal>with</literal>.
        </para>

        <programlisting><![CDATA[from Cat as cat 
    left join cat.kittens as kitten 
        <literal>with</literal> kitten.bodyWeight > 10.0]]></programlisting>

        <para>
            Adicionalmente, um "fetch" join permite que associações ou coleções de valores 
            sejam inicializadas junto com o objeto pai, usando apenas um select. Isso é 
            muito útil no caso das coleções. Isso efetivamente sobre escreve as declarações
            outer join e lazy do arquivo mapeamento para associações e coleções.
             Veja a seção <xref linkend="performance-fetching"/> para mais informações.
        </para>
    
        <programlisting><![CDATA[from Cat as cat 
    inner join <literal>fetch</literal>cat.mate
    left join <literal>fetch</literal>cat.kittens]]></programlisting>
    
        <para>
            Usualmente, um <literal>fetch</literal>join não precisa atribuir um alias, pois o objeto associado não 
            deve ser usado na clausula <literal>where</literal> (ou em qualquer outra clausula). 
            Também, os objetos associados não são retornados diretamente nos resultados da query. 
            Ao invés disso, eles devem ser acessados usando o objeto pai. A única razão que nós 
            podemos necessitar de um alias é quando fazemos um fech join recursivamente em uma 
            coleção adicional:
        </para>
        
        <programlisting><![CDATA[from Cat as cat 
    inner join <literal>fetch</literal>cat.mate
    left join <literal>fetch</literal>cat.kittens child
    left join <literal>fetch</literal>child.kittens]]></programlisting>
    
        <para>
            Observe que a construção <literal>fetch</literal>  não deve ser usada em queries invocadas usando 
            <literal>iterate()</literal> (embora possa ser usado com <literal>scroll()</literal>). O 
            <literal>fetch</literal> também não deve ser usado junto com o  <literal>setMaxResults()</literal> ou 
            <literal>setFirstResult()</literal> pois essas operações são baseadas nas linhas retornadas, que 
            normalmente contem duplicidade devido ao fetching das coleções, então o número de linhas pode não 
            ser o que você espera. 
            
            O <literal>fetch</literal> não deve ser usado junto com uma condição <literal>with</literal> em 
            uma condição <literal>with</literal> ad hoc. É possível que seja criado um produto cartesiano pelo 
            join fetching em mais do que uma coleção em uma query, então tome cuidado nesses casos. Um join 
            fetching em varias coleções pode trazer resultados inesperados para mapeamentos do tipo bag, tome 
            cuidado na hora de formular queries como essas. Finalmente, observe o seguinte, o 
            <literal>full join fetch</literal> e <literal>right join fetch</literal>  não são significativos.
        </para>
        
        <para>
            
            Se está usando o nível de propriedade lazy (<literal>com</literal> instrumentação de bytecode), é possível 
            forçar o Hibernate a  <literal>buscar</literal> as propriedades lazy imediatamente (na primeira query), 
            usando <literal>fetch all properties </literal>.            
        </para>
        
        <programlisting><![CDATA[from Document <literal>fetch</literal>all properties order by name]]></programlisting>
        <programlisting><![CDATA[from Document doc <literal>fetch</literal>all properties where lower(doc.name) like '%cats%']]></programlisting>

	    </sect1>

    <sect1 id="queryhql-joins-forms">
        <title>Formas e sintaxe de joins</title>

	    <para>
		    O HQL suporta duas formas de associação para união: <literal>implícita</literal> e <literal>explicita</literal>.
		</para>

	    <para>
		    As queries apresentadas na seção anterior usam a forma <literal>explicita</literal>, onde a 
		    palavra chave "join" é explicitamente usada na clausula "from". Essa é a forma recomendada.
	    </para>

	    <para>
		    A forma <literal>implícita</literal> não usa a palavra chave "join". Entretanto, as associações 
		    são diferenciadas usando pontuação ("." - dotnation). Uniões implícitas podem aparecer em
		    qualquer das clausulas HQL. A união <literal>implícita</literal> resulta em declarações
		    SQL que contem inner joins. 
	    </para>

        <programlisting><![CDATA[from Cat as cat where cat.mate.name like '%s%']]></programlisting>
	</sect1>

	<sect1 id="queryhql-identifier-property">
		<title>Refering to identifier property</title>
		
		<para>
			There are, generally speaking, 2 ways to refer to an entity's identifier property:
		</para>
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					The special property (lowercase) <literal>id</literal> may be used to reference the identifier
					property of an entity <emphasis>provided that entity does not define a non-identifier property
						named id</emphasis>.
				</para>
			</listitem>
			<listitem>
				<para>
					If the entity defines a named identifier property, you may use that property name.
				</para>
			</listitem>
		</itemizedlist>
		
		<para>
			References to composite identifier properties follow the same naming rules.  If the
			entity has a non-identifier property named id, the composite identifier property can only
			be referenced by its defined named; otherwise, the special <literal>id</literal> property
			can be used to rerference the identifier property.
		</para>
		
		<para>
			Note: this has changed significantly starting in version 3.2.2.  In previous versions,
			<literal>id</literal> <emphasis>always</emphasis> referred to the identifier property no
			matter what its actual name.  A ramification of that decision was that non-identifier
			properties named <literal>id</literal> could never be referenced in Hibernate queries.
		</para>
	</sect1>

    <sect1 id="queryhql-select">
        <title>Clausula select</title>

        <para>
            A clausula <literal>select</literal> seleciona quais obetos e propriedades retornam
             no resultado da query. Considere:            
        </para>

        <programlisting><![CDATA[select mate 
from Cat as cat 
    inner join cat.mate as mate]]></programlisting>

        <para>
            A query selecionará <literal>mate</literal>s (companheiros), de outros <literal>Cat</literal>s. 
            Atualmente, podemos expressar a query de forma mais compacta como:
        </para>

        <programlisting><![CDATA[select cat.mate from Cat cat]]></programlisting>

        <para>
            Queries podem retornar propriedades de qualquer tipo de valor, incluindo propriedades de tipo de componente:

        </para>

        <programlisting><![CDATA[select cat.name from DomesticCat cat
where cat.name like 'fri%']]></programlisting>

        <programlisting><![CDATA[select cust.name.firstName from Customer as cust]]></programlisting>

        <para>
            Queries podem retornar múltiplos objetos e/ou propriedades como um array do 
            tipo Object[],
        </para>

        <programlisting><![CDATA[select mother, offspr, mate.name 
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr]]></programlisting>
    
        <para>
            ou como um <literal>List</literal>,
        </para>
        
        <programlisting><![CDATA[select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr]]></programlisting>
    
        <para>
            ou como um objeto Java typesafe,
        </para>
        
        <programlisting><![CDATA[select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr]]></programlisting>
        
        <para>
            assumindo que a classe <literal>Family</literal> tenha um construtor apropriado.
        </para>
        
        <para>
            Pode-se designar referencias a expressões selecionadas, <literal>as</literal>:
        </para>

        <programlisting><![CDATA[select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat]]></programlisting>

        <para>
            Isto é bem mais útil quando usado junto <literal>com</literal> <literal>select new map</literal>:
        </para>
            
        <programlisting><![CDATA[select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat]]></programlisting>

        <para>
            Esta query retorna um <literal>Map</literal> de referencias para valores selecionados.
        </para>
         
    </sect1>

    <sect1 id="queryhql-aggregation">
        <title>Funções de agregação</title>

        <para>
            As queries HQL podem retornar o resultado de funções agregadas nas propriedades.
        </para>

        <programlisting><![CDATA[select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat]]></programlisting>

<!-- NO LONGER SUPPORTED
        <para>
            Collections may also appear inside aggregate functions in the <literal>select</literal> 
            clause.
        </para>

        <programlisting><![CDATA[select cat, count( elements(cat.kittens) ) 
from Cat cat group by cat]]></programlisting>
-->

        <para>
            As funções agregadas suportadas são:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>avg(...), sum(...), min(...), max(...)</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>count(*)</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>count(...), count(distinct ...), count(all...)</literal>
                </para>
            </listitem>
        </itemizedlist>
    
        <para>
            Pode-se usar operadores aritiméticos, concatenação e funções SQL 
            reconhecidas na clausula select:
        </para>
        
        <programlisting><![CDATA[select cat.weight + sum(kitten.weight) 
from Cat cat 
    join cat.kittens kitten
group by cat.id, cat.weight]]></programlisting>
    
        <programlisting><![CDATA[select firstName||' '||initial||' '||upper(lastName) from Person]]></programlisting>
    
        <para>
            As palavras <literal>distinct</literal> e <literal>all</literal> podem ser usadas e têm 
            a mesma semântica como no SQL.
        </para>

        <programlisting><![CDATA[select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat]]></programlisting>

    </sect1>
    
    <sect1 id="queryhql-polymorphism">
        <title>Queries polimórficas</title>

        <para>
            A query:
        </para>

        <programlisting><![CDATA[from Cat as cat]]></programlisting>

        <para>
            retorna instancias não só de <literal>Cat</literal>, mas também de subclasses como 
            <literal>DomesticCat</literal>. As queries do Hibernate podem nomear qualquer classe Java 
            ou interface na clausula <literal>from</literal>. A query retornará instancias de toda classe 
            persistente que extenda  a determinada classe ou implemente a determinada interface. A query
            , a seguir, pode retornar todo objeto persistente:            
        </para>
        
        <programlisting><![CDATA[from java.lang.Object o]]></programlisting>
        
        <para>
            A interface <literal>Named</literal> pode ser implementada por várias classes persistentes:
        </para>
        
        <programlisting><![CDATA[from Named n, Named m where n.name = m.name]]></programlisting>
        
        <para>
            Note que as duas últimas queries requerem mais de um SQL SELECT . Isto significa que a clausula 
            <literal>order by</literal> não ordena corretamente todo o resultado. (Isso também significa que 
            você não pode chamar essas queries usando <literal>Query.scroll()</literal>.)            
        </para>
        
    </sect1>

    <sect1 id="queryhql-where">
        <title>A clausula where</title>

        <para>
            A clausula <literal>where</literal> permite estreitar a lista de instancias retornada. 
            Se não houver referencia alguma, pode-se referir a propriedades pelo nome:
        </para>

        <programlisting><![CDATA[from Cat where name='Fritz']]></programlisting>
        
        <para>
        	Se houver uma referência, use o nome da propriedade qualificada:        	
        </para>
        
        <programlisting><![CDATA[from Cat as cat where cat.name='Fritz']]></programlisting>

        <para>
            retorna instancias de <literal>Cat</literal> com nome ‘Fritz’.
        </para>

        <programlisting><![CDATA[select foo 
from Foo foo, Bar bar
where foo.startDate = bar.date]]></programlisting>

        <para>
            retornará todas as instancias de <literal>Foo</literal>, para cada 
            um que tiver uma instancia de <literal>bar</literal> com a propriedade 
            <literal>date</literal> igual a propriedade 
            <literal>startDate</literal> de 
            <literal>Foo</literal>. Expressões de filtro compostas fazem da 
            clausula <literal>where</literal>, extremamente poderosa. Consideremos:
        </para>

        <programlisting><![CDATA[from Cat cat where cat.mate.name is not null]]></programlisting>

        <para>
            Esta query traduzida para uma query SQL <literal>com</literal> uma tabela (inner) join. Se fosse 
            escrever algo como:
        </para>

        <programlisting><![CDATA[from Foo foo  
where foo.bar.baz.customer.address.city is not null]]></programlisting>

        <para>
            Poderia-se terminar <literal>com</literal> uma query que necessitasse de join de quatro tabelas, 
            no SQL.
        </para>

        <para>
            O operador <literal>=</literal> pode ser uasdo para comparar não apenas propriedades, 
            mas também instancias: 
        </para>

        <programlisting><![CDATA[from Cat cat, Cat rival where cat.mate = rival.mate]]></programlisting>

        <programlisting><![CDATA[select cat, mate 
from Cat cat, Cat mate
where cat.mate = mate]]></programlisting>

        <para>
            A propriedade especial (lowercase)  <literal>id</literal> pode ser usada para referenciar 
            o identificador único de um objeto. (Pode-se usar também o nome de sua propriedade)
        </para>

        <programlisting><![CDATA[from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69]]></programlisting>

        <para>
            A Segunda query é eficiente. Nenhuma união de tabelas é necessária!
        </para>

        <para>
            As propriedades de identificadores compostas também podem ser usadas. Suponha que 
            <literal>Person</literal>  tenha um identificador composto que consiste de 
            <literal>country</literal> e <literal>medicareNumber</literal>.
        </para>

        <programlisting><![CDATA[from bank.Person person
where person.id.country = 'AU' 
    and person.id.medicareNumber = 123456]]></programlisting>

        <programlisting><![CDATA[from bank.Account account
where account.owner.id.country = 'AU' 
    and account.owner.id.medicareNumber = 123456]]></programlisting>

        <para>
            Mais uma vez, a Segunda query não precisa de nenhum join de tabela.
        </para>
            
        <para>
            Assim mesmo, a propriedade especial <literal>class</literal> acessa o valor discriminador da 
            instancia, no caso de persistência polimórfica. O nome de uma classe Java inclusa em uma 
            clausula "where", será traduzida para seu valor descriminante. 
        </para>

        <programlisting><![CDATA[from Cat cat where cat.class = DomesticCat]]></programlisting>
        
        <para>
            Pode-se também especificar as propriedades dos components ou tipos de usuário composto 
            (e de componentes de componentes). Nunca tente usar uma expressão de filtro que termine na propriedade 
            de um tipo de componente (ao contrário de uma propriedade de um componente). Por exemplo, 
            se store.owner é uma entidade  <literal>com</literal> um componente  <literal>address</literal>.
        </para>

        <programlisting><![CDATA[store.owner.address.city    // okay
store.owner.address         // error!]]></programlisting>

        <para>
            Um tipo "any" tem as propriedades <literal>id</literal> e <literal>class</literal> especiais, 
            nôs permitindo expressar um join da seguinte forma (onde <literal>AuditLog.item</literal> é 
            uma propriedade mapeada <literal>com</literal> <literal>&lt;any&gt;</literal>)
        </para>
       
        <programlisting><![CDATA[from AuditLog log, Payment payment 
where log.item.class = 'Payment' and log.item.id = payment.id]]></programlisting>
    
        <para>
            Veja que <literal>log.item.class</literal> e <literal>payment.class</literal> podem 
            referir-se a valores de colunas de banco de dados completamente diferentes, na query acima.
        </para>
        
    </sect1>

    <sect1 id="queryhql-expressions">
        <title>Expressões</title>

        <para>
            As expressões permitidas na cláusula <literal>where</literal> inclui a maioria 
            das coisas que você poderia escrever no SQL:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    operadores matemáticos <literal>+, -, *, /</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    operadores de comparação binários <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    operadores lógicos  <literal>and, or, not</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    parenteses <literal>( )</literal>, indicating grouping
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>in</literal>,
                    <literal>not in</literal>,
                    <literal>between</literal>,
                    <literal>is null</literal>,
                    <literal>is not null</literal>,
                    <literal>is empty</literal>,
                    <literal>is not empty</literal>,
                    <literal>member of</literal> and 
                    <literal>not member of</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                	case "simples" , <literal>case ... when ... then ... else ... end</literal>, and
                    "searched" case, <literal>case when ... then ... else ... end</literal> 
                </para>
            </listitem>
            <listitem>
                <para>
                    concatenação de string <literal>...||...</literal> ou <literal>concat(...,...)</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>current_date()</literal>, <literal>current_time()</literal>,
                    <literal>current_timestamp()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
					<literal>second(...)</literal>, <literal>minute(...)</literal>, 
					<literal>hour(...)</literal>, <literal>day(...)</literal>, 
					<literal>month(...)</literal>, <literal>year(...)</literal>,
                </para>
            </listitem>
            <listitem>
                <para>
                    qualquer funcao ou operador definida pela EJB-QL 3.0: <literal>substring(), trim(),
                    lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>coalesce()</literal> and <literal>nullif()</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>str()</literal> para converter valores numericos ou temporais para string
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>cast(... as ...)</literal>, onde o segundo argumento é o nome do tipo 
                    hibernate, e<literal>extract(... from ...)</literal> se ANSI 
                    <literal>cast()</literal> e <literal>extract()</literal> é suportado pele
                    banco de dados usado
                </para>
            </listitem>
            <listitem>
                <para>
                    A função HQL <literal>index()</literal> , que se aplicam a referencias de 
                    coleçôes associadas e indexadas
                </para>
            </listitem>
            <listitem>
                <para>
                    As funções hql que retornam expressões de coleções de valores:
                    <literal>size(), minelement(), maxelement(), minindex(), maxindex()</literal>, 
                    <literal>junto</literal> com o elemento especial, <literal>elements()</literal>,
                    e funções de <literal>índice</literal> que podem ser quantificadas usando 
                    <literal>some, all, exists, any, in</literal>.                    
                </para>
            </listitem>
            <listitem>
                <para>
                    Qualquer funçâo escalar pelo bando de dados como <literal>sign()</literal>, 
                    <literal>trunc()</literal>, <literal>rtrim()</literal>, <literal>sin()</literal> 
                </para>
            </listitem>
            <listitem>
                <para>
                    Parametros posicionais ao estilo JDBC <literal>?</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    Parametros nomeados <literal>:name</literal>, <literal>:start_date</literal>, <literal>:x1</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    Literais SQL <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E+2</literal>,
                    <literal>'1970-01-01 10:00:01.0'</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    Constantes Java <literal>public static final</literal> <literal>ex: Color.TABBY</literal>
                </para>
            </listitem>
        </itemizedlist>

        <para>
            <literal>in</literal> e <literal>between</literal> podem ser usadas da seguinte maneira:
        </para>

        <programlisting><![CDATA[from DomesticCat cat where cat.name between 'A' and 'B']]></programlisting>

        <programlisting><![CDATA[from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )]]></programlisting>

        <para>
            e as formas negativas podem ser escritas
        </para>

        <programlisting><![CDATA[from DomesticCat cat where cat.name not between 'A' and 'B']]></programlisting>

        <programlisting><![CDATA[from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )]]></programlisting>

        <para>
            Likewise, <literal>is null</literal> and <literal>is not null</literal> may be used to test 
            for null values.
            Assim mesmo, , <literal>is null</literal> e <literal>is not null</literal> podem ser usados 
            para testar valores nulos.
        </para>

        <para>
            Booleanos podem ser facilmente usados em expressões, declarando as substituições da HQL query, 
            na configuração do Hibernate
        </para>

        <programlisting><![CDATA[<property name="hibernate.query.substitutions">true 1, false 0</property>]]></programlisting>

        <para>
            Isso irá substituir as palavras chave <literal>true</literal> e <literal>false</literal>
            <literal>pelos</literal> literais <literal>1</literal> e <literal>0</literal> na tradução do HQL para SQL.
        </para>

        <programlisting><![CDATA[from Cat cat where cat.alive = true]]></programlisting>

        <para>
            Pode-se testar o tamanho de uma coleção <literal>com</literal> a propriedade especial  <literal>size</literal>, 
            ou a função especial <literal>size()</literal>.
        </para>

        <programlisting><![CDATA[from Cat cat where cat.kittens.size > 0]]></programlisting>

        <programlisting><![CDATA[from Cat cat where size(cat.kittens) > 0]]></programlisting>

        <para>
            Para coleções indexadas, você pode se referir aos índices máximo e mínimo, usando 
            as funções <literal>minindex</literal> e <literal>maxindex</literal>. Similarmente, 
            pode-se referir aos elementos máximo e mínimo de uma coleção de tipos básicos usando
            as funções <literal>minelement</literal> e <literal>maxelement</literal>.
        </para>
        
        <programlisting><![CDATA[from Calendar cal where maxelement(cal.holidays) > current_date]]></programlisting>
        
        <programlisting><![CDATA[from Order order where maxindex(order.items) > 100]]></programlisting>

        <programlisting><![CDATA[from Order order where minelement(order.items) > 10000]]></programlisting>
        
        <para>
            As funções SQL  <literal>any, some, all, exists, in</literal> são suportadas quando passado o 
            elemento ou o conjunto de índices de uma coleção (<literal>elements</literal> e 
            <literal>indices</literal> de funções), ou o resultado de uma subquery (veja abaixo).
        </para>

        <programlisting><![CDATA[select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)]]></programlisting>

        <programlisting><![CDATA[select p from NameList list, Person p
where p.name = some elements(list.names)]]></programlisting>

        <programlisting><![CDATA[from Cat cat where exists elements(cat.kittens)]]></programlisting>

        <programlisting><![CDATA[from Player p where 3 > all elements(p.scores)]]></programlisting>

        <programlisting><![CDATA[from Show show where 'fizard' in indices(show.acts)]]></programlisting>

        <para>
            Note que essas construções - <literal>size</literal>, <literal>elements</literal>,
            <literal>indices</literal>, <literal>minindex</literal>, <literal>maxindex</literal>,
            <literal>minelement</literal>, <literal>maxelement</literal>– 
            só podem ser usados na clausula where do Hibernate3.
        </para>
        
        <para>
            Elementos de coleções com índice (arrays, lists, maps), podem ser referenciadas 
            pelo índice (apenas na clausula where):
        </para>
        
        <programlisting><![CDATA[from Order order where order.items[0].id = 1234]]></programlisting>

        <programlisting><![CDATA[select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar]]></programlisting>

        <programlisting><![CDATA[select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11]]></programlisting>

        <programlisting><![CDATA[select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11]]></programlisting>

        <para>
            A expressão entre colchetes <literal>[]</literal>, pode ser até uma expressão aritimética.
        </para>
        
        <programlisting><![CDATA[select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item]]></programlisting>
        
        <para>
            O HQL também provê a função interna <literal>index()</literal>, para elementos de 
            associação um-pra-muitos ou coleção de valores.
        </para>

        <programlisting><![CDATA[select item, index(item) from Order order 
    join order.items item
where index(item) < 5]]></programlisting>

        <para>
            Funções escalares SQL, suportadas pelo banco de dados subjacente.
        </para>

        <programlisting><![CDATA[from DomesticCat cat where upper(cat.name) like 'FRI%']]></programlisting>

        <para>
            Se ainda ainda não está totalmente convencido, pense o quão maior e menos legível poderia 
            ser a query a seguir, em SQL:
        </para>

        <programlisting><![CDATA[select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)]]></programlisting>

        <para>
            <emphasis>Hint:</emphasis> something like
        </para>

        <programlisting><![CDATA[SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )]]></programlisting>

    </sect1>

    <sect1 id="queryhql-ordering">
        <title>A clausula order by</title>

        <para>
            A lista retornada pela query pode ser ordenada por qualquer propriedade da classe ou componente retornado:
        </para>

        <programlisting><![CDATA[from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate]]></programlisting>

        <para>
            As opções <literal>asc</literal> ou <literal>desc</literal> indicam ordem crescente ou decrescente, 
            respectivamente.  
        </para>
    </sect1>

    <sect1 id="queryhql-grouping">
        <title>A clausula group by</title>

        <para>
            Uma query que retorne valores agregados, podem ser agrupados por qualquer propriedade de uma classe 
            ou componente retornado:
        </para>

        <programlisting><![CDATA[select cat.color, sum(cat.weight), count(cat) 
from Cat cat
group by cat.color]]></programlisting>

        <programlisting><![CDATA[select foo.id, avg(name), max(name) 
from Foo foo join foo.names name
group by foo.id]]></programlisting>

        <para>
            Uma clausula <literal>having</literal> também é permitida.
        </para>

        <programlisting><![CDATA[select cat.color, sum(cat.weight), count(cat) 
from Cat cat
group by cat.color 
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)]]></programlisting>

        <para>
            Funções SQL e funções agregadas são permitidas nas clausulas 
            <literal>having</literal> e <literal>order by</literal>, se suportadas pelo banco 
            de dados subjacente (ex: não no MySQL).            
        </para>

        <programlisting><![CDATA[select cat
from Cat cat
    join cat.kittens kitten
group by cat
having avg(kitten.weight) > 100
order by count(kitten) asc, sum(kitten.weight) desc]]></programlisting>

        <para>
            Note que, nem a clausula <literal>group by</literal> ou 
            <literal>order by</literal>, podem conter expressões aritiméticas.
        </para>

    </sect1>
    
    <sect1 id="queryhql-subqueries" revision="2">
        <title>Subqueries</title>
        
        <para>
            Para bancos de dados que suportem subselects, o Hibernate suporta subqueries dentro de queries. 
            Uma subquery precisa estar entre parênteses (normalmente uma chamada de função agregada SQL). 
            Mesmo subqueries co-relacionadas (subqueries que fazem referência à alias de outras queries), 
            são aceitas.
        </para>

        <programlisting><![CDATA[from Cat as fatcat 
where fatcat.weight > ( 
    select avg(cat.weight) from DomesticCat cat 
)]]></programlisting>

        <programlisting><![CDATA[from DomesticCat as cat 
where cat.name = some ( 
    select name.nickName from Name as name 
)]]></programlisting>
    
        <programlisting><![CDATA[from Cat as cat 
where not exists ( 
    from Cat as mate where mate.mate = cat 
)]]></programlisting>

        <programlisting><![CDATA[from DomesticCat as cat 
where cat.name not in ( 
    select name.nickName from Name as name 
)]]></programlisting>

        <programlisting><![CDATA[select cat.id, (select max(kit.weight) from cat.kitten kit) 
from Cat as cat]]></programlisting>

        <para>
            Note que HQL subqueries podem aparecer apenas dentro de clausulas select ou where.
        </para>

	<para>
		Note that subqueries can also utilize <literal>row value constructor</literal> syntax.  See
		<xref linkend="queryhql-tuple"/> for more details.
        </para>        
    </sect1>

    <sect1 id="queryhql-examples">
        <title>Exemplos de HQL</title>
        
        <para>
            As queries do Hibernate, podem ser muito poderosas e complexas. De fato, o poder da linguagem de 
            querie é um dos pontos principais na distribuição do Hibernate. Aqui temos algumas queries de exemplo, 
            muito similares a queries que usei em um projeto recente. Note que a maioria das queries que você 
            irá escrever, são mais simples que estas.
        </para>
        
        <para>
            A query a seguir retorna o id de order, numero de itens e o valor total do order para todos os 
            orders não pagos para um freguês particular e valor total mínimo dado, ordenando os resultados por 
            valor total. Ao determinar os preços, é usado o catalogo corrente. A query SQL resultante, 
            usando tabelas  <literal>ORDER</literal>, <literal>ORDER_LINE</literal>, <literal>PRODUCT</literal>,
            <literal>CATALOG</literal> e <literal>PRICE</literal>, tem quatro inner joins e um 
            (não correlacionado) subselect.
        </para>
        
        <programlisting><![CDATA[select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate < sysdate
    and catalog.effectiveDate >= all (
        select cat.effectiveDate 
        from Catalog as cat
        where cat.effectiveDate < sysdate
    )
group by order
having sum(price.amount) > :minAmount
order by sum(price.amount) desc]]></programlisting>
        
        <para>
            Que monstro! Atualmente, na vida real, eu não sou muito afeiçoado a subqueries, então 
            minha query seria mais parecida com isto:
        </para>
        
        <programlisting><![CDATA[select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) > :minAmount
order by sum(price.amount) desc]]></programlisting>
        
        <para>
            A próxima query conta o número de pagamentos em cada status, tirando todos os pagamentos com 
            status <literal>AWAITING_APPROVAL</literal>, onde a mais recente mudança de status foi feita 
            pelo usuário corrente. Traduz-se para uma query SQL <literal>com</literal> dois inner joins e 
            um subselect correlacionado, nas tabelas <literal>PAYMENT</literal>, 
            <literal>PAYMENT_STATUS</literal> e <literal>PAYMENT_STATUS_CHANGE</literal> .
        </para>

        <programlisting><![CDATA[select count(payment), status.name 
from Payment as payment 
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name <> PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = ( 
            select max(change.timeStamp) 
            from PaymentStatusChange change 
            where change.payment = payment
        )
        and statusChange.user <> :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder]]></programlisting>

        <para>
            Se eu tivesse mapeado a Collection <literal>statusChanges</literal> como um List, ao invés de um 
            Set, a query teria sido muito mais simples de escrever.
        </para>
    
        <programlisting><![CDATA[select count(payment), status.name 
from Payment as payment
    join payment.currentStatus as status
where payment.status.name <> PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user <> :currentUser
group by status.name, status.sortOrder
order by status.sortOrder]]></programlisting>

        <para>
            A próxima query usa a função <literal>isNull()</literal> do MS SQL Server, para retornar 
            todas as contas e pagamentos não pagos para a organização, para cada usuário corrente 
            pertencente. Traduz-se para uma query SQL <literal>com</literal> três inner joins, 
            um outer join e um subselect nas tabelas <literal>ACCOUNT</literal>, <literal>PAYMENT</literal>, 
            <literal>PAYMENT_STATUS</literal>,<literal>ACCOUNT_TYPE</literal>, 
            <literal>ORGANIZATION</literal> e <literal>ORG_USER</literal> .
        </para>

        <programlisting><![CDATA[select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate]]></programlisting>

        <para>
            Para alguns bancos de dados, precisaremos eleminar o subselect (correlacionado).
        </para>

        <programlisting><![CDATA[select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate]]></programlisting>

   </sect1>

    <sect1 id="queryhql-bulk" revision="2">
        <title>update e delete em lote</title>

        <para>
            Agora o HQL suporta declarações, <literal>update</literal>, 
            <literal>delete</literal> e <literal>insert ... select ...</literal> 
            Veja <xref linkend="batch-direct"/>, para mais detalhes.
        </para>
    </sect1>

    <sect1 id="queryhql-tipstricks">
        <title>Dicas e Truques</title>

        <para>
            Pode-se contar o número de resultados da query, sem realmente retorna-los.
        </para>

        <programlisting><![CDATA[( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue()]]></programlisting>

        <para>
            Para ordenar um resultado pelo tamanho de uma Collection, use a query a seguir.
        </para>

        <programlisting><![CDATA[select usr.id, usr.name
from User as usr 
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)]]></programlisting>

        <para>
            Se seu banco de dados suporta subselects, pode-se colocar uma condição sobre 
            tamanho de seleção na cláusula where da sua query:
        </para>

        <programlisting><![CDATA[from User usr where size(usr.messages) >= 1]]></programlisting>

        <para>
            Se seu banco de dados não suporta subselects, use a query a seguir:
        </para>

        <programlisting><![CDATA[select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) >= 1]]></programlisting>

        <para>
            Com essa solução não se pode retornar um <literal>User</literal> <literal>com</literal> sem
            nenhuma menssagem, por causa do "inner join", a forma a seguir também é útil. 
        </para>

        <programlisting><![CDATA[select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0]]></programlisting>

        <para>
            As propriedades de um JavaBean podem ser limitadas à parâmetros nomeados da query:
        </para>

        <programlisting><![CDATA[Query q = s.createQuery("from foo Foo as foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean has getName() and getSize()
List foos = q.list();]]></programlisting>

        <para>
            As Collections são paginaveis, usando a interface <literal>Query</literal> <literal>com</literal> um filtro:
        </para>

        <programlisting><![CDATA[Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();]]></programlisting>

        <para>
            Os elementos da Collection podem ser ordenados ou agrupados 
            usando um filtro de query:
        </para>
        
        <programlisting><![CDATA[Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );]]></programlisting>

        <para>
            Pode-se achar o tamanho de uma Collection sem inicializa-la:
        </para>

        <programlisting><![CDATA[( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue();]]></programlisting>

    </sect1>

</chapter>

