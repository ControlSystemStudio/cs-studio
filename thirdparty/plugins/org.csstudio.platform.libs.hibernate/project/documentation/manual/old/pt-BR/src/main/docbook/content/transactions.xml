<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="transactions" revision="2">
    <title>Transações e Concorrência</title>

    <para>
        O ponto o mais importante sobre o Hibernate e o controle de concorrência é que é muito 
        fácil de ser compreendido. O Hibernate usa diretamente conexões de JDBC e recursos de 
        JTA sem adicionar nenhum comportamento de bloqueio a mais. Nós altamente recomendamos 
        que você gaste algum tempo com o JDBC, o ANSI e a especificação de isolamento de transação 
        de seu sistema de gerência da base de dados.
    </para>

    <para>
        O Hibernate não bloqueia objetos na memória. Sua aplicação pode esperar o comportamento 
        tal qual definido pelo nível de isolamento de suas transações de banco de dados. 
        Note que graças ao <literal>Session</literal>, que também é um cache de escopo de 
        transação, o Hibernate fornece leituras repetíveis para procurar por identificadores 
        e consultas de entidade (não pesquisas de relatórios que retornam valores escalares).
    </para>

    <para>        
    		Além do versionamento para o controle automático de concorrência otimista, o Hibernate 
        oferece também uma API (menor) para bloqueio pessimista de linhas usando a sintaxe 
        <literal>SELECT FOR UPDATE</literal>. O controle de concorrência otimista e esta 
        API são discutidos mais tarde neste capítulo. 
    </para>

    <para>
        Nós começamos a discussão do controle de concorrência no Hibernate com a granularidade 
        do <literal>Configuration</literal>, <literal>SessionFactory</literal>, e
        <literal>Session</literal>, além de transações de base de dados e conversações longas.
    </para>

    <sect1 id="transactions-basics" revision="1">
        <title>Session e escopos de transações</title>

        <para>
            Um <literal>SessionFactory</literal> é objeto threadsafe compartilhado por 
            todas as threads da aplicação que consome muitos recursos na sua criação. 
            É criado uma unica vez no inicio da execução da aplicação a partir da
            instância de uma <literal>Configuration</literal>.
        </para>

        <para>
            Uma <literal>Session</literal> é um objeto de baixo custo de criação, não é threadsafe, 
            deve ser usado uma vez, para uma única requisição, uma conversação, uma única unidade 
            do trabalho e então deve ser descartado. Um <literal>Session</literal> não obterá um 
            JDBC <literal>Connection</literal> (ou um <literal>Datasource</literal>) a menos que 
            necessite, conseqüentemente não consome nenhum recurso até ser usado. 
        </para>

        <para>
            Para completar, você também tem que pensar sobre as transações de base de dados. 
            Uma transação tem que ser tão curta quanto possível, para reduzir a disputa pelo 
            bloqueio na base de dados. Transações longas impedirão que sua aplicação escale a 
            carga altamente concorrente. Por isso, em um projeto raramente é para manter 
            uma transação de base de dados aberta durante o tempo que o usuário pensa, 
            até que a unidade do trabalho esteja completa.
        </para>

        <para>
            Qual é o escopo de uma unidade de trabalho? Pode uma únicoa <literal>Session</literal> 
            do Hibernate gerenciar diversas transações ou é esta um o relacionamento um-para-um dos 
            escopos? Quando deve você abrir e fechar uma <literal>Session</literal> e como você 
            demarca os limites da transação?
        </para>

        <sect2 id="transactions-basics-uow" revision="1">
            <title>Unidade de trabalho</title>

            <para>
                Primeiro, não use o antipattern <emphasis>sessão-por-operação</emphasis>, 
                isto é, não abra e não feche uma <literal>Session</literal> para cada simples chamada 
                ao banco de de dados em uma única thread! Naturalmente, o mesmo é verdadeiro para 
                transações. As chamadas a banco de dados em uma aplicação são feitas usando uma 
                seqüência planejada, elas são agrupadas em unidades de trabalho atômicas. 
                (Veja que isso também significa que um auto-commit depois de cada sentença SQL é 
                inútil em uma aplicação, esta modalidade é ideal para o trabalho ad hoc do console 
                do SQL. O Hibernate impede, ou espera que o servidor de aplicação impessa isso, 
                o uso da modalidade de auto-commit.) As transações nunca são opcionais, toda a 
                comunicação com um banco de dados tem que ocorrer dentro de uma transação, não 
                importa se você vai ler ou escrever dados. Como explicado, o comportamento auto-commit 
                para leitura de dados deve ser evitado, como muitas transações pequenas são 
                improváveis de executar melhor do que uma unidade claramente definida do trabalho. A
                última opção também muito mais manutenível e extensível.
            </para>

            <para>
                O pattern mais comum em uma aplicação multi-usuário cliente/servidor é 
                <emphasis>sessão-por-requisição</emphasis>. Neste modelo, uma requisição do cliente é 
                enviada ao servidor (onde a camada de persistência do Hibernate roda), uma 
                <literal>Session</literal> nova do Hibernate é aberta, e todas as operações da base de 
                dados são executadas nesta unidade do trabalho. Logo que o trabalho for completado 
                (e a resposta para o cliente for preparada), a sessão é descarregad e fechada. 
                Você usaria também uma única transação de base de dados para servir às requisições 
                dos clientes, começando e commitando-o quando você abre e fecha a  <literal>Session</literal>. 
                O relacionamento entre os dois é um-para-um e este modelo é um ajuste perfeito para muitas 
                aplicações.
          </para>

            <para>
                O desafio encontra-se na implementação. O Hibernate fornece gerência integrada da "sessão atual" 
                para simplificar este pattern. Tudo que você tem que fazer é iniciar uma transação quando uma 
                requisição tem que ser processada e termina a transação antes que a resposta seja enviada ao 
                cliente. Você pode fazer onde quiser, soluções comuns são <literal>ServletFilter</literal>, 
                interceptador AOP com um pointcut (ponto de corte) nos métodos de serviço ou em um 
                container de proxy/interceptação. Um container de EJB é uma maneira padronizada para 
                implementar aspectos cross-cutting tais como a demarcação da transação em EJB session beans, 
                declarativamente com CMT. Se você se decidir usar demarcação programática de transação, 
                de preferencia a API <literal>Transaction</literal> do Hibernate mostrada mais adiante neste 
                capítulo, para fácilidade no uso e portabilidade de código. 
            </para>

            <para>
                Seu código de aplicação pode acessar a "sessão atual" para processar a requisição 
                fazendo uma chamada simples a  <literal>sessionFactory.getCurrentSession()</literal> em 
                qualquer lugar e com a frequencia necessária. Você sempre conseguirá uma
                <literal>Session</literal> limitada a transação atual. Isto tem que ser configurado 
                para recurso local ou os ambientes JTA. Veja <xref linkend="architecture-current-session"/>. 
            </para>

            <para>
                Às vezes é conveniente estender o escopo de uma  <literal>Session</literal> e de 
                uma transação do banco de dados até que a "visão esteja renderizada". É especialmente 
                útil em aplicações servlet que utilizam uma fase de rendenderização separada depois 
                que a requisição ter sido processada. Estendendo a transação até que renderização da 
                visão esteja completa é fácil de fazer se você implementar seu próprio interceptador. 
                Entretanto, não se pode fazer facilmente se você confiar em EJBs com transações 
                gerenciadas por contêiner, porque uma transação será terminada quando um método de 
                EJB retornar, antes da renderização de toda visão puder começar. 
                Veja o website e o fórum do Hibernate para dicas e exemplos em torno deste 
                pattern <emphasis>Open Session in View</emphasis>. 

             </para>

        </sect2>

        <sect2 id="transactions-basics-apptx" revision="1">
            <title>Longas conversações</title>

            <para>
                O pattern sessão-por-requisição não é o único conceito útil que você pode usar ao projetar 
                unidades de trabalho. Muitos processos de negócio requerem uma totalidade de séries de 
                interações com o usuário intercaladas com acessos a uma base de dados. Em aplicações web 
                e corporativas não é aceitável para uma transação atrapalhe uma interação do usuário.
                Considere o seguinte exemplo:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        A primeira tela de um diálogo abre os dados carregado pelo usuário em através de 
                        <literal>Session</literal> e transação particulares. O usuário está livre 
                        modificar os objetos. 
                    </para>
                </listitem>
                <listitem>
                    <para>
                        O usuário clica em "Salvar" após 5 minutos e espera suas modificações serem persistidas; 
                        espera também que ele era a única pessoa que edita esta informação e que nenhuma 
                        modificação conflitante possa ocorrer. 
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Nós chamamos esta unidade de trabalho, do ponto da visão do usuário, executando uma 
                longa <emphasis>conversação</emphasis> (ou <emphasis>transação da aplicação</emphasis>). 
                Há muitas maneiras de você pode implementar em sua aplicação. 

            </para>

            <para>
                Uma primeira implementação simples pode manter a<literal>Session</literal> e a transação 
                aberta durante o tempo de interação do usuário, com bloqueios na base de dados para impedir 
                a modificação concorrente e para garantir o isolamento e a atomicidade. Esse é naturalmente 
                um anti-pattern, desde que a disputa do bloqueio não permitiria o escalonameneto da 
                aplicação com o número de usuários concorrentes. 
            </para>

            <para>
                Claramente, nós temos que usar diversas transações para implementar a conversação. 
                Neste caso, Manter o isolamento dos processos de negócio torna-se responsabilidade 
                parcial da camada da aplicação. Uma única conversação geralmente usa diversas transações. 
                Ela será atômica se somente uma destas transações (a última) armazenar os
                dados atualizados, todas as outras simplesmente leram os dados (por exemplo em um 
                diálogo do estilo wizard que mede diversos ciclos de requisição/resposta). Isto é mais 
                fácil de implementar do que pode parecer, especialmente se você usar as
                características do Hibernate: 
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>Versionamento automático</emphasis> - O Hibernate pode fazer o 
                        controle automático de concorrência otimista para você, ele pode 
                        automaticamente detectar se uma modificação concorrente 
                        ocorreu durante o tempo de interação do usuário. Geralmente nós verificamos 
                        somente no fim da conversação.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Detached Objects</emphasis>- se você se decidir usar o já discutido 
                        pattern <emphasis>session-per-request</emphasis>, todas as instâncias carregadas 
                        estarão no estado destacado durante o tempo em que o usuário estiver pensando.
                        O Hibernate permite que você reatache os objetos e persita as modificações,
                        esse pattern é chamado 
                        <emphasis>session-per-request-with-detached-objects</emphasis>.
                        É usado versionamento automatico para isolar as modificações concorrentes.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Extended (or Long) Session</emphasis> A <literal>Session</literal> 
                        do Hibernate pode ser desligada da conexão básica do JDBC depois que a 
                        transação foi commitada e ser reconectado quando uma nova requisição do 
                        cliente ocorrer. Este pattern é conhecido como 
                        <emphasis>session-per-conversation</emphasis> e faz o reatamento uniforme 
                        desnecessário. Versionamento automático é usado para isolar modificações 
                        concorrentes e a <emphasis>session-per-conversation</emphasis> usualmente 
                        não é permitido para ser nivelado automaticamente, e sim explicitamente. 
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Ambos <emphasis>session-per-request-with-detached-objects</emphasis> e
                <emphasis>session-per-conversation</emphasis> possuem vantagens e desvantagens, 
                nos discutiremos mais tarde neste capítulo no contexto do controle de 
                concorrência otimista. 
            </para>

        </sect2>

        <sect2 id="transactions-basics-identity">
            <title>Considerando a identidade do objeto</title>

            <para>
                Uma aplicação pode acessar concorrentemente o mesmo estado persistente em duas 
                <literal>Session</literal>s diferentes. Entretanto, uma instância de uma classe 
                persistente nunca é compartilhada entre duas instâncias <literal>Session</literal>. 
                Por tanto, há duas noções diferentes da identidade: 
            </para>

            <variablelist spacing="compact">
                <varlistentry>
                    <term>Identidade da base de dados</term>
                    <listitem>
                        <para>
                            <literal>foo.getId().equals( bar.getId() )</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Identidade da JVM</term>
                    <listitem>
                        <para>
                            <literal>foo==bar</literal>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                Então para os objetos acoplados a um <literal>Session</literal> em <literal>particular </literal>
                (isto é no escopo de um <literal>Session</literal>), as duas noções são equivalentes e a 
                identidade da JVM para a identidade da base de dados é garantida pelo Hibernate. Entretanto, 
                quando a aplicação pode acessar concorrentemente o "mesmo" objeto do negócio (identidade 
                persistente) em duas sessões diferentes, as duas instâncias serão realmente "diferentes"
                (identidade de JVM). Os conflitos são resolvidos usando (versionamento automático) no 
                flush/commit, usando abordagem otimista. 

            </para>

            <para>
                Este caminho deixa o Hibernate e o banco dedados se preocuparem com a concorrência; também 
                fornece uma escalabilidade melhor, garantindo que a identidade em unidades de trabalho 
                único-encadeadas não necessite de bloqueio dispendioso ou de outros meios de sincronização. 
                A aplicação nunca necessita sincronizar qualquer objeto de negócio tão longo que transpasse 
                uma única thread por <literal>Session</literal>. Dentro de uma <literal>Session</literal> a 
                aplicação pode usar com segurança o <literal>==</literal> para comparar objetos. 
            </para>

            <para>
                Com tudo, uma aplicação que usa <literal>==</literal> fora de uma <literal>Session</literal>, 
                pode ver resultados inesperados. Isto pode ocorrer mesmo em alguns lugares inesperados, por 
                exemplo, se você colocar duas instâncias desacopladas em um mesmo <literal>Set</literal>. 
                Ambos podem ter a mesma identidade na base de dados (isto é eles representam a mesma linha 
                em uma tabela), mas a identidade da JVM pela definição não garantida para instâncias em estado 
                desacoplado. O desenvolvedor tem que sobrescrever os métodos <literal>equals()</literal> e 
                <literal>hashCode()</literal> em classes persistentes e implementar sua própria noção da 
                igualdade do objeto. Advertência: nunca use o identificador da base de dados para implementar 
                a igualdade, use atributos de negócio, uma combinação única, geralmente imutável. O 
                identificador da base de dados mudará se um objeto transiente passar para o estado persistente. 
                Se a instância transiente (geralmente junto com instâncias desacopladas) for inserida em um 
                <literal>Set</literal>, mudar o hashcode quebra o contrato do <literal>Set</literal>. 
                Atributos para chaves de negócio não têm que ser tão estável quanto às chaves primárias 
                da base de dados, você somente tem que garantir a estabilidade durante o tempo que 
                os objetos estiverem no mesmo Set. Veja o website do Hibernate para uma discussão mais 
                completa sobre o assunto. Note também que esta não é uma caracteristica do Hibernate, 
                mas simplesmente como a identidade e a igualdade do objeto de Java têm que ser implementadas. 
	            </para>

        </sect2>

        <sect2 id="transactions-basics-issues">
            <title>Edições comuns</title>

             <para>
                 Nunca use o anti-patterns <emphasis>session-per-user-session</emphasis> ou 
                 <emphasis>session-per-application</emphasis> (naturalmente, há umas exceções raras a 
                 essa regra). Note que algumas das seguintes edições podem também aparecer com patterns 
                 recomendados, certifique-se que tenha compreendido as implicações antes de fazer 
                 uma decisão de projeto: 
             </para>

            <itemizedlist>
                <listitem>
                    <para>
                        Uma <literal>Session</literal> não é threadsafe. As coisas que são supostas para trabalhar 
                        concorrentemente, como requisições HTTP, session beans, ou Swing, causarão condições de 
                        disputa se uma instância <literal>Session</literal> for compartilhada. Se você mantiver 
                        sua <literal>Session</literal> do Hibernate em seu <literal>HttpSession</literal> 
                        (discutido mais tarde), você deve considerar sincronizar o acesso a sua sessão do HTTP. 
                        Caso contrário, um usuário que clica em reload várias muito rapidamente pode usar o 
                        mesmo <literal>Session</literal> em duas threads executando concorrentemente.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Uma exceção lançada pelo Hibernate significa que você tem que dar rollback na sua 
                        transação no banco de dados e fechar a <literal>Session</literal> imediatamente 
                        (discutido mais tarde em maiores detalhes). Se sua <literal>Session</literal> é 
                        limitado pela aplicação, você tem que parar a aplicação. Dando rollback na 
                        transação no banco de dados não põe seus objetos do negócio em um estado anterior 
                        que estavam no início da transação. Isto significa que o estado da base de dados 
                        e os objetos de negócio perdem a sincronização. Geralmente não é um problema 
                        porque as exceções não são recuperáveis e você tem que iniciar após o 
                        rollback de qualquer maneira.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        O <literal>Session</literal> guarda em cache cada objeto que está no estado persistente 
                        (guardado e checado para estado "sujo" pelo Hibernate). Isto significa que ele cresce 
                        infinitamente até que você obtenha uma OutOfMemoryException, se você o mantiver aberto 
                        por muito tempo ou simplesmente carregar dados demais. Uma solução é chamar  
                        <literal>clear()</literal> e <literal>evict()</literal> para controlar o cache 
                        da <literal>Session</literal>, mas você deve considerar uma Store Procedure 
                        se precisar de operações que envolvam grande volume de dados. Algumas soluções são
                        mostradas no  <xref linkend="batch"/>. Manter uma <literal>Session</literal> aberta 
                        durante uma sessão do usuário significa também uma probabilidade elevada de se acabar 
                        com dados velhos.
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

    </sect1>

    <sect1 id="transactions-demarcation">
        <title>Demarcação de transações de bancos de dados</title>

        <para>
            Os limites de uma transação de banco de dados (ou sistema) são sempre necessários. Nenhuma 
            comunicação com o banco de dados pode ocorrer fora de uma transação de banco de dados (isto 
            parece confundir muitos desenvolvedores que estão usados modo auto-commit). Sempre use os 
            limites desobstruídos da transação, até mesmo para operações somente leitura. Dependendo 
            de seu nível de isolamento e capacidade da base de dados isto pode não ser requerido, 
            mas não há nenhum aspecto negativo se você demarca sempre transações explicitamente. 
            Certamente, uma única transação será melhor executada do que muitas transações pequenas, 
            até mesmo para dados de leitura. 
        </para>

        <para>
            Uma aplicação do Hibernate pode funcionar em ambientes não gerenciados (isto é aplicações standalone, Web 
            simples ou Swing) e ambientes gerenciados J2EE. Em um ambiente não gerenciado, o Hibernate é geralmente 
            responsável pelo seu próprio pool de conexões. O desenvolvedor tem que manualmente ajustar limites das 
            transaçãos, ou seja, começar, commitar, ou dar rollback nas transações ele mesmo. Um ambiente gerenciado 
            fornece transações gerenciadas por contêiner (CMT - container-managed transactions), com um conjunto 
            da transações definido declarativamente em descritores de deployment de EJB session beans, por exemplo. 
            A demarcação programática é então já não é necessário. 
        </para>

        <para>
            Entretanto, é freqüentemente desejável manter sua camada de persistência portável entre ambientes 
            de recurso locais não gerenciados e sistemas que podem confiar em JTA, mas usar BMT em vez de CMT. 
            Em ambos os casos você usaria demarcação de transação programática. O Hibernate oferece uma API 
            chamada Transaction que traduz dentro do sistema de transação nativa de seu ambiente de deployment. 
            Esta API é realmente opcional, mas nós encorajamos fortemente seu uso a menos que você estiver 
            em um CMT session bean. 
        </para>

        <para>
            Geralmente, finalizar um <literal>Session</literal>envolve quatro fases distintas:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    flush da sessão
                </para>
            </listitem>
            <listitem>
                <para>
                    commitar a transação
                </para>
            </listitem>
            <listitem>
                <para>
                    fechar a sessão
                </para>
            </listitem>
            <listitem>
                <para>
                		tratar as exceções 
                </para>
            </listitem>
        </itemizedlist>

        <para>
            A limpeza da sessão já foi bem discutida, agora nós daremos uma olhada na demarcação da 
            transação e na manipulação de exceção em ambientes controlados e não controlados. 
        </para>


        <sect2 id="transactions-demarcation-nonmanaged" revision="2">
            <title>Ambiente não gerenciado</title>

            <para>
	               Se uma camada de persistência do Hibernate roda em um ambiente não gerenciado, as conexões 
	               do banco de dados são geralmente tratadas pelos pools de conexões simples 
	               (isto é, não baseados em DataSource) dos quais o Hibernate obtém as conexões assim 
	               que necessita. A maneira de se manipular uma sessão/transação é mais ou menos assim:             
	         </para>

            <programlisting><![CDATA[// Non-managed environment idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}]]></programlisting>

            <para>
                Você não pode chamar <literal>flush()</literal> do  <literal>Session()</literal> 
                explicitamente - a chamada ao <literal>commit()</literal> dispara automaticamente 
                a sincronização para a sessão (dependendo do <xref linkend="objectstate-flushing">
                FlushMode</xref>). Uma chamada ao <literal>close()</literal> marca o fim de uma sessão. 
                A principal implicação do <literal>close()</literal> é que a conexão JDBC será abandonada 
                pela sessão. Este código Java é portável e funciona em ambientes não gerenciado e de JTA. 
            </para>

           <para>
                Uma solução muito mais flexível é gerência integrada de contexto da "sessão atual" 
                do Hibernate, como descrito anteriormente: 
            </para>

            <programlisting><![CDATA[// Non-managed environment idiom with getCurrentSession()
try {
    factory.getCurrentSession().beginTransaction();

    // do some work
    ...

    factory.getCurrentSession().getTransaction().commit();
}
catch (RuntimeException e) {
    factory.getCurrentSession().getTransaction().rollback();
    throw e; // or display error message
}]]></programlisting>

            <para>
                Você muito provavelmente nunca verá estes fragmentos de código em uma aplicação 
                regular; as exceções fatais (do sistema) devem sempre ser pegas no "alto". 
                Ou seja, o código que executa chamadas do Hibernate (na camada de persistência) 
                e o código que trata <literal>RuntimeException</literal>  (e geralmente pode 
                somente limpar acima e na saída) estão em camadas diferentes. O gerenciamento do 
                contexto atual feito pelo Hibernate pode significativamente simplificar este 
                projeto, como tudo que você necessita é do acesso a um <literal>SessionFactory</literal>.
                A manipulação de exceção é discutida mais tarde neste capítulo. 
            </para>

           <para>
                Note que você deve selecionar <literal>org.hibernate.transaction.JDBCTransactionFactory</literal>
                (que é o padrão) e para o segundo exemplo <literal>"thread"</literal> como seu 
                <literal>hibernate.current_session_context_class</literal>.
            </para>
            
        </sect2>

        <sect2 id="transactions-demarcation-jta" revision="3">
            <title>Usando JTA</title>

            <para>
                Se sua camada de persistência funcionar em um servidor de aplicação (por exemplo, 
                dentro dos EJB session beans), cada conexão do datasource obtida pelo Hibernate 
                automaticamente fará parte da transação global de JTA. Você pode também instalar uma 
                implementação standalone de JTA e usá-la sem EJB. O Hibernate oferece duas estratégias 
                para a integração de JTA. 
            </para>

            <para>
                Se você usar bean-managed transactions (BMT - transações gerenciadas por bean) o Hibernate dirá 
                ao servidor de aplicação para começar e para terminar uma transação de BMT se você usar a API 
                Transaction. Assim, o código de gerência de transação é idêntico ao ambiente não gerenciado. 
            </para>
            
           <programlisting><![CDATA[// BMT idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}]]></programlisting>

           <para>
               Se você quiser usar um  <literal>Session</literal> limitada por transação, isto é, 
               a funcionalidade do <literal>getCurrentSession()</literal> para a propagação fácil 
               do contexto, você terá que usar diretamente a API JTA <literal>UserTransaction</literal>: 
            </para>

            <programlisting><![CDATA[// BMT idiom with getCurrentSession()
try {
    UserTransaction tx = (UserTransaction)new InitialContext()
                            .lookup("java:comp/UserTransaction");

    tx.begin();

    // Do some work on Session bound to transaction
    factory.getCurrentSession().load(...);
    factory.getCurrentSession().persist(...);

    tx.commit();
}
catch (RuntimeException e) {
    tx.rollback();
    throw e; // or display error message
}]]></programlisting>

            <para>
                Com CMT, a demarcação da transação é feita em descritores de deployment do session beans, 
                não programaticamente, conseqüentemente, o código é reduzido a: 
            </para>

            <programlisting><![CDATA[// CMT idiom
 Session sess = factory.getCurrentSession();

 // do some work
 ...
]]></programlisting>

            <para>
                Em um CMT/EJB mesmo um rollback acontece automaticamente, desde que uma exeção <literal>RuntimeException</literal>
                não tratável seja lançada por um método de um session bean que informa ao contêiner ajustar a 
                transação global ao rollback. <emphasis>Isto significa que você não necessita usar a API 
                <literal>Transaction</literal> do Hibernate em tudo com BMT ou CMT e você obtém a propagação 
                automática do Session "atual" limitada à transação.</emphasis>
            </para>

            <para>
                Veja que você deverá escolher <literal>org.hibernate.transaction.JTATransactionFactory</literal> 
                se você usar o JTA diretamente (BMT) e <literal>org.hibernate.transaction.CMTTransactionFactory</literal> 
                em um CMT session bean, quando você configura a fábrica de transação do Hibernate. Lembre-se também de 
                configurar o <literal>hibernate.transaction.manager_lookup_class</literal>. Além disso, certifique-se 
                que seu <literal>hibernate.current_session_context_class</literal> ou não é configurado (compatibilidade 
                com o legado) ou é definido para <literal>"jta"</literal>.

            </para>

            <para>
                A operação <literal>getCurrentSession()</literal> tem um aspecto negativo em um ambiente JTA. 
                Há uma advertência para o uso do método liberado de conexão <literal>after_statement</literal>, 
                o qual é usado então por padrão. Devido a uma limitação simples da especificação JTA, não é 
                possível para o Hibernate automaticamente limpar quaisquer instâncias <literal>ScrollableResults</literal>
                ou <literal>Iterator</literal> abertas retornadas pelo <literal>scroll()</literal> ou
                <literal>iterate()</literal>. Você <emphasis>deve</emphasis> liberar o cursor subjacente da 
                base de dados chamando <literal>ScrollableResults.close()</literal> ou
                <literal>Hibernate.close(Iterator)</literal> explicitamente de um bloco <literal>finally</literal>. 
                (Claro que a maioria de aplicações podem facilmente evitar o uso do <literal>scroll()</literal> ou 
                do <literal>iterate()</literal> em todo código provindo do JTA ou do CMT.) 

            </para>

        </sect2>

        <sect2 id="transactions-demarcation-exceptions">
            <title>Tratamento de Exceção</title>

            <para>
                Se a <literal>Session</literal> levantar uma exceção (incluindo qualquer 
                <literal>SQLException</literal>), você deve imediatamente dar um rollback 
                na transação do banco, chamando <literal>Session.close()</literal> e descartando 
                a instância da <literal>Session</literal>. Certos métodos da <literal>Session</literal> 
                <literal>não</literal> deixarão a sessão em um estado inconsistente. Nenhuma exceção 
                lançada pelo Hibernate pode ser recuperada. Certifique-se que a <literal>Session</literal>
                será fechada chamando <literal>close()</literal> no bloco <literal>finally</literal>.
            </para>

            <para>
                A exceção <literal>HibernateException</literal>, a qual envolve a maioria dos erros 
                que podem ocorrer em uma camada de persistência do Hibernate, é uma exceção unchecked (
                não estava em umas versões mais antigas de Hibernate). Em nossa opinião, nós não devemos
                forçar o desenvolvedor a tratar uma exceção irrecuperável em uma camada mais baixa. 
                Na maioria dos sistemas, as exceções unchecked e fatais são tratadas em um dos primeiros 
                frames da pilha da chamada do método (isto é, em umas camadas mais elevadas) e uma mensagem 
                de erro é apresentada ao usuário da aplicação (ou a alguma outra ação apropriada é feita). 
                Note que Hibernate pode também lançar outras exceções unchecked que não são um 
                <literal>HibernateException</literal>. Estas, também são, irrecuperáveis e uma ação 
                apropriada deve ser tomada.
            </para>

            <para>
                O Hibernate envolve <literal>SQLException</literal>s lançadas ao interagir com a base de dados 
                em um <literal>JDBCException</literal>. Na realidade, o Hibernate tentará converter a exceção em
                em uma sub classe mais significativa da <literal>JDBCException</literal>. A 
                <literal>SQLException</literal> subjacente está sempre disponível através de 
                <literal>JDBCException.getCause()</literal>. 

                O Hibernate converte a <literal>SQLException</literal> em uma sub classe 
                <literal>JDBCException</literal> apropriada usando <literal>SQLExceptionConverter</literal> 
                associado ao SessionFactory. Por padrão, o <literal>SQLExceptionConverter</literal>  é definido 
                pelo dialeto configurado; entretanto, é também possível conectar em uma implementação customizada
                (veja o javadoc para mais detalhes da classe  <literal>SQLExceptionConverterFactory</literal>). 
                Os subtipos padrão de <literal>JDBCException</literal> são:
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>JDBCConnectionException</literal> - indica um erro com a comunicação subjacente de JDBC.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>SQLGrammarException</literal> - indica um problema da gramática ou da sintaxe com o SQL emitido.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>ConstraintViolationException</literal> - indica algum forma de violação de confinamento de integridade.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>LockAcquisitionException</literal> - indica um erro ao adquirir um nível de bloqueio necessário para realizar a operação de requisição.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>GenericJDBCException</literal> - uma exceção genérica que não cai em algumas das outras categorias. 
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

        <sect2 id="transactions-demarcation-timeout">
            <title>Timeout de Transação</title>

            <para>
                Uma característica extremamente importante fornecida por um ambiente 
                gerenciado como EJB e que nunca é fornecido pelo código não gerenciado é o timeout 
                de transação. Timeouts de transação asseguram que nenhuma transação possa 
                reter  indefinidamente recursos enquanto não retorna nenhuma resposta ao usuário.
                Fora de um ambiente controlado (JTA), o Hibernate não pode fornecer inteiramente 
                esta funcionalidade. Entretanto, o Hibernate pode afinal controlar as operações 
                do acesso a dados, assegurando que o nível de deadlocks e queries do banco de 
                dados com imensos resultados definidos sejam limitados pelo timeout. Em um ambiente 
                gerenciado, o Hibernate pode delegar o timeout da transação ao JTA. Esta funcionalidade 
                é abstraída pelo objeto  <literal>Transaction</literal> do Hibernate. 
            </para>
            
            <programlisting><![CDATA[
Session sess = factory.openSession();
try {
    //set transaction timeout to 3 seconds
    sess.getTransaction().setTimeout(3);
    sess.getTransaction().begin();

    // do some work
    ...

    sess.getTransaction().commit()
}
catch (RuntimeException e) {
    sess.getTransaction().rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}]]></programlisting>

            <para>
                Veja que <literal>setTimeout()</literal> não pode ser chamado em um CMT bean, 
                onde os timeouts das transações devem ser definidos declarativamente.
            </para>
            
        </sect2>
        
    </sect1>

    <sect1 id="transactions-optimistic">
        <title>Controle de concorrência otimista</title>

        <para>
            O único caminho que é consistente com a elevada concorrência e escalabilidade 
            é controle de concorrência otimista com versionamento. Checagem de versão usa 
            número de versão, ou timestamps, para detectar conflitos de atualizações (e para 
            impedir atualizações perdidas). O Hibernate fornece três caminhos possíveis para 
            escrever aplicações que usam concorrência otimista. Os casos de uso que nós mostramos 
            estão no contexto de conversações longas, mas a checagem de versão também tem o 
            benefício de impedir atualizações perdidas em únicas transações.            
        </para>

        <sect2 id="transactions-optimistic-manual">
            <title>Checagem de versão da aplicação</title>

            <para>
                Em uma implementação sem muita ajuda do Hibernate, cada interação com o banco de dados 
                ocorre em uma nova <literal>Session</literal> e o desenvolvedor é responsável para 
                recarregar todas as instâncias persistentes da base de dados antes de manipulá-las. 
                Este caminho força a aplicação a realizar sua própria checagem de versão para assegurar 
                a conversação do isolamento da transação. Este caminho é menos eficiente em termos de 
                acesso ao banco de dados. É a caminho mais similar a EJBs entity.                
            </para>

            <programlisting><![CDATA[// foo is an instance loaded by a previous Session
session = factory.openSession();
Transaction t = session.beginTransaction();

int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() ); // load the current state
if ( oldVersion != foo.getVersion() ) throw new StaleObjectStateException();
foo.setProperty("bar");

t.commit();
session.close();]]></programlisting>

            <para>
                A propriedade <literal>version</literal> é mapeada usando <literal>&lt;version&gt;</literal>, 
                e o Hibernate vai incrementá-lo-á automaticamente durante o flush se a entidade 
                estiver alterada.
            </para>

            <para>
                Claro, se você se estiver operando em um ambiente de baixa concorrência de dados 
                e não requerer a checagem de versão, você pode usar este caminho e apenas saltar a 
                checagem de versão. Nesse caso, o  <emphasis>ultimo commit realizdo </emphasis> é 
                a estratégia padrão para suas conversações longas. Mantenha em mente que isto pode 
                confundir os usuários da aplicação, assim como eles podem experimentar atualizações
                perdidas sem mensagens de erro ou uma possibilidade ajustar mudanças de conflito.

            </para>

            <para>
                Claro que, checagem manual da versão é somente praticável em circunstâncias triviais 
                e não para a maioria de aplicações. Freqüentemente, os grafos completos de objetos 
                modificados têm que ser verificados, não somente únicas instâncias. O Hibernate oferece 
                checagem de versão automática com uma <literal>Session</literal> estendida ou instâncias 
                desatachadas como o paradigma do projeto.
            </para>

        </sect2>

        <sect2 id="transactions-optimistic-longsession">
            <title>Sessão estendida e versionamento automático</title>

            <para>
                Uma única instância de <literal>Session</literal> e suas instâncias persistentes 
                são usadas para a conversação inteira, isto é conhecido como 
                <emphasis>session-per-conversation</emphasis>. O Hibernate verifica versões da instância 
                no momento dio flush, lançando uma exceção se a modificação concorrente for detectada. 
                Até o desenvolvedor pegar e tratar essa exceção (as opções comuns são a oportunidade 
                para que o usuário intercale as mudanças ou reinicie a conversação do negócio com 
                dados não antigos).                
            </para>

            <para>
                The <literal>Session</literal> is disconnected from any underlying JDBC connection
                when waiting for user interaction. This approach is the most efficient in terms
                of database access. The application need not concern itself with version checking or
                with reattaching detached instances, nor does it have to reload instances in every
                database transaction.
                A <literal>Session</literal> é desconectada de toda a conexão JDBC subjacente 
                enquanto espera a interação do usuário. Este caminho é a mais eficiente em termos 
                de acesso a bancos de dados. A aplicação não necessita concernir-se com a checagem 
                de versão ou com as instâncias destacadas reatadas, nem tem que recarregar instâncias 
                em cada transação.
            </para>

            <programlisting><![CDATA[// foo is an instance loaded earlier by the old session
Transaction t = session.beginTransaction(); // Obtain a new JDBC connection, start transaction

foo.setProperty("bar");

session.flush();    // Only for last transaction in conversation
t.commit();         // Also return JDBC connection
session.close();    // Only for last transaction in conversation]]></programlisting>
            <para>
                O objeto <literal>foo</literal> sabe que <literal>Session</literal> já foi carregada. Começando 
                uma nova transação em uma sessão velha obtém uma conexão nova e recomeça a sessão. Commitando 
                uma transação desconecta uma sessão da conexão JDBC e retorna a conexão ao pool. Após a reconexão, 
                forçar uma checagem de versão em dados que você não está atualizando, você pode chamar 
                <literal>Session.lock()</literal> com o <literal>LockMode.READ</literal> em todos os objetos 
                que possam ter sido atualizados por uma outra transação. Você não necessita bloquear nenhum 
                dado para atualizar. Geralmente você configuraria <literal>FlushMode.MANUAL</literal> em uma
                <literal>Session</literal> estendida, de modo que somente o último ciclo da transação tenha
                permissão de persistir todas as modificações feitas nesta conversação. Disso, somente esta última 
                transação incluiria a operação <literal>flush()</literal> e então chamar também <literal>close()</literal>
                da sessão para terminar a conversação.
            </para>
            
            <para>
                Este pattern é problemático se a <literal>Session</literal> for demasiadamente grande para
                ser armazenado durante o tempo que usuário pensar, por exemplo um <literal>HttpSession</literal> 
                estiver mantido tão pequeno quanto possível. Como o <literal>Session</literal> é também cache 
                de primeiro nível (imperativo) e contém todos os objetos carregados, nós podemos provavelmente 
                usar esta estratégia somente para alguns ciclos de requisição/resposta. Você deve usar a
                <literal>Session</literal> somente para uma única conversação, porque ela logo também 
                estará com dados velhos.
            </para>

            <para>
                (Note que versões mais atuais de Hibernate requerem a desconexão e o reconexão explícitas de 
                uma <literal>Session</literal>. Estes métodos são desatualizados, como o início e término de 
                uma transação tem o mesmo efeito.)
            </para>

            <para>
                Note também que você deve manter a <literal>Session</literal> desconectada fechada 
                para a camada de persistência. Ou seja, use um EJB stateful session bean para 
                prender a <literal>Session</literal> em um ambiente do três camadas e não o 
                transferir à camada web (ou até serializá-lo para uma camada separada)
                para armazená-lo no <literal>HttpSession</literal>.

            </para>

            <para>
                O pattern sessão estendida, ou <emphasis>session-per-conversation</emphasis>, é mais 
                difícil de implementar com gerenciamento automático de sessão atual. Você precisa fornecer 
                sua própria implementação do <literal>CurrentSessionContext</literal> para isto
                (veja o Hibernate Wiki para exemplos).
            </para>

        </sect2>

        <sect2 id="transactions-optimistic-detached">
            <title>Objetos destacados e versionamento automático</title>

            <para>
                Cada interação com o armazenamento persistente ocorre em uma <literal>Session</literal> nova. 
                Entretanto, as mesmas instâncias persistentes são reusadas para cada interação com o banco de dados. 
                A aplicação manipula o estado das instâncias desatachadas originalmente carregadas em um outro 
                <literal>Session</literal> e reata-os então usando <literal>Session.update()</literal>, 
                <literal>Session.saveOrUpdate()</literal> ou <literal>Session.merge()</literal>.
            </para>

            <programlisting><![CDATA[// foo is an instance loaded by a previous Session
foo.setProperty("bar");
session = factory.openSession();
Transaction t = session.beginTransaction();
session.saveOrUpdate(foo); // Use merge() if "foo" might have been loaded already
t.commit();
session.close();]]></programlisting>

            <para>
                Outra vez, o Hibernate verificará versões da instância durante o flush, 
                lançando uma exceção se ocorrer conflitos de atualizações.
            </para>

            <para>
                Você pode também chamar o <literal>lock()</literal> em vez de <literal>update()</literal> 
                e usar <literal>LockMode.READ</literal> (executando uma checagem de versão, ignorando 
                todos os caches) se você estiver certo de que o objeto não foi modificado.
            </para>

        </sect2>

        <sect2 id="transactions-optimistic-customizing">
            <title>Versionamento automático customizado</title>

            <para>
                Você pode desabilitar o incremento da versão automática de Hibernate para propriedades 
                e coleções particulares configurando o mapeamento do atributo <literal>optimistic-lock</literal>
                para false. O Hibernate então não irá incrementa versões se a propriedade estiver
                modificada.
            </para>

            <para>
                Os esquemas da base de dados legada são freqüentemente estáticos e não podem ser modificados. 
                Ou outras aplicações puderam também acessar a mesma base de dados e não sabem tratar a 
                versão dos números ou timestamps. Em ambos os casos, o versionamento não pode confiar em uma 
                coluna particular em uma tabela. Para forçar uma checagem de versão sem uma versão ou mapeamento
                da propriedade do timestamp com uma comparação do estado de todos os campos em uma linha, 
                configure <literal>optimistic-lock="all"</literal> no mapeamento <literal>&lt;class&gt;</literal>. 
                Note que isto conceitualmente é somente feito em trabalhos se Hibernate puder comparar o estado 
                velho e novo, isto é, se você usa um único  <literal>Session</literal> longo e não 
                session-per-request-with-detached-objects.
            </para>

            <para>
                Às vezes a modificação concorrente pode ser permitida tão longa quanto às mudanças que 
                tiveram sido feitas que não sobrepuseram. Se você configurar <literal>optimistic-lock="dirty"</literal>
                ao mapear o <literal>&lt;class&gt;</literal>, o Hibernate comparará somente campos 
                modificados durante o flush.
            </para>

            <para>
                Em ambos os casos, com as colunas dedicadas da versão/timestamp ou com comparação do 
                campo cheio/modificados, o Hibernate usa uma única declaração UPDATE (com uma cláusula 
                WHERE apropriada ) por entidade para executar a checagem da versão e atualizar a informação. 
                Se você usa a persistência transitiva para cascatear o reatamento das entidades associadas, 
                o Hibernate pode executar atualizações desnecessárias. Isso não é geralmente um problema, 
                mas triggers <emphasis>on update</emphasis> em um banco de dados podem ser executados 
                mesmo quando nenhuma mudança foi feita nas instâncias destacadas. Você pode customizar 
                este comportamento configurando <literal>select-before-update="true"</literal> no 
                mapeamento  <literal>&lt;class&gt;</literal>, forçando o Hibernate a dá um SELECT nas 
                instâncias para assegurar-se esse as mudanças ocorreram realmente, antes de atualizar 
                a linha.
            </para>

        </sect2>

    </sect1>

    <sect1 id="transactions-locking">
        <title>Locking pessimista</title>

        <para>
            Não se pretende que os usuários gastam muitas horas se preocupando com suas estratégias de 
            locking. Geralmente é o bastante para especificar um nível de isolamento para as conexões 
            JDBC e então deixar simplesmente o banco de dados fazer todo o trabalho. Entretanto, os 
            usuários avançados podem às vezes desejar obter locks pessimistas exclusivos, ou re-obter 
            locks no início de uma nova transação. 
        </para>

        <para>
            O Hibernate usará sempre o mecanismo de lock da base de dados, nunca trava objetos 
            na memória!
        </para>

        <para>
            A classe <literal>LockMode</literal> define os diferentes níveis de lock que o Hibernate 
            pode adquirir. Um lock é obtido pelos seguintes mecanismos:

        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>LockMode.WRITE</literal> é adquirido automaticamente quando o Hibernate atualiza 
                    ou insere uma linha.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>LockMode.UPGRADE</literal> pode ser adquirido explicitamente pelo usuário 
                    usando <literal>SELECT ... FOR UPDATE</literal> em um banco de dados que suporte 
                    esse sintaxe.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>LockMode.UPGRADE_NOWAIT</literal> pode ser adquirido explicitamente pelo usuário 
                    usando <literal>SELECT ... FOR UPDATE NOWAIT</literal> no Oracle.

                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>LockMode.READ</literal> é adquirido automaticamente quando o Hibernate lê 
                    dados em um nível Repeatable Read ou Serializable isolation. Pode ser readquirido 
                    explicitamente pelo usuário.
                </para>
            </listitem>
        <listitem>
        <para>
            <literal>LockMode.NONE</literal> representa a ausência do lock. Todos os objetos mudam para 
            esse estado de lock no final da  <literal>Transaction</literal>. Objetos associados com a sessão 
            através do método <literal>update()</literal> ou <literal>saveOrUpdate()</literal> também são
             inicializados com esse lock mode.
        </para>
        </listitem>
        </itemizedlist>

        <para>
            O lock obtido "explicitamente pelo usuário" se dá em uma das seguintes maneiras:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    Uma chamada a <literal>Session.load()</literal>, especificando 
                    o <literal>LockMode</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Uma chamada a <literal>Session.lock()</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                   Uma chamada a  <literal>Query.setLockMode()</literal>.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Se uma <literal>Session.load()</literal> é invocada com <literal>UPGRADE</literal> ou
            <literal>UPGRADE_NOWAIT</literal>, e o objeto requisitado ainda não foi carregado 
            pela sessão, o objeto é carregado usando <literal>SELECT ... FOR UPDATE</literal>. 
            Se <literal>load()</literal> for chamado para um objeto que já foi carregado 
            com um lock menos restritivo que o novo lock solicitado, o Hibernate invoca o 
            método <literal>lock()</literal> para aquele objeto.
        </para>

        <para>
            O método  <literal>Session.lock()</literal> executa uma verificação no número da versão 
            se o modo de lock especificado for <literal>READ</literal>, <literal>UPGRADE</literal> ou
            <literal>UPGRADE_NOWAIT</literal>.. (No caso do <literal>UPGRADE</literal> ou
            <literal>UPGRADE_NOWAIT</literal>, é usado <literal>SELECT ... FOR UPDATE</literal>.)
        </para>

        <para>
            Se o banco de dados não suportar o lock mode solicitado, o Hibernate vai usar um modo 
            alternativo apropriado (ao invés de lançar uma exceção). Isso garante que a aplicação 
            vai ser portável.
        </para>

    </sect1>

    <sect1 id="transactions-connection-release">
        <title>Modos de liberar a Connection</title>

        <para>
            O comportamento legado do Hibernate (2.x) em consideração ao gerenciamento da conexão 
            via JDBC fez com que a <literal>Session</literal> precisasse obter uma conexão 
            quando ela precisasse pela primeira vez e depois manter a conexão enquanto 
            a sessão não fosse fechada. O Hibernate 3.x introduz a idéia de modos de liberar a 
            sessão, para informar a sessão a forma como deve manusear a sua conexão JDBC. 
            Veja que essa discussão só é pertinente para conexões fornecidas com um 
            <literal>ConnectionProvider</literal> configurado; conexões fornecidas pelo usuário 
            estão fora do escopo dessa discussão. Os diferentes modos de liberação estão definidos 
            pelos valores da enumeração 
            <literal>org.hibernate.ConnectionReleaseMode</literal>:
           
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>ON_CLOSE</literal> - essencialmente é o modo legado descrito acima. A sessão 
                    do Hibernate obtêm a conexão quando precisar executar alguma operação JDBC pela 
                    primeira vez e mantem enquanto a conexão não for fechada.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>AFTER_TRANSACTION</literal> – informa que a conexão deve ser 
                    liberada após a conclusão de uma <literal>org.hibernate.Transaction</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>AFTER_STATEMENT</literal> (também conhecida com liberação agressiva) – informa 
                    que a conexão deve ser liberada após a execução de cada statement. A liberação agressiva 
                    não ocorre se o statement deixa pra trás algum recurso aberto associado com a sessão 
                    obtida; atualmente, a única situação em que isso é possível é com o uso de 
                    <literal>org.hibernate.ScrollableResults</literal>.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            O parâmetro de configuração <literal>hibernate.connection.release_mode</literal> é usado 
            para especificar qual modo de liberação deve ser usado. Opções disponíveis:            
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>auto</literal>  (padrão) – essa opção delega ao modo de liberação retornado pelo 
                    método <literal>org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</literal>. 
                    Para JTATransactionFactory, ele retorna ConnectionReleaseMode.AFTER_STATEMENT; para 
                    JDBCTransactionFactory, ele retorna ConnectionReleaseMode.AFTER_TRANSACTION. 
                    Raramente é uma boa idéia alterar padrão, como frequencia ao se fazer isso temos falhas 
                    que parecem bugs e/ou suposições inválidas no código do usuário.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>on_close</literal> - indica o uso da ConnectionReleaseMode.ON_CLOSE. Essa opção 
                    foi deixada para manter a compatibilidade, mas seu uso é fortemente desencorajado.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>after_transaction</literal> – indica o uso da ConnectionReleaseMode.AFTER_TRANSACTION. 
                    Essa opção nada deve ser usada com ambientes JTA. Também note que no caso da 
                    ConnectionReleaseMode.AFTER_TRANSACTION, se a sessão foi colocada no modo auto-commit a 
                    conexão vai ser liberada de forma similar ao modo AFTER_STATEMENT.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>after_statement</literal> – indica o uso ConnectionReleaseMode.AFTER_STATEMENT. 
                    Adicionalmente, o  <literal>ConnectionProvider</literal> configurado é consultado para 
                    verificar se suporta essa configuração ((<literal>supportsAggressiveRelease()</literal>). 
                    Se não suportar, o modo de liberação é redefinido como ConnectionRelease-Mode.AFTER_TRANSACTION. 
                    Essa configuração só é segura em ambientes onde podemos readquirir a mesma conexão JDBC 
                    toda vez que o método <literal>ConnectionProvider.getConnection()</literal>  for chamado ou 
                    em um ambiente auto-commit onde não importa se nós recuperamos a mesma conexão. 
                </para>
            </listitem>
        </itemizedlist>

    </sect1>

</chapter>

