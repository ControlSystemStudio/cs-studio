<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="session-configuration" revision="1">

    <title>구성</title>
    
    <para>
        Hibernate가 많은 다른 환경들에서 동작하도록 설계되어 있으므로, 많은 개수의 구성 파라미터들이 존재한다. 다행히 대부분은 유의미한 
                디폴트 값들이고 Hibernate는 다양한 옵션들을 보여주는 <literal>etc/</literal> 내의 예제 파일 <literal>hibernate.properties</literal>로 
                배포된다. 당신은 단지 당신의 classpath 경로 속에 그 파일을 집어넣고 그것을 커스트마이징하기만 해야 한다.
    </para>

    <sect1 id="configuration-programmatic" revision="1">
        <title>프로그램 상의 구성</title>

        <para>
            <literal>org.hibernate.cfg.Configuration</literal>의 인스턴스는 어플리케이션의 Java 타입들을 SQL 데이터베이스 
                        타입으로의 전체 매핑 집합을 표현한다. <literal>Configuration</literal>은 (불변의) <literal>SessionFactory</literal>를 
                        빌드하는데 사용된다. 매핑들은 여러 XML 매핑 파일들로부터 컴파일 된다.
        </para>

        <para>
                        당신은 <literal>Configuration</literal> 인스턴스를 초기화 시키고 XML 매핑 문서들을 지정함으로써 <literal>Configuration</literal> 
                        인스턴스를 얻을 수 있다. 만일 매핑 파일들이 classpath 내에 있다면, <literal>addResource()</literal>를 사용하라: 
        </para>

        <programlisting><![CDATA[Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");]]></programlisting>

        <para>
            (때때로 더 나은) 다른 방법은 매핑된 클래스를 지정하는 것이고, Hibernate로 하여금 당신을 위해 매핑 문서를 찾도록 하라:
        </para>

        <programlisting><![CDATA[Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);]]></programlisting>

        <para>
                        그때 Hibernate는 classpath 내에서 <literal>/org/hibernate/auction/Item.hbm.xml</literal>과 
            <literal>/org/hibernate/auction/Bid.hbm.xml</literal>로 명명된 매핑 파일들을 룩업할 것이다. 이 접근법은 
                        임의의 하드코딩된 파일 이름들을 제거한다.
        </para>
        
        <para>
            <literal>Configuration</literal>은 또한 구성 프로퍼티들을 지정하는 것을 허용해준다:
        </para>

        <programlisting><![CDATA[Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");]]></programlisting>
    
        <para>
                        이것은 컨피그레이션 프로퍼티들을 Hibernate에 전달하는 유일한 방법이 아니다. 여러 가지 옵션들은 다음을 포함한다:
        </para>

        <orderedlist spacing="compact">
            <listitem>
                <para>
                    <literal>java.util.Properties</literal>의 인스턴스를 <literal>Configuration.setProperties()</literal>에 
                                        전달한다 .
                </para>
            </listitem>
            <listitem>
                <para>
                    classpath의 루트 디렉토리에 <literal>hibernate.properties</literal>를 위치지운다. 
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>java -Dproperty=value</literal>를 사용하여 <literal>System</literal> 프로퍼티들을 설정한다.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>hibernate.cfg.xml</literal>에 <literal>&lt;property&gt;</literal> 요소들을 포함한다
                    (나중에 논의됨). 
                </para>
            </listitem>
        </orderedlist>

        <para>
                        당신이 빠르게 시작하고 원할 경우 <literal>hibernate.properties</literal>는 가장 쉬운 접근법이다.
        </para>

        <para>
            <literal>Configuration</literal>은 시작 시(startup-time) 객체로서 일단 <literal>SessionFactory</literal>가 
                        생성되면 폐기되게끔 예정되어 있다.
        </para>

    </sect1>
    
    <sect1 id="configuration-sessionfactory">
        <title>SessionFactory 얻기</title>

        <para>
                        모든 매핑들이 <literal>Configuration</literal>에 의해 파싱되었을 때, 어플리케이션은 <literal>Session</literal> 
                        인스턴스들에 대한 팩토리를 얻어야 한다. 이 팩토리는 모든 어플리케이션 쓰레드들에 의해 공유되도록 고안되었다:
        </para>

        <programlisting><![CDATA[SessionFactory sessions = cfg.buildSessionFactory();]]></programlisting>

        <para>
                        하지만 Hibernate는 당신의 어플리케이션이 하나 이상의 <literal>SessionFactory</literal>를 초기화 시키는 것을 허용한다. 
                        이것은 당신이 하나 이상의 데이터베이스를 사용하는 경우에 유용하다.
        </para>

    </sect1>

    <sect1 id="configuration-hibernatejdbc" revision="1">
        <title>JDBC 커넥션들</title>

        <para>
                        대개 당신은 <literal>SessionFactory</literal>로 하여금 당신을 위한 JDBC 커넥션들을 생성시키고 풀링시키는 것을 원한다. 
                        만일 당신이 이 접근법을 취할 경우, 한 개의 <literal>Session</literal>을 여는 것은 다음과 같이 간단하다:
        </para>

        <programlisting><![CDATA[Session session = sessions.openSession(); // open a new Session]]></programlisting>
        
        <para>
                        당신이 데이터베이스에 대한 접근을 요청하는 어떤 것을 행하자 마자, 한 개의 JDBC 커넥션이 그 풀로부터 얻어질 것이다.
        </para>

        <para> 
                        이것이 동작하도록 하기 위해서, 우리는 몇몇 JDBC 커넥션 프로퍼티들을 Hibernate에 전달할 필요가 있다. 모든 Hibernate 프로퍼티 
                        이름들과 의미론들은 <literal>org.hibernate.cfg.Environment</literal> 클래스 상에 정의되어 있다. 우리는 이제 JDBC
                        커넥션 구성을 위한 가장 중요한 설정들을 설명할 것이다.
        </para>

        <para>
                        만일 당신이 다음 프로퍼티들을 설정할 경우 Hibernate는 <literal>java.sql.DriverManager</literal>를 사용하여 커넥션들을 
                        얻을 것이다(그리고 풀링시킬 것이다): 
        </para>

        <table frame="topbot">
            <title>Hibernate JDBC 프로퍼티들</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>프로퍼티 이름</entry>
                        <entry>용도</entry>
                    </row>
                </thead>
            <tbody>
            <row>
                <entry>
                    <literal>hibernate.connection.driver_class</literal>
                </entry>
                <entry>
                    <emphasis>jdbc 드라이버 클래스</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.url</literal>
                </entry>
                <entry>
                    <emphasis>jdbc URL</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.username</literal>
                </entry>
                <entry>
                    <emphasis>데이터베이스 사용자</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.password</literal>
                </entry>
                <entry>
                    <emphasis>데이터베이스 사용자 패스워드</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.pool_size</literal>
                </entry>
                <entry>
                    <emphasis>풀링된 커넥션들의 최대 개수</emphasis>
                </entry>
            </row>
            </tbody>
            </tgroup>
        </table>

        <para>
                        하지만 Hibernate 자신의 커넥션 풀링 알고리즘은 아주 기본적이다. 그것은 당신이 시작하는 것을 도와주려고 의도되었고 <emphasis>제품 
                        시스템 용도 또는 퍼포먼스 테스트용으로는 고안되지 않았다</emphasis>. 최상의 퍼포먼스와 안정성을 위해서는 제 3의 풀을 사용하라. 즉 
            <literal>hibernate.connection.pool_size</literal> 프로퍼티를 커넥션 풀 지정 설정들로 대체하라. 이것은 Hibernate의 내부 
            pool을 오프시킬 것이다. 예를 들어 당신은 C3P0를 사용할 수도 있다.
        </para>

        <para>
            C3P0는 <literal>lib</literal> 디펙토리 속에 Hibernate에 배포된 오픈 소스 JDBC 커넥션 풀이다. 당신이 <literal>hibernate.c3p0.*</literal> 
                        프로퍼티들을 설정할 경우  Hibernate는  커넥션 풀링을 위해 그것의 <literal>C3P0ConnectionProvider</literal>를 사용할 것이다. 
                        만일 당신이 Proxool을 사용하고자 원할 경우 패키지화 된 <literal>hibernate.properties</literal>를 참조하고 추가 정보는 
            Hibernate 웹 사이트를 참조하라.
        </para>

        <para>
                        다음은 C3P0에 대한 사용하는 예제 <literal>hibernate.properties</literal> 파일이다:
        </para>

        <programlisting id="c3p0-configuration" revision="1"><![CDATA[hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]></programlisting>

        <para>
                        어플리케이션 서버 내부의 용도로, 당신은 JNDI로 등록된 어플리케이션 서버 <literal>Datasource</literal>로부터 커넥션을 얻기 
                        위해 항상 Hibernate를 구성해야 한다. 당신은 적어도 다음 프로퍼티들 중 하나를 최소한으로 설정할 필요가 있을 것이다.
        </para>

        <table frame="topbot">
            <title>Hibernate Datasource Properties</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>프로퍼티 이름</entry>
                        <entry>용도</entry>
                    </row>
                </thead>
            <tbody>
            <row>
                <entry>
                    <literal>hibernate.connection.datasource</literal>
                </entry>
                <entry>
                    <emphasis>데이터소스 JNDI 이름</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.jndi.url</literal>
                </entry>
                <entry>
                    <emphasis>JNDI 프로바이더의 URL</emphasis> (옵션)
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.jndi.class</literal>
                </entry>
                <entry>
                    <emphasis>JNDI <literal>InitialContextFactory</literal>의 클래스 </emphasis> (옵션)
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.username</literal>
                </entry>
                <entry>
                    <emphasis>데이터베이스 사용자</emphasis> (옵션)
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.password</literal>
                </entry>
                <entry>
                    <emphasis>데이터베이스 사용자 패스워드</emphasis> (옵션)
                </entry>
            </row>
            </tbody>
            </tgroup>
        </table>

        <para>
                        다음은 어플리케이션 서버 제공 JNDI 데이터소스용 예제 <literal>hibernate.properties</literal> 파일이다:
        </para>

        <programlisting><![CDATA[hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]></programlisting>

        <para>
            JNDI datasource로부터 얻어진 JDBC 커넥션들은 어플리케이션 서버의 컨테이너에 의해 관리되는 트랜잭션들에 자동적으로 참여할 것이다.
        </para>

        <para>
                        임의의 커넥션 프로퍼티들은 프로퍼티 이름 앞에 "<literal>hibernate.connnection</literal>"을 첨가하여 부여될 수 있다. 예를 들어 
                        당신은 <literal>hibernate.connection.charSet</literal>을 사용하여 <literal>charSet</literal>을 지정할 수도 있다.
        </para>

        <para>
                        당신은 <literal>org.hibernate.connection.ConnectionProvider</literal> 인터페이스를 구현함으로써 JDBC 커넥션들을 
                        얻는 당신 자신의 플러그인 방도를 정의할수도 있다. 당신은 <literal>hibernate.connection.provider_class</literal>를 
                        설정하여 맞춤형 구현을 선택할 수도 있다.
        </para>

    </sect1>

    <sect1 id="configuration-optional" revision="1">
        <title>선택적인 구성 프로퍼티들</title>
        
        <para>
                        실행 시에 Hibernate의 행위를 제어하는 많은 다른 프로퍼티들이 존재한다. 모든 것이 옵션이지만 합당한 디폴트 값들을 갖는다.
        </para>

        <para>
        	<emphasis>경고: 이들 프로퍼티들 중 몇몇은 "system-level" 전용이다.</emphasis> 시스템 레벨 프로퍼티들은 오직 
            <literal>java -Dproperty=value</literal> 또는 <literal>hibernate.properties</literal>를 통해서만 설정될 수 
                        있다. 그것들은 위에 설명된 다른 기법들에 의해 설정될 수 <emphasis>없다</emphasis>.
        </para>

        <table frame="topbot" id="configuration-optional-properties" revision="8">
            <title>Hibernate 구성 프로퍼티들</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>프로퍼티 이름</entry>
                        <entry>용도</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.dialect</literal>
                        </entry>
                        <entry>
                                                        특정 관계형 데이터베이스에 최적화 된 SQL을 생성시키는 것을 Hibernate에게 허용해주는 
                            Hibernate <literal>Dialect</literal>의 클래스명. 
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>full.classname.of.Dialect</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.show_sql</literal>
                        </entry>
                        <entry>
                                                        모든 SQL 문장들을 콘솔에 기록한다. 이것은 로그 카테고리 <literal>org.hibernate.SQL</literal>를 
                            <literal>debug</literal>로 설정하는 것에 대한 하나의 다른 방법이다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.format_sql</literal>
                        </entry>
                        <entry>
                                                        로그와 콘솔 속에 SQL을 깔끔하게 프린트한다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_schema</literal>
                        </entry>
                        <entry>
                                                        생성된 SQL 내에 주어진 schema/tablespace로서 수식이 없는 테이블이름들을 수식한다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>SCHEMA_NAME</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_catalog</literal>
                        </entry>
                        <entry>
                                                        주어진 SQL 내에 주어진 카타록으로서 수식이 없는 테이블이름들을 수식한다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>CATALOG_NAME</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.session_factory_name</literal>
                        </entry>
                        <entry>
                            <literal>SessionFactory</literal>는 그것이 생성된 후에 JNDI 내에서  이 이름에 자동적으로 바인드 
                                                        될 것이다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>jndi/composite/name</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.max_fetch_depth</literal>
                        </entry>
                        <entry>
                            single-ended 연관관계들(one-to-one, many-to-one)의 경우에 outer join fetch 트리의 최대 "깊이"를 
                                                        설정한다. <literal>0</literal>은 디폴트 outer join fetching을 사용불가능하게 만든다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>0</literal>과 
                                <literal>3</literal> 사이의 값들이권장된다 
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_batch_fetch_size</literal>
                        </entry>
                        <entry>
                                                       연관들의 Hibernate 배치 페칭에 대한 디폴트 크기를 설정한다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                                            권장되는 값들은 <literal>4</literal>, <literal>8</literal>, 
                                <literal>16</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_entity_mode</literal>
                        </entry>
                        <entry>
                                                        이 <literal>SessionFactory</literal>로부터 열려진 모든 세션들에 대해 엔티티 표현을 디폴트 모드로 
                                                        설정한다
                            <para>
                                <literal>dynamic-map</literal>, <literal>dom4j</literal>,
                                <literal>pojo</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.order_updates</literal>
                        </entry>
                        <entry>
                                                        업데이트 중인 항목들의 프라이머리 키 값에 의해 SQL 업데이트들이 순서(ordering)지워지도록 Hibernate에게 
                                                        강제시킨다. 이것은 고도의 동시성 시스템들에서 더 적은 트랜잭션 데드락(deadlock)들로 귀결될 것이다
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.generate_statistics</literal>
                        </entry>
                        <entry>
                                                        이용 가능하게 되면, Hibernate는 퍼포먼스 튜닝에 유용한 통계들을 수집할 것이다.
                            <para>
                                <emphasis role="strong">예.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.use_identifer_rollback</literal>
                        </entry>
                        <entry>
                                                        이용 가능하게 되면, 객체가 삭제될 때 생성된 식별자 프로퍼티들은 디폴트 값들로 재설정될 것이다.
                            <para>
                                <emphasis role="strong">예.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.use_sql_comments</literal>
                        </entry>
                        <entry>
                                                        이용 가능하게 되면, Hibernate는 보다 쉬운 디버깅을 위해 SQL 내에 주석들을 생성시킬 것이다. 
                                                        디폴트는 <literal>false</literal>.
                            <para>
                                <emphasis role="strong">예.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-jdbc-properties" revision="8">
            <title>Hibernate JDBC 및 커넥션 프로퍼티들</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>프로퍼티 이름</entry>
                        <entry>용도</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.fetch_size</literal>
                        </entry>
                        <entry>
                            0 아닌 값은 JDBC fetch 사이즈를 결정한다(<literal>Statement.setFetchSize()</literal>을 호출한다 ).
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.batch_size</literal>
                        </entry>
                        <entry>
                            0 아닌 값은 Hibernate에 의한 JDBC2 배치 업데이트의 사용을 이용 가능하게 한다.
                            <para>
                                <emphasis role="strong">예.</emphasis>
                                <literal>5</literal>와 <literal>30</literal> 사이의 값들이 권장된다
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.batch_versioned_data</literal>
                        </entry>
                        <entry>
                                                        당신의 JDBC 드라이버가 <literal>executeBatch()</literal>로부터 정확한 행 카운트들을 반환할 경우에 
                                                        이 프로퍼티를 <literal>true</literal>로 설정하라(대개 이 옵션을 사용 가능하게 하는 것이 안전하다). 
                                                        그러면 Hibernate는 자동적으로 버전화 된 데이터에 대해 배치화된(batched) DML을 사용할 것이다. 
                                                        디폴트는  <literal>false</literal>.
                            <para>
                                <emphasis role="strong">예.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.factory_class</literal>
                        </entry>
                        <entry>
                                                        맞춤형 <literal>Batcher</literal>를 선택한다. 대부분의 어플리케이션들은 이 구성 프로퍼티를 필요로 하지 
                                                        않을 것이다.
                            <para>
                                <emphasis role="strong">예.</emphasis>
                                <literal>classname.of.BatcherFactory</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.use_scrollable_resultset</literal>
                        </entry>
                        <entry>
                            Hibernate에 의한 JDBC2 스크롤 가능한 결과셋들의 사용을 가능하게 해준다. 이 프로퍼티는 사용자가 제공한 
                            JDBC커넥션들을 사용할 때에만 필수적이고, 그 밖의 경우 Hibernate는 커넥션 메타데이터를 사용한다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.use_streams_for_binary</literal>
                        </entry>
                        <entry>
                            FUZZY! <literal>binary</literal> 또는 <literal>serializable</literal> 타입들을 읽어들일 때 
                                                        스트림들을 사용한다(시스템-레벨 프로퍼티).
                            <para>
                                <emphasis role="strong">예.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.use_get_generated_keys</literal>
                        </entry>
                        <entry>
                            insert 후에 고유하게 생성된 키들을 검색하는데 JDBC3 <literal>PreparedStatement.getGeneratedKeys()</literal>의 
                                                        사용을 이용 가능하도록 만든다. JDBC3+ 드라이버와 JRE1.4+를 필요로 하고, 당신의 드라이버가 Hibernate 
                                                        식별자 생성자들에 문제가 있을 경우에 false로 설정하라. 디폴트로 커넥션 메타 데이터를 사용하여 드라이버 
                                                        가용성들을 결정하려고 시도하라.
                            <para>
                                <emphasis role="strong">예.</emphasis>
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.connection.provider_class</literal>
                        </entry>
                        <entry>
                            Hibernate에 JDBC 커넥션들을 제공하는 맞춤형 <literal>ConnectionProvider</literal>의 클래스명.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>classname.of.ConnectionProvider</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                    <entry>
                        <literal>hibernate.connection.isolation</literal>
                    </entry>
                    <entry>
                        JDBC transaction isolation 레벨을 설정한다. 의미있는 값들로 <literal>java.sql.Connection</literal>을 
                                                체크하지만 대부분의 데이터베이스들이 모든 격리(isolate) 레벨들을 지원하지 않음을 노트하라.
                        <para>
                            <emphasis role="strong">예.</emphasis> 
                            <literal>1, 2, 4, 8</literal>
                        </para>
                    </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.connection.autocommit</literal>
                        </entry>
                        <entry>
                            JDBC 풀링된 커넥션들에 대해 자동커밋을 이용 가능하도록 한다(권장되지 않음).
                            <para>
                                <emphasis role="strong">예.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.connection.release_mode</literal>
                        </entry>
                        <entry>
                            Hibernate가 JDBC 커넥션들을 해제하게 될 시점을 지정한다. 디폴트로 한 개의 JDBC 커넥션은 그 세션이 명시적으로 
                                                        닫히거나 연결해제되기 전까지 보관된다. 어플리케이션 트랜잭션 서버 JTA 데이터소스의 경우, 당신은 모든 JDBC 
                                                        호출 후에 커넥션들을 과감하게 해제시키기 위해 <literal>after_statement</literal>를 사용해야 한다. 비-JTA 
                                                        연결의 경우, <literal>after_transaction</literal>을 사용하여 각각의 트랜잭션의 끝에서 커넥션들을 
                                                        해제시키는 것이 종종 의미가 있다. <literal>auto</literal>는 JTA 및 CMT 트랜잭션 방도들의 경우에 
                            <literal>after_statement</literal>를 선택하고 JDBC 트랜잭션 방도에 대해 <literal>after_transaction</literal>를 
                                                        선택할 것이다.
                            <para>
                                <emphasis role="strong">eg.</emphasis> 
                                <literal>auto</literal> (디폴트) | <literal>on_close</literal> |
                                <literal>after_transaction</literal> | <literal>after_statement</literal>
                            </para>
                            <para>
                                                                이 설정이 <literal>SessionFactory.openSession</literal>로부터 반환된 <literal>Session</literal>들에만 
                                                                영향을 준다는 점을 노트하라. <literal>SessionFactory.getCurrentSession</literal>을 통해 얻어진 
                                <literal>Session</literal>들의 경우, 사용하기 위해 구성된 <literal>CurrentSessionContext</literal> 구현이
                                                                그들 <literal>Session</literal>들에 대한 연결 해제를 제어한다. <xref linkend="architecture-current-session"/>를 
                                                                보라.
                            </para>
                        </entry>
                    </row>
                    <row>
                    <entry>
                        <literal>hibernate.connection.<emphasis>&lt;propertyName&gt;</emphasis></literal>
                    </entry>
                    <entry>
                        JDBC 프로퍼티 <literal>propertyName</literal>을 <literal>DriverManager.getConnection()</literal>에 
                                                전달한다.
                    </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jndi.<emphasis>&lt;propertyName&gt;</emphasis></literal>
                        </entry>
                        <entry>
                            <literal>propertyName</literal> 프로퍼티를 JNDI <literal>InitialContextFactory</literal>에 전달한다.
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-cache-properties" revision="7">
            <title>Hibernate Cache 프로퍼티들</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>프로퍼티 이름</entry>
                        <entry>용도</entry>
                    </row>
                </thead>
                <tbody>
                     <row>
                        <entry>
                            <literal>hibernate.cache.provider_class</literal>
                        </entry>
                        <entry>
                                                        맞춤형 <literal>CacheProvider</literal>의 클래스명.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>classname.of.CacheProvider</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_minimal_puts</literal>
                        </entry>
                        <entry>
                                                        읽기가 매우 빈번한 경우에, 쓰기를 최소화 시키기 위해 second-level 캐시 연산을 최적화 시킨다. 이 설정은 Hibernate3에서 클러스터링 된 
                                                        캐시들에 가장 유용하고, Hibernate3에서는 클러스터링된 캐시 구현들에 대해 디폴트로 이용 가능하다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_query_cache</literal>
                        </entry>
                        <entry>
                                                        질의 캐시를 가능하게 만든다. 개별 질의들은 여전히 캐시 가능한 것으로 설정되어야 한다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_second_level_cache</literal>
                        </entry>
                        <entry>
                            second-level 캐시를 완전히 사용 불가능하게 하는데 사용될 수 있고, 그것은 <literal>&lt;cache&gt;</literal> 매핑을 
                                                        지정하는 클래스들에 대해 디폴트로 이용 가능이다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.query_cache_factory</literal>
                        </entry>
                        <entry>
                                                        맞춤형 <literal>QueryCache</literal> 인터페이스의 클래스명. 디폴트는 미리 빌드된  
                            <literal>StandardQueryCache</literal>.
                            <para>
                                <emphasis role="strong">예.</emphasis>
                                <literal>classname.of.QueryCache</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.region_prefix</literal>
                        </entry>
                        <entry>
                            second-level 캐시 영역 이름들에 사용할 접두어.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>prefix</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_structured_entries</literal>
                        </entry>
                        <entry>
                                                        인간에게 보다 더 친숙한 형식으로 second-level 캐시 속에 데이터를 저장하도록 Hibernate에게 강제시킨다..
                            <para>
                                <emphasis role="strong">예.</emphasis>
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-transaction-properties" revision="9">
            <title>Hibernate 트랜잭션 프로퍼티들</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>프로퍼티 이름</entry>
                        <entry>용도</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.factory_class</literal>
                        </entry>
                        <entry>
                            Hibernate <literal>Transaction</literal> API 에 사용할 <literal>TransactionFactory</literal>의 
                                                       클래스 이름.(디폴트는 <literal>JDBCTransactionFactory</literal>). 
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>classname.of.TransactionFactory</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>jta.UserTransaction</literal>
                        </entry>
                        <entry>
                                                        어플리케이션 서버로부터 JTA <literal>UserTransaction</literal>을  얻기 위해 <literal>JTATransactionFactory</literal>에 
                                                        의해 사용되는 JNDI 이름.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>jndi/composite/name</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.manager_lookup_class</literal>
                        </entry>
                        <entry>
                            <literal>TransactionManagerLookup</literal>의 클래스명- JVM 레벨의 캐싱이 이용 가능할 때 또는 JTA 환경에서 
                            hilo generator를 사용할 때 필요하다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>classname.of.TransactionManagerLookup</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.flush_before_completion</literal>
                        </entry>
                        <entry>
                                                        만일 사용가능하도록 되면, 세션은 트랜잭션의 before completion 단계 동안에 자동적으로 flush 될 것이다.
                                                       빌드되어 있는 자동적인 세션 컨텍스트 관리가 선호되는데, 
                            <xref linkend="architecture-current-session"/>를 보라.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.auto_close_session</literal>
                        </entry>
                        <entry>
                                                        만일 사용가능토록 하면, after completion 단계 동안에 세션이 자동적으로 닫혀질 것이다.
                            (CMT에 대해 Hibernate를 사용할 때 매우 유용하다.)
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-misc-properties" revision="10">
            <title>여러가지 프로퍼티들</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>프로퍼티 이름</entry>
                        <entry>용도</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.current_session_context_class</literal>
                        </entry>
                        <entry>
                            "현재" <literal>Session</literal>의 영역화를 위한 하나의 (맞춤) 방도를 
                                                        제공한다. 빌드되어 있는 방도들에 대한 추가 정보는 
                            <xref linkend="architecture-current-session"/>를 보라.
                            <para>
                                <emphasis role="strong">예.</emphasis>
                            <literal>jta</literal> | <literal>thread</literal> |
                                <literal>managed</literal> | <literal>custom.Class</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.query.factory_class</literal>
                        </entry>
                        <entry>
                            Chooses the HQL 파서 구현을 선택한다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>org.hibernate.hql.ast.ASTQueryTranslatorFactory</literal> or
                                <literal>org.hibernate.hql.classic.ClassicQueryTranslatorFactory</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.query.substitutions</literal>
                        </entry>
                        <entry>
                            Hibernate 질의들 내의 토큰들로부터 SQL 토큰들로의 매핑
                            (예를 들어 토큰들은 함수 이름 또는 리터럴 이름일 수 있다).
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.hbm2ddl.auto</literal>
                        </entry>
                        <entry>
                            <literal>SessionFactory</literal>가 생성될 때, 자동적으로 유효성을 검사하거나 
                            schema DDL을 데이터베이스로 내보내기 한다. <literal>create-drop</literal>의 경우, 
                            <literal>SessionFactory</literal>가 명시적으로 닫혀질 때 데이터베이스 스키마가 
                                                        드롭될 것이다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>validate</literal> | <literal>update</literal> | 
                                <literal>create</literal> | <literal>create-drop</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cglib.use_reflection_optimizer</literal>
                        </entry>
                        <entry>
                                                        런타임 reflection 대신에 CGLIB의 사용을 가능하도록 만든다(시스템 레벨 프로퍼티). 
                             Reflection은 문제가 발생할 시에 때때로 유용할 수 있고, 
                                                        당신이 optimizer를 사용하지 않을 경우조차도 Hibernate는 항상 필요로 함을 유의하라. 
                                                        당신은 <literal>hibernate.cfg.xml</literal> 
                                                        속에 이 프로퍼티를 설정할수 없다.
                            <para>
                                <emphasis role="strong">예.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <sect2 id="configuration-optional-dialects" revision="1">
            <title>SQL Dialects</title>

            <para>
                                당신은 항상 당신의 데이터베이스를 위해 <literal>hibernate.dialect</literal> 프로퍼티를 정확한 <literal>org.hibernate.dialect.Dialect</literal> 
                                서브클래스로 설정해야 한다. 만일 당신이 dialect를 지정할 경우, 당신이 프로퍼티들을 수작업으로 지정하는 노력을 절약하도록 Hibernate는 위에 열거된 다른 프로퍼티들 
                                중 몇몇에 대해  의미있는 디폴트들을 사용할 것이다.
            </para>

            <table frame="topbot" id="sql-dialects" revision="2">
                <title>Hibernate SQL Dialects (<literal>hibernate.dialect</literal>)</title>
                <tgroup cols="2">
                    <colspec colwidth="1*"/>
                    <colspec colwidth="2.5*"/>
                    <thead>
                        <row>
                            <entry>RDBMS</entry>
                            <entry>Dialect</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>DB2</entry> <entry><literal>org.hibernate.dialect.DB2Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>DB2 AS/400</entry> <entry><literal>org.hibernate.dialect.DB2400Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>DB2 OS390</entry> <entry><literal>org.hibernate.dialect.DB2390Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>PostgreSQL</entry> <entry><literal>org.hibernate.dialect.PostgreSQLDialect</literal></entry>
                        </row>
                        <row>
                            <entry>MySQL</entry> <entry><literal>org.hibernate.dialect.MySQLDialect</literal></entry>
                        </row>
                        <row>
                            <entry>MySQL with InnoDB</entry> <entry><literal>org.hibernate.dialect.MySQLInnoDBDialect</literal></entry>
                        </row>
                        <row>
                            <entry>MySQL with MyISAM</entry> <entry><literal>org.hibernate.dialect.MySQLMyISAMDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Oracle (any version)</entry> <entry><literal>org.hibernate.dialect.OracleDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Oracle 9i/10g</entry> <entry><literal>org.hibernate.dialect.Oracle9Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>Sybase</entry> <entry><literal>org.hibernate.dialect.SybaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Sybase Anywhere</entry> <entry><literal>org.hibernate.dialect.SybaseAnywhereDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Microsoft SQL Server</entry> <entry><literal>org.hibernate.dialect.SQLServerDialect</literal></entry>
                        </row>
                        <row>
                            <entry>SAP DB</entry> <entry><literal>org.hibernate.dialect.SAPDBDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Informix</entry> <entry><literal>org.hibernate.dialect.InformixDialect</literal></entry>
                        </row>
                        <row>
                            <entry>HypersonicSQL</entry> <entry><literal>org.hibernate.dialect.HSQLDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Ingres</entry> <entry><literal>org.hibernate.dialect.IngresDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Progress</entry> <entry><literal>org.hibernate.dialect.ProgressDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Mckoi SQL</entry> <entry><literal>org.hibernate.dialect.MckoiDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Interbase</entry> <entry><literal>org.hibernate.dialect.InterbaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Pointbase</entry> <entry><literal>org.hibernate.dialect.PointbaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>FrontBase</entry> <entry><literal>org.hibernate.dialect.FrontbaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Firebird</entry> <entry><literal>org.hibernate.dialect.FirebirdDialect</literal></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

        </sect2>

        <sect2 id="configuration-optional-outerjoin" revision="4">
            <title>Outer Join Fetching</title>

            <para>
                                만일 당신의 데이터베이스가 ANSI, Oracle, 또는 Sybase 스타일의 outer join들을 지원할 경우, <emphasis>outer join
                fetching</emphasis>은 (데이터베이스 그 자체에 의해 보다 더 많은 작업이 수행되는 비용으로) 데이터베이스로의 그리고 
                                데이터베이스로부터의 라운드 트립들의 개수를 제한함으로써 종종 퍼포먼스를 증가시킬 것이다. Outer join fetching은 
                many-to-one, one-to-many, many-to-many,one-to-one 연관관계들이 에 의해 연결된 객체들의 전체 그래프가  
                                하나의 SQL <literal>SELECT</literal> 속에서 검색되게끔 허용해준다.
            </para>

            <para>
                Outer join fetching은 hibernate.max_fetch_depth 프로퍼티를 <literal>0</literal>으로 설정함으로써 
                <emphasis>전역적으로</emphasis> 사용 불가능하게 할 수 있다. <literal>1</literal> 이상의 값을 설정하는 
                                것은 <literal>fetch="join"</literal>으로 매핑되었던 모든 one-to-one 및 many-to-one 연관관계들에 대해 
                outer join fetching을 사용 가능하도록 만든다.
            </para>

            <para>
                                추가 정보는 <xref linkend="performance-fetching"/>를 보라.
            </para>

        </sect2>

        <sect2 id="configuration-optional-binarystreams" revision="1">
            <title>Binary Streams</title>

            <para>
                Oracle은 JDBC 드라이버 로/부터 전달되는 <literal>byte</literal> 배열들의 크기를 제한시킨다. 만일 당신이 
                <literal>binary</literal> 또는 <literal>serializable</literal> 타입의 대형 인스턴스를 사용하고자 
                                원할 경우에, 당신은 <literal>hibernate.jdbc.use_streams_for_binary</literal>를 사용 가능하게 해야 
                                할 것이다. <emphasis>이것은 오직 시스템 레벨 설정이다.</emphasis>
            </para>

        </sect2>

        <sect2 id="configuration-optional-cacheprovider" revision="2">
            <title>Second-level 캐시와 query 캐시</title>

            <para>
                <literal>hibernate.cache</literal> 접두어가 붙은 프로퍼티들은 Hibernate에 대해 프로세스 또는 
                                클러스터 범위의 두 번째 레벨 캐시 시스템을 사용하는 것을 허용해준다. 상세한 것은 
                <xref linkend="performance-cache"/>를 보라. 
            </para>

        </sect2>

        <sect2 id="configuration-optional-querysubstitution">
            <title>Query Language 치환</title>

            <para>
                                당신은 <literal>hibernate.query.substitutions</literal>을 사용하여 새로운 Hibernate 질의 토큰들을 
                                정의할 수 있다. 예를 들어:
            </para>

            <programlisting>hibernate.query.substitutions true=1, false=0</programlisting>

            <para>
                                은<literal>true</literal>와 <literal>false</literal> 토큰들이 생성된 SQL 내에서 
                                정수 리터럴들로 번역되도록 강제할 것이다.
            </para>

            <programlisting>hibernate.query.substitutions toLowercase=LOWER</programlisting>

            <para>
                               은 SQL <literal>LOWER</literal> function  함수 이름을 변경하는 것을 당신에게 허용해 줄 것이다
            </para>

        </sect2>

        <sect2 id="configuration-optional-statistics" revision="2">
            <title>Hibernate 통계</title>

            <para>
                                만일 당신이 <literal>hibernate.generate_statistics</literal>를 사용 가능하도록 할 경우, Hibernate는 
                <literal>SessionFactory.getStatistics()</literal>를 통해 가동 중인 시스템을 튜닝할 때 유용한 많은 통계들을 
                                노출시킬 것이다. Hibernate는 심지어 JMX를 통해 이들 통계들을 노출시키도록 구성될 수 있다. 추가 정보는 
                <literal>org.hibernate.stats</literal>에 있는 인터페이스들에 관한 Javadoc를 읽어라.
            </para>

        </sect2>
    </sect1>

    <sect1 id="configuration-logging">
        <title>로깅</title>

        <para>
            Hibernate는 Apache commons-logging를 사용하여 다양한 이벤트들을 로그시킨다. 
        </para>

        <para>
            commons-logging 서비스는 (만일 당신이 classpath 내에 <literal>log4j.jar</literal>를 포함할 경우) Apache Log4j로 
                        또는 (JDK1.4 이상의 버전에서 실행될 경우) JDK 1.4 로깅으로 직접 출력할 것이다. 당신은 <literal>http://jakarta.apache.org</literal>에서 
            Log4j를 다운로드 할 수 있다. Log4j를 사용하기 위해, 당신은 <literal>log4j.properties</literal> 파일을 당신의 classpath 
                        내에 위치지울 필요가 있을 것이고, 예제 properties 파일은 Hibernate의  <literal>src/</literal> 디렉토리 내에 배포되어 있다. 
        </para>
        
        <para>
                        우리는 당신이 Hibernate의 로그 메시지들에 익숙해지기를 강력히 권장한다. 읽기 불가능하지 않게끔 가능한 한 상세하게 Hibernate 로그를 
                        만들도록 많은 작업이 행해졌다. 그것은 본질적인 문제던지기 장치이다. 가장 흥미로운 로그 카테고리들이 다음에 있다:
        </para>
        
            <table frame="topbot" id="log-categories" revision="2">
                <title>Hibernate 로그 카테고리들</title>
                <tgroup cols="2">
                    <colspec colwidth="1*"/>
                    <colspec colwidth="2.5*"/>
                    <thead>
                        <row>
                            <entry>카테고리</entry>
                            <entry>기능</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>org.hibernate.SQL</literal></entry>
                            <entry>SQL DML 문장들이 실행될 때 그것들 모두를 로그 시킨다</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.type</literal></entry>
                            <entry>모든 JDBC 파라미터들을 로그시킨다</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.tool.hbm2ddl</literal></entry>
                            <entry>SQL DDL 문장들이 실행될 때 그것들 모두를 로그 시킨다</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.pretty</literal></entry>
                            <entry>
                                flush 시점에서 세션과 연관된 모든 엔티티들(최대 20개의 엔티티들)의 상태를 로그 시킨다
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.cache</literal></entry>
                            <entry>모든 second-level 캐시 액티비티를 로그시킨다</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction</literal></entry>
                            <entry>트랜잭션 관련 액티비티를 로그 시킨다</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.jdbc</literal></entry>
                            <entry>모든 JDBC 리소스 취득을 로그 시킨다</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.hql.ast.AST</literal></entry>
                            <entry>
                                                                질의 파싱 동안에 HQL AST와 SQL AST를 로그시킨다
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.secure</literal></entry>
                            <entry>모든 JAAS 허가 요청들을 로그시킨다</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate</literal></entry>
                            <entry>
                                                                모든 것을 로그시킨다(많은 정보이지만, 문제해결에 매우 유용하다)
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            
        <para>
            Hibernate로 어플리케이션들을 개발할 때, 당신은 거의 항상 <literal>org.hibernate.SQL</literal> 카테고리에 대해 
                        이용 가능한 <literal>debug</literal> 모드로 작업하거나, 다른 방법으로 <literal>hibernate.show_sql</literal> 
                        프로퍼티를 이용가능하게 하여 작업해야 할 것이다.
        </para>
                       
        
    </sect1>

    <sect1 id="configuration-namingstrategy">
        <title><literal>NamingStrategy</literal> 구현하기</title>

        <para>
            <literal>org.hibernate.cfg.NamingStrategy</literal> 인터페이스는 데이터베이스 객체들과 스키마 요소들에 대한 
            "네이밍 표준"을 지정하는 것을 당신에게 허용해준다.
        </para>

        <para>
                        당신은 Java 식별자들로부터 데이터베이스 식별자들을 자동적으로 생성시키거나 매핑 파일에 주어진 "논리적" 컬럼과 테이블 
                        이름들을 "물리적" 테이블과 컬럼 이름들로 자동적으로 처리하는 규칙들을 제공할 수 있다. 이 특징은 반복되는 잡음(예를 들어 
            <literal>TBL_</literal>접두어들)을 제거함으로써, 매핑 문서의 말많은 장황함을 감소시키도록 도와준다. Hibernate에 
                        의해 사용되는 디폴트 방도는 아주 작은 작품이다.
        </para>

        <para>
                        당신은 매핑들을 추가하기 이전에 <literal>Configuration.setNamingStrategy()</literal>를 호출함으로써 다른 방도를 
                        지정할 수 있다:
        </para>

        <programlisting><![CDATA[SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();]]></programlisting>
    
        <para>
            <literal>org.hibernate.cfg.ImprovedNamingStrategy</literal>는 어떤 어플리케이션들에 대한 유용한 시작점일 수 있는 
                        미리 빌드된 방도이다.
        </para>

    </sect1>

    <sect1 id="configuration-xmlconfig" revision="2">
        <title>XML 구성 파일</title>

        <para>
                        구성에 대한 다른 접근법은 <literal>hibernate.cfg.xml</literal>로 명명된 파일 속에 전체 구성을 지정하는 것이다. 이 파일은 
            <literal>hibernate.properties</literal> 파일에 대한 대용물로서 사용될 수 있거나, 만일 둘 다 존재할 경우에 프로퍼티들을 
                        중복정의하는데 사용될 수 있다.
        </para>

        <para>
            XML 구성 파일은 디폴트로 당신의 <literal>CLASSPATH</literal>의 루트에 존재하는 것이 기대된다. 다음은 예제이다:
        </para>

        <programlisting><![CDATA[<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>

    <!-- a SessionFactory instance listed as /jndi/name -->
    <session-factory
        name="java:hibernate/SessionFactory">

        <!-- properties -->
        <property name="connection.datasource">java:/comp/env/jdbc/MyDB</property>
        <property name="dialect">org.hibernate.dialect.MySQLDialect</property>
        <property name="show_sql">false</property>
        <property name="transaction.factory_class">
            org.hibernate.transaction.JTATransactionFactory
        </property>
        <property name="jta.UserTransaction">java:comp/UserTransaction</property>

        <!-- mapping files -->
        <mapping resource="org/hibernate/auction/Item.hbm.xml"/>
        <mapping resource="org/hibernate/auction/Bid.hbm.xml"/>

        <!-- cache settings -->
        <class-cache class="org.hibernate.auction.Item" usage="read-write"/>
        <class-cache class="org.hibernate.auction.Bid" usage="read-only"/>
        <collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/>

    </session-factory>

</hibernate-configuration>]]></programlisting>

        <para>
                        당신이 볼 수 있듯이, 이 접근법의 장점은 구성에 대한 매핑 파일 이름들을 구체화 시키는 것이다. <literal>hibernate.cfg.xml</literal>은 
                        또한 당신이 Hibernate 캐시를 튜닝해야할 때 보다 편리하다. <literal>hibernate.properties</literal> 또는 
            <literal>hibernate.cfg.xml</literal> 중 어느 것을 사용하는가는 당신의 선택이다. XML 구문을 사용하는 위에 언급된 
                        이점들을 제외하면 둘다 같은 것임을 노트하라.
        </para>

       <para>
           Hibernate 구성으로, Hibernate를 시작하는 것은 다음과 같이 간단하다
       </para>

       <programlisting><![CDATA[SessionFactory sf = new Configuration().configure().buildSessionFactory();]]></programlisting>

       <para>
                      당신은 다음을 사용하여 다른 XML 구성 파일을 찾아낼 수 있다
       </para>

       <programlisting><![CDATA[SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();]]></programlisting>

    </sect1>

    <sect1 id="configuration-j2ee" revision="1">
        <title>J2EE 어플리케이션 서버 통합</title>

        <para>
            Hibernate는 J2EE 인프라스트럭처에 대한 다음 통합 점들을 갖고 있다: 
        </para>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>Container-managed datasources</emphasis>: Hibernate는 컨테이너에 의해 관리되는 JDBC 커넥션들을 
                                사용할 수 있고 JNDI를 통해 제공된다. 대개 JTA 호환 <literal>TransactionManager</literal>와 <literal>ResourceManager</literal>는 
                                트랜잭션 관리(CMT), 특히 몇몇 데이터소스들을 가로질러 분산된 트랜잭션 핸들링을 처리한다. 물론 당신은 또한 프로그램 상으로 
                                트랜잭션 경계들을 한정할 수도 있거나(BMT) 당신은 당신의 코드가 이식성을 유지하도록 이것에 대한 선택적인 Hibernate 
                <literal>Transaction</literal> API를 사용하고자 원할 수도 있다.
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>자동적인 JNDI 바인딩</emphasis>: Hibernate는 시작 후에 그것의 <literal>SessionFactory</literal>를 
                JNDI에 바인드 시킬 수 있다.
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>JTA Session 바인딩</emphasis>: Hibernate <literal>Session</literal>은 
                JTA 트랜잭션들의 영역(scope)에 자동적으로 바인드 시킬 수도 있다. 간단하게 JNDI로부터 <literal>SessionFactory</literal>를 
                                룩업하고 현재 <literal>Session</literal>을 얻어라. Hibernate로 하여금 당신의 JTA 트랜잭션이 완료될 때 <literal>Session</literal>을 
                flush시키고 닫는 것을 처리하도록 하라. 트랜잭션 경계 구분은 선언적(CMT)이거나 프로그래밍적((BMT/UserTransaction))이다.
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>JMX 배치</emphasis>: 만일 당신이 JMX 가용성이 있는 어플리케이션 서버(예를 들면 JBoss AS)를 갖고 있다면, 
                                당신은 Hibernate를 하나의 managed MBean으로서 배치하는 것을 선택할 수 있다. 이것은 <literal>Configuration</literal>으로부터 
                                당신의 <literal>SessionFactory</literal>를 빌드 시키는 한 줄의 시작 코드를 절약해준다. 컨테이너는 당신의 <literal>HibernateService</literal>를 
                                시작할 것이고, 또한 이상적으로 서비스 의존성들을 처리할 것이다(데이터소스는 Hibernate가 시작되기 전에 이용 가능해야 한다). 
                </para>
            </listitem>
        </itemizedlist>

        <para>
                        당신의 환경에 따라, 당신은 당신의 어플리케이션 서버가 "connection containment(연결 봉쇄)" 예외상황들을 보일 경우에 구성 옵션 
            <literal>hibernate.connection.aggressive_release</literal>를 true로 설정해야 될 수도 있다.
        </para>

        <sect2 id="configuration-optional-transactionstrategy" revision="3">
            <title>트랜잭션 방도 구성</title>

            <para>
                Hibernate <literal>Session</literal> API는 당신의 아카텍처 내에서 임의의 트랜잭션 관할 시스템에 독립적이다. 만일 
                                당신이 Hibernate로 하여금 커넥션 풀을 통해 직접 JDBC를 사용하도록 강제할 경우, 당신은 JDBC API를 호출하여 당신의 트랜잭션을 
                                시작하고 끝낼 수 있다. 만일 당신이 J2EE 어플리케이션 서버를 실행 중이라면, 당신은 필요할 때 bean-managed 트랜잭션들을 사용하고 
                JTA API와 <literal>UserTransaction</literal>을 호출하고자 원할 수 있다.
            </para>

            <para>
                                이들 두 개의 (그리고 다른) 환경들에서 당신의 코드에 이식성을 유지하기 위해 우리는 기본 시스템을 포장하고 은폐시키는 선택적인 
                Hibernate <literal>Transaction</literal> API를 권장한다. 당신은 Hibernate 구성 프로퍼티 <literal>hibernate.transaction.factory_class</literal>를 
                                사용하여 <literal>Transaction</literal> 인스턴스들에 대한 팩토리 클래스를 지정해야 한다.
            </para>

            <para>
                                세 개의 표준(미리 만들어진) 선택들이 존재한다:
            </para>

            <variablelist spacing="compact">
                <varlistentry>
                    <term><literal>org.hibernate.transaction.JDBCTransactionFactory</literal></term>
                    <listitem>
                        <para>데이터베이스 (JDBC) 트랜잭션들에게 위임시킨다(디폴트)</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>org.hibernate.transaction.JTATransactionFactory</literal></term>
                    <listitem>
                        <para>
                                                        기존의 트랜잭션이 이 컨텍스트(예를 들면 EJB session bean 메소드) 내에서 진행 중일 경우에 
                            container-managed transaction에게 위임시키고, 그 밖의 경우 새로운 트랜잭션이 시작되고 
                            bean-managed transaction이 사용된다.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>org.hibernate.transaction.CMTTransactionFactory</literal></term>
                    <listitem>
                        <para>container-managed JTA 트랜잭션들에게 위임시킨다</para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                                당신은 또한 당신 자신의 트랜잭션 방도들(예를 들면 CORBA 트랜잭션 서비스)을 정의할 수도 있다.
            </para>

            <para>
                Hibernate에 있는 몇몇 특징들(예를 들면. second level 캐시, JTA를 가진 컨텍스트 상의 세션들, 기타.)은 관리되는 환경에서 
                JTA <literal>TransactionManager</literal>에 대한 접근을 필요로 한다. 어플리케이션 서버에서 당신은 Hibernate가 
                <literal>TransactionManager</literal>에 대한 참조를 획득하는 방법을 지정해야 한다. 왜냐하면 J2EE가 한 개의 메커니즘을 
                                표준화 시키고 있지 않기 때문이다:
            </para>

            <table frame="topbot" id="jtamanagerlookup" revision="1">
                <title>JTA TransactionManagers</title>
                <tgroup cols="2">
                    <colspec colwidth="2.5*"/>
                    <colspec colwidth="1*"/>
                    <thead>
                        <row>
                            <entry>트랜잭션 팩토리</entry>
                            <entry align="center">어플리케이션 서버</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>org.hibernate.transaction.JBossTransactionManagerLookup</literal></entry>
                            <entry align="center">JBoss</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.WeblogicTransactionManagerLookup</literal></entry>
                            <entry align="center">Weblogic</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.WebSphereTransactionManagerLookup</literal></entry>
                            <entry align="center">WebSphere</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</literal></entry>
                            <entry align="center">WebSphere 6</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.OrionTransactionManagerLookup</literal></entry>
                            <entry align="center">Orion</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.ResinTransactionManagerLookup</literal></entry>
                            <entry align="center">Resin</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.JOTMTransactionManagerLookup</literal></entry>
                            <entry align="center">JOTM</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.JOnASTransactionManagerLookup</literal></entry>
                            <entry align="center">JOnAS</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.JRun4TransactionManagerLookup</literal></entry>
                            <entry align="center">JRun4</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.BESTransactionManagerLookup</literal></entry>
                            <entry align="center">Borland ES</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

        </sect2>

        <sect2 id="configuration-optional-jndi" revision="3">
            <title>JNDI-bound <literal>SessionFactory</literal></title>

            <para>
                                하나의 JNDI 바인드된 Hibernate <literal>SessionFactory</literal>는 그 팩토리에 대한 룩업과 새로운 
                <literal>Session</literal>들의 생성을 단순화 시킬 수 있다. 이것은 JNDI 바인드된 <literal>Datasource</literal>에 
                                관련되어 있지 않고, 단순하게 둘 다 동일한 레지스트리를 사용한다는 점을 노트하라!
            </para>

            <para>
                                만일 당신이 <literal>SessionFactory</literal>를 하나의 JNDI namespace에 바인드 시키고자 원할 경우, 
                <literal>hibernate.session_factory_name</literal> 프로퍼티를 사용하여 한 개의 이름(예를 들면. 
                <literal>java:hibernate/SessionFactory</literal>)을 지정하라. 만일 이 프로퍼티가 생략될 경우, 
                <literal>SessionFactory</literal>는 JNDI에 바인드 되지 않을 것이다. (이것은 읽기-전용 JNDI 디폴트 
                                구현을 가진 환경들, 예를 들면 Tomcat에서 특히 유용하다.)
            </para>

            <para>
                <literal>SessionFactory</literal>를 JNDI에 바인드 시킬 때, Hibernate는 초기 컨텍스트를 초기화 시키기 위해 
                <literal>hibernate.jndi.url</literal>, <literal>hibernate.jndi.class</literal>의 값들을 사용할 것이다. 
                                만일 그것들이 지정되어 있지 않을 경우, 디폴트 <literal>InitialContext</literal>가 사용될 것이다.
            </para>

            <para>
                Hibernate는 당신이 <literal>cfg.buildSessionFactory()</literal>를 호출한 후에 <literal>SessionFactory</literal>를 JNDI 내에 
                                자동적으로 위치지울 것이다. 이것은 당신이 (나중에 논의되는) <literal>HibernateService</literal>를 가진 JMX 배치를 
                                사용하지 않는 한, 당신이 적어도 당신의 어플리케이션 내에 있는 어떤 시작 코드 (또는 유틸리티 클래스) 내에서 이것을 호출할 것임을 
                                의미한다.
            </para>

            <para>
                                만일 당신이 하나의 JNDI <literal>SessionFactory</literal>를 사용할 경우, 하나의 EJB 또는 어떤 다른 클래스는 JNDI 
                                룩업을 사용하여 <literal>SessionFactory</literal>를 얻을 수 있다.
            </para>

            <para>
                                 우리는 관리되는 환경들에서 <literal>SessionFactory</literal>를 JNDI에 바인드 시키고 그 밖의 경우에는 
                                 하나의 <literal>static</literal> 싱글톤을 사용하는 것을 권장한다. 이들 상세로부터 당신의 어플리케이션 코드를 
                                 은폐시키기 위해, 우리는 또한 <literal>HibernateUtil.getSessionFactory()</literal>과 같은 하나의 
                 helper 클래스 내에서 <literal>SessionFactory</literal>에 대한 실제 룩업 코드를 은폐시키기를 권장한다.
                                 그런 클래스는 또한 Hibernate를 시작하는 편리한 방법임을 노트하라&mdash; 1장을 보라.
            </para>
            
        </sect2>

        <sect2 id="configuration-j2ee-currentsession" revision="4">
            <title>Current Session context management with JTA</title>

            <para>
	           	당신 자신의 <literal>ThreadLocal</literal> 유틸리티를 작동시키는 대신에, 우리는 또한 Hibernate <literal>Session</literal>를 
	           	얻기 위해 <literal>SessionFactory</literal> 상의 <literal>getCurrentSession()</literal> 메소드 사용을 
	           	권장한다. <xref linkend="architecture-current-session">현재 세션들</xref>에 관한 논의를 보라. <literal>"jta"</literal>
	           	세션 컨텍스트를 사용하고 있는 경우에, 현재의 JTA 트랜잭션으로 시작되고 연관된 Hibernate <literal>Session</literal>이 
	           	존재하지 않을 경우, 우리는 JTA 트랜잭션으로 시작되고 연관될 것이다. <literal>"jta"</literal> 컨텍스트에서 
	           	<literal>getCurrentSession()</literal>를 통해 검색된 <literal>Session</literal>들은 그 트랜잭션이 완료되기 전에
	           	자동적으로 flush될 것이고 트랜잭션 완료 후에 닫혀질 것이고, 그리고 각각의 문장 뒤에 JDBC 커넥션들을 적극적으로 해제할 것이다.
	           	이것은 그런 관리 사항들에 대해 사용자 코드를 명료하게 유지시켜서, 연관되어 있는 JTA 트랜잭션의 생명주기에 의해 <literal>Session</literal>들이 
	           	관리되도록 허용해준다. 이것은 그런 관리 사항들에 대해 사용자 코드를 명료하게 유지시켜서, 세션이 연관되어 있는 JTA 트랜잭션의 
	           	생명주기에 의해 관리되는 것을 <literal>Session</literal>들에게 허용해준다. 당신의 코드는 
	           	
	           	<literal>Session</literal>들과 트랜잭션들을 처리하는 가장 손쉬운 방법은 Hibernate의 자동적인 "현재"
	           	<literal>Session</literal>이다. 
	           	<xref linkend="architecture-current-session">current sessions</xref>에 관한 논의를 보라.
	           	<literal>"jta"</literal> 세션 컨텍스트를 사용하는 경우, 현재의 JTA 트랜잭션으로 시작되고 연관된 
	           	Hibernate <literal>Session</literal>들이 존재하지 않을 경우, 당신이 
	           	<literal>sessionFactory.getCurrentSession()</literal>을 처음 호출할 때 하나의 세션이 현재의 JTA 트랜잭션에 대해 
	           	시작되고 연관될 것이다. <literal>"jta"</literal> 컨텍스트에서 <literal>getCurrentSession()</literal>을 
	           	통해 검색된 <literal>Session</literal>들은 그 트랜잭션이 완료되기 전에 자동적으로 flush될 것이고
	           	그 트랜잭션 완료들 후에 닫혀질 것이고 각각의 문장 후에 JDBC 커넥션들을 적극적으로 해제할 것이다.
	           	이것은 그런 관리 사항들에 대해 사용자 코드를 명료하게 유지시켜서, 연관되어 있는 JTA 트랜잭션의 생명주기에 의해 <literal>Session</literal>들이 
	           	관리되도록 허용해준다. 이것은 그런 관리 사항들에 대해 사용자 코드를 명료하게 유지시켜서, 세션이 연관되어 있는 JTA 트랜잭션의 
	           	생명주기에 의해 관리되는 것을 <literal>Session</literal>들에게 허용해준다. 당신의 코드는 트랜잭션 경계들을 설정하는데 
	           	<literal>UserTransaction</literal>을 통해 프로그램 상으로 JTA를 사용하거나, Hibernate <literal>Transaction</literal> API를 (이식성을 위한 코드로 권장됨)
	           	사용할 수 있다. 만일 당신이 하나의 EJB 컨테이너에서 실행하고 있을 경우, CMT의 경우에 선언적인 트랜잭션 경계설정이 선호된다.
            </para>

        </sect2>

        <sect2 id="configuration-j2ee-jmx" revision="1">
            <title>JMX 배치</title>

            <para>
                <literal>cfg.buildSessionFactory()</literal> 줄은 여전히 JNDI에 붙은 하나의 <literal>SessionFactory</literal>를 얻기 위해 
                                어딘가에서 실행되어야 한다. 당신은 (<literal>HibernateUtil</literal> 내에 있는 것처럼) <literal>static</literal> initializer 
                                블록 속에서 이것을 행할 수 있거나 당신은 Hibernate를 <emphasis>managed service</emphasis>로서 배치할 수 있다.
            </para>

            <para>
                Hibernate는 JBoss AS와 같은 JMX 가용성들을 가진 어플리케이션 서버 상의 배치를 위해 <literal>org.hibernate.jmx.HibernateService</literal>를 
                                배포하고 있다. 실제 배치와 구성은 벤더 지정적이다. 다음은 JBoss 4.0.x를 위한 <literal>jboss-service.xml</literal> 예제이다:
            </para>

            <programlisting><![CDATA[<?xml version="1.0"?>
<server>

<mbean code="org.hibernate.jmx.HibernateService"
    name="jboss.jca:service=HibernateFactory,name=HibernateFactory">

    <!-- Required services -->
    <depends>jboss.jca:service=RARDeployer</depends>
    <depends>jboss.jca:service=LocalTxCM,name=HsqlDS</depends>

    <!-- Bind the Hibernate service to JNDI -->
    <attribute name="JndiName">java:/hibernate/SessionFactory</attribute>

    <!-- Datasource settings -->
    <attribute name="Datasource">java:HsqlDS</attribute>
    <attribute name="Dialect">org.hibernate.dialect.HSQLDialect</attribute>

    <!-- Transaction integration -->
    <attribute name="TransactionStrategy">
        org.hibernate.transaction.JTATransactionFactory</attribute>
    <attribute name="TransactionManagerLookupStrategy">
        org.hibernate.transaction.JBossTransactionManagerLookup</attribute>
    <attribute name="FlushBeforeCompletionEnabled">true</attribute>
    <attribute name="AutoCloseSessionEnabled">true</attribute>

    <!-- Fetching options -->
    <attribute name="MaximumFetchDepth">5</attribute>

    <!-- Second-level caching -->
    <attribute name="SecondLevelCacheEnabled">true</attribute>
    <attribute name="CacheProviderClass">org.hibernate.cache.EhCacheProvider</attribute>
    <attribute name="QueryCacheEnabled">true</attribute>

    <!-- Logging -->
    <attribute name="ShowSqlEnabled">true</attribute>

    <!-- Mapping files -->
    <attribute name="MapResources">auction/Item.hbm.xml,auction/Category.hbm.xml</attribute>

</mbean>

</server>]]></programlisting>

            <para>
                                이 파일은 <literal>META-INF</literal>로 명명된 디렉토리 속에 배치되고 확장자 <literal>.sar</literal>
                (service archive)를 가진 한 개의 JAR 파일 속에 패키징된다. 당신은 또한 Hibernate, 그것의 필요한 제 3의 라이브러리들, 당신의 컴파일된 
                                영속 클래스들 뿐만 아니라 당신의 매핑 파일들을 동일한 아카이브 속에 패키징할 필요가 있다. 당신의 엔터프라이즈 빈즈(대개 session beans)는 
                                그것들 자신의 JAR 파일 속에 유지될 수 있지만, 당신은 한 개의 (hot-)배치 가능한 단위를 얻기 위해 메인 서비스 아카이브 속에 이 EJB JAR 파일을 
                                포함시킬 수도 있다. JMX 서비스와 EJB 배치에 관한 추가 정보는 JBoss AS 문서를 참조하라.
            </para>

        </sect2>

    </sect1>

</chapter>

