<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="session-configuration" revision="1">

    <title>
        配置
    </title>
    
    <para>
        由于Hibernate是为了能在各种不同环境下工作而设计的, 因此存在着大量的配置参数. 幸运的是多数配置参数都
        有比较直观的默认值, 并有随Hibernate一同分发的配置样例<literal>hibernate.properties</literal>
        (位于<literal>etc/</literal>)来展示各种配置选项. 所需做的仅仅是将这个样例文件复制到类路径
        (classpath)下并做一些自定义的修改.
    </para>

    <sect1 id="configuration-programmatic" revision="1">
        <title>
            可编程的配置方式
        </title>

        <para>
            一个<literal>org.hibernate.cfg.Configuration</literal>实例代表了一个应用程序中Java类型
            到SQL数据库映射的完整集合. <literal>Configuration</literal>被用来构建一个(不可变的
            (immutable))<literal>SessionFactory</literal>. 映射定义则由不同的XML映射定义文件编译而来.
        </para>

        <para>
            你可以直接实例化<literal>Configuration</literal>来获取一个实例，并为它指定XML映射定义
            文件. 如果映射定
            义文件在类路径(classpath)中, 请使用<literal>addResource()</literal>:
        </para>

        <programlisting><![CDATA[Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");]]></programlisting>

        <para>
            一个替代方法（有时是更好的选择）是，指定被映射的类，让Hibernate帮你寻找映射定义文件:
        </para>

        <programlisting><![CDATA[Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);]]></programlisting>

        <para>
            Hibernate将会在类路径(classpath)中寻找名字为
            <literal>/org/hibernate/auction/Item.hbm.xml</literal>和
            <literal>/org/hibernate/auction/Bid.hbm.xml</literal>映射定义文件.
            这种方式消除了任何对文件名的硬编码(hardcoded).
        </para>
        
        <para>
            <literal>Configuration</literal>也允许你指定配置属性:
        </para>

        <programlisting><![CDATA[Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");]]></programlisting>
    
        <para>
            当然这不是唯一的传递Hibernate配置属性的方式, 其他可选方式还包括:
        </para>

        <orderedlist spacing="compact">
            <listitem>
                <para>
                    传一个<literal>java.util.Properties</literal>实例给
                    <literal>Configuration.setProperties()</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    将<literal>hibernate.properties</literal>放置在类路径(classpath)的根目录下
                    (root directory).
                </para>
            </listitem>
            <listitem>
                <para>
                    通过<literal>java -Dproperty=value</literal>来设置系统
                    (<literal>System</literal>)属性.
                </para>
            </listitem>
            <listitem>
                <para>
                    在<literal>hibernate.cfg.xml</literal>中加入元素
                    <literal>&lt;property&gt;</literal> (稍后讨论).
                </para>
            </listitem>
        </orderedlist>

        <para>
            如果想尽快体验Hibernate, <literal>hibernate.properties</literal>是最简单的方式.
        </para>

        <para>
            <literal>Configuration</literal>实例被设计成启动期间（startup-time）对象, 
            一旦<literal>SessionFactory</literal>创建完成它就被丢弃了.
        </para>

    </sect1>
    
    <sect1 id="configuration-sessionfactory">
        <title>
            获得SessionFactory
        </title>
		

        <para>
            当所有映射定义被<literal>Configuration</literal>解析后, 
            应用程序必须获得一个用于构造<literal>Session</literal>实例的工厂. 
            这个工厂将被应用程序的所有线程共享:
        </para>

        <programlisting><![CDATA[SessionFactory sessions = cfg.buildSessionFactory();]]></programlisting>

        <para>
            Hibernate允许你的应用程序创建多个<literal>SessionFactory</literal>实例. 这对
            使用多个数据库的应用来说很有用.
        </para>

    </sect1>

    <sect1 id="configuration-hibernatejdbc" revision="1">
        <title>
            JDBC连接
        </title>

        <para>
            通常你希望<literal>SessionFactory</literal>来为你创建和缓存(pool)JDBC连接. 如果你采用这种方式, 
            只需要如下例所示那样，打开一个<literal>Session</literal>:
        </para>

        <programlisting><![CDATA[Session session = sessions.openSession(); // open a new Session]]></programlisting>
        
        <para>
            一旦你需要进行数据访问时, 就会从连接池(connection pool)获得一个JDBC连接.
        </para>

        <para>
            为了使这种方式工作起来, 我们需要向Hibernate传递一些JDBC连接的属性.
            所有Hibernate属性的名字和语义都在<literal>org.hibernate.cfg.Environment</literal>中定义. 
            我们现在将描述JDBC连接配置中最重要的设置.
        </para>

        <para>
            如果你设置如下属性，Hibernate将使用<literal>java.sql.DriverManager</literal>来获得(和缓存)JDBC连接 :
        </para>

        <table frame="topbot">
            <title>
                Hibernate JDBC属性
            </title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>
                            属性名
                        </entry>
                        <entry>
                            用途
                        </entry>
                    </row>
                </thead>
            <tbody>
            <row>
                <entry>
                    <literal>hibernate.connection.driver_class</literal>
                </entry>
                <entry>
                    <emphasis>jdbc驱动类</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.url</literal>
                </entry>
                <entry>
                    <emphasis>jdbc URL</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.username</literal>
                </entry>
                <entry>
                    <emphasis>数据库用户</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.password</literal>
                </entry>
                <entry>
                    <emphasis>数据库用户密码</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.pool_size</literal>
                </entry>
                <entry>
                    <emphasis>连接池容量上限数目</emphasis>
                </entry>
            </row>
            </tbody>
            </tgroup>
        </table>

        <para>
            但Hibernate自带的连接池算法相当不成熟. 
            它只是为了让你快些上手<emphasis>，并不适合用于产品系统</emphasis>或性能测试中。
            出于最佳性能和稳定性考虑你应该使用第三方的连接池。只需要用特定连接池的设置替换
            <literal>hibernate.connection.pool_size</literal>即可。这将关闭Hibernate自带的连接池.
            例如, 你可能会想用C3P0.
        </para>

        <para>
            C3P0是一个随Hibernate一同分发的开源的JDBC连接池, 它位于<literal>lib</literal>目录下。
            如果你设置了<literal>hibernate.c3p0.*</literal>相关的属性, Hibernate将使用
            <literal>C3P0ConnectionProvider</literal>来缓存JDBC连接. 如果你更原意使用Proxool, 请参考发
            行包中的<literal>hibernate.properties</literal>并到Hibernate网站获取更多的信息.
        </para>

        <para>
            这是一个使用C3P0的<literal>hibernate.properties</literal>样例文件:
        </para>

        <programlisting id="c3p0-configuration" revision="1"><![CDATA[hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]></programlisting>

        <para>
            为了能在应用程序服务器(application server)中使用Hibernate, 应当总是将Hibernate
            配置成从注册在JNDI中的<literal>Datasource</literal>处获得连接，你至少需要设置下列属性中的一个:
        </para>

        <table frame="topbot">
            <title>
                Hibernate数据源属性
            </title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>
                            属性名
                        </entry>
                        <entry>
                            用途
                        </entry>
                    </row>
                </thead>
            <tbody>
            <row>
                <entry>
                    <literal>hibernate.connection.datasource</literal>
                </entry>
                <entry>
                    <emphasis>数据源JNDI名字</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.jndi.url</literal>
                </entry>
                <entry>
                    <emphasis>JNDI提供者的URL</emphasis> (可选)
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.jndi.class</literal>
                </entry>
                <entry>
                    <emphasis>JNDI <literal>InitialContextFactory</literal>类</emphasis> (可选)
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.username</literal>
                </entry>
                <entry>
                    <emphasis>数据库用户</emphasis> (可选)
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.password</literal>
                </entry>
                <entry>
                    <emphasis>数据库用户密码</emphasis> (可选)
                </entry>
            </row>
            </tbody>
            </tgroup>
        </table>

        <para>
            这是一个使用应用程序服务器提供的JNDI数据源的<literal>hibernate.properties</literal>样例文件:
        </para>

        <programlisting><![CDATA[hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]></programlisting>

        <para>
            从JNDI数据源获得的JDBC连接将自动参与到应用程序服务器中容器管理的事务(container-managed transactions)中去.
        </para>

        <para>
            任何连接(connection)属性的属性名都要以"<literal>hibernate.connnection</literal>"开头. 
            例如, 你可能会使用<literal>hibernate.connection.charSet</literal>来指定字符集<literal>charSet</literal>.
        </para>

        <para>
            通过实现<literal>org.hibernate.connection.ConnectionProvider</literal>接口，你可以定义属于
            你自己的获得JDBC连接的插件策略。通过设置<literal>hibernate.connection.provider_class</literal>，
            你可以选择一个自定义的实现.
        </para>

    </sect1>

    <sect1 id="configuration-optional" revision="1">
        <title>
            可选的配置属性
        </title>
        
        <para>
            有大量属性能用来控制Hibernate在运行期的行为. 它们都是可选的, 并拥有适当的默认值.
        </para>

        <para>
            <emphasis>警告: 其中一些属性是"系统级(system-level)的".</emphasis>
            系统级属性只能通过<literal>java -Dproperty=value</literal>或
            <literal>hibernate.properties</literal>来设置, 而<emphasis>不能</emphasis>用上面描述的其他方法来设置.
        </para>

        <table frame="topbot" id="configuration-optional-properties" revision="8">
            <title>
                Hibernate配置属性
            </title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>
                            属性名
                        </entry>
                        <entry>
                            用途
                        </entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.dialect</literal>
                        </entry>
                        <entry>
                            一个Hibernate <literal>Dialect</literal>类名允许Hibernate针对特定的关系数据库生成优化的SQL.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>full.classname.of.Dialect</literal>
               
             </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.show_sql</literal>
                        </entry>
                        <entry>
                            输出所有SQL语句到控制台.
							有一个另外的选择是把<literal>org.hibernate.SQL</literal>这个log category设为<literal>debug</literal>。
                            <para>
                                <emphasis role="strong">eg.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.format_sql</literal>
                        </entry>
                        <entry>
                            在log和console中打印出更漂亮的SQL。
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_schema</literal>
                        </entry>
                        <entry>
                            在生成的SQL中, 将给定的schema/tablespace附加于非全限定名的表名上.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>SCHEMA_NAME</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_catalog</literal>
                        </entry>
                        <entry>
                            在生成的SQL中, 将给定的catalog附加于非全限定名的表名上.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>CATALOG_NAME</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.session_factory_name</literal>
                        </entry>
                        <entry>
                            <literal>SessionFactory</literal>创建后，将自动使用这个名字绑定到JNDI中.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>jndi/composite/name</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.max_fetch_depth</literal>
                        </entry>
                        <entry>
                            为单向关联(一对一, 多对一)的外连接抓取（outer join fetch）树设置最大深度.
                            值为<literal>0</literal>意味着将关闭默认的外连接抓取.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                建议在<literal>0</literal>到<literal>3</literal>之间取值
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_batch_fetch_size</literal>
                        </entry>
                        <entry>
                            为Hibernate关联的批量抓取设置默认数量.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                建议的取值为<literal>4</literal>, <literal>8</literal>, 
                                和<literal>16</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_entity_mode</literal>
                        </entry>
                        <entry>
                            为由这个<literal>SessionFactory</literal>打开的所有Session指定默认的实体表现模式.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>dynamic-map</literal>, <literal>dom4j</literal>,
                                <literal>pojo</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.order_updates</literal>
                        </entry>
                        <entry>
                            强制Hibernate按照被更新数据的主键，为SQL更新排序。这么做将减少在高并发系统中事务的死锁。
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.generate_statistics</literal>
                        </entry>
                        <entry>
                            如果开启, Hibernate将收集有助于性能调节的统计数据.
                            <para>
                                <emphasis role="strong">取值</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.use_identifer_rollback</literal>
                        </entry>
                        <entry>
                            如果开启, 在对象被删除时生成的标识属性将被重设为默认值.
                            <para>
                                <emphasis role="strong">取值</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.use_sql_comments</literal>
                        </entry>
                        <entry>
                            如果开启, Hibernate将在SQL中生成有助于调试的注释信息, 默认值为<literal>false</literal>.
                            <para>
                                <emphasis role="strong">取值</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-jdbc-properties" revision="8">
            <title>
                Hibernate JDBC和连接(connection)属性
            </title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>
                            属性名
                        </entry>
                        <entry>
                            用途
                        </entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.fetch_size</literal>
                        </entry>
                        <entry>
                            非零值，指定JDBC抓取数量的大小 (调用<literal>Statement.setFetchSize()</literal>).
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.batch_size</literal>
                        </entry>
                        <entry>
                            非零值，允许Hibernate使用JDBC2的批量更新.
                            <para>
                                <emphasis role="strong">取值</emphasis>
                                建议取<literal>5</literal>到<literal>30</literal>之间的值
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.batch_versioned_data</literal>
                        </entry>
                        <entry>
                            如果你想让你的JDBC驱动从<literal>executeBatch()</literal>返回正确的行计数 , 
                            那么将此属性设为<literal>true</literal>(开启这个选项通常是安全的). 
                            同时，Hibernate将为自动版本化的数据使用批量DML. 默认值为<literal>false</literal>.
                            <para>
                                <emphasis role="strong">eg.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.factory_class</literal>
                        </entry>
                        <entry>
                            选择一个自定义的<literal>Batcher</literal>. 多数应用程序不需要这个配置属性.
                            <para>
                                <emphasis role="strong">eg.</emphasis>
                                <literal>classname.of.BatcherFactory</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.use_scrollable_resultset</literal>
                        </entry>
                        <entry>
                            允许Hibernate使用JDBC2的可滚动结果集.
                            只有在使用用户提供的JDBC连接时，这个选项才是必要的, 
                            否则Hibernate会使用连接的元数据.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.use_streams_for_binary</literal>
                        </entry>
                        <entry>
                            在JDBC读写<literal>binary (二进制)</literal>或<literal>serializable (可序列化)</literal>
                            的类型时使用流(stream)(系统级属性).
                            <para>
                                <emphasis role="strong">取值</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.use_get_generated_keys</literal>
                        </entry>
                        <entry>
                            在数据插入数据库之后，允许使用JDBC3 <literal>PreparedStatement.getGeneratedKeys()</literal>
                            来获取数据库生成的key(键)。需要JDBC3+驱动和JRE1.4+, 如果你的数据库驱动在使用Hibernate的标
                            识生成器时遇到问题，请将此值设为false. 默认情况下将使用连接的元数据来判定驱动的能力.
                            <para>
                                <emphasis role="strong">取值</emphasis>
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.connection.provider_class</literal>
                        </entry>
                        <entry>
                            自定义<literal>ConnectionProvider</literal>的类名, 此类用来向Hibernate提供JDBC连接.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>classname.of.ConnectionProvider</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                    <entry>
                        <literal>hibernate.connection.isolation</literal>
                    </entry>
                    <entry>
                        设置JDBC事务隔离级别. 查看<literal>java.sql.Connection</literal>来了解各个值的具体意义, 
                        但请注意多数数据库都不支持所有的隔离级别.
                        <para>
                            <emphasis role="strong">取值</emphasis> 
                            <literal>1, 2, 4, 8</literal>
                        </para>
                    </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.connection.autocommit</literal>
                        </entry>
                        <entry>
                            允许被缓存的JDBC连接开启自动提交(autocommit) (不建议).
                            <para>
                                <emphasis role="strong">取值</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.connection.release_mode</literal>
                        </entry>
                        <entry>
                            指定Hibernate在何时释放JDBC连接. 默认情况下,直到Session被显式关闭或被断开连接时,才会释放JDBC连接. 
                            对于应用程序服务器的JTA数据源, 你应当使用<literal>after_statement</literal>, 这样在每次JDBC调用后，都会主动的释放连接. 
                            对于非JTA的连接, 使用<literal>after_transaction</literal>在每个事务结束时释放连接是合理的. 
                            <literal>auto</literal>将为JTA和CMT事务策略选择<literal>after_statement</literal>, 
                            为JDBC事务策略选择<literal>after_transaction</literal>.
                            <para>
                                <emphasis role="strong">取值</emphasis>
                                <literal>auto</literal> (默认) | <literal>on_close</literal> |
                                <literal>after_transaction</literal> | <literal>after_statement</literal>
                            </para>
                            <para>

                                注意,这些设置仅对通过<literal>SessionFactory.openSession</literal>得到的<literal>Session</literal>起作用。对于通过<literal>SessionFactory.getCurrentSession</literal>得到的<literal>Session</literal>，所配置的<literal>CurrentSessionContext</literal>实现控制这些<literal>Session</literal>的连接释放模式。请参阅<xref linkend="architecture-current-session"/>。
                            </para>


  	                    </entry>
  	                </row>
  	                <row>
  	                    <entry>
                            <literal>hibernate.connection.<emphasis>&lt;propertyName&gt;</emphasis></literal>
                        </entry>
                        <entry>
                            将JDBC属性<literal>propertyName</literal>传递到<literal>DriverManager.getConnection()</literal>中去.
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jndi.<emphasis>&lt;propertyName&gt;</emphasis></literal>
                        </entry>
                        <entry>
                            将属性<literal>propertyName</literal>传递到JNDI <literal>InitialContextFactory</literal>中去.
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-cache-properties" revision="7">
            <title>
                Hibernate缓存属性
            </title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>
                            属性名
                        </entry>
                        <entry>
                            用途
                        </entry>
                    </row>
                </thead>
                <tbody>
                     <row>
                        <entry>
                            <literal>hibernate.cache.provider_class</literal>
                        </entry>
                        <entry>
                            自定义的<literal>CacheProvider</literal>的类名.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>classname.of.CacheProvider</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_minimal_puts</literal>
                        </entry>
                        <entry>
                            以频繁的读操作为代价, 优化二级缓存来最小化写操作. 在Hibernate3中，这个设置对的集群缓存非常有用, 
                            对集群缓存的实现而言，默认是开启的.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_query_cache</literal>
                        </entry>
                        <entry>
                            允许查询缓存, 个别查询仍然需要被设置为可缓存的.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_second_level_cache</literal>
                        </entry>
                        <entry>
                            能用来完全禁止使用二级缓存. 对那些在类的映射定义中指定<literal>&lt;cache&gt;</literal>的类，会默认开启二级缓存.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.query_cache_factory</literal>
                        </entry>
                        <entry>
                            自定义实现<literal>QueryCache</literal>接口的类名,
                            默认为内建的<literal>StandardQueryCache</literal>.
                            <para>
                                <emphasis role="strong">取值</emphasis>
                                <literal>classname.of.QueryCache</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.region_prefix</literal>
                        </entry>
                        <entry>
                            二级缓存区域名的前缀.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>prefix</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_structured_entries</literal>
                        </entry>
                        <entry>
                            强制Hibernate以更人性化的格式将数据存入二级缓存.
                            <para>
                                <emphasis role="strong">取值</emphasis>
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-transaction-properties" revision="9">
            <title>
                Hibernate事务属性
            </title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>
                            属性名
                        </entry>
                        <entry>
                            用途
                        </entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.factory_class</literal>
                        </entry>
                        <entry>
                            一个<literal>TransactionFactory</literal>的类名, 用于Hibernate <literal>Transaction</literal> API
                            (默认为<literal>JDBCTransactionFactory</literal>).
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>classname.of.TransactionFactory</literal>
                            </para>                            
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>jta.UserTransaction</literal>
                        </entry>
                        <entry>
                            一个JNDI名字，被<literal>JTATransactionFactory</literal>用来从应用服务器获取JTA <literal>UserTransaction</literal>.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>jndi/composite/name</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.manager_lookup_class</literal>
                        </entry>
                        <entry>
                            一个<literal>TransactionManagerLookup</literal>的类名
                            - 当使用JVM级缓存，或在JTA环境中使用hilo生成器的时候需要该类.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>classname.of.TransactionManagerLookup</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.flush_before_completion</literal>
                        </entry>
                        <entry>
                            如果开启, session在事务完成后将被自动清洗(flush)。 现在更好的方法是使用自动session上下文管理。请参见<xref linkend="architecture-current-session"/>。
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.auto_close_session</literal>
                        </entry>
                        <entry>
                            如果开启, session在事务完成后将被自动关闭。 现在更好的方法是使用自动session上下文管理。请参见<xref linkend="architecture-current-session"/>。
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-misc-properties" revision="10">
            <title>
                其他属性
            </title>

            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>
                            属性名
                            </entry>
                        <entry>
                            用途
                        </entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.current_session_context_class</literal>
                        </entry>
                        <entry>
                            为"当前"
                            <literal>Session</literal>指定一个(自定义的)策略。关于内置策略的详情，请参见<xref linkend="architecture-current-session"/> 。
                            <para>
                                <emphasis role="strong">eg.</emphasis>
                                <literal>jta</literal> | <literal>thread</literal> |
                                <literal>managed</literal> | <literal>custom.Class</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.query.factory_class</literal>
                        </entry>
                        <entry>
                            选择HQL解析器的实现.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>org.hibernate.hql.ast.ASTQueryTranslatorFactory</literal> or
                                <literal>org.hibernate.hql.classic.ClassicQueryTranslatorFactory</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.query.substitutions</literal>
                        </entry>
                        <entry>
                            将Hibernate查询中的符号映射到SQL查询中的符号
                            (符号可能是函数名或常量名字).
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.hbm2ddl.auto</literal>
                        </entry>
                        <entry>
                            在<literal>SessionFactory</literal>创建时，自动检查数据库结构，或者将数据库schema的DDL导出到数据库. 使用
                            <literal>create-drop</literal>时,在显式关闭<literal>SessionFactory</literal>时，将drop掉数据库schema.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>validate</literal> | <literal>update</literal> | 
                                <literal>create</literal> | <literal>create-drop</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cglib.use_reflection_optimizer</literal>
                        </entry>
                        <entry>
                            开启CGLIB来替代运行时反射机制(系统级属性). 反射机制有时在除错时比较有用. 
                            注意即使关闭这个优化, Hibernate还是需要CGLIB. 你不能在<literal>hibernate.cfg.xml</literal>中设置此属性.
                            <para>
                                <emphasis role="strong">取值</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <sect2 id="configuration-optional-dialects" revision="1">
            <title>
                SQL方言
            </title>

            <para>
                你应当总是为你的数据库将<literal>hibernate.dialect</literal>属性设置成正确的
                <literal>org.hibernate.dialect.Dialect</literal>子类. 如果你指定一种方言, 
                Hibernate将为上面列出的一些属性使用合理的默认值, 为你省去了手工指定它们的功夫.
            </para>

            <table frame="topbot" id="sql-dialects" revision="2">
                <title>
                    Hibernate SQL方言 (<literal>hibernate.dialect</literal>)
                </title>
                <tgroup cols="2">
                    <colspec colwidth="1*"/>
                    <colspec colwidth="2.5*"/>
                    <thead>
                        <row>
                            <entry>RDBMS</entry>
                            <entry>
                                方言
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>DB2</entry> <entry><literal>org.hibernate.dialect.DB2Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>DB2 AS/400</entry> <entry><literal>org.hibernate.dialect.DB2400Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>DB2 OS390</entry> <entry><literal>org.hibernate.dialect.DB2390Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>PostgreSQL</entry> <entry><literal>org.hibernate.dialect.PostgreSQLDialect</literal></entry>
                        </row>
                        <row>
                            <entry>MySQL</entry> <entry><literal>org.hibernate.dialect.MySQLDialect</literal></entry>
                        </row>
                        <row>
                            <entry>MySQL with InnoDB</entry> <entry><literal>org.hibernate.dialect.MySQLInnoDBDialect</literal></entry>
                        </row>
                        <row>
                            <entry>MySQL with MyISAM</entry> <entry><literal>org.hibernate.dialect.MySQLMyISAMDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Oracle (any version)</entry> <entry><literal>org.hibernate.dialect.OracleDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Oracle 9i/10g</entry> <entry><literal>org.hibernate.dialect.Oracle9Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>Sybase</entry> <entry><literal>org.hibernate.dialect.SybaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Sybase Anywhere</entry> <entry><literal>org.hibernate.dialect.SybaseAnywhereDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Microsoft SQL Server</entry> <entry><literal>org.hibernate.dialect.SQLServerDialect</literal></entry>
                        </row>
                        <row>
                            <entry>SAP DB</entry> <entry><literal>org.hibernate.dialect.SAPDBDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Informix</entry> <entry><literal>org.hibernate.dialect.InformixDialect</literal></entry>
                        </row>
                        <row>
                            <entry>HypersonicSQL</entry> <entry><literal>org.hibernate.dialect.HSQLDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Ingres</entry> <entry><literal>org.hibernate.dialect.IngresDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Progress</entry> <entry><literal>org.hibernate.dialect.ProgressDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Mckoi SQL</entry> <entry><literal>org.hibernate.dialect.MckoiDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Interbase</entry> <entry><literal>org.hibernate.dialect.InterbaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Pointbase</entry> <entry><literal>org.hibernate.dialect.PointbaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>FrontBase</entry> <entry><literal>org.hibernate.dialect.FrontbaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Firebird</entry> <entry><literal>org.hibernate.dialect.FirebirdDialect</literal></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

        </sect2>

        <sect2 id="configuration-optional-outerjoin" revision="4">
            <title>
                外连接抓取(Outer Join Fetching)
            </title>

            <para>
                如果你的数据库支持ANSI, Oracle或Sybase风格的外连接, <emphasis>外连接抓取</emphasis>通常能通过限制往返数据库次数
                (更多的工作交由数据库自己来完成)来提高效率. 外连接抓取允许在单个<literal>SELECT</literal>SQL语句中，
                通过many-to-one, one-to-many, many-to-many和one-to-one关联获取连接对象的整个对象图.
            </para>

            <para>
                将<literal>hibernate.max_fetch_depth</literal>设为<literal>0</literal>能在<emphasis>全局</emphasis>
                范围内禁止外连接抓取. 设为<literal>1</literal>或更高值能启用one-to-one和many-to-oneouter关联的外连接抓取, 它们通过
                <literal>fetch="join"</literal>来映射.
            </para>

            <para>
                参见<xref linkend="performance-fetching"/>获得更多信息.
            </para>

        </sect2>

        <sect2 id="configuration-optional-binarystreams" revision="1">
            <title>
                二进制流 (Binary Streams)
            </title>

            <para>
                Oracle限制那些通过JDBC驱动传输的<literal>字节</literal>数组的数目. 如果你希望使用<literal>二进值 (binary)</literal>或
                <literal>可序列化的 (serializable)</literal>类型的大对象, 你应该开启
                <literal>hibernate.jdbc.use_streams_for_binary</literal>属性.
                <emphasis>这是系统级属性.</emphasis>
            </para>

        </sect2>

        <sect2 id="configuration-optional-cacheprovider" revision="2">
            <title>
                二级缓存与查询缓存
            </title>

            <para>
                以<literal>hibernate.cache</literal>为前缀的属性允许你在Hibernate中，使用进程或群集范围内的二级缓存系统.
                参见<xref linkend="performance-cache"/>获取更多的详情.
            </para>

        </sect2>

        <sect2 id="configuration-optional-querysubstitution">
            <title>
                查询语言中的替换
            </title>

            <para>
                你可以使用<literal>hibernate.query.substitutions</literal>在Hibernate中定义新的查询符号.
                例如:         
            </para>

            <programlisting>hibernate.query.substitutions true=1, false=0</programlisting>

            <para>
                将导致符号<literal>true</literal>和<literal>false</literal>在生成的SQL中被翻译成整数常量.
            </para>

            <programlisting>hibernate.query.substitutions toLowercase=LOWER</programlisting>

            <para>
                将允许你重命名SQL中的<literal>LOWER</literal>函数.
            </para>

        </sect2>

        <sect2 id="configuration-optional-statistics" revision="2">
            <title>
                Hibernate的统计(statistics)机制
            </title>

            <para>
                如果你开启<literal>hibernate.generate_statistics</literal>, 那么当你通过
                <literal>SessionFactory.getStatistics()</literal>调整正在运行的系统时，Hibernate将导出大量有用的数据.
                Hibernate甚至能被配置成通过JMX导出这些统计信息. 参考<literal>org.hibernate.stats</literal>中接口的Javadoc，以获得更多信息.
            </para>

        </sect2>
    </sect1>

    <sect1 id="configuration-logging">
        <title>
            日志
        </title>

        <para>
            Hibernate使用Apache commons-logging来为各种事件记录日志.
        </para>

        <para>
            commons-logging将直接输出到Apache Log4j(如果在类路径中包括<literal>log4j.jar</literal>)或
            JDK1.4 logging (如果运行在JDK1.4或以上的环境下). 你可以从<literal>http://jakarta.apache.org</literal>
                下载Log4j. 要使用Log4j，你需要将<literal>log4j.properties</literal>文件放置在类路径下, 随Hibernate
                一同分发的样例属性文件在<literal>src/</literal>目录下.
        </para>
        
        <para>
            我们强烈建议你熟悉一下Hibernate的日志消息. 在不失可读性的前提下，
            我们做了很多工作，使Hibernate的日志可能地详细. 这是必要的查错利器.
             最令人感兴趣的日志分类有如下这些:
        </para>
        
            <table frame="topbot" id="log-categories" revision="2">
                <title>
                    Hibernate日志类别
                </title>
                <tgroup cols="2">
                    <colspec colwidth="1*"/>
                    <colspec colwidth="2.5*"/>
                    <thead>
                        <row>
                            <entry>
                                类别
                            </entry>
                            <entry>
                                功能
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>org.hibernate.SQL</literal></entry>
                            <entry>
                                在所有SQL DML语句被执行时为它们记录日志
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.type</literal></entry>
                            <entry>
                                为所有JDBC参数记录日志
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.tool.hbm2ddl</literal></entry>
                            <entry>
                                在所有SQL DDL语句执行时为它们记录日志
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.pretty</literal></entry>
                            <entry>
                                在session清洗(flush)时，为所有与其关联的实体(最多20个)的状态记录日志
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.cache</literal></entry>
                            <entry>
                                为所有二级缓存的活动记录日志
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction</literal></entry>
                            <entry>
                                为事务相关的活动记录日志
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.jdbc</literal></entry>
                            <entry>
                                为所有JDBC资源的获取记录日志
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.hql.AST</literal></entry>
                            <entry>
                                在解析查询的时候,记录HQL和SQL的AST分析日志
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.secure</literal></entry>
                            <entry>
                                为JAAS认证请求做日志
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate</literal></entry>
                            <entry>
                                为任何Hibernate相关信息做日志 (信息量较大, 但对查错非常有帮助)
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            
        <para>
            在使用Hibernate开发应用程序时, 你应当总是为<literal>org.hibernate.SQL</literal>
            开启<literal>debug</literal>级别的日志记录,或者开启<literal>hibernate.show_sql</literal>属性。
        </para>        
        
    </sect1>

    <sect1 id="configuration-namingstrategy">
        <title>
            实现<literal>NamingStrategy</literal>
        </title>

        <para>
            <literal>org.hibernate.cfg.NamingStrategy</literal>接口允许你为数据库中的对象和schema
            元素指定一个“命名标准”.
        </para>

        <para>
            你可能会提供一些通过Java标识生成数据库标识或将映射定义文件中"逻辑"表/列名处理成"物理"表/列名的规则.
            这个特性有助于减少冗长的映射定义文件.
        </para>

        <para>
            在加入映射定义前，你可以调用
            <literal>Configuration.setNamingStrategy()</literal>指定一个不同的命名策略:
        </para>

        <programlisting><![CDATA[SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();]]></programlisting>
    
        <para>
            <literal>org.hibernate.cfg.ImprovedNamingStrategy</literal>是一个内建的命名策略, 对
            一些应用程序而言，可能是非常有用的起点.
        </para>

    </sect1>

    <sect1 id="configuration-xmlconfig" revision="2">
        <title>
            XML配置文件
        </title>

        <para>
            另一个配置方法是在<literal>hibernate.cfg.xml</literal>文件中指定一套完整的配置. 
            这个文件可以当成<literal>hibernate.properties</literal>的替代。 若两个文件同时存在，它将覆盖前者的属性.
        </para>

        <para>
            XML配置文件被默认是放在<literal>CLASSPATH</literal>的根目录下. 这是一个例子:
        </para>
		<para>
            
        </para>

        <programlisting><![CDATA[<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>

    <!-- 以/jndi/name绑定到JNDI的SessionFactory实例 -->
    <session-factory
        name="java:hibernate/SessionFactory">

        <!-- 属性 -->
        <property name="connection.datasource">java:/comp/env/jdbc/MyDB</property>
        <property name="dialect">org.hibernate.dialect.MySQLDialect</property>
        <property name="show_sql">false</property>
        <property name="transaction.factory_class">
            org.hibernate.transaction.JTATransactionFactory
        </property>
        <property name="jta.UserTransaction">java:comp/UserTransaction</property>

        <!-- 映射定义文件 -->
        <mapping resource="org/hibernate/auction/Item.hbm.xml"/>
        <mapping resource="org/hibernate/auction/Bid.hbm.xml"/>

        <!-- 缓存设置 -->
        <class-cache class="org.hibernate.auction.Item" usage="read-write"/>
        <class-cache class="org.hibernate.auction.Bid" usage="read-only"/>
        <collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/>

    </session-factory>

</hibernate-configuration>]]></programlisting>

        <para>
            如你所见, 这个方法优势在于，在配置文件中指出了映射定义文件的名字. 一旦你需要调整Hibernate的缓存，
            <literal>hibernate.cfg.xml</literal>也是更方便. 注意，使用<literal>hibernate.properties</literal>还是
            <literal>hibernate.cfg.xml</literal>完全是由你来决定, 除了上面提到的XML语法的优势之外, 两者是等价的.
        </para>
		
        <para>
            使用XML配置，使得启动Hibernate变的异常简单, 如下所示，一行代码就可以搞定：
        </para>

        <programlisting><![CDATA[SessionFactory sf = new Configuration().configure().buildSessionFactory();]]></programlisting>

        <para>
            你可以使用如下代码来添加一个不同的XML配置文件
        </para>

        <programlisting><![CDATA[SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();]]></programlisting>

    </sect1>

    <sect1 id="configuration-j2ee" revision="1">
        <title>
            J2EE应用程序服务器的集成
        </title>

        <para>
            针对J2EE体系,Hibernate有如下几个集成的方面:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>容器管理的数据源(Container-managed datasources)</emphasis>: 
                Hibernate能使用通过容器管理，并由JNDI提供的JDBC连接. 通常, 特别是当处理多个数据源的分布式事务的时候, 
                由一个JTA兼容的<literal>TransactionManager</literal>和一个
                <literal>ResourceManager</literal>来处理事务管理(CMT, 容器管理的事务). 当然你可以通过
                编程方式来划分事务边界(BMT, Bean管理的事务). 或者为了代码的可移植性，你也也许会想使用可选的
                Hibernate <literal>Transaction</literal> API.
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>自动JNDI绑定</emphasis>: Hibernate可以在启动后将
                <literal>SessionFactory</literal>绑定到JNDI.
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>JTA Session绑定:</emphasis> Hibernate <literal>Session</literal>
                可以自动绑定到JTA事务作用的范围. 只需简单地从JNDI查找<literal>SessionFactory</literal>并获得当前的
                <literal>Session</literal>. 当JTA事务完成时, 让Hibernate来处理
                <literal>Session</literal>的清洗(flush)与关闭. 事务的划分可以是声明式的(CMT),也可以是编程式的(BMT/UserTransaction).
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>JMX部署:</emphasis> 如果你使用支持JMX应用程序服务器(如, JBoss AS), 那么你可以选择将Hibernate部署成托管MBean. 
                这将为你省去一行从<literal>Configuration</literal>构建<literal>SessionFactory</literal>的启动代码. 
                容器将启动你的<literal>HibernateService</literal>, 并完美地处理好服务间的依赖关系 (在Hibernate启动前，数据源必须是可用的，等等).
                </para>
            </listitem>
        </itemizedlist>
        <para>
            如果应用程序服务器抛出"connection containment"异常, 根据你的环境，也许该将配置属性
            <literal>hibernate.connection.release_mode</literal>设为<literal>after_statement</literal>.
        </para>
        <sect2 id="configuration-optional-transactionstrategy" revision="3">
            <title>
                事务策略配置
            </title>

            <para>
                在你的架构中，Hibernate的<literal>Session</literal> API是独立于任何事务分界系统的. 
                如果你让Hibernate通过连接池直接使用JDBC, 你需要调用JDBC API来打开和关闭你的事务. 
                如果你运行在J2EE应用程序服务器中, 你也许想用Bean管理的事务并在需要的时候调用JTA API和<literal>UserTransaction</literal>.
            </para>

            <para>
                为了让你的代码在两种(或其他)环境中可以移植，我们建议使用可选的Hibernate <literal>Transaction</literal> API, 
                它包装并隐藏了底层系统. 你必须通过设置Hibernate配置属性<literal>hibernate.transaction.factory_class</literal>来指定
                一个<literal>Transaction</literal>实例的工厂类.
            </para>

            <para>
                有三个标准(内建)的选择:
            </para>

            <variablelist spacing="compact">
                <varlistentry>
                    <term><literal>org.hibernate.transaction.JDBCTransactionFactory</literal></term>
                    <listitem>
                        <para>
                            委托给数据库(JDBC)事务（默认）
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>org.hibernate.transaction.JTATransactionFactory</literal></term>
                    <listitem>
                        <para>
                            如果在上下文环境中存在运行着的事务(如, EJB会话Bean的方法), 则委托给容器管
                            理的事务, 否则，将启动一个新的事务，并使用Bean管理的事务.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>org.hibernate.transaction.CMTTransactionFactory</literal></term>
                    <listitem>
                        <para>
                            委托给容器管理的JTA事务
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                你也可以定义属于你自己的事务策略 (如, 针对CORBA的事务服务)
            </para>

            <para>
                Hibernate的一些特性 (比如二级缓存, Contextual Sessions with JTA等等)需要访问在托管环境中的JTA <literal>TransactionManager</literal>. 
                由于J2EE没有标准化一个单一的机制,Hibernate在应用程序服务器中，你必须指定Hibernate如何获得<literal>TransactionManager</literal>的引用:
            </para>

            <table frame="topbot" id="jtamanagerlookup" revision="1">
                <title>JTA TransactionManagers</title>
                <tgroup cols="2">
                    <colspec colwidth="2.5*"/>
                    <colspec colwidth="1*"/>
                    <thead>
                        <row>
                            <entry>
                                Transaction工厂类
                            </entry>
                            <entry align="center">
                                应用程序服务器
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>org.hibernate.transaction.JBossTransactionManagerLookup</literal></entry>
                            <entry align="center">JBoss</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.WeblogicTransactionManagerLookup</literal></entry>
                            <entry align="center">Weblogic</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.WebSphereTransactionManagerLookup</literal></entry>
                            <entry align="center">WebSphere</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</literal></entry>
                            <entry align="center">WebSphere 6</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.OrionTransactionManagerLookup</literal></entry>
                            <entry align="center">Orion</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.ResinTransactionManagerLookup</literal></entry>
                            <entry align="center">Resin</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.JOTMTransactionManagerLookup</literal></entry>
                            <entry align="center">JOTM</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.JOnASTransactionManagerLookup</literal></entry>
                            <entry align="center">JOnAS</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.JRun4TransactionManagerLookup</literal></entry>
                            <entry align="center">JRun4</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.BESTransactionManagerLookup</literal></entry>
                            <entry align="center">Borland ES</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

        </sect2>

        <sect2 id="configuration-optional-jndi" revision="3">
            <title>
                JNDI绑定的<literal>SessionFactory</literal>
            </title>


            <para>
                与JNDI绑定的Hibernate的<literal>SessionFactory</literal>能简化工厂的查询，简化创建新的<literal>Session</literal>. 
                需要注意的是这与JNDI绑定<literal>Datasource</literal>没有关系, 它们只是恰巧用了相同的注册表!
            </para>

            <para>
                如果你希望将<literal>SessionFactory</literal>绑定到一个JNDI的名字空间, 
                用属性<literal>hibernate.session_factory_name</literal>指定一个名字(如, <literal>java:hibernate/SessionFactory</literal>). 
                如果不设置这个属性, <literal>SessionFactory</literal>将不会被绑定到JNDI中. (在以只读JNDI为默认实现的环境中，这个设置尤其有用, 如Tomcat.)
            </para>

            <para>
                在将<literal>SessionFactory</literal>绑定至JNDI时, Hibernate将使用<literal>hibernate.jndi.url</literal>, 
                和<literal>hibernate.jndi.class</literal>的值来实例化初始环境(initial context). 
                如果它们没有被指定, 将使用默认的<literal>InitialContext</literal>.
            </para>

            <para>
                在你调用<literal>cfg.buildSessionFactory()</literal>后, Hibernate会自动将<literal>SessionFactory</literal>注册到JNDI.
                这意味这你至少需要在你应用程序的启动代码(或工具类)中完成这个调用, 除非你使用<literal>HibernateService</literal>来做JMX部署 (见后面讨论).
            </para>

            <para>
                假若你使用JNDI <literal>SessionFactory</literal>,EJB或者任何其它类都可以从JNDI中找到此<literal>SessionFactory</literal>。
            </para>

            <para>
                我们建议，在受管理的环境中，把<literal>SessionFactory</literal>绑定到JNDI，在其它情况下，使用一个<literal>static(静态的)</literal>singleton。为了在你的应用程序代码中隐藏这些细节，我们还建议你用一个helper类把实际查找<literal>SessionFactory</literal>的代码隐藏起来,比如<literal>HibernateUtil.getSessionFactory()</literal>。注意，这个类也就可以方便地启动Hibernate，参见第一章。
            </para>

        </sect2>

        <sect2 id="configuration-j2ee-currentsession" revision="4">
            <title>在JTA环境下使用Current Session context (当前session上下文)管理</title>

            <para>
	            在Hibernate中，管理<literal>Session</literal>和transaction最好的方法是自动的"当前"<literal>Session</literal>管理。请参见<xref linkend="architecture-current-session">contextual sessions</xref>一节的讨论。使用<literal>"jta"</literal>session上下文，假若在当前JTA事务中还没有Hibernate<literal>Session</literal>关联，第一次<literal>sessionFactory.getCurrentSession()</literal>调用会启动一个Session,并关联到当前的JTA事务。在<literal>"jta"</literal>上下文中调用<literal>getCurrentSession()</literal>获得的<literal>Session</literal>，会被设置为在transaction关闭的时候自动flush（清洗）、在transaction关闭之后自动关闭，每句语句之后主动释放JDBC连接。这就可以根据JTA事务的生命周期来管理与之关联的<literal>Session</literal>，用户代码中就可以不再考虑这些管理。你的代码也可以通过<literal>UserTransaction</literal>用编程方式使用JTA，或者(我们建议，为了便于移植代码）使用Hibernate的<literal>Transaction</literal> API来设置transaction边界。如果你的代码运行在EJB容器中，建议对CMT使用声明式事务声明。
	            
            </para>
        </sect2>
        <sect2 id="configuration-j2ee-jmx" revision="1">
            <title>
                JMX部署
            </title>

            <para>
                为了将<literal>SessionFactory</literal>注册到JNDI中，<literal>cfg.buildSessionFactory()</literal>这行代码仍需在某处被执行.
                你可在一个<literal>static</literal>初始化块(像<literal>HibernateUtil</literal>中的那样)中执行它或将Hibernate部署为一个<emphasis>托管的服务</emphasis>.
            </para>

            <para>
                为了部署在一个支持JMX的应用程序服务器上，Hibernate和
                <literal>org.hibernate.jmx.HibernateService</literal>一同分发，如Jboss AS。
                实际的部署和配置是由应用程序服务器提供者指定的. 这里是JBoss 4.0.x的<literal>jboss-service.xml</literal>样例:
            </para>

            <programlisting><![CDATA[<?xml version="1.0"?>
<server>

<mbean code="org.hibernate.jmx.HibernateService"
    name="jboss.jca:service=HibernateFactory,name=HibernateFactory">

    <!-- 必须的服务 -->
    <depends>jboss.jca:service=RARDeployer</depends>
    <depends>jboss.jca:service=LocalTxCM,name=HsqlDS</depends>

    <!-- 将Hibernate服务绑定到JNDI -->
    <attribute name="JndiName">java:/hibernate/SessionFactory</attribute>

    <!-- 数据源设置 -->
    <attribute name="Datasource">java:HsqlDS</attribute>
    <attribute name="Dialect">org.hibernate.dialect.HSQLDialect</attribute>

    <!-- 事务集成 -->
    <attribute name="TransactionStrategy">
        org.hibernate.transaction.JTATransactionFactory</attribute>
    <attribute name="TransactionManagerLookupStrategy">
        org.hibernate.transaction.JBossTransactionManagerLookup</attribute>
    <attribute name="FlushBeforeCompletionEnabled">true</attribute>
    <attribute name="AutoCloseSessionEnabled">true</attribute>

    <!-- 抓取选项 -->
    <attribute name="MaximumFetchDepth">5</attribute>

    <!-- 二级缓存 -->
    <attribute name="SecondLevelCacheEnabled">true</attribute>
    <attribute name="CacheProviderClass">org.hibernate.cache.EhCacheProvider</attribute>
    <attribute name="QueryCacheEnabled">true</attribute>

    <!-- 日志 -->
    <attribute name="ShowSqlEnabled">true</attribute>

    <!-- 映射定义文件 -->
    <attribute name="MapResources">auction/Item.hbm.xml,auction/Category.hbm.xml</attribute>

</mbean>

</server>]]></programlisting>

            <para>
                这个文件是部署在<literal>META-INF</literal>目录下的, 并会被打包到以<literal>.sar</literal> (service archive)为扩展名的JAR文件中.
                同时，你需要将Hibernate、它所需要的第三方库、你编译好的持久化类以及你的映射定义文件打包进同一个文档. 
                你的企业Bean(一般为会话Bean)可能会被打包成它们自己的JAR文件, 但你也许会将EJB JAR文件一同包含进能独立(热)部署的主服务文档.
                参考JBoss AS文档以了解更多的JMX服务与EJB部署的信息.
            </para>

        </sect2>

    </sect1>

</chapter>
