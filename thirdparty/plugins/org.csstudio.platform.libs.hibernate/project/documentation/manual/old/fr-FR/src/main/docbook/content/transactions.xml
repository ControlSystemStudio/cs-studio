<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="transactions"  revision="2">
    <title>Transactions et accès concurrents</title>

    <para>
        L'un des principaux avantages du mécanisme de contrôle des accès concurrents d'Hibernate est qu'il est très
        facile à comprendre. Hibernate utilise directement les connexions JDBC ainsi que les ressources JTA sans y
        ajouter davantage de mécanisme de blocage. Nous vous recommandons de vous familiariser avec les spécifications
        JDBC, ANSI et d'isolement de transaction de la base de données que vous utilisez.
    </para>

    <para>
        Hibernate ne vérouille pas vos objets en mémoire. Votre application peut suivre le
        comportement défini par le niveau d'isolation de vos transactions de base de données.
        Notez que grâce à la <literal>Session</literal>, qui est aussi un cache de scope transaction, Hibernate
        fournit des lectures répétées pour les récupération par identifiants et les requêtes
        d'entités (pas celle de valeurs scalaires).
    </para>
    
    <para>
        En addition au versionning pour le controle automatique de concurrence, Hibernate fournit
        une API (mineure) pour le verrouillage perssimiste des enregistrements, en générant
        une syntaxe <literal>SELECT FOR UPDATE</literal>. Le controle de concurrence optimiste
        et cette API seront détaillés plus tard dans ce chapitre.
    </para>

    <para>
        Nous aborderons la gestion des accès concurrents en discutant de la granularité des objets <literal>Configuration</literal>,
        <literal>SessionFactory</literal>, et <literal>Session</literal>, ainsi que de certains concepts relatifs à la base de données
        et aux longues transactions applicatives.
    </para>

    <sect1 id="transactions-basics" revision="1">
        <title>Gestion de session et délimitation de transactions</title>

        <para>Il est important de savoir qu'un objet <literal>SessionFactory</literal> est un objet complexe et optimisé pour
            fonctionner avec les threads(thread- safe). Il est coûteux à créer et est ainsi prévu pour n'être instancié qu?une
            seule fois via un objet <literal>Configuration</literal> au démarrage de l'application, 
            et être partagé par tous les threads d'une application.
        </para>

        <para>Un objet <literal>Session</literal> est relativement simple et n'est threadsafe. Il est également peu
            coûteux à créer. Il devrait n'être utilisé qu'une seule fois, pour un processus d'affaire ou une unité de
            travail ou une conversation et ensuite être relâché. Un objet <literal>Session</literal> ne tentera pas 
            d'obtenir de connexion ( <literal>Connection</literal> ) 
            JDBC (ou de <literal>Datasource</literal> ) si ce n'est pas nécessaire.             
        </para>

        <para>Afin de compléter ce tableau, vous devez également penser aux transactions de base de données. Une
            transaction de base de données se doit d'être la plus courte possible afin de réduire les risques de
            collision sur des enregistrements verrouillés. De longues transactions à la base de données nuiront à
            l'extensibilité de vos applications lorsque confrontées à de hauts niveaux de charge. Par conséquent,
            il n'est jamais bon de maintenir une transaction ouverte pendant la durée de reflexion de l'utilisateur,
            jusqu'a ce que l'unité de travail soit achevée.
        </para>

        <para>Maintenant, comment délimiter une unité de travail? Est-ce qu'une instance de <literal>Session</literal> peut avoir une durée
            de vie dépassant plusieurs transactions à la base de données, ou bien est-ce que celles-ci doivent être liées une à une?
            Quand faut-il ouvrir et fermer une <literal>Session</literal> ? Comment définir la démarcation de vos transactions à la base de données?
        </para>

        <sect2 id="transactions-basics-uow" revision="1">
            <title>Unité de travail</title>

            <para>
                Il est important de mentionner que d'utiliser un paradigme <emphasis>session-par-operation</emphasis>
                est un anti-pattern. Autrement dit: n'ouvrez et ne fermez pas la
                <literal>Session</literal> à chacun de vos accès simples à la base de données dans un même thread! Bien sûr, le même raisonnement
                s'applique sur la gestion des transactions à la base de données. Les appels à la base de données
                devraient être faits en ordre et selon une séquence définie. Ils devraient également être regroupés en
                des unités de travail atomiques. (Notez que l?utilisation d?une connexion auto-commit constitue le même
                anti-pattern. Ce mode de fonctionnement existe pour les applications émettant des commandes SQL à partir
                d?une console. Hibernate désengage le mode auto-commit et s'attend à ce qu'un serveur d'applications le
                fasse également.)
                Les transactions avec la base de données ne sont jamais optionnelles, toute communication
                avec une base de données doit se dérouler dans une transaction, peu importe si vous lisez
                ou écrivez des données. Comme évoqué, le comportement auto-commit pour lire les
                données devrait être évité, puisque plusieurs petites transactions ne seront jamais
                aussi efficaces qu'une seule plus grosse clairement définie comme unité de travail.
                Ce dernier choix et en plus beaucoup plus facile a maintenir et à faire évoluer.
            </para>

            <para>
                Le pattern d'utilisation le plus fréquemment rencontré dans des applications clients serveur
                multi-usagers est le <emphasis>session-per-request</emphasis>
                (littéralement : Session par requête). Dans ce modèle, la requête d'un client est envoyée à un serveur
                (Où la couche de persistance est implémentée via Hibernate), une nouvelle
                <literal>Session</literal> est ouverte et toutes les opérations d'accès à la base de données sont exécutées à l'intérieur de
                celle-ci. Lorsque le travail est terminé (et que les réponses à envoyer au client ont été préparées), la
                session est flushée et fermée. Une seule transaction à la base de données peut être utilisée pour répondre
                à la requête du client. La transaction est démarrée et validée au même moment où la Session est ouverte 
                et fermée. La relation entre la <literal>Session</literal> et la <literal>Transaction</literal> est donc one-to-one. 
                Ce modèle permet de répondre parfaitement aux attentes de la grande majorité des
                applications.
            </para>

            <para>
                Le défi réside dans l'implémentation. Hibernate fournit une fonction de gestion de
                la "session courante" pour simplifier ce pattern. Tout ce que vous devez faire
                est démarrer une transaction lorsqu'une requête est traitée par le serveur, et
                la terminer avant que la réponse ne soit envoyée au client. Vous pouvez le faire
                de la manière que vous voulez, les solutions communes sont un <literal>ServletFilter</literal>, 
                l'interception via AOP avec une pointcut sur les méthodes de type "service", ou un conteneur
                avec interception/proxy. Un conteneur EJB est un moyen standard d'implémenter ce genre d'acpect
                tranverse comme la démarcation des transactions sur les EJBs session, de manière déclarative
                avec CMT. Si vous décidez d'utiliser la démarcation programmatique des transactions, préferrez
                l'API Hibernate <literal>Transaction</literal> détaillée plus tard dans ce chapitre, afin de
                facilité l'utilisation et la portabilité du code.
            </para>

            <para>
                Votre application peut accéder la "session courante" pour exécuter une requête
                en invoquant simplement <literal>sessionFactory.getCurrentSession()</literal> n'importe où
                et autant de fois que souhaité. Vous obtiendrez toujours une <literal>Session</literal> 
                dont le scope est la transaction courante avec la base de données. Ceci doit être configuré 
                soit dans les ressources local ou dans l'environnement JTA, voir <xref linkend="architecture-current-session"/>.
            </para>

            <para>
                Il est parfois utile d'étendre le scope d'une <literal>Session</literal> et d'une transaction
                à la base de données jusqu'à ce que "la vue soit rendue". Ceci est particulièrement
                utile dans des applications à base de servlet qui utilisent une phase de rendue séparée une fois
                que la réponse a été préparée. Etendre la transaction avec la base de données jusqu'à la fin du
                rendering de la vue est aisé si vous implémentez  votre propre intercepteur. Cependant,
                ce n'est pas facile si vous vous appuyez sur les EJBs avec CMT, puisqu'une transaction sera
                achevée au retour de la méthode EJB, avant le rendu de la vue. Rendez vous sur le site
                Hibernate et sur le forum pour des astuces et des exemples sur le pattern
                <emphasis>Open Session in View</emphasis> pattern..
             </para>
        </sect2>

        <sect2 id="transactions-basics-apptx"  revision="1">
            <title>Longue conversation</title>

            <para>Le paradigme
                <emphasis>session-per-request</emphasis>
                n'est pas le seul élément à utiliser dans le design de vos unités de travail. Plusieurs processus
                d'affaire requièrent toute une série d'interactions avec l'utilisateur, entrelacées d'accès à la base de
                donnée. Dans une application Web ou une application d'entreprise, il serait inacceptable que la durée de
                vie d'une transaction s'étale sur plusieurs interactions avec l'usager. Considérez l'exemple suivant:
            </para>

            <itemizedlist>
                <listitem>
                    <para>Un écran s'affiche. Les données vues par l'usager ont été chargées dans l'instance d'un objet
                        <literal>Session</literal> , dans le cadre d'une transaction de base de données. L'usager est libre de modifier ces objets.
                    </para>
                </listitem>
                <listitem>

                    <para>L'usager clique "Sauvegarder" après 5 minutes et souhaite persister les modifications qu'il a
                        apportées. Il s'attend à être la seule personne a avoir modifié ces données et qu'aucune
                        modification conflictuelle ne se soit produite durant ce laps de temps.</para>
                </listitem>
            </itemizedlist>

            <para>Ceci s'appelle une unité de travail. Du point de vue de l'utilisateur: une
                <emphasis>conversation</emphasis> (ou <emphasis>transaction d'application</emphasis>).
                Il y a plusieurs façon de mettre ceci en place dans votre application.
            </para>

            <para>Une première implémentation naïve pourrait consister à garder la
                <literal>Session</literal> et la transaction à la base de données ouvertes durant le temps de travail de l'usager, à maintenir les
                enregistrements verrouillés dans la base de données afin d'éviter des modifications concurrentes et de
                maintenir l'isolation et l'atomicité de la transaction de l'usager. Ceci est un anti-pattern à éviter,
                puisque le verrouillage des enregistrements dans la base de données ne permettrait pas à l'application
                de gérer un grand nombre d'usagers concurrents.
            </para>

            <para>Il apparaît donc évident qu'il faille utiliser plusieurs transactions BDD afin d'implémenter la
                conversation. Dans ce cas, maintenir l'isolation des processus d'affaire devient
                partiellement la responsabilité de la couche applicative. Ainsi, la durée de vie d'une conversation
                devrait englober celle d'une ou de plusieurs transactions de base de données. Celle-ci sera
                atomique seulement si l'écriture des données mises à jour est faite exclusivement par la dernière
                transaction BDD la composant. Toutes les autres sous transactions BD ne doivent faire que la lecture de
                données. Ceci est relativement facile à mettre en place, surtout avec l'utilisation de certaines
                fonctionnalités d'Hibernate:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>Versionnage Automatique</emphasis>
                        - Hibernate peut gérer automatiquement les accès concurrents de manière optimiste et détecter si
                        une modification concurrente s'est produite durant le temps de réflexion d'un usager.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Objets Détachés</emphasis>
                        - Si vous décidez d'utiliser le paradigme
                        <emphasis>session-par-requête</emphasis>
                        discuté plus haut, toutes les entités chargées en mémoire deviendront des objets détachés durant
                        le temps de réflexion de l'usager. Hibernate vous permet de rattacher ces objets et de persister
                        les modifications y ayant été apportées. Ce pattern est appelé:
                        <emphasis>session-per- request-with-detached-objects</emphasis>
                        (littéralement: session- par-requête-avec-objets-détachés). Le versionnage automatique est
                        utilisé afin d'isoler les modifications concurrentes.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Session Longues (conversation)</emphasis>
                        - Une
                        <literal>Session</literal> Hibernate peut être déconnectée de la couche JDBC sous-jacente après que commit() ait été appelé
                        sur une transaction à la base de données et reconnectée lors d'une nouvelle requête-client. Ce
                        pattern s'appelle:
                        <emphasis>session-per-conversation</emphasis>
                        (Littéralement: session-par- conversation) et rend superflu le rattachement des
                        objets. Le versionnage automatique est utilisé afin d'isoler les modifications concurrentes.
                    </para>
                </listitem>
            </itemizedlist>

            <para>Les deux patterns
                <emphasis>session-per-request-with- detached- objects</emphasis>
                (session-par-requête-avec-objets- détachés) et
                <emphasis>session-per-conversation</emphasis>
                (session-par-conversation) ont chacun leurs avantages et désavantages qui seront exposés
                dans ce même chapitre, dans la section au sujet du contrôle optimiste de concurrence.
            </para>

        </sect2>

        <sect2 id="transactions-basics-identity">
            <title>L'identité des objets</title>

            <para>Une application peut accéder à la même entité persistante de manière concurrente dans deux
                <literal>Session</literal> s différentes. Toutefois, une instance d'une classe persistante n'est jamais partagée par deux instances
                distinctes de la classe
                <literal>Session</literal> . Il existe donc deux notions de l'identité d'un objet:
            </para>

            <variablelist spacing="compact">
                <varlistentry>
                    <term>Identité BD</term>
                    <listitem>
                        <para>
                            <literal>foo.getId().equals( bar.getId() )</literal> </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Identité JVM</term>
                    <listitem>
                        <para>
                            <literal>foo==bar</literal> </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>Ainsi, pour des objets attachés à une
                <literal>Session</literal> <emphasis>précise</emphasis>
                (dans la cadre d'exécution (scope) d'une instance de
                <literal>Session</literal> ), ces deux notions d'identité sont équivalentes et garanties par Hibernate. Par contre, si une
                application peut accéder de manière concurrente à la même entité persistante dans deux sessions
                différentes, les deux instances seront en fait différentes (en ce qui a trait à l'identité JVM). Les
                conflits sont résolus automatiquement par approche optimiste grâce au système de versionnage automatique
                lorsque
                <literal>Session.flush()</literal> ou
                <literal>Transaction.commit()</literal> est appelé.
            </para>

            <para>Cette approche permet de reléguer à Hibernate et à la base de données sous-jacente le soin de gérer
                les problèmes d'accès concurrents. Cette manière de faire assure également une meilleure extensibilité
                de l'application puisque assurer l'identité JVM dans un thread ne nécessite pas de mécanismes de
                verrouillage coûteux ou d'autres dispositifs de synchronisation. Une application n'aura jamais le besoin
                de synchroniser des objets d'affaire tant qu'elle peut garantir qu'un seul thread aura accès à une
                instance de
                <literal>Session</literal> . Dans le cadre d'exécution d'un objet
                <literal>Session</literal> , l'application peut utiliser en toute sécurité <literal>==
            </literal> pour comparer des objets.
        </para>

        <para>
            Une application qui utiliserait <literal>==</literal> à l'extérieur du cadre d'exécution d'une <literal>Session</literal> 
            pourrait obtenir des résultats inattendus et causer certains effets de bords. Par exemple, si vous mettez 2
            objets dans le même <literal>Set</literal> , ceux-ci pourraient avoir la même identité BD (i.e. ils représentent le même enregistrement), mais leur
            identité JVM pourrait être différente (elle ne peut, par définition, pas être garantie sur deux objets
            détachés). Le développeur doit donc redéfinir l'implémentation des méthodes <literal>equals()</literal> et <literal>hashcode()</literal> 
            dans les classes persistantes et y adjoindre sa propre notion d'identité. Il existe toutefois une
            restriction: Il ne faut jamais utiliser uniquement l'identifiant de la base de données dans l'implémentation
            de l'égalité; Il faut utiliser une clé d'affaire, généralement une combinaison de plusieurs attributs
            uniques, si possible immuables. Les identifiants de base de données vont changer si un objet transitoire
            (transient) devient persistant. Si une instance transitoire est contenue dans un <literal>Set</literal> ,
            changer le hashcode brisera le contrat du <literal>Set</literal> . Les attributs pour les clés d'affaire 
            n'ont pas à être aussi stables que des clés primaires de bases de
            données. Il suffit simplement qu'elles soient stables tant et aussi longtemps que les objets sont dans le
            même <literal>Set</literal> . Veuillez consulter le site web Hibernate pour des discussions plus pointues à ce sujet. Notez que ce
            concept n'est pas propre à Hibernate mais bien général à l'implémentation de l'identité et de l'égalité en
            Java.
        </para>
    </sect2>


    <sect2 id="transactions-basics-issues">
        <title>Problèmes communs</title>

        <para>Bien qu'il puisse y avoir quelques rares exceptions à cette règle, il est recommandé de ne jamais utiliser
            les anti-patterns
            <emphasis>session-per- user-session</emphasis>
            et
            <emphasis>session-per-application</emphasis>
            . Vous trouverez ici- bas quelques problèmes que vous risquez de rencontrer si vous en faite l?utilisation.
            (Ces problèmes pourraient quand même survenir avec des patterns recommandés) Assurez-vous de bien comprendre
            les implications de chacun des patterns avant de prendre votre décision.
        </para>

        <itemizedlist>
            <listitem>
                <para>L'objet
                    <literal>Session</literal> n?est pas conçu pour être utilisé par de multiples threads. En conséquence, les objets
                    potentiellement multi-thread comme les requêtes HTTP, les EJB Session et Swing Worker, risquent de
                    provoquer des conditions de course dans la
                    <literal>Session</literal> si celle-ci est partagée. Dans un environnement web classique, il serait préférable de synchroniser
                    les accès à la session http afin d?éviter qu?un usager ne recharge une page assez rapidement pour
                    que deux requêtes s?exécutant dans des threads concurrents n?utilisent la même
                    <literal>Session</literal> .
                </para>
            </listitem>
            <listitem>
                <para>Lorsque Hibernate lance une exception, le roll back de la transaction en cours doit être effectué
                    et la
                    <literal>Session</literal> doit être immédiatement fermée. (Ceci sera exploré plus tard dans le chapitre.) Si la
                    <literal>Session</literal> est directement associée à une application, il faut arrêter l?application. Le roll back de la
                    transaction ne remettra pas les objets dans leur état du début de la transaction. Ainsi, ceux-ci
                    pourraient être désynchronisés d?avec les enregistrements. (Généralement, cela ne cause pas de réels
                    problèmes puisque la plupart des exceptions sont non traitables et requièrent la reprise du
                    processus d?affaire ayant échoué.)
                </para>
            </listitem>
            <listitem>
                <para>La
                    <literal>Session</literal> met en mémoire cache tous les objets persistants (les objets surveillés et dont l'état est géré par
                    Hibernate.) Si la
                    <literal>Session</literal> est ouverte indéfiniment ou si une trop grande quantité d'objets y est chargée, l?utilisation de la
                    mémoire peut potentiellement croître jusqu?à atteindre le maximum allouable à l?application
                    (java.lang.OutOfMemoryError.) Une solution à ce problème est d?appeler les méthodes
                    <literal>Session.clear()</literal> et
                    <literal>Session.evict()</literal> pour gérer la mémoire cache de la
                    <literal>Session</literal> . Vous pouvez également utiliser des stored procedures si vous devez lancer des traitements sur de
                    grandes quantités d?informations. Certaines solutions sont décrites ici :
                    <xref linkend="batch"/>
                    . Garder une
                    <literal>Session</literal> ouverte pour toute la durée d?une session usager augmente également considérablement le risque de
                    travailler avec de l?information périmée.
                </para>
            </listitem>
        </itemizedlist>

    </sect2>
</sect1>

<sect1 id="transactions-demarcation">
    <title>Démarcation des transactions</title>

    <para>La démarcation des transactions est importante dans le design d?une application. Aucune communication avec la
        base de données ne peut être effectuée à l?extérieur du cadre d?une transaction. (Il semble que ce concept soit
        mal compris par plusieurs développeurs trop habitués à utiliser le mode auto-commit.) Même si certains niveaux
        d'isolation et certaines possibilités offertes par les bases de données permettent de l?éviter, il n'est jamais
        désavantageux de toujours explicitement indiquer les bornes de transaction pour les opérations complexes comme
        pour les opérations simples de lecture.</para>

    <para>Une application utilisant Hibernate peut s'exécuter dans un environnement léger n?offrant pas la gestion
        automatique des transactions (application autonome, application web simple ou applications Swing) ou dans un
        environnement J2EE offrant des services de gestion automatique des transactions JTA. Dans un environnement
        simple, Hibernate a généralement la responsabilité de la gestion de son propre pool de connexions à la base de
        données. Le développeur de l'application doit manuellement délimiter les transactions. En d'autres mots, il
        appartient au développeur de gérer les appels à
        <literal>Transaction.begin()</literal>
        ,
        <literal>Transaction.commit()</literal>
        et
        <literal>Transaction.rollback()</literal>
        . Un environnement transactionnel J2EE (serveur d'application J2EE) doit offrir la gestion des transactions au
        niveau du container J2EE. Les bornes de transaction peuvent normalement être définies de manière déclarative
        dans les descripteurs de déploiement d'EJB Session, par exemple. La gestion programmatique des transactions n'y
        est donc pas nécessaire. Même les appels à
        <literal>Session.flush()</literal>
        sont faits automatiquement.
    </para>

    <para>Il peut être requis d'avoir une couche de persistance portable. Hibernate offre donc une API appelée
        <literal>Transaction</literal>
        qui sert d'enveloppe pour le système de transaction natif de l'environnement de déploiement. Il n'est pas
        obligatoire d'utiliser cette API mais il est fortement conseillé de le faire, sauf lors de l'utilisation de CMT
        Session Bean (EJB avec transactions gérées automatiquement par le container EJB).
    </para>

    <para>Il existe quatre étapes disctinctes lors de la fermeture d'une
        <literal>Session</literal>
    </para>

    <itemizedlist spacing="compact">
        <listitem>
            <para>flush de la session</para>
        </listitem>
        <listitem>
            <para>commit de la transaction</para>
        </listitem>
        <listitem>
            <para>Fermeture de la session (Close)</para>
        </listitem>
        <listitem>
            <para>Gestion des exceptions</para>
        </listitem>
    </itemizedlist>

    <para>La synchronisation de bdd depuis la session (flush) a déjà été expliqué, nous nous attarderons maintenant à la démarcation des
        transactions et à la gestion des exceptions dans les environnements légers et les environnements J2EE.</para>


    <sect2 id="transactions-demarcation-nonmanaged"  revision="2">
        <title>Environnement non managé</title>

        <para>
            Si la couche de persistance Hibernate s'exécute dans un environnement non managé, les connexions à la base de
            données seront généralement prises en charge par le mécanisme de pool d'Hibernate. La gestion de la session
            et de la transaction se fera donc de la manière suivante:</para>

            <programlisting><![CDATA[// Non-managed environment idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}]]></programlisting>

            <para>
                Vous n'avez pas à invoquer <literal>flush()</literal> explicitement sur la <literal>Session</literal> -
                l'appel de <literal>commit()</literal> déclenchera automatiquement la synchronisation (selon le <xref linkend="objectstate-flushing">FlushMode</xref> 
                de la session. Un appel à <literal>close()</literal> marque la fin de la session.
                La conséquence directe est que la connexion à la base de données sera relachée par la session.
                Ce code est portable est fonctionne dans les environnements non managé ET les environnements JTA.
            </para>

           <para>
                Une solution plus flexible est la gestion par contexte fourni par Hibernate que nous avons
                déjà rencontré:
            </para>

            <programlisting><![CDATA[// Non-managed environment idiom with getCurrentSession()
try {
    factory.getCurrentSession().beginTransaction();

    // do some work
    ...

    factory.getCurrentSession().getTransaction().commit();
}
catch (RuntimeException e) {
    factory.getCurrentSession().getTransaction().rollback();
    throw e; // or display error message
}]]></programlisting>

            <para>
                Vous ne verrez probablement jamais ces exemples de code dans les applications;
                les exceptions fatales (exceptions du système) ne devraient être traitées que
                dans la couche la plus "haute". En d'autres termes, le code qui exécute les appels
                à Hibernate (à la couche de persistance) et le code qui gère les
                <literal>RuntimeException</literal> (qui ne peut généralement effectuer qu'un nettoyage et une sortie) 
                sont dans des couches différentes. La gestion du contexte courant par Hibernate peut
                simplifier notablement ce design, puisque vous devez accéder à la gestion des exceptions
                de la <literal>SessionFactory</literal>, ce qui est décrit plus tard dans ce chapitre.
            </para>

           <para>
                Notez que vous devriez sélectionner <literal>org.hibernate.transaction.JDBCTransactionFactory</literal>
                (le défaut), pour le second exemple <literal>"thread"</literal> comme
                <literal>hibernate.current_session_context_class</literal>.
            </para>

    </sect2>

    <sect2 id="transactions-demarcation-jta" revision="2">
        <title>Utilisation de JTA</title>

        <para>Si votre couche de persistance s'exécute dans un serveur d'application (par exemple, derrière un EJB
            Session Bean), toutes les datasource utilisées par Hibernate feront automatiquement partie de transactions
            JTA globales. Hibernate propose deux stratégies pour réussir cette intégration.</para>

        <para>
            Si vous utilisez des transactions gérées par un EJB (bean managed transactions - BMT), Hibernate informera
            le serveur d'application du début et de la fin des transactions si vous utilisez l'API <literal>Transaction</literal> . 
            Ainsi, le code de gestion des transactions sera identique dans les deux types d'environnements.
        </para>

           <programlisting><![CDATA[// BMT idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}]]></programlisting>

        <para>Ou encore, avec la gestion automatique de contexte:</para>

            <programlisting><![CDATA[// BMT idiom with getCurrentSession()
try {
    factory.getCurrentSession().beginTransaction();

    // do some work
    ...

    factory.getCurrentSession().getTransaction().commit();
}
catch (RuntimeException e) {
    factory.getCurrentSession().getTransaction().rollback();
    throw e; // or display error message
}]]></programlisting>

        <para>
            Avec CMT, la démarcation des transactions est faite dans les descripteurs de déploiement des Beans Sessions et non
            de manière programmmatique, ceci réduit le code:
        </para>
        
        <programlisting><![CDATA[// CMT idiom
 Session sess = factory.getCurrentSession();

 // do some work
 ...
]]></programlisting>
        
        <para>
            Dans un EJB CMT même le rollback intervient automatiquement, puisqu'une <literal>RuntimeException</literal>
            non traitée et soulevée par une méthode d'un bean session indique au conteneur d'annuler la transaction
            globale. <emphasis>Ceci veut donc dire que vous n'avez pas à utiliser l'API <literal>Transaction</literal> d'Hibernate
            dans CMT.</emphasis>
        </para>
       
        <para>
            Notez que le fichier de configuration Hibernate devrait contenir les valeurs 
            <literal>org.hibernate.transaction.JTATransactionFactory</literal> dans un environnement BMT ou 
            <literal>org.hibernate.transaction.CMTTransactionFactory</literal> dans un environnement CMT là  où vous
            configurez votre transaction factory Hibernate. 
            N'oubliez pas non plus de spécifier le paramètre <literal>org.hibernate.transaction.manager_lookup_class</literal> .
            De plus, assurez vous de fixez votre <literal>hibernate.current_session_context_class</literal> soit à <literal>"jta"</literal>
            ou de ne pas le configurer (compatibilité avec les versions précédentes).
        </para>

        <para>
            La méthode <literal>getCurrentSession()</literal> a un inconvénient dans les environnement JTA.
            Il y a une astuce qui est d'utiliser un mode de libération de connexion <literal>after_statement</literal> ,
            qui est alors utilisé par défaut. Du à une étrange limitation de la spec JTA, il n'est pas possible
            pour Hibernate de nettoyer et ferme automatiquement un <literal>ScrollableResults</literal> ouvert
            ou une instance d'<literal>Iterator</literal> retournés <literal>scroll()</literal> ou
            <literal>iterate()</literal>. Vous <emphasis>devez</emphasis> libérer le curseur base de données
            sous jacent ou invoquer <literal>Hibernate.close(Iterator)</literal> explicitement depuis un
            bloc <literal>finally</literal>. (Bien sur, la plupart des applications peuvent éviter
            d'uiliser <literal>scroll()</literal> ou <literal>iterate()</literal> dans un code CMT.)
        </para>

    </sect2>

    <sect2 id="transactions-demarcation-exceptions">
        <title>Gestion des exceptions</title>

        <para>
            Si une <literal>Session</literal> lance une exception (incluant les exceptions du type <literal>SQLException</literal> 
            ou d'un sous-type), vous devez immédiatement faire le rollback de la transaction, appeler <literal>Session.close()</literal> 
            et relâcher les références sur l'objet <literal>Session</literal> . La <literal>Session</literal> contient des méthodes 
            pouvant la mettre dans un état inutilisable. Vous devez considérer qu'<emphasis>aucune</emphasis>
            exception lancée par Hibernate n'est traitable. Assurez-vous de fermer la session en faisant l'appel à 
            <literal>close()</literal> dans un bloc <literal>finally</literal> .
        </para>

        <para>
            L'exception <literal>HibernateException</literal> , qui englobe la plupart des exceptions pouvant survenir dans la 
            couche de persistance Hibernate, est une exception non vérifiée (Ceci n'était pas le cas dans certaines versions antérieures de Hibernate.) Il est de
            notre avis que nous ne devrions pas forcer un développeur à gérer une exception qu'il ne peut de toute façon
            pas traiter dans une couche technique. Dans la plupart des applications, les exceptions non vérifiées et les
            exceptions fatales sont gérées en amont du processus (dans les couches hautes) et un message d'erreur est
            alors affiché à l'usager (ou un traitement alternatif est invoqué.) Veuillez noter qu'Hibernate peut
            également lancer des exceptions non vérifiées d'un autre type que <literal>HibernateException</literal> . Celles-ci sont 
            également non traitables et vous devez les traiter comme telles.
        </para>

        <para>
            Hibernate englobe les <literal>SQLException</literal> s lancées lors des interactions directes avec la base de données 
            dans des exceptions de type: <literal>JDBCException</literal> . En fait, Hibernate essaiera de convertir l'exception dans 
            un sous-type plus significatif de <literal>JDBCException</literal> . L'exception <literal>SQLException</literal> sous-jacente 
            est toujours disponible via la méthode <literal>JDBCException.getCause()</literal> . Cette conversion est faite par un objet 
            de type <literal>SQLExceptionConverter</literal> , qui est rattaché à l'objet <literal>SessionFactory</literal> . 
            Par défaut, le <literal>SQLExceptionConverter</literal> est associé au dialecte de BD configuré dans Hibernate. Toutefois, 
            il est possible de fournir sa propre implémentation de l'interface. (Veuillez vous référer à la javadoc sur la classe 
            <literal>SQLExceptionConverterFactory</literal> pour plus de détails. Les sous-types standard de <literal>JDBCException</literal> sont:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>JDBCConnectionException</literal> - Indique une erreur de communication avec la couche JDBC sous-jacente.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>SQLGrammarException</literal> - Indique un problème de grammaire ou de syntaxe avec la requête SQL envoyée.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>ConstraintViolationException</literal> - Indique une violation de contrainte d'intégrité.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>LockAcquisitionException</literal> - Indique une erreur de verrouillage lors de l'éxécution de la requête.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>GenericJDBCException</literal> - Indique une erreur générique JDBC d'une autre catégorie.
                </para>
            </listitem>
        </itemizedlist>

    </sect2>

    <sect2 id="transactions-demarcation-timeout">
        <title>Timeout de transaction</title>

        <para>L'un des avantages fournis par les environnements transactionnels JTA (tels les containers EJB) est la
            gestion du timeout de transaction. La gestion des dépassements de temps de transaction vise à s'assurer
            qu'une transaction agissant incorrectement ne viendra pas bloquer indéfiniment les ressources de
            l'application. Hibernate ne peut fournir cette fonctionnalité dans un environnement transactionnel non-JTA.
            Par contre, Hibernate gère les opérations d'accès aux données en allouant un temps maximal aux requêtes pour
            s'exécuter. Ainsi, une requête créant de l'inter blocage ou retournant de très grandes quantités
            d'information pourrait être interrompue. Dans un environnement transactionnel JTA, Hibernate peut déléguer
            au gestionnaire de transaction le soin de gérer les dépassements de temps. Cette fonctionnalité est
            abstraite par l'objet <literal>Transaction</literal> .
        </para>

        <programlisting><![CDATA[
        Session sess = factory.openSession();
        try {
            //mettre le timeout à 3 secondes.
            sess.getTransaction().setTimeout(3);
            sess.getTransaction().begin();

            // Effectuer le travail ...

            sess.getTransaction().commit()
        }
        catch (RuntimeException e) {
            if ( sess.getTransaction().isActive() ) {
                sess.getTransaction().rollback();
            }
            throw e;
            // ou afficher le message d'erreur.
        }
        finally {
            sess.close();
        }]]></programlisting>


        <para>
            Notez que <literal>setTimeout()</literal> ne peut pas être appelé d'un EJB CMT, puisque le timeout 
            des transaction doit être spécifié de manière déclarative.
        </para>

    </sect2>

</sect1>

<sect1 id="transactions-optimistic">
    <title>Contrôle de consurrence optimiste</title>

    <para>La gestion optimiste des accès concurrents avec versionnage est la seule approche pouvant garantir
        l'extensibilité des applications à haut niveau de charge. Le système de versionnage utilise des numéros de
        version ou l'horodatage pour détecter les mises à jour causant des conflits avec d'autres actualisations
        antérieures. Hibernate propose trois approches pour l'écriture de code applicatif utilisant la gestion optimiste
        d'accès concurrents. Le cas d'utilisation décrit plus bas fait mention de conversation,
        mais le versionnage peut également améliorer la qualité d'une application en prévenant la perte de mises à
        jour.</para>

    <sect2 id="transactions-optimistic-manual">
        <title>Gestion du versionnage au niveau applicatif</title>

        <para>Dans cet exemple d'implémentation utilisant peu les fonctionnalités d'Hibernate, chaque interaction avec
            la base de données se fait en utilisant une nouvelle <literal>Session</literal> et le développeur doit recharger 
            les données persistantes à partir de la BD avant de les manipuler. Cette
            implémentation force l'application à vérifier la version des objets afin de maintenir l'isolation
            transactionnelle. Cette approche, semblable à celle retrouvée pour les EJB, est la moins efficace de celles
            présentées dans ce chapitre.
        </para>

        <programlisting>
            <![CDATA[// foo est une instance chargée antérieurement par une autre
            Session session = factory.openSession();
            Transaction t = session.beginTransaction();

            int oldVersion = foo.getVersion();
            session.load( foo, foo.getKey() ); // Charger l'état courant

            if ( oldVersion != foo.getVersion() )
                throw new StaleObjectStateException();

            foo.setProperty("bar");
            t.commit();
            session.close();]]></programlisting>

        <para>Le mapping de la propriété <literal>version</literal> est fait via <literal>&lt;version&gt;</literal> et 
        Hibernate l'incrémentera automatiquement à chaque flush() si l'entité doit être mise à jour.
        </para>


        <para>Bien sûr, si votre application ne fait pas face à beaucoup d'accès concurrents et ne nécessite pas
            l'utilisation du versionnage, cette approche peut également être utilisée, il n'y a qu'à ignorer le code
            relié au versionnage. Dans ce cas, la stratégie du
            <emphasis>last commit wins</emphasis>
            (littéralement: le dernier commit l'emporte) sera utilisée pour les conversations (longues transactions applicatives).
            Gardez à l'esprit que cette approche pourrait rendre perplexe les utilisateurs de l'application car ils
            pourraient perdre des données mises à jour sans qu'aucun message d'erreur ne leur soit présenté et sans
            avoir la possibilité de fusionner les données.
        </para>

        <para>Il est clair que la gestion manuelle de la vérification du versionnage des objets ne peut être effectuée
            que dans certains cas triviaux et que cette approche n'est pas valable pour la plupart des applications. De
            manière générale, les applications ne cherchent pas à actualiser de simples objets sans relations, elles le
            font généralement pour de larges graphes d'objets. Pour toute application utilisant le paradigme des conversations
             ou des objets détachés, Hibernate peut gérer automatiquement la vérification des versions
            d'objets.</para>

    </sect2>

    <sect2 id="transactions-optimistic-longsession">
        <title>Les sessions longues et le versionnage automatique.</title>

        <para>Dans ce scénario, une seule instance de <literal>Session</literal> et des objets persistants est utilisée 
            pour toute l'application. Hibernate vérifie la version des objets
            persistants avant d'effectuer le flush() et lance une exception si une modification concurrente est
            détectée. Il appartient alors au développeur de gérer l'exception. Les traitements alternatifs généralement
            proposés sont alors de permettre à l'usager de faire la fusion des données ou de lui offrir de recommencer
            son travail à partie des données les plus récentes dans la BD.
        </para>

        <para>Il est à noter que lorsqu'une application est en attente d'une action de la part de l?usager, La <literal>Session</literal> 
            n'est pas connectée à la couche JDBC sous-jacente. C'est la manière la plus efficace de gérer les accès à la
            base de données. L'application ne devrait pas se préoccuper du versionnage des objets, de la réassociation
            des objets détachés, ni du rechargement de tous les objets à chaque transaction.
        </para>

        <programlisting>
            <![CDATA[// foo est une instance chargée antérieurement par une autre session

            session.reconnect();// Obtention d'une nouvelle connexion JDBC
            Transaction t = session.beginTransaction();
            foo.setProperty("bar");
            t.commit(); //Terminer la transaction, propager les changements et vérifier les versions.
            session.disconnect(); // Retourner la connexion JDBC
            ]]></programlisting>


        <para>L'objet <literal>foo</literal> sait quel objet <literal>Session</literal> l'a chargé. <literal>Session.reconnect()</literal> 
            obtient une nouvelle connexion (celle-ci peut être également fournie) et permet à la session de continuer
            son travail. La méthode <literal>Session.disconnect()</literal> déconnecte la session de la connexion JDBC et 
            retourne celle-ci au pool de connexion (à moins que vous ne
            lui ayez fourni vous même la connexion.) Après la reconnexion, afin de forcer la vérification du versionnage
            de certaines entités que vous ne cherchez pas à actualiser, vous pouvez faire un appel à <literal>Session.lock()</literal> 
            en mode <literal>LockMode.READ</literal> pour tout objet ayant pu être modifié par une autre transaction. Il n'est pas nécessaire de verrouiller les
            données que vous désirez mettre à jour.
        </para>

        <para>Si des appels implicites aux méthodes <literal>disconnect()</literal> et <literal>reconnect()</literal> sont trop 
        coûteux, vous pouvez les éviter en utilisant <literal>hibernate.connection.release_mode</literal> .
        </para>

        <para>Ce pattern peut présenter des problèmes si la <literal>Session</literal> est trop volumineuse pour être 
            stockée entre les actions de l'usager. Plus spécifiquement, une session <literal>HttpSession</literal> se doit 
            d'être la plus petite possible. Puisque la <literal>Session</literal> joue obligatoirement le rôle de mémoire 
            cache de premier niveau et contient à ce titre tous les objets
            chargés, il est préférable de n'utiliser cette stratégie que pour quelques cycles de requêtes car les objets
            risquent d'y être rapidement périmés.
        </para>

        <para>Notez que la <literal>Session</literal> déconnectée devrait être conservée près de la couche de persistance. Autrement dit, utilisez un EJB stateful
            pour conserver la <literal>Session</literal> et évitez de la sérialiser et de la transférer à la couche de présentation (i.e. Il est préférable de ne pas
            la conserver dans la session <literal>HttpSession</literal> .)
        </para>
	<para>
		The extended session pattern, or <emphasis>session-per-conversation</emphasis>, is
		more difficult to implement with automatic current session context management.
		You need to supply your own implementation of the <literal>CurrentSessionContext</literal>
		for this, see the Hibernate Wiki for examples.
            </para>
    </sect2>

    <sect2 id="transactions-optimistic-detached">
        <title>Les objets détachés et le versionnage automatique</title>

        <para>Chaque interaction avec le système de persistance se fait via une nouvelle <literal>Session</literal> . 
            Toutefois, les mêmes instances d'objets persistants sont réutilisées pour chacune de ces interactions.
            L'application doit pouvoir manipuler l'état des instances détachées ayant été chargées antérieurement via
            une autre session. Pour ce faire, ces objets persistants doivent être rattachés à la <literal>Session</literal> 
            courante en utilisant <literal>Session.update()</literal> , <literal>Session.saveOrUpdate()</literal> , ou <literal>Session.merge()</literal> .
        </para>

        <programlisting>
            <![CDATA[// foo est une instance chargée antérieurement par une autre session

            foo.setProperty("bar");
            session = factory.openSession();
            Transaction t = session.beginTransaction();
            session.saveOrUpdate(foo);  //Utiliser merge() si "foo" pourrait avoir été chargé précédement
            t.commit();
            session.close();]]> </programlisting>


        <para>Encore une fois, Hibernate vérifiera la version des instances devant être actualisées durant le flush().
            Une exception sera lancée si des conflits sont détectés.</para>

        <para>Vous pouvez également utiliser <literal>lock()</literal> au lieu de <literal>update()</literal> et 
            utiliser le mode <literal>LockMode.READ</literal> (qui lancera une vérification de version, en ignorant tous les niveaux de mémoire cache) si vous êtes
            certain que l'objet n'a pas été modifié.
        </para>

    </sect2>

    <sect2 id="transactions-optimistic-customizing">
        <title>Personnaliser le versionnage automatique</title>

        <para>Vous pouvez désactiver l'incrémentation automatique du numéro de version de certains attributs et
            collections en mettant la valeur du paramètre de mapping <literal>optimistic-lock</literal> à
            false. Hibernate cessera ainsi d'incrémenter leur numéro de version s'ils sont mis à jour.
        </para>

        <para>Certaines entreprises possèdent de vieux systèmes dont les schémas de bases de données sont statiques et
            ne peuvent être modifiés. Il existe aussi des cas où plusieurs applications doivent accéder à la même base
            de données, mais certaines d'entre elles ne peuvent gérer les numéros de version ou les champs horodatés.
            Dans les deux cas, le versionnage ne peut être implanté par le rajout d'une colonne dans la base de données.
            Afin de forcer la vérification de version dans un système sans en faire le mapping, mais en forçant une
            comparaison des états de tous les attributs d'une entité, vous pouvez utiliser l'attribut <literal>optimistic- lock="all"</literal> 
            sous l'élément <literal>&lt;class&gt;</literal> . Veuillez noter que cette manière de gérer le versionnage ne peut être utilisée que si l'application
            utilises de longues sessions, lui permettant de comparer l'ancien état et le nouvel état d'une entité.
            L'utilisation d'un pattern <literal>session-per-request-with-detached- objects</literal> devient alors impossible.
        </para>

        <para>Il peut être souhaitable de permettre les modifications concurrentes lorsque des champs distincts sont
            modifiés. En mettant la propriété <literal>optimistic-lock="dirty"</literal> dans l'élément <literal>&lt;class&gt;</literal> , 
            Hibernate ne fera la comparaison que des champs devant être actualisés lors du flush().
        </para>

        <para>Dans les deux cas: en utilisant une colonne de version/horodatée ou via la comparaison de l'état complet
            de l'objet ou de ses champs modifiés, Hibernate ne créera qu'une seule commande d'UPDATE par entité avec la
            clause WHERE appropriée pour mettre à jour l'entité
            <emphasis>ET</emphasis>
            en vérifier la version. Si vous utilisez la persistance transitive pour propager l'évènement de rattachement
            à des entités associées, il est possible qu'Hibernate génère des commandes d'UPDATE inutiles. Ceci n'est
            généralement pas un problème, mais certains déclencheurs
            <emphasis>on update</emphasis>
            dans la base de données pourraient être activés même si aucun changement n'était réellement persisté sur des
            objets associés. Vous pouvez personnaliser ce comportement en indiquant <literal>select-before- update="true"</literal>
            dans l'élément de mapping <literal>&lt;class&gt;</literal> . Ceci forcera Hibernate à faire le SELECT de l'instance 
            afin de s'assurer que l'entité doit réellement être
            actualisée avant de lancer la commande d'UPDATE.
        </para>

    </sect2>

</sect1>

<sect1 id="transactions-locking">
    <title>Verouillage pessimiste</title>

    <para>Il n'est nécessaire de s'attarder à la stratégie de verrouillage des entités dans une application utilisant
        Hibernate. Il est généralement suffisant de définir le niveau d'isolation pour les connexions JDBC et de laisser
        ensuite la base de donnée effectuer son travail. Toutefois, certains utilisateurs avancés peuvent vouloir
        obtenir un verrouillage pessimiste exclusif sur un enregistrement et le réobtenir au lancement d'une nouvelle
        transaction.</para>

    <para>Hibernate utilisera toujours le mécanisme de verrouillage de la base de données et ne verrouillera jamais les
        objets en mémoire!</para>

    <para>La classe
        <literal>LockMode</literal>
        définit les différents niveaux de verrouillage pouvant être obtenus par Hibernate. Le verrouillage est obtenu
        par les mécanismes suivants:
    </para>

    <itemizedlist spacing="compact">
        <listitem>
            <para>
                <literal>LockMode.WRITE</literal> est obtenu automatiquement quand Hibernate actualise ou insert un enregistrement.
            </para>
        </listitem>
        <listitem>
            <para>
                <literal>LockMode.UPGRADE</literal> peut être obtenu de manière explicite via la requête en utilisant
                <literal>SELECT ... FOR UPDATE</literal> sur une base de données supportant cette syntaxe.
            </para>
        </listitem>
        <listitem>
            <para>
                <literal>LockMode.UPGRADE_NOWAIT</literal> peut être obtenu de manière explicite en utilisant
                <literal>SELECT ... FOR UPDATE NOWAIT</literal> sur Oracle.
            </para>
        </listitem>
        <listitem>
            <para>
                <literal>LockMode.READ</literal> est obtenu automatiquement quand Hibernate lit des données dans un contexte d'isolation
                <literal>Repeatable Read</literal> ou
                <literal>Serializable</literal> . Peut être réobtenu explicitement via une requête.
            </para>
        </listitem>
        <listitem>
            <para>
                <literal>LockMode.NONE</literal> représente l'absence de verouillage. Tous les objets migrent vers ce mode a la fin d'une
                <literal>Transaction</literal> . Les objets associés à une session via un appel à
                <literal>saveOrUpdate()</literal> commencent également leur cycle de vie dans cet état.
            </para>
        </listitem>
    </itemizedlist>

    <para>Les niveaux de verrouillage peuvent être explicitement obtenus de l'une des manières suivantes:</para>

    <itemizedlist spacing="compact">
        <listitem>
            <para>Un appel à
                <literal>Session.load()</literal> , en spécifiant un niveau verrouillage
                <literal>LockMode</literal> .
            </para>
        </listitem>
        <listitem>
            <para>Un appel à
                <literal>Session.lock()</literal> .
            </para>
        </listitem>
        <listitem>
            <para>Une appel à
                <literal>Query.setLockMode()</literal> .
            </para>
        </listitem>
    </itemizedlist>

    <para>Si
        <literal>Session.load()</literal>
        est appelé avec le paramètre de niveau de verouillage
        <literal>UPGRADE</literal>
        ou
        <literal>UPGRADE_NOWAIT</literal>
        et que l'objet demandé n'est pas présent dans la session, celui-ci sera chargé à l'aide d'une requête
        <literal>SELECT ... FOR UPDATE</literal>
        . Si la méthode
        <literal>load()</literal>
        est appelée pour un objet déjà en session avec un verrouillage moindre que celui demandé, Hibernate appellera la
        méthode
        <literal>lock()</literal>
        pour cet objet.
    </para>

    <para>
        <literal>Session.lock()</literal>
        effectue une vérification de version si le niveau de verrouillage est
        <literal>READ</literal>
        ,
        <literal>UPGRADE</literal>
        ou
        <literal>UPGRADE_NOWAIT</literal>
        . (Dans le cas des niveaux
        <literal>UPGRADE</literal>
        ou
        <literal>UPGRADE_NOWAIT</literal>
        , une requête
        <literal>SELECT ... FOR UPDATE</literal>
        sera utilisée.)
    </para>

    <para>Si une base de données ne supporte pas le niveau de verrouillage demandé, Hibernate utilisera un niveau
        alternatif convenable au lieux de lancer une exception. Ceci assurera la portabilité de votre
        application.</para>
</sect1> 

    <sect1 id="transactions-connection-release">
        <title>Mode de libération de Connection</title>

        <para>
            Le comportement original (2.x) d'Hibernate pour la gestion des connexions JDBC
            était que la <literal>Session</literal> obtenait une connexion dès qu'elle en avait
            besoin et la libérait une fois la session fermée.
            Hibernate 3 a introduit les modes de libération de connexion pour indiquer à la session
            comment gérer les transactions JDBC. Notez que la discussion suivante n'est pertinente 
            que pour des connexions fournies par un <literal>ConnectionProvider</literal>, celles gérées 
            par l'utilisateur sont en dehors du scope de cette discussion. Les différents modes
            sont définies par <literal>org.hibernate.ConnectionReleaseMode</literal>:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>ON_CLOSE</literal> - est essentiellement le comportement passé.
                    La session Hibernate obtient une connexion lorsqu'elle en a besoin et la garde
                    jusqu'à ce que la session se ferme.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>AFTER_TRANSACTION</literal> - indique de relacher la connexion après qu'une
                    <literal>org.hibernate.Transaction</literal> se soit achevée.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>AFTER_STATEMENT</literal> (aussi appelé libération brutale) - indique de relacher
                    les connexions après chaque exécution d'un statement. Ce relachement aggressif est annulé
                    si ce statement laisse des ressources associées à une session donnée ouvertes, actuellement
                    ceci n'arrive que lors de l'utilisation de <literal>org.hibernate.ScrollableResults</literal>.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Le paramètre de configuration <literal>hibernate.connection.release_mode</literal> est utilisé
            pour spécifier quel mode de libération doit être utiliser. Les valeurs possibles sont:
        </para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <literal>auto</literal> (valeur par défaut) - ce choix délègue le choix de libération
                    à la méthode <literal>org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</literal>
                    Pour la JTATransactionFactory, elle retourne ConnectionReleaseMode.AFTER_STATEMENT; pour
                    JDBCTransactionFactory, elle retourne ConnectionReleaseMode.AFTER_TRANSACTION. C'est rarement
                    une bonne idée de changer ce comportement par défaut puisque les erreurs soulevées par ce
                    paramétrage tend à prouver une erreur dans le code de l'utilisateur.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>on_close</literal> - indique d'utiliser ConnectionReleaseMode.ON_CLOSE.  Ce paramétrage
                    existe pour garantir la compatibilité avec les versions précédentes, mais ne devrait plus être utilisé.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>after_transaction</literal> - indique d'utiliser ConnectionReleaseMode.AFTER_TRANSACTION.
                    Ne devrait pas être utilisé dans les environnements JTA. Notez aussi qu'avec 
                    ConnectionReleaseMode.AFTER_TRANSACTION, si une session est considérée comme étant en mode auto-commit
                    les connexions seront relachées comme si le mode était AFTER_STATEMENT.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>after_statement</literal> - indique d'utiliser ConnectionReleaseMode.AFTER_STATEMENT.
                    Additonnellement, le <literal>ConnectionProvider</literal> utilisé est consulté pour savoir s'il supporte
                    ce paramétrage (<literal>supportsAggressiveRelease()</literal>). Si ce n'est pas le cas, le mode de
                    libération est ré initialisé à ConnectionReleaseMode.AFTER_TRANSACTION.  
                    Ce paramétrage n'est sûr que dans les environnements où il est possible d'obtenir à nouveau
                    la même connexion JDBC à chaque fois que l'on fait un appel de <literal>ConnectionProvider.getConnection()</literal> 
                    ou dans les envrionnements auto-commit où il n'est pas important d'obtenir plusieurs fois la 
                    même connexion.
                </para>
            </listitem>
        </itemizedlist>

    </sect1>

</chapter>

