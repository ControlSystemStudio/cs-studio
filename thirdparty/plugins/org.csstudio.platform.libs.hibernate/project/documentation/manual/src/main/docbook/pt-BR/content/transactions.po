# translation of transactions.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# Michael H. Smith <mhideo@redhat.com>, 2007.
# Glaucia Cintra <gcintra@redhat.com>, 2007.
msgid ""
msgstr ""
"Project-Id-Version: transactions\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:16\n"
"PO-Revision-Date: 2010-03-19 14:01+1000\n"
"Last-Translator: \n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Transactions and Concurrency"
msgstr "Transações e Concorrência "

#. Tag: para
#, no-c-format
msgid ""
"The most important point about Hibernate and concurrency control is that it "
"is easy to understand. Hibernate directly uses JDBC connections and JTA "
"resources without adding any additional locking behavior. It is recommended "
"that you spend some time with the JDBC, ANSI, and transaction isolation "
"specification of your database management system."
msgstr ""
"O fator mais importante sobre o Hibernate e o controle de concorrência é que "
"é muito fácil de ser compreendido. O Hibernate usa diretamente conexões de "
"JDBC e recursos de JTA sem adicionar nenhum comportamento de bloqueio a "
"mais. Recomendamos que você gaste algum tempo com o JDBC, o ANSI e a "
"especificação de isolamento de transação de seu sistema de gerência da base "
"de dados. "

#. Tag: para
#, no-c-format
msgid ""
"Hibernate does not lock objects in memory. Your application can expect the "
"behavior as defined by the isolation level of your database transactions. "
"Through <literal>Session</literal>, which is also a transaction-scoped "
"cache, Hibernate provides repeatable reads for lookup by identifier and "
"entity queries and not reporting queries that return scalar values."
msgstr ""
"O Hibernate não bloqueia objetos na memória. Sua aplicação pode esperar o "
"comportamento tal qual definido de acordo com o nível de isolamento de suas "
"transações de banco de dados. Note que graças ao <literal>Session</literal>, "
"que também é um cache de escopo de transação, o Hibernate procura "
"repetidamente por identificadores e consultas de entidade não consultas de "
"relatórios que retornam valores escalares. "

#. Tag: para
#, no-c-format
msgid ""
"In addition to versioning for automatic optimistic concurrency control, "
"Hibernate also offers, using the <literal>SELECT FOR UPDATE</literal> "
"syntax, a (minor) API for pessimistic locking of rows. Optimistic "
"concurrency control and this API are discussed later in this chapter."
msgstr ""
"Além do versionamento para o controle automático de concorrência otimista, o "
"Hibernate oferece também uma API (menor) para bloqueio pessimista de linhas "
"usando a sintáxe <literal>SELECT FOR UPDATE</literal>. O controle de "
"concorrência otimista e esta API são discutidos mais tarde neste capítulo. "

#. Tag: para
#, no-c-format
msgid ""
"The discussion of concurrency control in Hibernate begins with the "
"granularity of <literal>Configuration</literal>, <literal>SessionFactory</"
"literal>, and <literal>Session</literal>, as well as database transactions "
"and long conversations."
msgstr ""
"Nós começamos a discussão do controle de concorrência no Hibernate com a "
"granularidade do <literal>Configuration</literal>, <literal>SessionFactory</"
"literal> e <literal>Session</literal>, além de transações de base de dados e "
"conversações longas. "

#. Tag: title
#, no-c-format
msgid "Session and transaction scopes"
msgstr "Sessão e escopos de transações"

#. Tag: para
#, no-c-format
msgid ""
"A <literal>SessionFactory</literal> is an expensive-to-create, threadsafe "
"object, intended to be shared by all application threads. It is created "
"once, usually on application startup, from a <literal>Configuration</"
"literal> instance."
msgstr ""
"Um <literal>SessionFactory</literal> é objeto threadsafe com um custo alto "
"de criação, compartilhado por todas as threads da aplicação. É criado uma "
"única vez, no início da execução da aplicação, a partir da instância de uma "
"<literal>Configuration</literal>. "

#. Tag: para
#, no-c-format
msgid ""
"A <literal>Session</literal> is an inexpensive, non-threadsafe object that "
"should be used once and then discarded for: a single request, a conversation "
"or a single unit of work. A <literal>Session</literal> will not obtain a "
"JDBC <literal>Connection</literal>, or a <literal>Datasource</literal>, "
"unless it is needed. It will not consume any resources until used."
msgstr ""
"Uma <literal>Session</literal> é um objeto de baixo custo de criação, não é "
"threadsafe, deve ser usado uma vez, para uma única requisição, uma "
"conversação, uma única unidade do trabalho e então deve ser descartado. Um "
"<literal>Session</literal> não obterá um JDBC <literal>Connection</literal>, "
"ou um <literal>Datasource</literal>, a menos que necessite. Isto não consome "
"nenhum recurso até ser usado."

#. Tag: para
#, no-c-format
msgid ""
"In order to reduce lock contention in the database, a database transaction "
"has to be as short as possible. Long database transactions will prevent your "
"application from scaling to a highly concurrent load. It is not recommended "
"that you hold a database transaction open during user think time until the "
"unit of work is complete."
msgstr ""
"Uma transação precisa ser o mais curta possível, para reduzir a disputa pelo "
"bloqueio na base de dados. Transações longas impedirão que sua aplicação "
"escale a carga altamente concorrente. Por isso, não é bom manter uma "
"transação de base de dados aberta durante o tempo que o usuário pensa, até "
"que a unidade do trabalho esteja completa."

#. Tag: para
#, no-c-format
msgid ""
"What is the scope of a unit of work? Can a single Hibernate "
"<literal>Session</literal> span several database transactions, or is this a "
"one-to-one relationship of scopes? When should you open and close a "
"<literal>Session</literal> and how do you demarcate the database transaction "
"boundaries? These questions are addressed in the following sections."
msgstr ""
"Qual é o escopo de uma unidade de trabalho? Pode uma única <literal>Session</"
"literal> do Hibernate gerenciar diversas transações ou este é um o "
"relacionamento um-para-um dos escopos? Quando você deve abrir e fechar uma "
"<literal>Session</literal> e como você demarca os limites da transação? "
"Estas questões estão endereçadas nas seguintes seções."

#. Tag: title
#, no-c-format
msgid "Unit of work"
msgstr "Unidade de trabalho"

#. Tag: para
#, no-c-format
msgid ""
"First, let's define a unit of work. A unit of work is a design pattern "
"described by Martin Fowler as <quote> [maintaining] a list of objects "
"affected by a business transaction and coordinates the writing out of "
"changes and the resolution of concurrency problems. </quote><citation>PoEAA</"
"citation> In other words, its a series of operations we wish to carry out "
"against the database together. Basically, it is a transaction, though "
"fulfilling a unit of work will often span multiple physical database "
"transactions (see <xref linkend=\"transactions-basics-apptx\" />). So really "
"we are talking about a more abstract notion of a transaction. The term "
"\"business transaction\" is also sometimes used in lieu of unit of work."
msgstr ""
"Primeiro, vamos definir uma unidade de trabalho. Uma unidade de trabalho é "
"um padrão de design descrito por Martin Fowler como <quote> [maintaining] a list of objects "
"affected by a business transaction and coordinates the writing out of "
"changes and the resolution of concurrency problems. </quote><citation>PoEAA</"
"citation>. Em outras palavras, é uma série de "
"operações que desejamos cuidar junto ao banco de dados. Basicamente, é uma "
"transação, que apesar de completar uma unidade de trabalho, sempre "
"distribuirá transações de banco de dados físico múltiplos (consulte <xref linkend=\"transactions-basics-apptx\" />. Portanto, estamos conversando "
"sobre uma noção mais abstrata da transação. O termo \"transação comercial\" "
"é também usada em acúmulo na unidade de trabalho. "

#. Tag: para
#, no-c-format
msgid ""
"Do not use the <emphasis>session-per-operation</emphasis> antipattern: do "
"not open and close a <literal>Session</literal> for every simple database "
"call in a single thread. The same is true for database transactions. "
"Database calls in an application are made using a planned sequence; they are "
"grouped into atomic units of work. This also means that auto-commit after "
"every single SQL statement is useless in an application as this mode is "
"intended for ad-hoc SQL console work. Hibernate disables, or expects the "
"application server to disable, auto-commit mode immediately. Database "
"transactions are never optional. All communication with a database has to "
"occur inside a transaction. Auto-commit behavior for reading data should be "
"avoided, as many small transactions are unlikely to perform better than one "
"clearly defined unit of work. The latter is also more maintainable and "
"extensible."
msgstr ""
"Primeiro, não use o antipattern <emphasis>sessão-por-operação</emphasis>: "
"isto é, não abra e feche uma <literal>Session</literal> para cada simples "
"chamada ao banco de dados em uma única thread. Naturalmente, o mesmo se "
"aplica às transações do banco de dados. As chamadas ao banco de dados em uma "
"aplicação são feitas usando uma seqüência planejada, elas são agrupadas em "
"unidades de trabalho atômicas. Veja que isso também significa que realizar "
"um auto-commit depois de cada instrução SQL é inútil em uma aplicação, esta "
"modalidade é ideal para o trabalho ad hoc do console do SQL. O Hibernate "
"impede, ou espera que o servidor de aplicação impessa isso, aplique a "
"modalidade auto-commit imediatamente. As transações de banco de dados nunca "
"são opcionais, toda a comunicação com um banco de dados tem que ocorrer "
"dentro de uma transação, não importa se você vai ler ou escrever dados. Como "
"explicado, o comportamento auto-commit para leitura de dados deve ser "
"evitado, uma vez que muitas transações pequenas são improváveis de executar "
"melhor do que uma unidade de trabalho claramente definida. A última opção é "
"também muito mais sustentável e expandida."

#. Tag: para
#, no-c-format
msgid ""
"The most common pattern in a multi-user client/server application is "
"<emphasis>session-per-request</emphasis>. In this model, a request from the "
"client is sent to the server, where the Hibernate persistence layer runs. A "
"new Hibernate <literal>Session</literal> is opened, and all database "
"operations are executed in this unit of work. On completion of the work, and "
"once the response for the client has been prepared, the session is flushed "
"and closed. Use a single database transaction to serve the clients request, "
"starting and committing it when you open and close the <literal>Session</"
"literal>. The relationship between the two is one-to-one and this model is a "
"perfect fit for many applications."
msgstr ""
"O modelo mais comum em uma aplicação de cliente/servidor multi-usuário  é "
"<emphasis>sessão-por-requisição</emphasis>. Neste modelo, uma requisição do "
"cliente é enviada ao servidor, onde a camada de persistência do Hibernate é "
"executada. Uma <literal>Session</literal> nova do Hibernate é aberta, e "
"todas as operações da base de dados são executadas nesta unidade do "
"trabalho. Logo que o trabalho for completado, e a resposta para o cliente "
"for preparada, a sessão é descarregada e fechada. Você usaria também uma "
"única transação de base de dados para servir às requisições dos clientes, "
"iniciando e submetendo-o ao abrir e fechar da <literal>Session</literal>. O "
"relacionamento entre os dois é um-para-um e este modelo é um ajuste perfeito "
"para muitas aplicações."

#. Tag: para
#, no-c-format
msgid ""
"The challenge lies in the implementation. Hibernate provides built-in "
"management of the \"current session\" to simplify this pattern. Start a "
"transaction when a server request has to be processed, and end the "
"transaction before the response is sent to the client. Common solutions are "
"<literal>ServletFilter</literal>, AOP interceptor with a pointcut on the "
"service methods, or a proxy/interception container. An EJB container is a "
"standardized way to implement cross-cutting aspects such as transaction "
"demarcation on EJB session beans, declaratively with CMT. If you use "
"programmatic transaction demarcation, for ease of use and code portability "
"use the Hibernate <literal>Transaction</literal> API shown later in this "
"chapter."
msgstr ""
"O desafio encontra-se na implementação. O Hibernate fornece gerenciamento "
"integrado da \"sessão atual\" para simplificar este modelo. Tudo que você "
"tem a fazer é iniciar uma transação quando uma requisição precisa ser "
"processada e terminar a transação antes que a resposta seja enviada ao "
"cliente. Você pode fazer onde quiser, soluções comuns são "
"<literal>ServletFilter</literal>, interceptador AOP com um pointcut (ponto "
"de corte) nos métodos de serviço ou em um recipiente de proxy/interceptação. "
"Um recipiente de EJB é uma maneira padronizada de implementar aspectos cross-"
"cutting, tais como a demarcação da transação em beans de sessão EJB, "
"declarativamente com CMT. Se você se decidir usar demarcação programática de "
"transação, dê preferência à API <literal>Transaction</literal> do Hibernate "
"mostrada mais adiante neste capítulo, para facilidade no uso e portabilidade "
"de código. "

#. Tag: para
#, no-c-format
msgid ""
"Your application code can access a \"current session\" to process the "
"request by calling <literal>sessionFactory.getCurrentSession()</literal>. "
"You will always get a <literal>Session</literal> scoped to the current "
"database transaction. This has to be configured for either resource-local or "
"JTA environments, see <xref linkend=\"architecture-current-session\" />."
msgstr ""
"Seu código de aplicação pode acessar a \"sessão atual\" para processar a "
"requisição fazendo uma chamada simples a <literal>sessionFactory."
"getCurrentSession()</literal> em qualquer lugar e com a freqüência "
"necessária. Você sempre conseguirá uma <literal>Session</literal> limitada a "
"transação atual. Isto tem que ser configurado para recurso local ou para "
"ambientes JTA. Veja <xref linkend=\"architecture-current-session\" />."

#. Tag: para
#, no-c-format
msgid ""
"You can extend the scope of a <literal>Session</literal> and database "
"transaction until the \"view has been rendered\". This is especially useful "
"in servlet applications that utilize a separate rendering phase after the "
"request has been processed. Extending the database transaction until view "
"rendering, is achieved by implementing your own interceptor. However, this "
"will be difficult if you rely on EJBs with container-managed transactions. A "
"transaction will be completed when an EJB method returns, before rendering "
"of any view can start. See the Hibernate website and forum for tips and "
"examples relating to this <emphasis>Open Session in View</emphasis> pattern."
msgstr ""
"Ás vezes, é conveniente estender o escopo de uma <literal>Session</literal> "
"e de uma transação do banco de dados até que a \"visão esteja renderizada\". "
"É especialmente útil em aplicações servlet que utilizam uma fase de "
"renderização separada depois da requisição ter sido processada. Estender a "
"transação até que a renderização da visão esteja completa é fácil de fazer "
"se você implementar seu próprio interceptador. Entretanto, não será fácil se "
"você confiar em EJBs com transações gerenciadas por recipiente, porque uma "
"transação será terminada quando um método de EJB retornar, antes que a "
"renderização de toda visão possa começar. Veja o website e o fórum do "
"Hibernate para dicas e exemplos em torno deste modelo de <emphasis>Sessão "
"Aberta na Visualização</emphasis>."

#. Tag: title
#, no-c-format
msgid "Long conversations"
msgstr "Longas conversações"

#. Tag: para
#, no-c-format
msgid ""
"The session-per-request pattern is not the only way of designing units of "
"work. Many business processes require a whole series of interactions with "
"the user that are interleaved with database accesses. In web and enterprise "
"applications, it is not acceptable for a database transaction to span a user "
"interaction. Consider the following example:"
msgstr ""
"O modelo sessão-por-requisição não é o único conceito útil que você pode "
"usar ao projetar unidades de trabalho. Muitos processos de negócio requerem "
"uma totalidade de séries de interações com o usuário, intercaladas com "
"acessos a uma base de dados. Em aplicações da web e corporativas não é "
"aceitável que uma transação atrapalhe uma interação do usuário. Considere o "
"seguinte exemplo:"

#. Tag: para
#, no-c-format
msgid ""
"The first screen of a dialog opens. The data seen by the user has been "
"loaded in a particular <literal>Session</literal> and database transaction. "
"The user is free to modify the objects."
msgstr ""
"A primeira tela de um diálogo se abre e os dados vistos pelo usuário são "
"carregados em uma <literal>Session</literal> e transação de banco de dados "
"particulares. O usuário está livre para modificar os objetos. "

#. Tag: para
#, no-c-format
msgid ""
"The user clicks \"Save\" after 5 minutes and expects their modifications to "
"be made persistent. The user also expects that they were the only person "
"editing this information and that no conflicting modification has occurred."
msgstr ""
"O usuário clica em \"Salvar\" após 5 minutos e espera suas modificações "
"serem persistidas. O usuário também espera que ele seja a única pessoa que "
"edita esta informação e que nenhuma modificação conflitante possa ocorrer."

#. Tag: para
#, no-c-format
msgid ""
"From the point of view of the user, we call this unit of work a long-running "
"<emphasis>conversation</emphasis> or <emphasis>application transaction</"
"emphasis>. There are many ways to implement this in your application."
msgstr ""
"Nós chamamos esta unidade de trabalho, do ponto da visão do usuário, uma "
"<emphasis>conversação</emphasis> de longa duração (ou <emphasis>transação da "
"aplicação</emphasis>). Há muitas maneiras de você implementar em sua "
"aplicação. "

#. Tag: para
#, no-c-format
msgid ""
"A first naive implementation might keep the <literal>Session</literal> and "
"database transaction open during user think time, with locks held in the "
"database to prevent concurrent modification and to guarantee isolation and "
"atomicity. This is an anti-pattern, since lock contention would not allow "
"the application to scale with the number of concurrent users."
msgstr ""
"Uma primeira implementação simples pode manter a <literal>Session</literal> "
"e a transação aberta durante o tempo de interação do usuário, com bloqueios "
"na base de dados para impedir a modificação concorrente e para garantir o "
"isolamento e a atomicidade. Esse é naturalmente um anti-pattern, uma vez que "
"a disputa do bloqueio não permitiria o escalonameneto da aplicação com o "
"número de usuários concorrentes."

#. Tag: para
#, no-c-format
msgid ""
"You have to use several database transactions to implement the conversation. "
"In this case, maintaining isolation of business processes becomes the "
"partial responsibility of the application tier. A single conversation "
"usually spans several database transactions. It will be atomic if only one "
"of these database transactions (the last one) stores the updated data. All "
"others simply read data (for example, in a wizard-style dialog spanning "
"several request/response cycles). This is easier to implement than it might "
"sound, especially if you utilize some of Hibernate's features:"
msgstr ""
"Claramente, temos que usar diversas transações para implementar a "
"conversação. Neste caso, manter o isolamento dos processos de negócio, torna-"
"se responsabilidade parcial da camada da aplicação. Uma única conversação "
"geralmente usa diversas transações. Ela será atômica se somente uma destas "
"transações (a última) armazenar os dados atualizados, todas as outras "
"simplesmente leram os dados (por exemplo em um diálogo do estilo wizard que "
"mede diversos ciclos de requisição/resposta). Isto é mais fácil de "
"implementar do parece, especialmente se você usar as características do "
"Hibernate: "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Automatic Versioning</emphasis>: Hibernate can perform automatic "
"optimistic concurrency control for you. It can automatically detect if a "
"concurrent modification occurred during user think time. Check for this at "
"the end of the conversation."
msgstr ""
"<emphasis>Versionamento automático</emphasis>: o Hibernate pode fazer o "
"controle automático de concorrência otimista para você, ele pode "
"automaticamente detectar se uma modificação concorrente ocorreu durante o "
"tempo de interação do usuário. Geralmente nós verificamos somente no fim da "
"conversação. "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Detached Objects</emphasis>: if you decide to use the "
"<emphasis>session-per-request</emphasis> pattern, all loaded instances will "
"be in the detached state during user think time. Hibernate allows you to "
"reattach the objects and persist the modifications. The pattern is called "
"<emphasis>session-per-request-with-detached-objects</emphasis>. Automatic "
"versioning is used to isolate concurrent modifications."
msgstr ""
"<emphasis>Objetos Desanexados</emphasis>: se você se decidir usar o já "
"discutido pattern <emphasis>sessão-por-solicitação</emphasis>, todas as "
"instâncias carregadas estarão no estado destacado durante o tempo em que o "
"usuário estiver pensando. O Hibernate permite que você re-anexe os objetos e "
"persista as modificações, esse pattern é chamado <emphasis>sessão-por-"
"solicitação-com-objetos-desanexados</emphasis>. Utiliza-se versionamento "
"automático para isolar as modificações concorrentes."

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Extended (or Long) Session</emphasis>: the Hibernate "
"<literal>Session</literal> can be disconnected from the underlying JDBC "
"connection after the database transaction has been committed and reconnected "
"when a new client request occurs. This pattern is known as <emphasis>session-"
"per-conversation</emphasis> and makes even reattachment unnecessary. "
"Automatic versioning is used to isolate concurrent modifications and the "
"<literal>Session</literal> will not be allowed to be flushed automatically, "
"but explicitly."
msgstr ""
"<emphasis>Sessão Estendida (ou Longa)</emphasis> A <literal>Session</"
"literal> do Hibernate pode ser desligada da conexão adjacente do JDBC depois "
"que a transação foi submetida, e ser reconectada quando uma nova requisição "
"do cliente ocorrer. Este pattern é conhecido como <emphasis>sessão-por-"
"conversação</emphasis> e faz o reatamento uniforme desnecessário. "
"Versionamento automático é usado para isolar modificações concorrentes e a "
"<emphasis>sessão-por-conversação</emphasis> geralmente pode ser nivelada "
"automaticamente, e sim explicitamente. "

#. Tag: para
#, no-c-format
msgid ""
"Both <emphasis>session-per-request-with-detached-objects</emphasis> and "
"<emphasis>session-per-conversation</emphasis> have advantages and "
"disadvantages. These disadvantages are discussed later in this chapter in "
"the context of optimistic concurrency control."
msgstr ""
"Tanto a <emphasis>sessão-por-solicitação-com-objetos-desanexados</emphasis> "
"quanto a <emphasis>sessão-por-conversação</emphasis> possuem vantagens e "
"desvantagens. Estas desvantagens serão discutidas mais tarde neste capítulo "
"no contexto do controle de concorrência otimista. "

#. Tag: title
#, no-c-format
msgid "Considering object identity"
msgstr "Considerando a identidade do objeto"

#. Tag: para
#, no-c-format
msgid ""
"An application can concurrently access the same persistent state in two "
"different <literal>Session</literal>s. However, an instance of a persistent "
"class is never shared between two <literal>Session</literal> instances. It "
"is for this reason that there are two different notions of identity:"
msgstr ""
"Uma aplicação pode acessar concorrentemente o mesmo estado persistente em "
"duas <literal>Session</literal>s diferentes. Entretanto, uma instância de "
"uma classe persistente nunca é compartilhada entre duas instâncias "
"<literal>Session</literal>. Portanto, há duas noções diferentes da "
"identidade:  "

#. Tag: term
#, no-c-format
msgid "Database Identity"
msgstr "Identidade da base de dados"

#. Tag: para
#, no-c-format
msgid "<literal>foo.getId().equals( bar.getId() )</literal>"
msgstr "<literal>foo.getId().equals( bar.getId() )</literal>"

#. Tag: term
#, no-c-format
msgid "JVM Identity"
msgstr "Identidade da JVM"

#. Tag: para
#, no-c-format
msgid "<literal>foo==bar</literal>"
msgstr "<literal>foo==bar</literal>"

#. Tag: para
#, no-c-format
msgid ""
"For objects attached to a <emphasis>particular</emphasis> <literal>Session</"
"literal> (i.e., in the scope of a <literal>Session</literal>), the two "
"notions are equivalent and JVM identity for database identity is guaranteed "
"by Hibernate. While the application might concurrently access the \"same"
"\" (persistent identity) business object in two different sessions, the two "
"instances will actually be \"different\" (JVM identity). Conflicts are "
"resolved using an optimistic approach and automatic versioning at flush/"
"commit time."
msgstr ""
"Então para os objetos acoplados a uma <literal>Session</literal> "
"<emphasis>específica</emphasis> (ex.: isto está no escopo de uma "
"<literal>Session</literal>), as duas noções são equivalentes e a identidade "
"da JVM para a identidade da base de dados é garantida pelo Hibernate. "
"Entretanto, embora a aplicação possa acessar concorrentemente o \"mesmo\" "
"objeto do negócio (identidade persistente) em duas sessões diferentes, as "
"duas instâncias serão realmente \"diferentes\" (identidade de JVM). Os "
"conflitos são resolvidos usando (versionamento automático) no flush/commit, "
"usando uma abordagem otimista."

#. Tag: para
#, no-c-format
msgid ""
"This approach leaves Hibernate and the database to worry about concurrency. "
"It also provides the best scalability, since guaranteeing identity in single-"
"threaded units of work means that it does not need expensive locking or "
"other means of synchronization. The application does not need to synchronize "
"on any business object, as long as it maintains a single thread per "
"<literal>Session</literal>. Within a <literal>Session</literal> the "
"application can safely use <literal>==</literal> to compare objects."
msgstr ""
"Este caminho deixa o Hibernate e o banco de dados se preocuparem com a "
"concorrência. Ele também fornece uma escalabilidade melhor, garantindo que a "
"identidade em unidades de trabalho single-threaded não necessite de bloqueio "
"dispendioso ou de outros meios de sincronização. A aplicação nunca necessita "
"sincronizar qualquer objeto de negócio tão longo que transpasse uma única "
"thread por <literal>Session</literal>. Dentro de uma <literal>Session</"
"literal> a aplicação pode usar com segurança o <literal>==</literal> para "
"comparar objetos. "

#. Tag: para
#, no-c-format
msgid ""
"However, an application that uses <literal>==</literal> outside of a "
"<literal>Session</literal> might produce unexpected results. This might "
"occur even in some unexpected places. For example, if you put two detached "
"instances into the same <literal>Set</literal>, both might have the same "
"database identity (i.e., they represent the same row). JVM identity, "
"however, is by definition not guaranteed for instances in a detached state. "
"The developer has to override the <literal>equals()</literal> and "
"<literal>hashCode()</literal> methods in persistent classes and implement "
"their own notion of object equality. There is one caveat: never use the "
"database identifier to implement equality. Use a business key that is a "
"combination of unique, usually immutable, attributes. The database "
"identifier will change if a transient object is made persistent. If the "
"transient instance (usually together with detached instances) is held in a "
"<literal>Set</literal>, changing the hashcode breaks the contract of the "
"<literal>Set</literal>. Attributes for business keys do not have to be as "
"stable as database primary keys; you only have to guarantee stability as "
"long as the objects are in the same <literal>Set</literal>. See the "
"Hibernate website for a more thorough discussion of this issue. Please note "
"that this is not a Hibernate issue, but simply how Java object identity and "
"equality has to be implemented."
msgstr ""
"No entanto, uma aplicação que usa <literal>==</literal> fora de uma "
"<literal>Session</literal>, pode ver resultados inesperados. Isto pode "
"ocorrer mesmo em alguns lugares inesperados, por exemplo, se você colocar "
"duas instâncias desacopladas em um mesmo <literal>Set</literal>. Ambas podem "
"ter a mesma identidade na base de dados (ex.: elas representam a mesma "
"linha), mas a identidade da JVM não é, por definição, garantida para "
"instâncias em estado desacoplado. O desenvolvedor tem que substituir os "
"métodos <literal>equals()</literal> e <literal>hashCode()</literal> em "
"classes persistentes e implementar sua própria noção da igualdade do objeto. "
"Advertência: nunca use o identificador da base de dados para implementar a "
"igualdade, use atributos de negócio, uma combinação única, geralmente "
"imutável. O identificador da base de dados mudará se um objeto transiente "
"passar para o estado persistente. Se a instância transiente (geralmente "
"junto com instâncias desacopladas) for inserida em um <literal>Set</"
"literal>, a mudança do hashcode quebrará o contrato do <literal>Set</"
"literal>. As funções para chaves de negócio não têm que ser tão estável "
"quanto às chaves primárias da base de dados, você somente tem que garantir a "
"estabilidade durante o tempo que os objetos estiverem no mesmo <literal>Set</"
"literal>. Veja o website do Hibernate para uma discussão mais completa sobre "
"o assunto. Note também que esta não é uma característica do Hibernate, mas "
"simplesmente a maneira como a identidade e a igualdade do objeto de Java têm "
"que ser implementadas. "

#. Tag: title
#, no-c-format
msgid "Common issues"
msgstr "Edições comuns"

#. Tag: para
#, no-c-format
msgid ""
"Do not use the anti-patterns <emphasis>session-per-user-session</emphasis> "
"or <emphasis>session-per-application</emphasis> (there are, however, rare "
"exceptions to this rule). Some of the following issues might also arise "
"within the recommended patterns, so ensure that you understand the "
"implications before making a design decision:"
msgstr ""
"Nunca use o anti-patterns <emphasis>sessão-por-usuário-sessão</emphasis> ou "
"<emphasis>sessão-por-aplicação</emphasis> (naturalmente, existem exceções "
"raras para essa regra). Note que algumas das seguintes edições podem também "
"aparecer com modelos recomendados, certifique-se que tenha compreendido as "
"implicações antes de fazer uma decisão de projeto: "

#. Tag: para
#, no-c-format
msgid ""
"A <literal>Session</literal> is not thread-safe. Things that work "
"concurrently, like HTTP requests, session beans, or Swing workers, will "
"cause race conditions if a <literal>Session</literal> instance is shared. If "
"you keep your Hibernate <literal>Session</literal> in your "
"<literal>HttpSession</literal> (this is discussed later in the chapter), you "
"should consider synchronizing access to your Http session. Otherwise, a user "
"that clicks reload fast enough can use the same <literal>Session</literal> "
"in two concurrently running threads."
msgstr ""
"Uma <literal>Session</literal> não é threadsafe. As coisas que são supostas "
"para trabalhar concorrentemente, como requisições HTTP, beans de sessão, ou "
"Swing, causarão condições de disputa se uma instância <literal>Session</"
"literal> for compartilhada. Se você mantiver sua <literal>Session</literal> "
"do Hibernate em seu <literal>HttpSession</literal> (discutido mais tarde), "
"você deverá considerar sincronizar o acesso a sua sessão do HTTP. Caso "
"contrário, um usuário que clica em recarga rápido demais, pode usar o mesmo "
"<literal>Session</literal> em duas threads executando simultaneamente. "

#. Tag: para
#, no-c-format
msgid ""
"An exception thrown by Hibernate means you have to rollback your database "
"transaction and close the <literal>Session</literal> immediately (this is "
"discussed in more detail later in the chapter). If your <literal>Session</"
"literal> is bound to the application, you have to stop the application. "
"Rolling back the database transaction does not put your business objects "
"back into the state they were at the start of the transaction. This means "
"that the database state and the business objects will be out of sync. "
"Usually this is not a problem, because exceptions are not recoverable and "
"you will have to start over after rollback anyway."
msgstr ""
"Uma exceção lançada pelo Hibernate significa que você tem que dar rollback "
"na sua transação no banco de dados e fechar a <literal>Session</literal> "
"imediatamente (discutido mais tarde em maiores detalhes). Se sua "
"<literal>Session</literal> é limitada pela aplicação, você tem que parar a "
"aplicação. Fazer o rollback na transação no banco de dados não retorna seus "
"objetos do negócio ao estado que estavam no início da transação. Isto "
"significa que o estado da base de dados e os objetos de negócio perdem a "
"sincronização. Geralmente, não é um problema porque as exceções não são "
"recuperáveis e você tem que iniciar após o rollback de qualquer maneira. "

#. Tag: para
#, no-c-format
msgid ""
"The <literal>Session</literal> caches every object that is in a persistent "
"state (watched and checked for dirty state by Hibernate). If you keep it "
"open for a long time or simply load too much data, it will grow endlessly "
"until you get an OutOfMemoryException. One solution is to call <literal>clear"
"()</literal> and <literal>evict()</literal> to manage the <literal>Session</"
"literal> cache, but you should consider a Stored Procedure if you need mass "
"data operations. Some solutions are shown in <xref linkend=\"batch\" />. "
"Keeping a <literal>Session</literal> open for the duration of a user session "
"also means a higher probability of stale data."
msgstr ""
"A <literal>Session</literal> realiza o cache em cada objeto que se encontra o estado "
"persistente (assistido e checado para o estado dirty do Hibernate). Isto "
"significa o crescimento contínuo até chegar a um OutOfMemoryException, caso "
"você mantenha isto aberto por um longo período ou simplesmente carregue "
"muitos dados. Para resolver este problema, chame <literal>clear()</literal> "
"e <literal>evict()</literal> para gerenciar o cache da <literal>Session</"
"literal>, mas você ainda deve considerar a possibilidade de um Procedimento "
"Armazenado, caso precise de operações de dados em massa. Algumas soluções "
"poderão ser encontradas em <xref linkend=\"batch\"/>. Se você mantiver uma "
"<literal>Session</literal> aberta durante todo o tempo da sessão do usuário, "
"terá maior probabilidade de obter dados danificados. "

#. Tag: title
#, no-c-format
msgid "Database transaction demarcation"
msgstr "Demarcação de transações de bancos de dados"

#. Tag: para
#, no-c-format
msgid ""
"Database, or system, transaction boundaries are always necessary. No "
"communication with the database can occur outside of a database transaction "
"(this seems to confuse many developers who are used to the auto-commit "
"mode). Always use clear transaction boundaries, even for read-only "
"operations. Depending on your isolation level and database capabilities this "
"might not be required, but there is no downside if you always demarcate "
"transactions explicitly. Certainly, a single database transaction is going "
"to perform better than many small transactions, even for reading data."
msgstr ""
"Os limites de uma transação de banco de dados, ou sistema, são sempre "
"necessários. Nenhuma comunicação com o banco de dados pode ocorrer fora de "
"uma transação de banco de dados (isto parece confundir muitos "
"desenvolvedores que estão acostumados ao modo auto-commit). Sempre use os "
"limites desobstruídos da transação, até mesmo para operações somente "
"leitura. Dependendo de seu nível de isolamento e capacidade da base de dados "
"isto pode não ser requerido, mas não há nenhum aspecto negativo se você "
"sempre demarcar transações explicitamente. Certamente, uma única transação "
"será melhor executada do que muitas transações pequenas, até mesmo para "
"dados de leitura. "

#. Tag: para
#, no-c-format
msgid ""
"A Hibernate application can run in non-managed (i.e., standalone, simple "
"Web- or Swing applications) and managed J2EE environments. In a non-managed "
"environment, Hibernate is usually responsible for its own database "
"connection pool. The application developer has to manually set transaction "
"boundaries (begin, commit, or rollback database transactions) themselves. A "
"managed environment usually provides container-managed transactions (CMT), "
"with the transaction assembly defined declaratively (in deployment "
"descriptors of EJB session beans, for example). Programmatic transaction "
"demarcation is then no longer necessary."
msgstr ""
"Uma aplicação do Hibernate pode funcionar em ambientes não gerenciados (isto "
"é, aplicações standalone, Web simples ou Swing) e ambientes gerenciados "
"J2EE. Em um ambiente não gerenciado, o Hibernate é geralmente responsável "
"pelo seu próprio pool de conexões. O desenvolvedor, precisa ajustar "
"manualmente os limites das transaçãos, ou seja, começar, submeter ou efetar "
"rollback nas transações ele mesmo. Um ambiente gerenciado fornece transações "
"gerenciadas por recipiente (CMT), com um conjunto da transações definido "
"declarativamente em descritores de implementação de beans de sessão EJB, por "
"exemplo. A demarcação programática é portanto, não mais necessária."

#. Tag: para
#, no-c-format
msgid ""
"However, it is often desirable to keep your persistence layer portable "
"between non-managed resource-local environments, and systems that can rely "
"on JTA but use BMT instead of CMT. In both cases use programmatic "
"transaction demarcation. Hibernate offers a wrapper API called "
"<literal>Transaction</literal> that translates into the native transaction "
"system of your deployment environment. This API is actually optional, but we "
"strongly encourage its use unless you are in a CMT session bean."
msgstr ""
"Entretanto, é freqüentemente desejável manter sua camada de persistência "
"portável entre ambientes de recurso locais não gerenciados e sistemas que "
"podem confiar em JTA, mas use BMT ao invés de CMT. Em ambos os casos você "
"usaria demarcação de transação programática. O Hibernate oferece uma API "
"chamada Transaction que traduz dentro do sistema de transação nativa de seu "
"ambiente de implementação. Esta API é realmente opcional, mas nós "
"encorajamos fortemente seu uso a menos que você esteja em um bean de sessão "
"CMT.  "

#. Tag: para
#, no-c-format
msgid "Ending a <literal>Session</literal> usually involves four distinct phases:"
msgstr ""
"Geralmente, finalizar uma <literal>Session</literal> envolve quatro fases "
"distintas:"

#. Tag: para
#, no-c-format
msgid "flush the session"
msgstr "liberar a sessão"

#. Tag: para
#, no-c-format
msgid "commit the transaction"
msgstr "submeter a transação"

#. Tag: para
#, no-c-format
msgid "close the session"
msgstr "fechar a sessão"

#. Tag: para
#, no-c-format
msgid "handle exceptions"
msgstr "tratar as exceções"

#. Tag: para
#, no-c-format
msgid ""
"We discussed Flushing the session earlier, so we will now have a closer look "
"at transaction demarcation and exception handling in both managed and non-"
"managed environments."
msgstr ""
"A liberação da sessão já foi bem discutida, agora nós daremos uma olhada na "
"demarcação da transação e na manipulação de exceção em ambientes controlados "
"e não controlados. "

#. Tag: title
#, no-c-format
msgid "Non-managed environment"
msgstr "Ambiente não gerenciado"

#. Tag: para
#, no-c-format
msgid ""
"If a Hibernate persistence layer runs in a non-managed environment, database "
"connections are usually handled by simple (i.e., non-DataSource) connection "
"pools from which Hibernate obtains connections as needed. The session/"
"transaction handling idiom looks like this:"
msgstr ""
"Se uma camada de persistência do Hibernate roda em um ambiente não "
"gerenciado, as conexões do banco de dados são geralmente tratadas pelos "
"pools de conexões simples (ex.: não DataSource) dos quais o Hibernate obtém "
"as conexões assim que necessitar. A maneira de se manipular uma sessão/"
"transação é mais ou menos assim:"

#. Tag: para
#, no-c-format
msgid ""
"You do not have to <literal>flush()</literal> the <literal>Session</literal> "
"explicitly: the call to <literal>commit()</literal> automatically triggers "
"the synchronization depending on the <link linkend=\"objectstate-flushing"
"\">FlushMode</link> for the session. A call to <literal>close()</literal> "
"marks the end of a session. The main implication of <literal>close()</"
"literal> is that the JDBC connection will be relinquished by the session. "
"This Java code is portable and runs in both non-managed and JTA environments."
msgstr ""
"Você não pode chamar <literal>flush()</literal> da <literal>Session()</"
"literal> explicitamente. A chamada ao <literal>commit()</literal> dispara "
"automaticamente a sincronização para a sessão, dependendo do <xref linkend="
"\"objectstate-flushing\"/>. Uma chamada ao <literal>close()</literal> marca "
"o fim de uma sessão. A principal implicação do <literal>close()</literal> é "
"que a conexão JDBC será abandonada pela sessão. Este código Java é portável "
"e funciona em ambientes não gerenciados e de JTA.  "

#. Tag: para
#, no-c-format
msgid ""
"As outlined earlier, a much more flexible solution is Hibernate's built-in "
"\"current session\" context management:"
msgstr ""
"Uma solução muito mais flexível é o gerenciamento de contexto \"sessão atual"
"\" da construção interna do Hibernate, como descrito anteriormente: "

#. Tag: para
#, no-c-format
msgid ""
"You will not see these code snippets in a regular application; fatal "
"(system) exceptions should always be caught at the \"top\". In other words, "
"the code that executes Hibernate calls in the persistence layer, and the "
"code that handles <literal>RuntimeException</literal> (and usually can only "
"clean up and exit), are in different layers. The current context management "
"by Hibernate can significantly simplify this design by accessing a "
"<literal>SessionFactory</literal>. Exception handling is discussed later in "
"this chapter."
msgstr ""
"Você muito provavelmente nunca verá estes fragmentos de código em uma "
"aplicação regular; as exceções fatais (do sistema) devem sempre ser pegas no "
"\"topo\". Ou seja, o código que executa chamadas do Hibernate (na camada de "
"persistência) e o código que trata <literal>RuntimeException</literal> (e "
"geralmente pode somente limpar acima e na saída) estão em camadas "
"diferentes. O gerenciamento do contexto atual feito pelo Hibernate pode "
"significativamente simplificar este projeto, como tudo que você necessita é "
"do acesso a um <literal>SessionFactory</literal>. A manipulação de exceção é "
"discutida mais tarde neste capítulo. "

#. Tag: para
#, no-c-format
msgid ""
"You should select <literal>org.hibernate.transaction.JDBCTransactionFactory</"
"literal>, which is the default, and for the second example select <literal>"
"\"thread\"</literal> as your <literal>hibernate."
"current_session_context_class</literal>."
msgstr ""
"Note que você deve selecionar <literal>org.hibernate.transaction."
"JDBCTransactionFactory</literal>, que é o padrão, e para o segundo exemplo "
"<literal>\"thread\"</literal> como seu <literal>hibernate."
"current_session_context_class</literal>."

#. Tag: title
#, no-c-format
msgid "Using JTA"
msgstr "Usando JTA"

#. Tag: para
#, no-c-format
msgid ""
"If your persistence layer runs in an application server (for example, behind "
"EJB session beans), every datasource connection obtained by Hibernate will "
"automatically be part of the global JTA transaction. You can also install a "
"standalone JTA implementation and use it without EJB. Hibernate offers two "
"strategies for JTA integration."
msgstr ""
"Se sua camada de persistência funcionar em um servidor de aplicação (por "
"exemplo, dentro dos beans de sessão EJB), cada conexão da fonte de dados "
"obtida pelo Hibernate automaticamente fará parte da transação global de JTA. "
"Você pode também instalar uma implementação standalone de JTA e usá-la sem "
"EJB. O Hibernate oferece duas estratégias para a integração de JTA. "

#. Tag: para
#, no-c-format
msgid ""
"If you use bean-managed transactions (BMT), Hibernate will tell the "
"application server to start and end a BMT transaction if you use the "
"<literal>Transaction</literal> API. The transaction management code is "
"identical to the non-managed environment."
msgstr ""
"Se você usar transações de bean gerenciado (BMT) o Hibernate dirá ao "
"servidor de aplicação para começar e para terminar uma transação de BMT se "
"você usar a <literal>Transaction</literal> API. Assim, o código de gerência "
"de transação é idêntico ao ambiente não gerenciado."

#. Tag: para
#, no-c-format
msgid ""
"If you want to use a transaction-bound <literal>Session</literal>, that is, "
"the <literal>getCurrentSession()</literal> functionality for easy context "
"propagation, use the JTA <literal>UserTransaction</literal> API directly:"
msgstr ""
"Se você quiser usar uma <literal>Session</literal> limitada por transação, "
"isto é, a funcionalidade do <literal>getCurrentSession()</literal> para a "
"propagação fácil do contexto, você terá que usar diretamente a API JTA "
"<literal>UserTransaction</literal>: "

#. Tag: para
#, no-c-format
msgid ""
"With CMT, transaction demarcation is completed in session bean deployment "
"descriptors, not programmatically. The code is reduced to:"
msgstr ""
"Com CMT, a demarcação da transação é feita em descritores de implementação "
"de beans de sessão, não programaticamente, conseqüentemente, o código é "
"reduzido a: "

#. Tag: para
#, no-c-format
msgid ""
"In a CMT/EJB, even rollback happens automatically. An unhandled "
"<literal>RuntimeException</literal> thrown by a session bean method tells "
"the container to set the global transaction to rollback. <emphasis>You do "
"not need to use the Hibernate <literal>Transaction</literal> API at all with "
"BMT or CMT, and you get automatic propagation of the \"current\" Session "
"bound to the transaction.</emphasis>"
msgstr ""
"Em um CMT/EJB, até mesmo um rollback acontece automaticamente, desde que uma "
"exceção <literal>RuntimeException</literal> não tratável seja lançada por um "
"método de um bean de sessão que informa ao recipiente ajustar a transação "
"global ao rollback. <emphasis>Isto significa que você não precisa mesmo usar "
"a API <literal>Transaction</literal> do Hibernate com BMT ou CMT e você "
"obterá a propagação automática da Sessão \"atual\" limitada à transação.</"
"emphasis> "

#. Tag: para
#, no-c-format
msgid ""
"When configuring Hibernate's transaction factory, choose <literal>org."
"hibernate.transaction.JTATransactionFactory</literal> if you use JTA "
"directly (BMT), and <literal>org.hibernate.transaction."
"CMTTransactionFactory</literal> in a CMT session bean. Remember to also set "
"<literal>hibernate.transaction.manager_lookup_class</literal>. Ensure that "
"your <literal>hibernate.current_session_context_class</literal> is either "
"unset (backwards compatibility), or is set to <literal>\"jta\"</literal>."
msgstr ""
"Veja que você deverá escolher <literal>org.hibernate.transaction."
"JTATransactionFactory</literal> se você usar o JTA diretamente (BMT) e "
"<literal>org.hibernate.transaction.CMTTransactionFactory</literal> em um "
"bean de sessão CMT, quando você configura a fábrica de transação do "
"Hibernate. Lembre-se também de configurar o <literal>hibernate.transaction."
"manager_lookup_class</literal>. Além disso, certifique-se que seu "
"<literal>hibernate.current_session_context_class</literal> ou não é "
"configurado (compatibilidade com o legado) ou está definido para <literal>"
"\"jta\"</literal>. "

#. Tag: para
#, no-c-format
msgid ""
"The <literal>getCurrentSession()</literal> operation has one downside in a "
"JTA environment. There is one caveat to the use of <literal>after_statement</"
"literal> connection release mode, which is then used by default. Due to a "
"limitation of the JTA spec, it is not possible for Hibernate to "
"automatically clean up any unclosed <literal>ScrollableResults</literal> or "
"<literal>Iterator</literal> instances returned by <literal>scroll()</"
"literal> or <literal>iterate()</literal>. You <emphasis>must</emphasis> "
"release the underlying database cursor by calling <literal>ScrollableResults."
"close()</literal> or <literal>Hibernate.close(Iterator)</literal> explicitly "
"from a <literal>finally</literal> block. Most applications can easily avoid "
"using <literal>scroll()</literal> or <literal>iterate()</literal> from the "
"JTA or CMT code.)"
msgstr ""
"A operação <literal>getCurrentSession()</literal> tem um aspecto negativo em "
"um ambiente JTA. Há uma advertência para o uso do método liberado de conexão "
"<literal>after_statement</literal>, o qual é usado então por padrão. Devido "
"a uma limitação simples da especificação JTA, não é possível para o "
"Hibernate automaticamente limpar quaisquer instâncias "
"<literal>ScrollableResults</literal> ou <literal>Iterator</literal> abertas "
"retornadas pelo <literal>scroll()</literal> ou <literal>iterate()</literal>. "
"Você <emphasis>deve</emphasis> liberar o cursor subjacente da base de dados "
"chamando <literal>ScrollableResults.close()</literal> ou <literal>Hibernate."
"close(Iterator)</literal> explicitamente de um bloco <literal>finally</"
"literal>. Claro que a maioria das aplicações podem facilmente evitar o uso "
"do <literal>scroll()</literal> ou do <literal>iterate()</literal> em todo "
"código provindo do JTA ou do CMT."

#. Tag: title
#, no-c-format
msgid "Exception handling"
msgstr "Tratamento de Exceção"

#. Tag: para
#, no-c-format
msgid ""
"If the <literal>Session</literal> throws an exception, including any "
"<literal>SQLException</literal>, immediately rollback the database "
"transaction, call <literal>Session.close()</literal> and discard the "
"<literal>Session</literal> instance. Certain methods of <literal>Session</"
"literal> will <emphasis>not</emphasis> leave the session in a consistent "
"state. No exception thrown by Hibernate can be treated as recoverable. "
"Ensure that the <literal>Session</literal> will be closed by calling "
"<literal>close()</literal> in a <literal>finally</literal> block."
msgstr ""
"Se a <literal>Session</literal> levantar uma exceção, incluindo qualquer "
"<literal>SQLException</literal>, você deverá imediatamente dar um rollback "
"na transação do banco, chamando <literal>Session.close()</literal> e "
"descartando a instância da <literal>Session</literal>. Certos métodos da "
"<literal>Session</literal><literal>não</literal> deixarão a sessão em um "
"estado inconsistente. Nenhuma exceção lançada pelo Hibernate pode ser "
"recuperada. Certifique-se que a <literal>Session</literal> será fechada "
"chamando <literal>close()</literal> no bloco <literal>finally</literal>. "

#. Tag: para
#, no-c-format
msgid ""
"The <literal>HibernateException</literal>, which wraps most of the errors "
"that can occur in a Hibernate persistence layer, is an unchecked exception. "
"It was not in older versions of Hibernate. In our opinion, we should not "
"force the application developer to catch an unrecoverable exception at a low "
"layer. In most systems, unchecked and fatal exceptions are handled in one of "
"the first frames of the method call stack (i.e., in higher layers) and "
"either an error message is presented to the application user or some other "
"appropriate action is taken. Note that Hibernate might also throw other "
"unchecked exceptions that are not a <literal>HibernateException</literal>. "
"These are not recoverable and appropriate action should be taken."
msgstr ""
"A exceção <literal>HibernateException</literal>, a qual envolve a maioria "
"dos erros que podem ocorrer em uma camada de persistência do Hibernate, é "
"uma exceção não verificada. Ela não constava em versões mais antigas de "
"Hibernate. Em nossa opinião, nós não devemos forçar o desenvolvedor a tratar "
"uma exceção irrecuperável em uma camada mais baixa. Na maioria dos sistemas, "
"as exceções não verificadas e fatais são tratadas em um dos primeiros frames "
"da pilha da chamada do método (isto é, em umas camadas mais elevadas) e uma "
"mensagem de erro é apresentada ao usuário da aplicação (ou alguma outra ação "
"apropriada é feita). Note que Hibernate pode também lançar outras exceções "
"não verificadas que não sejam um <literal>HibernateException</literal>. "
"Estas, também são, irrecuperáveis e uma ação apropriada deve ser tomada. "

#. Tag: para
#, no-c-format
msgid ""
"Hibernate wraps <literal>SQLException</literal>s thrown while interacting "
"with the database in a <literal>JDBCException</literal>. In fact, Hibernate "
"will attempt to convert the exception into a more meaningful subclass of "
"<literal>JDBCException</literal>. The underlying <literal>SQLException</"
"literal> is always available via <literal>JDBCException.getCause()</"
"literal>. Hibernate converts the <literal>SQLException</literal> into an "
"appropriate <literal>JDBCException</literal> subclass using the "
"<literal>SQLExceptionConverter</literal> attached to the "
"<literal>SessionFactory</literal>. By default, the "
"<literal>SQLExceptionConverter</literal> is defined by the configured "
"dialect. However, it is also possible to plug in a custom implementation. "
"See the javadocs for the <literal>SQLExceptionConverterFactory</literal> "
"class for details. The standard <literal>JDBCException</literal> subtypes "
"are:"
msgstr ""
"O Hibernate envolve <literal>SQLException</literal>s lançadas ao interagir "
"com a base de dados em um <literal>JDBCException</literal>. Na realidade, o "
"Hibernate tentará converter a exceção em uma subclasse mais significativa da "
"<literal>JDBCException</literal>. A <literal>SQLException</literal> "
"subjacente está sempre disponível através de <literal>JDBCException.getCause"
"()</literal>. O Hibernate converte a <literal>SQLException</literal> em uma "
"subclasse <literal>JDBCException</literal> apropriada usando "
"<literal>SQLExceptionConverter</literal> associado ao "
"<literal>SessionFactory</literal>. Por padrão, o "
"<literal>SQLExceptionConverter</literal> é definido pelo dialeto "
"configurado. Entretanto, é também possível conectar em uma implementação "
"customizada. Veja o javadoc para mais detalhes da classe "
"<literal>SQLExceptionConverterFactory</literal>. Os subtipos padrão de "
"<literal>JDBCException</literal> são: "

#. Tag: para
#, no-c-format
msgid ""
"<literal>JDBCConnectionException</literal>: indicates an error with the "
"underlying JDBC communication."
msgstr ""
"<literal>JDBCConnectionException</literal>: indica um erro com a comunicação "
"subjacente de JDBC."

#. Tag: para
#, no-c-format
msgid ""
"<literal>SQLGrammarException</literal>: indicates a grammar or syntax "
"problem with the issued SQL."
msgstr ""
"<literal>SQLGrammarException</literal>: indica um problema da gramática ou "
"da sintáxe com o SQL emitido."

#. Tag: para
#, no-c-format
msgid ""
"<literal>ConstraintViolationException</literal>: indicates some form of "
"integrity constraint violation."
msgstr ""
"<literal>ConstraintViolationException</literal>: indica algum forma de "
"violação de confinamento de integridade."

#. Tag: para
#, no-c-format
msgid ""
"<literal>LockAcquisitionException</literal>: indicates an error acquiring a "
"lock level necessary to perform the requested operation."
msgstr ""
"<literal>LockAcquisitionException</literal>: indica um erro ao adquirir um "
"nível de bloqueio necessário para realizar a operação de requisição."

#. Tag: para
#, no-c-format
msgid ""
"<literal>GenericJDBCException</literal>: a generic exception which did not "
"fall into any of the other categories."
msgstr ""
"<literal>GenericJDBCException</literal>: uma exceção genérica que não está "
"inclusa em nenhuma das outras categorias."

#. Tag: title
#, no-c-format
msgid "Transaction timeout"
msgstr "Tempo de espera de Transação"

#. Tag: para
#, no-c-format
msgid ""
"An important feature provided by a managed environment like EJB, that is "
"never provided for non-managed code, is transaction timeout. Transaction "
"timeouts ensure that no misbehaving transaction can indefinitely tie up "
"resources while returning no response to the user. Outside a managed (JTA) "
"environment, Hibernate cannot fully provide this functionality. However, "
"Hibernate can at least control data access operations, ensuring that "
"database level deadlocks and queries with huge result sets are limited by a "
"defined timeout. In a managed environment, Hibernate can delegate "
"transaction timeout to JTA. This functionality is abstracted by the "
"Hibernate <literal>Transaction</literal> object."
msgstr ""
"O tempo de espera de transação é uma característica extremamente importante "
"fornecida por um ambiente gerenciado como EJB e que nunca é fornecido pelo "
"código não gerenciado. Os tempos de espera de transação asseguram que "
"nenhuma transação retenha indefinidamente recursos enquanto não retornar "
"nenhuma resposta ao usuário. Fora de um ambiente controlado (JTA), o "
"Hibernate não pode fornecer inteiramente esta funcionalidade. Entretanto, o "
"Hibernate pode afinal controlar as operações do acesso a dados, assegurando "
"que o nível de deadlocks e consultas do banco de dados com imensos "
"resultados definidos sejam limitados pelo tempo de espera. Em um ambiente "
"gerenciado, o Hibernate pode delegar o tempo de espera da transação ao JTA. "
"Esta funcionalidade é abstraída pelo objeto <literal>Transaction</literal> "
"do Hibernate. "

#. Tag: para
#, no-c-format
msgid ""
"<literal>setTimeout()</literal> cannot be called in a CMT bean, where "
"transaction timeouts must be defined declaratively."
msgstr ""
"Veja que <literal>setTimeout()</literal> não pode ser chamado em um bean "
"CMT, onde o tempo de espera das transações deve ser definido declaradamente. "

#. Tag: title
#, no-c-format
msgid "Optimistic concurrency control"
msgstr "Controle de concorrência otimista"

#. Tag: para
#, no-c-format
msgid ""
"The only approach that is consistent with high concurrency and high "
"scalability, is optimistic concurrency control with versioning. Version "
"checking uses version numbers, or timestamps, to detect conflicting updates "
"and to prevent lost updates. Hibernate provides three possible approaches to "
"writing application code that uses optimistic concurrency. The use cases we "
"discuss are in the context of long conversations, but version checking also "
"has the benefit of preventing lost updates in single database transactions."
msgstr ""
"O único caminho que é consistente com a elevada concorrência e "
"escalabilidade é o controle de concorrência otimista com versionamento. A "
"checagem de versão usa número de versão, ou carimbo de hora (timestamp), "
"para detectar conflitos de atualizações (e para impedir atualizações "
"perdidas). O Hibernate fornece três caminhos possíveis para escrever "
"aplicações que usam concorrência otimista. Os casos de uso que nós mostramos "
"estão no contexto de conversações longas, mas a checagem de versão também "
"tem o benefício de impedir atualizações perdidas em únicas transações. "

#. Tag: title
#, no-c-format
msgid "Application version checking"
msgstr "Checagem de versão da aplicação"

#. Tag: para
#, no-c-format
msgid ""
"In an implementation without much help from Hibernate, each interaction with "
"the database occurs in a new <literal>Session</literal> and the developer is "
"responsible for reloading all persistent instances from the database before "
"manipulating them. The application is forced to carry out its own version "
"checking to ensure conversation transaction isolation. This approach is the "
"least efficient in terms of database access. It is the approach most similar "
"to entity EJBs."
msgstr ""
"Em uma implementação sem muita ajuda do Hibernate, cada interação com o "
"banco de dados ocorre em uma nova <literal>Session</literal> e o "
"desenvolvedor é responsável por recarregar todas as instâncias persistentes "
"da base de dados antes de manipulá-las. Este caminho força a aplicação a "
"realizar sua própria checagem de versão para assegurar a conversação do "
"isolamento da transação. Este caminho é menos eficiente em termos de acesso "
"ao banco de dados. É o caminho mais similar à entidade EJBs."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>version</literal> property is mapped using <literal>&lt;"
"version&gt;</literal>, and Hibernate will automatically increment it during "
"flush if the entity is dirty."
msgstr ""
"A propriedade <literal>version</literal> é mapeada usando <literal>&lt;"
"version&gt;</literal>, e o Hibernate vai incrementá-lá automaticamente "
"durante a liberação se a entidade estiver alterada."

#. Tag: para
#, no-c-format
msgid ""
"If you are operating in a low-data-concurrency environment, and do not "
"require version checking, you can use this approach and skip the version "
"check. In this case, <emphasis>last commit wins</emphasis> is the default "
"strategy for long conversations. Be aware that this might confuse the users "
"of the application, as they might experience lost updates without error "
"messages or a chance to merge conflicting changes."
msgstr ""
"Claro, se você estiver operando em um ambiente de baixa concorrência de "
"dados e não precisar da checagem de versão, você pode usar este caminho e "
"apenas pular a checagem de versão. Nesse caso, o <emphasis>último commit "
"realizado</emphasis> é a estratégia padrão para suas conversações longas. "
"Tenha em mente que isto pode confundir os usuários da aplicação, como também "
"poderão ter atualizações perdidas sem mensagens de erro ou uma possibilidade "
"de ajustar mudanças conflitantes."

#. Tag: para
#, no-c-format
msgid ""
"Manual version checking is only feasible in trivial circumstances and not "
"practical for most applications. Often not only single instances, but "
"complete graphs of modified objects, have to be checked. Hibernate offers "
"automatic version checking with either an extended <literal>Session</"
"literal> or detached instances as the design paradigm."
msgstr ""
"Claro que, a checagem manual da versão é somente possível em circunstâncias "
"triviais e não para a maioria de aplicações. Freqüentemente, os "
"gráficoscompletos de objetos modificados têm que ser verificados, não "
"somente únicas instâncias. O Hibernate oferece checagem de versão automática "
"com uma <literal>Session</literal> estendida ou instâncias desatachadas como "
"o paradigma do projeto. "

#. Tag: title
#, no-c-format
msgid "Extended session and automatic versioning"
msgstr "Sessão estendida e versionamento automático"

#. Tag: para
#, no-c-format
msgid ""
"A single <literal>Session</literal> instance and its persistent instances "
"that are used for the whole conversation are known as <emphasis>session-per-"
"conversation</emphasis>. Hibernate checks instance versions at flush time, "
"throwing an exception if concurrent modification is detected. It is up to "
"the developer to catch and handle this exception. Common options are the "
"opportunity for the user to merge changes or to restart the business "
"conversation with non-stale data."
msgstr ""
"Uma única instância de <literal>Session</literal> e suas instâncias "
"persistentes são usadas para a conversação inteira, isto é conhecido como "
"<emphasis>sessão-por-conversação</emphasis>. O Hibernate verifica versões da "
"instância no momento da liberação, lançando uma exceção se a modificação "
"concorrente for detectada. Até o desenvolvedor pegar e tratar essa exceção. "
"As opções comuns são a oportunidade para que o usuário intercale as mudanças "
"ou reinicie a conversação do negócio com dados não antigos."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>Session</literal> is disconnected from any underlying JDBC "
"connection when waiting for user interaction. This approach is the most "
"efficient in terms of database access. The application does not version "
"check or reattach detached instances, nor does it have to reload instances "
"in every database transaction."
msgstr ""
"A <literal>Session</literal> é desconectada de toda a conexão JDBC adjacente "
"enquanto espera a interação do usuário. Este caminho é o mais eficiente em "
"termos de acesso a bancos de dados. A aplicação não precisa se preocupar com "
"a checagem de versão ou com as instâncias destacadas reatadas, nem precisa "
"recarregar instâncias a cada transação."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>foo</literal> object knows which <literal>Session</literal> it "
"was loaded in. Beginning a new database transaction on an old session "
"obtains a new connection and resumes the session. Committing a database "
"transaction disconnects a session from the JDBC connection and returns the "
"connection to the pool. After reconnection, to force a version check on data "
"you are not updating, you can call <literal>Session.lock()</literal> with "
"<literal>LockMode.READ</literal> on any objects that might have been updated "
"by another transaction. You do not need to lock any data that you "
"<emphasis>are</emphasis> updating. Usually you would set <literal>FlushMode."
"MANUAL</literal> on an extended <literal>Session</literal>, so that only the "
"last database transaction cycle is allowed to actually persist all "
"modifications made in this conversation. Only this last database transaction "
"will include the <literal>flush()</literal> operation, and then "
"<literal>close()</literal> the session to end the conversation."
msgstr ""
"O objeto <literal>foo</literal> sabe que a <literal>Session</literal> já foi "
"carregada. Ao começar uma nova transação ou uma sessão velha, você obterá "
"uma conexão nova e reiniciará a sessão. Submeter uma transação implica em "
"desconectar uma sessão da conexão JDBC e retornar à conexão ao pool. Após a "
"reconexão, para forçar uma checagem de versão em dados que você não esteja "
"atualizando, você poderá chamar <literal>Session.lock()</literal> com o "
"<literal>LockMode.READ</literal> em todos os objetos que possam ter sido "
"atualizados por uma outra transação. Você não precisa bloquear nenhum dado "
"que você <emphasis>está</emphasis> atualizando. Geralmente, você "
"configuraria <literal>FlushMode.NEVER</literal> em uma <literal>Session</"
"literal> estendida, de modo que somente o último ciclo da transação tenha "
"permissão de persistir todas as modificações feitas nesta conversação. Por "
"isso, somente esta última transação incluiria a operação <literal>flush()</"
"literal> e então também iria <literal>close()</literal> a sessão para "
"terminar a conversação. "

#. Tag: para
#, no-c-format
msgid ""
"This pattern is problematic if the <literal>Session</literal> is too big to "
"be stored during user think time (for example, an <literal>HttpSession</"
"literal> should be kept as small as possible). As the <literal>Session</"
"literal> is also the first-level cache and contains all loaded objects, we "
"can probably use this strategy only for a few request/response cycles. Use a "
"<literal>Session</literal> only for a single conversation as it will soon "
"have stale data."
msgstr ""
"Este modelo é problemático se a <literal>Session</literal> for "
"demasiadamente grande para ser armazenada durante o tempo de espera do "
"usuário (por exemplo uma <literal>HttpSession</literal> deve ser mantida o "
"menor possível). Como a <literal>Session</literal> é também cache de "
"primeiro nível (imperativo) e contém todos os objetos carregados, nós "
"podemos provavelmente usar esta estratégia somente para alguns ciclos de "
"requisição/resposta. Você deve usar a <literal>Session</literal> somente "
"para uma única conversação, porque ela logo também estará com dados velhos. "

#. Tag: title
#, no-c-format
msgid "Note"
msgstr "Nota"

#. Tag: para
#, no-c-format
msgid ""
"Earlier versions of Hibernate required explicit disconnection and "
"reconnection of a <literal>Session</literal>. These methods are deprecated, "
"as beginning and ending a transaction has the same effect."
msgstr ""
"Note que versões mais atuais de Hibernate requerem a desconexão e reconexão "
"explícitas de uma <literal>Session</literal>. Estes métodos são "
"desatualizados, pois o início e término de uma transação têm o mesmo efeito."

#. Tag: para
#, no-c-format
msgid ""
"Keep the disconnected <literal>Session</literal> close to the persistence "
"layer. Use an EJB stateful session bean to hold the <literal>Session</"
"literal> in a three-tier environment. Do not transfer it to the web layer, "
"or even serialize it to a separate tier, to store it in the "
"<literal>HttpSession</literal>."
msgstr ""
"Note também que você deve manter a <literal>Session</literal> desconectada, "
"fechada para a camada de persistência. Ou seja, use um bean de sessão com "
"estado EJB para prender a <literal>Session</literal> em um ambiente de três "
"camadas. Não transfira à camada web, ou até serializá-lo para uma camada "
"separada, para armazená-lo no <literal>HttpSession</literal>."

#. Tag: para
#, no-c-format
msgid ""
"The extended session pattern, or <emphasis>session-per-conversation</"
"emphasis>, is more difficult to implement with automatic current session "
"context management. You need to supply your own implementation of the "
"<literal>CurrentSessionContext</literal> for this. See the Hibernate Wiki "
"for examples."
msgstr ""
"O modelo da sessão estendida, ou <emphasis>sessão-por-conversação</"
"emphasis>, é mais difícil de implementar com gerenciamento automático de "
"sessão atual. Você precisa fornecer sua própria implementação do "
"<literal>CurrentSessionContext</literal> para isto. Veja o Hibernate Wiki "
"para exemplos."

#. Tag: title
#, no-c-format
msgid "Detached objects and automatic versioning"
msgstr "Objetos destacados e versionamento automático"

#. Tag: para
#, no-c-format
msgid ""
"Each interaction with the persistent store occurs in a new <literal>Session</"
"literal>. However, the same persistent instances are reused for each "
"interaction with the database. The application manipulates the state of "
"detached instances originally loaded in another <literal>Session</literal> "
"and then reattaches them using <literal>Session.update()</literal>, "
"<literal>Session.saveOrUpdate()</literal>, or <literal>Session.merge()</"
"literal>."
msgstr ""
"Cada interação com o armazenamento persistente ocorre em uma "
"<literal>Session</literal> nova. Entretanto, as mesmas instâncias "
"persistentes são reusadas para cada interação com o banco de dados. A "
"aplicação manipula o estado das instâncias desatachadas originalmente "
"carregadas em uma outra <literal>Session</literal> e as reata então usando "
"<literal>Session.update()</literal>, <literal>Session.saveOrUpdate()</"
"literal> ou <literal>Session.merge()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Again, Hibernate will check instance versions during flush, throwing an "
"exception if conflicting updates occurred."
msgstr ""
"Outra vez, o Hibernate verificará versões da instância durante a liberação, "
"lançando uma exceção se ocorrer conflitos de atualizações. "

#. Tag: para
#, no-c-format
msgid ""
"You can also call <literal>lock()</literal> instead of <literal>update()</"
"literal>, and use <literal>LockMode.READ</literal> (performing a version "
"check and bypassing all caches) if you are sure that the object has not been "
"modified."
msgstr ""
"Você pode também chamar o <literal>lock()</literal> em vez de <literal>update"
"()</literal> e usar <literal>LockMode.READ</literal> (executando uma "
"checagem de versão, ignorando todos os caches) se você estiver certo de que "
"o objeto não foi modificado. "

#. Tag: title
#, no-c-format
msgid "Customizing automatic versioning"
msgstr "Versionamento automático customizado"

#. Tag: para
#, no-c-format
msgid ""
"You can disable Hibernate's automatic version increment for particular "
"properties and collections by setting the <literal>optimistic-lock</literal> "
"mapping attribute to <literal>false</literal>. Hibernate will then no longer "
"increment versions if the property is dirty."
msgstr ""
"Você pode desabilitar o incremento da versão automática de Hibernate para "
"propriedades e coleções particulares, configurando a função de mapeamento "
"<literal>optimistic-lock</literal> para <literal>false</literal>. O "
"Hibernate então, não incrementará mais versões se a propriedade estiver "
"modificada. "

#. Tag: para
#, no-c-format
msgid ""
"Legacy database schemas are often static and cannot be modified. Or, other "
"applications might access the same database and will not know how to handle "
"version numbers or even timestamps. In both cases, versioning cannot rely on "
"a particular column in a table. To force a version check with a comparison "
"of the state of all fields in a row but without a version or timestamp "
"property mapping, turn on <literal>optimistic-lock=\"all\"</literal> in the "
"<literal>&lt;class&gt;</literal> mapping. This conceptually only works if "
"Hibernate can compare the old and the new state (i.e., if you use a single "
"long <literal>Session</literal> and not session-per-request-with-detached-"
"objects)."
msgstr ""
"Os esquemas da base de dados legado são freqüentemente estáticos e não podem "
"ser modificados. Ou então, outras aplicações puderam também acessar a mesma "
"base de dados e não sabem tratar a versão dos números ou carimbos de hora. "
"Em ambos os casos, o versionamento não pode confiar em uma coluna particular "
"em uma tabela. Para forçar uma checagem de versão sem uma versão ou "
"mapeamento da propriedade do carimbo de hora com uma comparação do estado de "
"todos os campos em uma linha, configure <literal>optimistic-lock=\"all\"</"
"literal> no mapeamento <literal>&lt;class&gt;</literal>. Note que isto "
"conceitualmente é somente feito em trabalhos se o Hibernate puder comparar o "
"estado velho e novo (ex.: se você usar uma única <literal>Session</literal> "
"longa e não uma sessão-por-solicitação-com-objetos-desanexados)."

#. Tag: para
#, no-c-format
msgid ""
"Concurrent modification can be permitted in instances where the changes that "
"have been made do not overlap. If you set <literal>optimistic-lock=\"dirty"
"\"</literal> when mapping the <literal>&lt;class&gt;</literal>, Hibernate "
"will only compare dirty fields during flush."
msgstr ""
"Às vezes a modificação concorrente pode ser permitida, desde que as mudanças "
"realizadas não se sobreponham. Se você configurar <literal>optimistic-lock="
"\"dirty\"</literal> ao mapear o <literal>&lt;class&gt;</literal>, o "
"Hibernate comparará somente campos modificados durante a liberação. "

#. Tag: para
#, no-c-format
msgid ""
"In both cases, with dedicated version/timestamp columns or with a full/dirty "
"field comparison, Hibernate uses a single <literal>UPDATE</literal> "
"statement, with an appropriate <literal>WHERE</literal> clause, per entity "
"to execute the version check and update the information. If you use "
"transitive persistence to cascade reattachment to associated entities, "
"Hibernate may execute unnecessary updates. This is usually not a problem, "
"but <emphasis>on update</emphasis> triggers in the database might be "
"executed even when no changes have been made to detached instances. You can "
"customize this behavior by setting <literal>select-before-update=\"true\"</"
"literal> in the <literal>&lt;class&gt;</literal> mapping, forcing Hibernate "
"to <literal>SELECT</literal> the instance to ensure that changes did occur "
"before updating the row."
msgstr ""
"Em ambos os casos, com as colunas de versão/carimbo de hora dedicados com "
"comparação de campo cheio/sujo, o Hibernate usa uma única instrução "
"<literal>UPDATE</literal>, com uma cláusula <literal>WHERE</literal> "
"apropriada, por entidade para executar a checagem da versão e atualizar a "
"informação. Se você usar a persistência transitiva para cascatear o "
"reatamento das entidades associadas, o Hibernate pode executar atualizações "
"desnecessárias. Isso não é geralmente um problema, mas os triggers "
"<emphasis>em atualizações</emphasis> num banco de dados pode ser executado "
"mesmo quando nenhuma mudança foi feita nas instâncias desanexadas. Você pode "
"customizar este comportamento configurando <literal>selecionar-antes-de "
"atualizar=\"verdadeiro\"</literal> no mapeamento <literal>&lt;class&gt;</"
"literal>, forçando o Hibernate a fazer um <literal>SELECT</literal> nas "
"instâncias para assegurar-se de que as mudanças realmente aconteceram, antes "
"de atualizar a linha. "

#. Tag: title
#, no-c-format
msgid "Pessimistic locking"
msgstr "Bloqueio Pessimista "

#. Tag: para
#, no-c-format
msgid ""
"It is not intended that users spend much time worrying about locking "
"strategies. It is usually enough to specify an isolation level for the JDBC "
"connections and then simply let the database do all the work. However, "
"advanced users may wish to obtain exclusive pessimistic locks or re-obtain "
"locks at the start of a new transaction."
msgstr ""
"Não ha intenção alguma que usuários gastem muitas horas se preocupando com "
"suas estratégias de bloqueio. Geralmente, é o bastante especificar um nível "
"de isolamento para as conexões JDBC e então deixar simplesmente o banco de "
"dados fazer todo o trabalho. Entretanto, os usuários avançados podem às "
"vezes desejar obter bloqueios pessimistas exclusivos, ou re-obter bloqueios "
"no início de uma nova transação. "

#. Tag: para
#, no-c-format
msgid ""
"Hibernate will always use the locking mechanism of the database; it never "
"lock objects in memory."
msgstr ""
"O Hibernate usará sempre o mecanismo de bloqueio da base de dados, nunca "
"bloquiar objetos na memória."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>LockMode</literal> class defines the different lock levels that "
"can be acquired by Hibernate. A lock is obtained by the following mechanisms:"
msgstr ""
"A classe <literal>LockMode</literal> define os diferentes níveis de bloqueio "
"que o Hibernate pode adquirir. Um bloqueio é obtido pelos seguintes "
"mecanismos: "

#. Tag: para
#, no-c-format
msgid ""
"<literal>LockMode.WRITE</literal> is acquired automatically when Hibernate "
"updates or inserts a row."
msgstr ""
"<literal>LockMode.WRITE</literal> é adquirido automaticamente quando o "
"Hibernate atualiza ou insere uma linha."

#. Tag: para
#, no-c-format
msgid ""
"<literal>LockMode.UPGRADE</literal> can be acquired upon explicit user "
"request using <literal>SELECT ... FOR UPDATE</literal> on databases which "
"support that syntax."
msgstr ""
"<literal>LockMode.UPGRADE</literal> pode ser adquirido explicitamente pelo "
"usuário usando <literal>SELECT ... FOR UPDATE</literal> em um banco de dados "
"que suporte essa sintáxe. "

#. Tag: para
#, no-c-format
msgid ""
"<literal>LockMode.UPGRADE_NOWAIT</literal> can be acquired upon explicit "
"user request using a <literal>SELECT ... FOR UPDATE NOWAIT</literal> under "
"Oracle."
msgstr ""
"<literal>LockMode.UPGRADE_NOWAIT</literal> pode ser adquirido explicitamente "
"pelo usuário usando <literal>SELECT ... FOR UPDATE NOWAIT</literal> no "
"Oracle. "

#. Tag: para
#, no-c-format
msgid ""
"<literal>LockMode.READ</literal> is acquired automatically when Hibernate "
"reads data under Repeatable Read or Serializable isolation level. It can be "
"re-acquired by explicit user request."
msgstr ""
"<literal>LockMode.READ</literal> é adquirido automaticamente quando o "
"Hibernate lê dados em um nível de Leitura Repetida ou isolamento "
"Serializável. Pode ser readquirido explicitamente pelo usuário. "

#. Tag: para
#, no-c-format
msgid ""
"<literal>LockMode.NONE</literal> represents the absence of a lock. All "
"objects switch to this lock mode at the end of a <literal>Transaction</"
"literal>. Objects associated with the session via a call to <literal>update()"
"</literal> or <literal>saveOrUpdate()</literal> also start out in this lock "
"mode."
msgstr ""
"<literal>LockMode.NONE</literal> representa a ausência do bloqueio. Todos os "
"objetos mudam para esse estado de bloqueio no final da <literal>Transaction</"
"literal>. Objetos associados com a sessão através do método <literal>update()"
"</literal> ou <literal>saveOrUpdate()</literal> também são inicializados com "
"esse modo de bloqueio."

#. Tag: para
#, no-c-format
msgid "The \"explicit user request\" is expressed in one of the following ways:"
msgstr "O bloqueio obtido \"explicitamente pelo usuário\" se dá nas seguintes formas:"

#. Tag: para
#, no-c-format
msgid ""
"A call to <literal>Session.load()</literal>, specifying a <literal>LockMode</"
"literal>."
msgstr ""
"Uma chamada a <literal>Session.load()</literal>, especificando o "
"<literal>LockMode</literal>."

#. Tag: para
#, no-c-format
msgid "A call to <literal>Session.lock()</literal>."
msgstr "Uma chamada à <literal>Session.lock()</literal>."

#. Tag: para
#, no-c-format
msgid "A call to <literal>Query.setLockMode()</literal>."
msgstr "Uma chamada à <literal>Query.setLockMode()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"If <literal>Session.load()</literal> is called with <literal>UPGRADE</"
"literal> or <literal>UPGRADE_NOWAIT</literal>, and the requested object was "
"not yet loaded by the session, the object is loaded using "
"<literal>SELECT ... FOR UPDATE</literal>. If <literal>load()</literal> is "
"called for an object that is already loaded with a less restrictive lock "
"than the one requested, Hibernate calls <literal>lock()</literal> for that "
"object."
msgstr ""
"Se uma <literal>Session.load()</literal> é invocada com <literal>UPGRADE</"
"literal> ou <literal>UPGRADE_NOWAIT</literal>, e o objeto requisitado ainda "
"não foi carregado pela sessão, o objeto é carregado usando "
"<literal>SELECT ... FOR UPDATE</literal>. Se <literal>load()</literal> for "
"chamado para um objeto que já foi carregado com um bloqueio menos restritivo "
"que o novo bloqueio solicitado, o Hibernate invoca o método <literal>lock()</"
"literal> para aquele objeto."

#. Tag: para
#, no-c-format
msgid ""
"<literal>Session.lock()</literal> performs a version number check if the "
"specified lock mode is <literal>READ</literal>, <literal>UPGRADE</literal> "
"or <literal>UPGRADE_NOWAIT</literal>. In the case of <literal>UPGRADE</"
"literal> or <literal>UPGRADE_NOWAIT</literal>, <literal>SELECT ... FOR "
"UPDATE</literal> is used."
msgstr ""
"O <literal>Session.lock()</literal> executa uma verificação no número da "
"versão se o modo de bloqueio especificado for <literal>READ</literal>, "
"<literal>UPGRADE</literal> ou <literal>UPGRADE_NOWAIT</literal>. No caso do "
"<literal>UPGRADE</literal> ou <literal>UPGRADE_NOWAIT</literal>, é usado "
"<literal>SELECT ... FOR UPDATE</literal>."

#. Tag: para
#, no-c-format
msgid ""
"If the requested lock mode is not supported by the database, Hibernate uses "
"an appropriate alternate mode instead of throwing an exception. This ensures "
"that applications are portable."
msgstr ""
"Se o banco de dados não suportar o modo de bloqueio solicitado, o Hibernate "
"usará um modo alternativo apropriado, ao invés de lançar uma exceção. Isso "
"garante que a aplicação seja portátil. "

#. Tag: title
#, no-c-format
msgid "Connection release modes"
msgstr "Modos para liberar a conexão"

#. Tag: para
#, no-c-format
msgid ""
"One of the legacies of Hibernate 2.x JDBC connection management meant that a "
"<literal>Session</literal> would obtain a connection when it was first "
"required and then maintain that connection until the session was closed. "
"Hibernate 3.x introduced the notion of connection release modes that would "
"instruct a session how to handle its JDBC connections. The following "
"discussion is pertinent only to connections provided through a configured "
"<literal>ConnectionProvider</literal>. User-supplied connections are outside "
"the breadth of this discussion. The different release modes are identified "
"by the enumerated values of <literal>org.hibernate.ConnectionReleaseMode</"
"literal>:"
msgstr ""
"O comportamento legado do Hibernate 2.x referente ao gerenciamento da "
"conexão via JDBC era que a <literal>Session</literal> precisaria obter uma "
"conexão quando ela precisasse pela primeira vez e depois manteria a conexão "
"enquanto a sessão não fosse fechada. O Hibernate 3.x introduz a idéia de "
"modos para liberar a sessão, para informar a sessão a forma como deve "
"manusear a sua conexão JDBC. Veja que essa discussão só é pertinente para "
"conexões fornecidas com um <literal>ConnectionProvider</literal> "
"configurado. As conexões fornecidas pelo usuário estão fora do escopo dessa "
"discussão. Os diferentes modos de liberação estão definidos pelos valores da "
"enumeração <literal>org.hibernate.ConnectionReleaseMode</literal>:"

#. Tag: para
#, no-c-format
msgid ""
"<literal>ON_CLOSE</literal>: is the legacy behavior described above. The "
"Hibernate session obtains a connection when it first needs to perform some "
"JDBC access and maintains that connection until the session is closed."
msgstr ""
"<literal>ON_CLOSE</literal>: é o modo legado descrito acima. A sessão do "
"Hibernate obtém a conexão quando precisar executar alguma operação JDBC pela "
"primeira vez e mantém enquanto a conexão não for fechada."

#. Tag: para
#, no-c-format
msgid ""
"<literal>AFTER_TRANSACTION</literal>: releases connections after a "
"<literal>org.hibernate.Transaction</literal> has been completed."
msgstr ""
"<literal>AFTER_TRANSACTION</literal>: informa que a conexão deve ser "
"liberada após a conclusão de uma <literal>org.hibernate.Transaction</"
"literal>. "

#. Tag: para
#, no-c-format
msgid ""
"<literal>AFTER_STATEMENT</literal> (also referred to as aggressive release): "
"releases connections after every statement execution. This aggressive "
"releasing is skipped if that statement leaves open resources associated with "
"the given session. Currently the only situation where this occurs is through "
"the use of <literal>org.hibernate.ScrollableResults</literal>."
msgstr ""
"<literal>AFTER_STATEMENT</literal> (também conhecida como liberação "
"agressiva): informa que a conexão deve ser liberada após a execução de cada "
"instrução. A liberação agressiva não ocorre se a instrução deixa pra trás "
"algum recurso aberto associado com a sessão obtida. Atualmente, a única "
"situação em que isto ocorre é com o uso de <literal>org.hibernate."
"ScrollableResults</literal>. "

#. Tag: para
#, no-c-format
msgid ""
"The configuration parameter <literal>hibernate.connection.release_mode</"
"literal> is used to specify which release mode to use. The possible values "
"are as follows:"
msgstr ""
"O parâmetro de configuração <literal>hibernate.connection.release_mode</"
"literal> é usado para especificar qual modo de liberação deve ser usado. "
"Segue abaixo os valores possíveis:"

#. Tag: para
#, no-c-format
msgid ""
"<literal>auto</literal> (the default): this choice delegates to the release "
"mode returned by the <literal>org.hibernate.transaction.TransactionFactory."
"getDefaultReleaseMode()</literal> method. For JTATransactionFactory, this "
"returns ConnectionReleaseMode.AFTER_STATEMENT; for JDBCTransactionFactory, "
"this returns ConnectionReleaseMode.AFTER_TRANSACTION. Do not change this "
"default behavior as failures due to the value of this setting tend to "
"indicate bugs and/or invalid assumptions in user code."
msgstr ""
"<literal>auto</literal> (padrão): essa opção delega ao modo de liberação "
"retornado pelo método <literal>org.hibernate.transaction.TransactionFactory."
"getDefaultReleaseMode()</literal>. Para JTATransactionFactory, ele retorna "
"ConnectionReleaseMode.AFTER_STATEMENT; para JDBCTransactionFactory, ele "
"retorna ConnectionReleaseMode.AFTER_TRANSACTION. Raramente, é uma boa idéia "
"alterar padrão, pois ao se fazer isso temos falhas que parecem bugs e/ou "
"suposições inválidas no código do usuário. "

#. Tag: para
#, no-c-format
msgid ""
"<literal>on_close</literal>: uses ConnectionReleaseMode.ON_CLOSE. This "
"setting is left for backwards compatibility, but its use is discouraged."
msgstr ""
"<literal>on_close</literal>: indica o uso da ConnectionReleaseMode.ON_CLOSE. "
"Essa opção foi deixada para manter a compatibilidade, mas seu uso é "
"fortemente desencorajado. "

#. Tag: para
#, no-c-format
msgid ""
"<literal>after_transaction</literal>: uses ConnectionReleaseMode."
"AFTER_TRANSACTION. This setting should not be used in JTA environments. Also "
"note that with ConnectionReleaseMode.AFTER_TRANSACTION, if a session is "
"considered to be in auto-commit mode, connections will be released as if the "
"release mode were AFTER_STATEMENT."
msgstr ""
"<literal>after_transaction</literal>: indica o uso da ConnectionReleaseMode."
"AFTER_TRANSACTION. Essa opção não deve ser usada com ambientes JTA. Também "
"note que no caso da ConnectionReleaseMode.AFTER_TRANSACTION, se a sessão foi "
"colocada no modo auto-commit a conexão vai ser liberada de forma similar ao "
"modo AFTER_STATEMENT. "

#. Tag: para
#, no-c-format
msgid ""
"<literal>after_statement</literal>: uses ConnectionReleaseMode."
"AFTER_STATEMENT. Additionally, the configured <literal>ConnectionProvider</"
"literal> is consulted to see if it supports this setting "
"(<literal>supportsAggressiveRelease()</literal>). If not, the release mode "
"is reset to ConnectionReleaseMode.AFTER_TRANSACTION. This setting is only "
"safe in environments where we can either re-acquire the same underlying JDBC "
"connection each time you make a call into <literal>ConnectionProvider."
"getConnection()</literal> or in auto-commit environments where it does not "
"matter if we re-establish the same connection."
msgstr ""
"<literal>after_statement</literal>: indica o uso ConnectionReleaseMode."
"AFTER_STATEMENT. Além disso, o <literal>ConnectionProvider</literal> "
"configurado é consultado para verificar se suporta essa configuração "
"(<literal>supportsAggressiveRelease()</literal>). Se não suportar, o modo de "
"liberação é redefinido como ConnectionRelease-Mode.AFTER_TRANSACTION. Essa "
"configuração só é segura em ambientes onde podemos tanto readquirir a mesma "
"conexão JDBC adjacente todas as vezes que chamarmos "
"<literal>ConnectionProvider.getConnection()</literal> quanto em um ambiente "
"auto-commit, onde não importa se voltamos para a mesma conexão. "

