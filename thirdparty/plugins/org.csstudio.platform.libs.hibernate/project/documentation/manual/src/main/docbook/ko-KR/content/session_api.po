msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-04T04:51:22\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, no-c-format
msgid "Working with objects"
msgstr "객체들로 작업하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate is a full object/relational mapping solution that not only shields "
"the developer from the details of the underlying database management system, "
"but also offers <emphasis>state management</emphasis> of objects. This is, "
"contrary to the management of SQL <literal>statements</literal> in common "
"JDBC/SQL persistence layers, a natural object-oriented view of persistence "
"in Java applications."
msgstr ""
"Hibernate는 기본 데이터베이스 관리 시스템의 상세로부터 개발자들을 은폐시켜줄 "
"뿐만 아니라, 또한 객체들에 대한 <emphasis>상태 관리</emphasis>를 제공하는 하"
"나의 완전한 객체/관계형 매핑 솔루션이다. 이것은 공통적인 JDBC/SQL 영속 계층"
"들 내에서의 SQL <literal>문장들</literal>에 대한 관리와는 반대로, 자바 어플리"
"케이션들에서 영속에 관한 매우 고유한 객체-지향적 관점이다."

#. Tag: para
#, no-c-format
msgid ""
"In other words, Hibernate application developers should always think about "
"the <emphasis>state</emphasis> of their objects, and not necessarily about "
"the execution of SQL statements. This part is taken care of by Hibernate and "
"is only relevant for the application developer when tuning the performance "
"of the system."
msgstr ""
"달리 말해, Hibernate 어플리케이션 개발자들은 그들의 객체들의 <emphasis>상태</"
"emphasis>에 대해 항상 생각해야 하고, SQL 문장들의 실행에 대해서는 필수적이지 "
"않다. 이 부분은 Hibernate에 의해 처리되고 시스템의 퍼포먼스를 튜닝할 때 어플"
"리케이션 개발자와 유일하게 관련된다."

#. Tag: title
#, no-c-format
msgid "Hibernate object states"
msgstr "Hibernate 객체 상태들"

#. Tag: para
#, no-c-format
msgid "Hibernate defines and supports the following object states:"
msgstr "Hibernate 다음 객체 상태들을 정의하고 지원한다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis>Transient</emphasis> - an object is transient if it has just been "
"instantiated using the <literal>new</literal> operator, and it is not "
"associated with a Hibernate <literal>Session</literal>. It has no persistent "
"representation in the database and no identifier value has been assigned. "
"Transient instances will be destroyed by the garbage collector if the "
"application does not hold a reference anymore. Use the Hibernate "
"<literal>Session</literal> to make an object persistent (and let Hibernate "
"take care of the SQL statements that need to be executed for this "
"transition)."
msgstr ""
"<emphasis>Transient</emphasis> - 만일 객체가 <literal>new</literal> 연산자를 "
"사용하여 방금 초기화 되었다면 객체는 transient이고, 그것은 Hibernate "
"<literal>Session</literal>과 연관되어 있지 않다. 그것은 데이터베이스 내에서 "
"영속 표상을 갖지 않고 식별자 값이 할당되지 않았다. 만일 어플리케이션이 더 이"
"상 참조를 소유하지 않을 경우 transient 인스턴스들은 쓰레기 수집기에 의해 파괴"
"될 것이다. 객체를 영속화 시키는데 (그리고 이 전이(transition)에 대해 실행될 "
"필요가 있는 SQL 문장들을 Hibernate로 하여금 처리하도록 하는데) Hibernate "
"<literal>Session</literal>을 사용하라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis>Persistent</emphasis> - a persistent instance has a representation "
"in the database and an identifier value. It might just have been saved or "
"loaded, however, it is by definition in the scope of a <literal>Session</"
"literal>. Hibernate will detect any changes made to an object in persistent "
"state and synchronize the state with the database when the unit of work "
"completes. Developers do not execute manual <literal>UPDATE</literal> "
"statements, or <literal>DELETE</literal> statements when an object should be "
"made transient."
msgstr ""
"<emphasis>Persistent</emphasis> - 하나의 영속 인스턴스는 데이터베이스 내에서 "
"하나의 표상을 갖고 하나의 식별자 값을 갖는다. 그것은 방금 저장되었거나 로드되"
"었을 수 있지만, 정의상 그것은 <literal>Session</literal>의 범위 내에 있다. "
"Hibernate는 영속 상태에서 객체에 대해 행해진 임의의 변경들을 검출해낼 것이고 "
"단위 작업이 완료될 때 그 상태를 데이터베이스와 동기화 시킬 것이다. 개발자들"
"은 하나의 객체가 transient로 되어야 할 때 <literal>UPDATE</literal> 문장들이"
"나 <literal>DELETE</literal> 문장들을 수작업으로 실행하지 않는다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis>Detached</emphasis> - a detached instance is an object that has "
"been persistent, but its <literal>Session</literal> has been closed. The "
"reference to the object is still valid, of course, and the detached instance "
"might even be modified in this state. A detached instance can be reattached "
"to a new <literal>Session</literal> at a later point in time, making it (and "
"all the modifications) persistent again. This feature enables a programming "
"model for long running units of work that require user think-time. We call "
"them <emphasis>application transactions</emphasis>, i.e., a unit of work "
"from the point of view of the user."
msgstr ""
"<emphasis>Detached</emphasis> - 하나의 detached 인스턴스는 영속화 되었지만, "
"그것의 <literal>Session</literal>이 닫혀진 객체이다. 물론 그 객체에 대한 참조"
"는 여전히 유효하고, 그 detached 인스턴스는 이 상태에서도 변경될 수도 있다. 하"
"나의 detached 인스턴스는 나중에 그것(과 모두 변경들)을 다시 영속화 시켜서 새"
"로운 <literal>Session</literal>에 다시 첨부될 수 있다. 이 특징은 사용자가 생"
"각할 시간을 필요로 하는 장 기간 실행되는 작업 단위를 위한 프로그래밍 모형을 "
"가능하게 해준다. 우리는 그것들을 <emphasis>어플리케이션 트랜잭션들</"
"emphasis>, 즉 사용자의 관점의 작업 단위라고 부른다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"We will now discuss the states and state transitions (and the Hibernate "
"methods that trigger a transition) in more detail."
msgstr ""
"이제 우리는 상태들과 상태 전이(transition)들(그리고 전이를 트리거 시키는 "
"Hibernate 메소드들)을 상세하게 논의할 것이다."

#. Tag: title
#, no-c-format
msgid "Making objects persistent"
msgstr "객체들을 영속화 시키기"

#. Tag: para
#, no-c-format
msgid ""
"Newly instantiated instances of a a persistent class are considered "
"<emphasis>transient</emphasis> by Hibernate. We can make a transient "
"instance <emphasis>persistent</emphasis> by associating it with a session:"
msgstr ""
"하나의 영속 클래스의 새로이 초기화 된 인스턴스들은 Hibernate에 의해 "
"<emphasis>transient</emphasis>로 간주된다. 우리는 그것을 세션과 연관지어서 "
"transient 인스턴스를 <emphasis>영속화</emphasis> 시킬 수 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If <literal>Cat</literal> has a generated identifier, the identifier is "
"generated and assigned to the <literal>cat</literal> when <literal>save()</"
"literal> is called. If <literal>Cat</literal> has an <literal>assigned</"
"literal> identifier, or a composite key, the identifier should be assigned "
"to the <literal>cat</literal> instance before calling <literal>save()</"
"literal>. You can also use <literal>persist()</literal> instead of "
"<literal>save()</literal>, with the semantics defined in the EJB3 early "
"draft."
msgstr ""
"만일 <literal>Cat</literal>이 생성된 식별자를 가질 경우, <literal>save()</"
"literal>가 호출될 때 그 식별자가 생성되고 <literal>cat</literal>에 할당된다. "
"만일 <literal>Cat</literal>이 하나의 <literal>assigned</literal> 식별자나 하"
"나의 composite key를 가질 경우, <literal>save()</literal>를 호출하기 전에 그 "
"식별자가<literal>cat</literal> 인스턴스에 할당될 것이다. 당신은 또한 EJB3 초"
"기 드래프트에서 정의된 의미로 <literal>save()</literal> 대신 <literal>persist"
"()</literal>를 사용할 수도 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>persist()</literal> makes a transient instance persistent. However, "
"it does not guarantee that the identifier value will be assigned to the "
"persistent instance immediately, the assignment might happen at flush time. "
"<literal>persist()</literal> also guarantees that it will not execute an "
"<literal>INSERT</literal> statement if it is called outside of transaction "
"boundaries. This is useful in long-running conversations with an extended "
"Session/persistence context."
msgstr ""
"UNTRANSLATED! <literal>persist()</literal> makes a transient instance "
"persistent. However, it doesn't guarantee that the identifier value will be "
"assigned to the persistent instance immediately, the assignment might happen "
"at flush time. <literal>persist()</literal> also guarantees that it will not "
"execute an <literal>INSERT</literal> statement if it is called outside of "
"transaction boundaries. This is useful in long-running conversations with an "
"extended Session/persistence context."

#. Tag: para
#, no-c-format
msgid ""
"<literal>save()</literal> does guarantee to return an identifier. If an "
"INSERT has to be executed to get the identifier ( e.g. \"identity\" "
"generator, not \"sequence\"), this INSERT happens immediately, no matter if "
"you are inside or outside of a transaction. This is problematic in a long-"
"running conversation with an extended Session/persistence context."
msgstr ""
"<literal>save()</literal> does guarantee to return an identifier. If an "
"INSERT has to be executed to get the identifier ( e.g. \"identity\" "
"generator, not \"sequence\"), this INSERT happens immediately, no matter if "
"you are inside or outside of a transaction. This is problematic in a long-"
"running conversation with an extended Session/persistence context."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Alternatively, you can assign the identifier using an overloaded version of "
"<literal>save()</literal>."
msgstr ""
"다른 방법으로, 당신은 <literal>save()</literal>의 오버로드된 버전을 사용하여 "
"식별자를 할당할 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If the object you make persistent has associated objects (e.g. the "
"<literal>kittens</literal> collection in the previous example), these "
"objects can be made persistent in any order you like unless you have a "
"<literal>NOT NULL</literal> constraint upon a foreign key column. There is "
"never a risk of violating foreign key constraints. However, you might "
"violate a <literal>NOT NULL</literal> constraint if you <literal>save()</"
"literal> the objects in the wrong order."
msgstr ""
"만일 당신이 영속화 시키는 객체가 연관된 객체들(예를 들면. 앞의 예제에 있는 "
"<literal>kittens</literal> 콜렉션)을 갖고 있다면, 당신이 하나의 foreign 키 컬"
"럼에 대해 하나의 <literal>NOT NULL</literal> 컨스트레인트를 갖지 않는 한, 이"
"들 객체들은 당신이 좋아하는 임의의 순서로 영속화 되었을 수도 있다. foreign "
"키 컨스트레인트들을 위배하는 위험성이 결코 존재하지 않는다. 하지만 당신이 잘"
"못된 순서로 그 객체들을 <literal>save()</literal> 시킬 경우 당신은 "
"<literal>NOT NULL</literal> 컨스트레인트를 위배할 수도 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Usually you do not bother with this detail, as you will normally use "
"Hibernate's <emphasis>transitive persistence</emphasis> feature to save the "
"associated objects automatically. Then, even <literal>NOT NULL</literal> "
"constraint violations do not occur - Hibernate will take care of everything. "
"Transitive persistence is discussed later in this chapter."
msgstr ""
"당신이 연관된 객체들을 자동적으로 저장시키는데 Hibernate의 "
"<emphasis>transitive persistence(전이 영속)</emphasis> 특징을 사용하는 것을 "
"매우 좋아할 것이므로 대개 당신은 이 상세를 내버려둔다. 그때 <literal>NOT "
"NULL</literal> 컨스트레인트 위배들이 발생되지 않을지라도 - Hibernate는 모든 "
"것을 처리할 것이다. Transitive persistence(전이 영속)은 이 장에서 후반부에서 "
"논의된다."

#. Tag: title
#, no-c-format
msgid "Loading an object"
msgstr "객체를 로드시키기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>load()</literal> methods of <literal>Session</literal> provide "
"a way of retrieving a persistent instance if you know its identifier. "
"<literal>load()</literal> takes a class object and loads the state into a "
"newly instantiated instance of that class in a persistent state."
msgstr ""
"<literal>Session</literal>의 <literal>load()</literal> 메소드들은 만일 당신"
"이 그것(영속 인스턴스)의 식별자들을 이미 알고 있을 경우에 영속 인스턴스를 검"
"색하는 방법을 당신에게 제공한다. <literal>load()</literal>는 하나의 클래스 객"
"체를 취하고 그 상태를 영속(persistent) 상태로 그 클래스의 새로이 초기화 된 인"
"스턴스 속으로 로드시킬 것이다."

#. Tag: para
#, no-c-format
msgid "Alternatively, you can load state into a given instance:"
msgstr "다른 방법으로 당신은 주어진 인스턴스 속으로 상태를 로드시킬 수 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Be aware that <literal>load()</literal> will throw an unrecoverable "
"exception if there is no matching database row. If the class is mapped with "
"a proxy, <literal>load()</literal> just returns an uninitialized proxy and "
"does not actually hit the database until you invoke a method of the proxy. "
"This is useful if you wish to create an association to an object without "
"actually loading it from the database. It also allows multiple instances to "
"be loaded as a batch if <literal>batch-size</literal> is defined for the "
"class mapping."
msgstr ""
"만일 일치하는 데이터베이스 행이 존재하지 않을 경우에 <literal>load()</"
"literal>가 unrecoverable(복구 불가능한) 예외상황을 던질 것임을 노트하라. 만"
"일 클래스가 프락시를 갖도록 매핑된 경우, <literal>load()</literal>는 초기화 "
"되지 않은 프락시를 단지 반환하고 당신이 그 프락시의 메소드를 호출하기 전까지"
"는 실제로 데이터베이스에 접속하지 않는다. 당신이 데이터베이스로부터 객체에 대"
"한 연관을 실제로 로드시키지 않고서 객체에 대한 연관을 생성시키고자 원할 경우"
"에 이 특징이 매우 유용하다. 만일 <literal>batch-size</literal>가 class 매핑"
"에 정의되는 경우 그것은 또한 다중 인스턴스들이 하나의 배치로서 로드되는 것을 "
"허용해준다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you are not certain that a matching row exists, you should use the "
"<literal>get()</literal> method which hits the database immediately and "
"returns null if there is no matching row."
msgstr ""
"만일 당신이 하나의 일치하는 행이 존재하는지를 확신할 수 없을 경우, 당신은 "
"<literal>get()</literal> 메소드를 사용해야 한다. 그것(<literal>get()</"
"literal> 메소드)는 데이터베이스에 즉시 접속하고 만일 일치하는 행이 없을 경우 "
"null을 반환한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can even load an object using an SQL <literal>SELECT ... FOR UPDATE</"
"literal>, using a <literal>LockMode</literal>. See the API documentation for "
"more information."
msgstr ""
"당신은 하나의 <literal>LockMode</literal>를 사용하는, <literal>SELECT ... "
"FOR UPDATE</literal>를 사용하여 하나의 객체를 로드시킬 수도 있다. 추가 정보"
"는 API 문서를 보라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Any associated instances or contained collections will <emphasis>not</"
"emphasis> be selected <literal>FOR UPDATE</literal>, unless you decide to "
"specify <literal>lock</literal> or <literal>all</literal> as a cascade style "
"for the association."
msgstr ""
"어떤 연관된 인스턴스들이나 포함된 콜렉션들은 당신이 그 연관에 대한 케스케이"
"드 스타일로서 <literal>lock</literal> 또는 <literal>all</literal>을 지정하도"
"록 결정하지 않는 한, <literal>FOR UPDATE</literal>로 선택되지 않음을 노트하"
"라."

#. Tag: para
#, no-c-format
msgid ""
"It is possible to re-load an object and all its collections at any time, "
"using the <literal>refresh()</literal> method. This is useful when database "
"triggers are used to initialize some of the properties of the object."
msgstr ""
"<literal>refresh()</literal> 메소드를 사용하여, 아무때나 하나의 객체와 모든 "
"그것의 콜렉션들을 다시 로드시키는 것이 가능하다. 데이터베이스 트리거들이 그 "
"객체의 프로퍼티들 중 어떤 것을 초기화 시키는데 사용될 때 이것이 유용하다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"How much does Hibernate load from the database and how many SQL "
"<literal>SELECT</literal>s will it use? This depends on the "
"<emphasis>fetching strategy</emphasis>. This is explained in <xref linkend="
"\"performance-fetching\" />."
msgstr ""
"중요한 질문이 대개 이 지점에서 나타난다: Hibernate는 데이터베이로부터 그것을 "
"얼마나 많이 로드시키고 그리고 얼마나 많은 SQL <literal>SELECT</literal>들이 "
"그것을 사용할 것인가? 이것은 <emphasis>페칭 방도</emphasis>에 의존하고 <xref "
"linkend=\"performance-fetching\"/>에 설명되어 있다."

#. Tag: title
#, no-c-format
msgid "Querying"
msgstr "질의하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you do not know the identifiers of the objects you are looking for, you "
"need a query. Hibernate supports an easy-to-use but powerful object oriented "
"query language (HQL). For programmatic query creation, Hibernate supports a "
"sophisticated Criteria and Example query feature (QBC and QBE). You can also "
"express your query in the native SQL of your database, with optional support "
"from Hibernate for result set conversion into objects."
msgstr ""
"만일 당신이 당신이 찾고 있는 객체들에 대한 식별자들을 모를 경우, 당신은 하나"
"의 질의를 필요로 한다. Hibernate는 사용이 쉽지만 강력한 객체 지향 질의 언어"
"(HQL)를 지원한다. 프로그램 상의 질의 생성을 위해, Hibernate는 정교한 "
"Criteria 및 Example 질의 특징(QBC와 QBE)를 지원한다. 당신은 또한 객체들로의 "
"결과 셋 변환을 위한 선택적인 Hibernate의 지원으로, 당신의 데이터베이스의 "
"native SQL 속에 당신의 질의를 표현할 수도 있다."

#. Tag: title
#, no-c-format
msgid "Executing queries"
msgstr "질의들을 실행하기"

#. Tag: para
#, no-c-format
msgid ""
"HQL and native SQL queries are represented with an instance of <literal>org."
"hibernate.Query</literal>. This interface offers methods for parameter "
"binding, result set handling, and for the execution of the actual query. You "
"always obtain a <literal>Query</literal> using the current <literal>Session</"
"literal>:"
msgstr ""
"HQL 질의와 native SQL 질의는 <literal>org.hibernate.Query</literal>의 인스턴"
"스로 표현된다. 이 인터페이스는 파라미터 바인딩, 결과셋 핸들링을 위한, 그리고 "
"실제 질의의 실행을 위한 메소드들을 제공한다. 당신은 항상 현재 "
"<literal>Session</literal>을 사용하여 하나의 <literal>Query</literal>를 얻는"
"다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A query is usually executed by invoking <literal>list()</literal>. The "
"result of the query will be loaded completely into a collection in memory. "
"Entity instances retrieved by a query are in a persistent state. The "
"<literal>uniqueResult()</literal> method offers a shortcut if you know your "
"query will only return a single object. Queries that make use of eager "
"fetching of collections usually return duplicates of the root objects, but "
"with their collections initialized. You can filter these duplicates through "
"a <literal>Set</literal>."
msgstr ""
"하나의 질의는 대개 <literal>list()</literal>를 호출하여 실행되고, 질의의 결과"
"는 메모리 내에서 하나의 콜렉션 속으로 전체적으로 로드될 것이다. 하나의 질의"
"에 의해 검색된 엔티티 인스턴스들은 영속(persistent) 상태에 있다. 당신의 질의"
"가 하나의 객체를 오직 반환할 것임을 당신이 알고 있을 경우에 "
"<literal>uniqueResult()</literal> 메소드는 단축을 제공한다. 콜렉션들에 대해 "
"eager 페칭을 사용하는 질의들은 대개 (그것들의 초기화된 콜렉션들을 가진) 루트 "
"객체들에 대한 중복들을 대개 반환한다. 당신은 <literal>Set</literal>을 통해 이"
"들 중복들을 간단하게 필터링할 수 있다."

#. Tag: title
#, no-c-format
msgid "Iterating results"
msgstr "결과들을 반복하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Occasionally, you might be able to achieve better performance by executing "
"the query using the <literal>iterate()</literal> method. This will usually "
"be the case if you expect that the actual entity instances returned by the "
"query will already be in the session or second-level cache. If they are not "
"already cached, <literal>iterate()</literal> will be slower than "
"<literal>list()</literal> and might require many database hits for a simple "
"query, usually <emphasis>1</emphasis> for the initial select which only "
"returns identifiers, and <emphasis>n</emphasis> additional selects to "
"initialize the actual instances."
msgstr ""
"종종, 당신은 <literal>iterate()</literal> 메소드를 사용하여 질의를 실행함으로"
"써 더 나은 퍼포먼스를 성취하는 것이 가능할 수 있다. 이것은 오직 대개 질의에 "
"의해 반환되는 실제 엔티티 인스턴스들이 이미 세션 내에 있거나 second-level 캐"
"시 내에 있을 것임을 당신이 예상하는 경우일 것이다. 만일 그것들이 이미 캐시되"
"지 않았다면, <literal>iterate()</literal>는 <literal>list()</literal> 보다 "
"더 느릴 것이고 간단한 질의에 대해 많은 데이터베이스 접속들을, 대개 오직 식별"
"자들을 반환하는 초기 select에 대해 <emphasis>1</emphasis>번의 접속과 실제 인"
"스턴스들을 초기화 시키는 추가적인 select들에 대해 <emphasis>n</emphasis> 번"
"의 접속을 필요로 할 수 있다."

#. Tag: title
#, no-c-format
msgid "Queries that return tuples"
msgstr "튜플들을 반환하는 질의들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate queries sometimes return tuples of objects. Each tuple is returned "
"as an array:"
msgstr ""
"Hibernate 질의들은 때때로 객체들의 튜플들을 반환하고, 그 경우에 각각의 튜플"
"은 배열로서 반환된다:"

#. Tag: title
#, no-c-format
msgid "Scalar results"
msgstr "스칼라 결과들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Queries can specify a property of a class in the <literal>select</literal> "
"clause. They can even call SQL aggregate functions. Properties or aggregates "
"are considered \"scalar\" results and not entities in persistent state."
msgstr ""
"질의들은 <literal>select</literal> 절 내에 하나의 클래스에 대한 하나의 프로퍼"
"티를 지정할 수 있다. 그것들은 심지어 SQL 집계 함수들을 호출할 수도 있다. 프로"
"퍼티들이나 aggregate들은 \"스칼라\" 결과들(그리고 영속 상태에 있는 엔티티들"
"이 아닌 것으)로 간주된다."

#. Tag: title
#, no-c-format
msgid "Bind parameters"
msgstr "바인드 프라미터들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Methods on <literal>Query</literal> are provided for binding values to named "
"parameters or JDBC-style <literal>?</literal> parameters. <emphasis>Contrary "
"to JDBC, Hibernate numbers parameters from zero.</emphasis> Named parameters "
"are identifiers of the form <literal>:name</literal> in the query string. "
"The advantages of named parameters are as follows:"
msgstr ""
"<literal>Query</literal> 상의 메소드들은 명명된 파라미터들 또는 JDBC-스타일"
"의 <literal>?</literal> 파라미터들에 바인딩 값들을 제공한다. <emphasis>JDBC와"
"는 대조적으로, Hibernate 숫자 파라미터들은 0에서 시작된다.</emphasis> 명명된 "
"파라미터들은 질의 문자열 속에서 <literal>:name</literal> 형식의 식별자들이"
"다. 명명된 파라미터들의 장점들은 다음과 같다:"

#. Tag: para
#, no-c-format
msgid ""
"named parameters are insensitive to the order they occur in the query string"
msgstr "명명된 파라미터들은 그것들이 질의 문자열 내에 발생하는 순서에 관계없다"

#. Tag: para
#, fuzzy, no-c-format
msgid "they can occur multiple times in the same query"
msgstr "그것들은 동일한 질의 내에서 여러 번 발생할 수 있다"

#. Tag: para
#, no-c-format
msgid "they are self-documenting"
msgstr "그것은 자기-설명적이다"

#. Tag: title
#, no-c-format
msgid "Pagination"
msgstr "쪽매김"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you need to specify bounds upon your result set, that is, the maximum "
"number of rows you want to retrieve and/or the first row you want to "
"retrieve, you can use methods of the <literal>Query</literal> interface:"
msgstr ""
"만일 당신이 당신의 결과 셋에 경계(당신이 검색하고자 원하는 최대 개수 그리고/"
"또는 당신이 검색하고자 원하는 첫 번째 행)을 지정할 필요가 있다면 당신은 "
"<literal>Query</literal> 인터페이스의 메소드들을 사용해야 한다:"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate knows how to translate this limit query into the native SQL of "
"your DBMS."
msgstr ""
"Hibernate는 이 limit 질의를 당신의 DBMS의 native SQL로 번역하는 방법을 알고 "
"있다."

#. Tag: title
#, no-c-format
msgid "Scrollable iteration"
msgstr "스크롤 가능한 iteration"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If your JDBC driver supports scrollable <literal>ResultSet</literal>s, the "
"<literal>Query</literal> interface can be used to obtain a "
"<literal>ScrollableResults</literal> object that allows flexible navigation "
"of the query results."
msgstr ""
"당신의 JDBC 드라이버가 스크롤 가능한 <literal>ResultSet</literal>들을 지원할 "
"경우, <literal>Query</literal> 인터페이스는 <literal>ScrollableResults</"
"literal> 객체를 얻는데 사용될 수 있고, 그것은 질의 결과들에 대한 유연한 네비"
"게이션을 허용해준다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Note that an open database connection and cursor is required for this "
"functionality. Use <literal>setMaxResult()</literal>/<literal>setFirstResult"
"()</literal> if you need offline pagination functionality."
msgstr ""
"열려진 데이터베이스 커넥션(과 커서)가 이 기능에 필요함을 노트하고, 만일 당신"
"이 쪽매김 기능을 작동시킬 필요가 있다면 <literal>setMaxResult()</literal>/"
"<literal>setFirstResult()</literal>를 사용하라."

#. Tag: title
#, no-c-format
msgid "Externalizing named queries"
msgstr "명명된 질의들을 구체화 시키기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can also define named queries in the mapping document. Remember to use a "
"<literal>CDATA</literal> section if your query contains characters that "
"could be interpreted as markup."
msgstr ""
"당신은 또한 매핑 문서 속에 명명된 질의들을 정의할 수 있다.(만일 당신의 질의"
"가 마크업으로서 해석될 수 있는 문자들을 포함할 경우에 <literal>CDATA</"
"literal> 섹션을 사용하는 것을 기억하라))"

#. Tag: para
#, no-c-format
msgid "Parameter binding and executing is done programatically:"
msgstr "파라미터 바인딩과 실행은 프로그램 상으로 행해진다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The actual program code is independent of the query language that is used. "
"You can also define native SQL queries in metadata, or migrate existing "
"queries to Hibernate by placing them in mapping files."
msgstr ""
"실제 프로그램 코드는 사용되는 질의 언어에 독립적이고, 당신은 또한 메타데이터"
"로 native SQL 질의들을 정의할 수도 있거나 그것들을 매핑 파일들 속에 기존 질의"
"들을 위치지움으로써 기존 질의들을 Hibernate로 이전시킬 수도 있음을 노트하라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Also note that a query declaration inside a <literal>&lt;hibernate-"
"mapping&gt;</literal> element requires a global unique name for the query, "
"while a query declaration inside a <literal>&lt;class&gt;</literal> element "
"is made unique automatically by prepending the fully qualified name of the "
"class. For example <literal>eg.Cat.ByNameAndMaximumWeight</literal>."
msgstr ""
"또한 <literal>&lt;hibernate-mapping&gt;</literal> 요소 내에서 하나의 질의 선"
"언은 그 질의에 대한 전역 유일 이름을 필요로 하고, 반면에 <literal>&lt;"
"class&gt;</literal> 요소 내에서의 질의 선언은 클래스 이름으로 수직된이름을 첨"
"가하여 자동적으로 유일하게 만들어진다. 예를 들어 <literal>eg.Cat."
"ByNameAndMaximumWeight</literal>."

#. Tag: title
#, no-c-format
msgid "Filtering collections"
msgstr "콜렉션들을 필터링 하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A collection <emphasis>filter</emphasis> is a special type of query that can "
"be applied to a persistent collection or array. The query string can refer "
"to <literal>this</literal>, meaning the current collection element."
msgstr ""
"콜렉션 <emphasis>필터</emphasis>는 영속 콜렉션 또는 배열에 적용될 수 있는 질"
"의의 특별한 타입이다. 질의 문자열은 현재의 콜렉션 요소를 의미하는 "
"<literal>this</literal>를 참조할 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The returned collection is considered a bag that is a copy of the given "
"collection. The original collection is not modified. This is contrary to the "
"implication of the name \"filter\", but consistent with expected behavior."
msgstr ""
"반환되는 콜렉션은 하나의 bag으로 간주되고, 그것은 주어진 콜렉션에 대한 사본이"
"다. 원래의 콜렉션은 변경되지 않는다 (이것은 이름 \"filter\"의 의미와는 정반대"
"이지만, 예상되는 행위와 일치된다)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Observe that filters do not require a <literal>from</literal> clause, "
"although they can have one if required. Filters are not limited to returning "
"the collection elements themselves."
msgstr ""
"필터들은 <literal>from</literal> 절을 필요로 하지 않음을 관찰하라(필요할 경우"
"에 필터들이 한 개의 from 절을 가질 수 있을지라도). 필터들은 콜렉션 요소들 자"
"체들을 반환하는 것으로 한정되지 않는다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Even an empty filter query is useful, e.g. to load a subset of elements in a "
"large collection:"
msgstr ""
"심지어 하나의 공백의 필터 질의도 예를 들어 거대한 콜렉션 내에 있는 요소들의 "
"부분집합들을 로드시키는데 유용하다:"

#. Tag: title
#, no-c-format
msgid "Criteria queries"
msgstr "Criteria 질의들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"HQL is extremely powerful, but some developers prefer to build queries "
"dynamically using an object-oriented API, rather than building query "
"strings. Hibernate provides an intuitive <literal>Criteria</literal> query "
"API for these cases:"
msgstr ""
"HQL은 극히 강력하지만 몇몇 개발자들은 질의 문자열들을 빌드하기 보다, 객체 지"
"향 API를 사용하여 동적으로 질의들을 빌드시키는 것을 선호한다. Hibernate는 이"
"들 경우들을 위한 직관적인 <literal>Criteria</literal> query API를 제공한다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>Criteria</literal> and the associated <literal>Example</"
"literal> API are discussed in more detail in <xref linkend=\"querycriteria"
"\" />."
msgstr ""
"<literal>Criteria</literal>와 연관된 <literal>Example</literal> API 는 <xref "
"linkend=\"querycriteria\"/>에서 상세하게 논의된다."

#. Tag: title
#, no-c-format
msgid "Queries in native SQL"
msgstr "native SQL에서 질의들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can express a query in SQL, using <literal>createSQLQuery()</literal> "
"and let Hibernate manage the mapping from result sets to objects. You can at "
"any time call <literal>session.connection()</literal> and use the JDBC "
"<literal>Connection</literal> directly. If you choose to use the Hibernate "
"API, you must enclose SQL aliases in braces:"
msgstr ""
"당신은 <literal>createSQLQuery()</literal>를 사용하여 SQL 속에 하나의 질의를 "
"표현할 수 있고, Hibernate로 하여금 결과 셋들로부터 객체들로의 매핑을 처리하도"
"록 할수도 있다. 당신은 아무때나 <literal>session.connection()</literal>을 호"
"출할 수 있고 직접 JDBC <literal>Connection</literal>을 사용할 수 있음을 노트"
"하라. 만일 당신이 Hibernate API를 사용하고자 선택한 경우에 , 당신은 SQL alias"
"들을 중괄호들 속에 포함시켜야 한다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"SQL queries can contain named and positional parameters, just like Hibernate "
"queries. More information about native SQL queries in Hibernate can be found "
"in <xref linkend=\"querysql\" />."
msgstr ""
"SQL 질의들은 Hibernate 질의들처럼 명명된 파라미터들과 위치 파라미터들을 포함"
"할 수도 있다. SQL 질의들에 대한 추가 정보는 <xref linkend=\"querysql\"/>에서 "
"찾을 수 있다."

#. Tag: title
#, no-c-format
msgid "Modifying persistent objects"
msgstr "영속 객체들을 변경하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis>Transactional persistent instances</emphasis> (i.e. objects "
"loaded, saved, created or queried by the <literal>Session</literal>) can be "
"manipulated by the application, and any changes to persistent state will be "
"persisted when the <literal>Session</literal> is <emphasis>flushed</"
"emphasis>. This is discussed later in this chapter. There is no need to call "
"a particular method (like <literal>update()</literal>, which has a different "
"purpose) to make your modifications persistent. The most straightforward way "
"to update the state of an object is to <literal>load()</literal> it and then "
"manipulate it directly while the <literal>Session</literal> is open:"
msgstr ""
"<emphasis>트랜잭션 상의 영속 인스턴스들</emphasis> (예를들면. "
"<literal>Session</literal>에 의해 로드되고, 저장되고, 생성되거나 질의된 객체"
"들)은 어플리케이션에 의해 처리될 수 있고 영속 상태에 대한 임의의 변경들은 "
"<literal>Session</literal>이 <emphasis>flush될</emphasis> 때 영속화 될 것이다"
"(이 장의 뒷 부분에서 논의됨). 당신의 변경들을 영속화 시키기 위해 (다른 용도"
"를 가진 <literal>update()</literal>와 같은) 특별한 메소드를 호출할 필요가 없"
"다. 따라서 객체의 상태를 업데이트 시키는 가장 간단한 방법은 "
"<literal>Session</literal>이 열려 있는 동안, 그것을 <literal>load()</literal>"
"시키고 나서, 그것을 직접 처리하는 것이다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Sometimes this programming model is inefficient, as it requires in the same "
"session both an SQL <literal>SELECT</literal> to load an object and an SQL "
"<literal>UPDATE</literal> to persist its updated state. Hibernate offers an "
"alternate approach by using detached instances."
msgstr ""
"때때로 이 프로그래밍 모형은 불충분하다. 왜냐하면 그것은 동일한 세션 내에서 "
"(객체를 로드시키는) SQL <literal>SELECT</literal>와 (그것의 업데이트된 상태"
"를 영속화 시키는) SQL <literal>UPDATE</literal> 양자를 필요로 할 것이기 때문"
"이다. 그러므로 Hibernate는 detached 인스턴스들을 사용하는 대안적인 접근법을 "
"제공한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate does not offer its own API for direct execution of "
"<literal>UPDATE</literal> or <literal>DELETE</literal> statements. Hibernate "
"is a <emphasis>state management</emphasis> service, you do not have to think "
"in <emphasis>statements</emphasis> to use it. JDBC is a perfect API for "
"executing SQL statements, you can get a JDBC <literal>Connection</literal> "
"at any time by calling <literal>session.connection()</literal>. Furthermore, "
"the notion of mass operations conflicts with object/relational mapping for "
"online transaction processing-oriented applications. Future versions of "
"Hibernate can, however, provide special mass operation functions. See <xref "
"linkend=\"batch\" /> for some possible batch operation tricks."
msgstr ""
"Hibernate는 <placeholder-1/> 문장 또는 <placeholder-2/> 문장의 직접적인 실행"
"을 위한 그것 자신의 API를 제공하지 않음을 노트하라. Hibernate는 하나의 "
"<placeholder-3/> 서비스이고, 당신은 그것을 사용할 <placeholder-4/>을 생각하"
"지 말아야 한다. JDBC는 SQL 문장들을 실행시키는 완전한 API이고, 당신은 "
"<placeholder-5/>을 호출하여 아무때나 한 개의 JDBC <placeholder-6/>을 얻을 수 "
"있다. 게다가 대량 오퍼레이션의 개념은 온라인 트랜잭션 처리-지향적인 어플리케"
"이션들을 위한 객체/관계형 매핑과 충돌한다. 하지만 Hibernate의 장래 버전들은 "
"특별한 대용량의 오퍼레이션 기능들을 제공할 수도 있다. 몇몇 가능한 배치 오퍼레"
"이션 트릭들에 대해서는 <xref linkend=\"batch\"/>을 보라."

#. Tag: title
#, no-c-format
msgid "Modifying detached objects"
msgstr "detached 객체들을 변경시키기"

#. Tag: para
#, no-c-format
msgid ""
"Many applications need to retrieve an object in one transaction, send it to "
"the UI layer for manipulation, then save the changes in a new transaction. "
"Applications that use this kind of approach in a high-concurrency "
"environment usually use versioned data to ensure isolation for the \"long\" "
"unit of work."
msgstr ""
"많은 어플리케이션들은 하나의 트랜잭션 내에서 하나의 객체를 검색하고, 처리를 "
"위한 UI 계층으로 그것을 전송하고, 그런 다음 새로운 트랜잭션 내에서 변경들을 "
"저장할 필요가 있다. 고도의-동시성 환경에서 이런 종류의 접근법을 사용하는 어플"
"리케이션들은 대개 작업의 \"긴\" 단위를 확실히 격리시키기 위해 버전화 된 데이"
"터를 사용한다."

#. Tag: para
#, no-c-format
msgid ""
"Hibernate supports this model by providing for reattachment of detached "
"instances using the <literal>Session.update()</literal> or <literal>Session."
"merge()</literal> methods:"
msgstr ""
"Hibernate는 <literal>Session.update()</literal> 메소드 또는 <literal>Session."
"merge()</literal> 메소드를 사용하여 detached 인스턴스들의 재첨부를 제공함으로"
"써 이 모형을 지원한다:"

#. Tag: para
#, no-c-format
msgid ""
"If the <literal>Cat</literal> with identifier <literal>catId</literal> had "
"already been loaded by <literal>secondSession</literal> when the application "
"tried to reattach it, an exception would have been thrown."
msgstr ""
"만일 <literal>catId</literal> 식별자를 가진 <literal>Cat</literal>이 "
"<literal>secondSession</literal>에 의해 이미 로드되었을 경우에 어플리케이션"
"이 그것을 다시 재첨부하려고 시도할 때, 예외상황이 던져졌을 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Use <literal>update()</literal> if you are certain that the session does not "
"contain an already persistent instance with the same identifier. Use "
"<literal>merge()</literal> if you want to merge your modifications at any "
"time without consideration of the state of the session. In other words, "
"<literal>update()</literal> is usually the first method you would call in a "
"fresh session, ensuring that the reattachment of your detached instances is "
"the first operation that is executed."
msgstr ""
"만일 그 세션이 동일한 식별자를 가진 영속 인스턴스를 이미 포함하지 않음을 당신"
"이 확신하는 경우에는 <literal>update()</literal>를 사용하고, 만일 당신이 세션"
"의 상태를 고려하지 않은채로 아무때나 당신의 변경을 병합시키고자 원할 경우에"
"는 <literal>merge()</literal>를 사용하라. 달리 말해, 당신의 detached 인스턴스"
"들에 대한 재첨부가 실행되는 첫 번째 오퍼레이션임을 확실히 함으로써, "
"<literal>update()</literal>는 대개 갓 만들어진 세션에서 당신이 호출하게 될 "
"첫 번째 메소드이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The application should individually <literal>update()</literal> detached "
"instances that are reachable from the given detached instance "
"<emphasis>only</emphasis> if it wants their state to be updated. This can be "
"automated using <emphasis>transitive persistence</emphasis>. See <xref "
"linkend=\"objectstate-transitive\" /> for more information."
msgstr ""
"어플리케이션은 만일 그것이 detached 인스턴스들의 상태가 또한 업데이트 되는 것"
"을 원할 경우에<emphasis>만</emphasis> 주어진 detached 인스턴스로부터 도달 가"
"능한 detached 인스턴스들을 개별적으로<literal>update()</literal> 시킬 것이"
"다. 이것은 물론 <emphasis>transitive persistence(전이 영속)</emphasis>을 사용"
"하여 자동화 될 수 있고, <xref linkend=\"objectstate-transitive\"/>를 보라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>lock()</literal> method also allows an application to "
"reassociate an object with a new session. However, the detached instance has "
"to be unmodified."
msgstr ""
"<literal>lock()</literal> 메소드는 또한 하나의 객체를 새로운 세션에 대해 다"
"시 연관시키는것을 어플리케이션에게 허용해준다. 하지만 detached 인스턴스는 변"
"경되지 않아야 한다!"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Note that <literal>lock()</literal> can be used with various "
"<literal>LockMode</literal>s. See the API documentation and the chapter on "
"transaction handling for more information. Reattachment is not the only "
"usecase for <literal>lock()</literal>."
msgstr ""
"<literal>lock()</literal>이 여러가지 <literal>LockMode</literal>들에 사용될 "
"수 있음을 노트하고, 상세한 것은 API 문서와 트랜잭션 처리에 관한 장을 보라. 재"
"첨부는 <literal>lock()</literal>에 대한 유일한 쓰임새는 아니다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Other models for long units of work are discussed in <xref linkend="
"\"transactions-optimistic\" />."
msgstr ""
"긴 작업 단위에 대한 다른 모형들은 <xref linkend=\"transactions-optimistic\"/>"
"에서 논의된다."

#. Tag: title
#, no-c-format
msgid "Automatic state detection"
msgstr "자동적인 상태 검출"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate users have requested a general purpose method that either saves a "
"transient instance by generating a new identifier or updates/reattaches the "
"detached instances associated with its current identifier. The "
"<literal>saveOrUpdate()</literal> method implements this functionality."
msgstr ""
"Hibernate 사용자들은 새로운 식별자를 생성시켜서 transient 인스턴스를 저장하거"
"나 그것의 현재 식별자와 연관된 detached 인스턴스들을 업데이트/재첨부 시키는 "
"일반적인 용도의 메소드를 요청했다. <literal>saveOrUpdate()</literal> 메소드"
"는 이 기능을 구현한다."

#. Tag: para
#, no-c-format
msgid ""
"The usage and semantics of <literal>saveOrUpdate()</literal> seems to be "
"confusing for new users. Firstly, so long as you are not trying to use "
"instances from one session in another new session, you should not need to "
"use <literal>update()</literal>, <literal>saveOrUpdate()</literal>, or "
"<literal>merge()</literal>. Some whole applications will never use either of "
"these methods."
msgstr ""
"<literal>saveOrUpdate()</literal>의 사용 예제와 의미는 초심자들에게는 혼동스"
"러워 보인다. 먼저, 하나의 세션에서 온 인스턴스를 또 다른 새로운 세션 내에서 "
"사용하려고 시도하지 않는 한, 당신은 <literal>update()</literal>, "
"<literal>saveOrUpdate()</literal>, 또는 <literal>merge()</literal>를 사용할 "
"필요는 없을 것이다. 몇몇 전체 어플리케이션들은 이들 메소드들 중 어느 것도 결"
"코 사용하지 않을 것이다."

#. Tag: para
#, no-c-format
msgid ""
"Usually <literal>update()</literal> or <literal>saveOrUpdate()</literal> are "
"used in the following scenario:"
msgstr ""
"대개 <literal>update()</literal> 또는 <literal>saveOrUpdate()</literal>는 다"
"음 시나리오에서 사용된다:"

#. Tag: para
#, no-c-format
msgid "the application loads an object in the first session"
msgstr "어플리케이션이 첫 번째 세션 내에 객체를 로드시킨다"

#. Tag: para
#, no-c-format
msgid "the object is passed up to the UI tier"
msgstr "객체가 UI 티어로 전달된다"

#. Tag: para
#, no-c-format
msgid "some modifications are made to the object"
msgstr "몇몇 변경들이 그 객체에 행해진다"

#. Tag: para
#, no-c-format
msgid "the object is passed back down to the business logic tier"
msgstr "객체가 비지니스 로직 티어로 전달된다"

#. Tag: para
#, no-c-format
msgid ""
"the application persists these modifications by calling <literal>update()</"
"literal> in a second session"
msgstr ""
"어플리케이션은 두 번째 세션에서 <literal>update()</literal>를 호출함으로써 이"
"들 변경들을 영속화 시킨다"

#. Tag: para
#, no-c-format
msgid "<literal>saveOrUpdate()</literal> does the following:"
msgstr "<literal>saveOrUpdate()</literal>는 다음을 행한다:"

#. Tag: para
#, no-c-format
msgid "if the object is already persistent in this session, do nothing"
msgstr ""
"만일 객체가 이 세션 내에서 이미 영속화 되어 있을 경우, 아무것도 행하지 않는다"

#. Tag: para
#, no-c-format
msgid ""
"if another object associated with the session has the same identifier, throw "
"an exception"
msgstr ""
"만일 그 세션과 연관된 또 다른 객체가 동일한 식별자를 가질 경우, 예외상황을 던"
"진다"

#. Tag: para
#, no-c-format
msgid "if the object has no identifier property, <literal>save()</literal> it"
msgstr ""
"만일 그 객체가 식별자 프로퍼티를 갖지 않을 경우, 그것을 <literal>save()</"
"literal> 시킨다"

#. Tag: para
#, no-c-format
msgid ""
"if the object's identifier has the value assigned to a newly instantiated "
"object, <literal>save()</literal> it"
msgstr ""
"만일 객체의 식별자가 새로이 초기화 된 객체에 할당된 값을 가질 경우, 그것을 "
"<literal>save()</literal> 시킨다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"if the object is versioned by a <literal>&lt;version&gt;</literal> or "
"<literal>&lt;timestamp&gt;</literal>, and the version property value is the "
"same value assigned to a newly instantiated object, <literal>save()</"
"literal> it"
msgstr ""
"만일 객체가 (<literal>&lt;version&gt;</literal> 또는 <literal>&lt;"
"timestamp&gt;</literal>에 의해) 버전화 되고, version 프로퍼티 값이 새로이 초"
"기화 된 객체에 할당된 것과 동일한 값일 경우, 그것을 <literal>save()</"
"literal> 시킨다"

#. Tag: para
#, no-c-format
msgid "otherwise <literal>update()</literal> the object"
msgstr "그 밖의 경우 그 객체를 <literal>update()</literal> 시킨다"

#. Tag: para
#, no-c-format
msgid "and <literal>merge()</literal> is very different:"
msgstr "그리고 <literal>merge()</literal>는 매우 다르다:"

#. Tag: para
#, no-c-format
msgid ""
"if there is a persistent instance with the same identifier currently "
"associated with the session, copy the state of the given object onto the "
"persistent instance"
msgstr ""
"만일 세션과 현재 연관된 동일한 식별자를 가진 영속 인스턴스가 존재할 경우, 주"
"어진 객체의 상태를 영속 인스턴스 상으로 복사한다"

#. Tag: para
#, no-c-format
msgid ""
"if there is no persistent instance currently associated with the session, "
"try to load it from the database, or create a new persistent instance"
msgstr ""
"만일 세션과 현재 연관된 영속 인스턴스가 존재하지 않을 경우, 데이터베이스로부"
"터 그것을 로드시키려고 시도하거나 새로운 영속 인스턴스를 생성시키려고 시도한"
"다"

#. Tag: para
#, no-c-format
msgid "the persistent instance is returned"
msgstr "영속 인스턴스가 반환된다"

#. Tag: para
#, no-c-format
msgid ""
"the given instance does not become associated with the session, it remains "
"detached"
msgstr ""
"주어진 인스턴스는 세션과 연관되지 않고, 그것은 detached 상태에 머무른다"

#. Tag: title
#, no-c-format
msgid "Deleting persistent objects"
msgstr "영속 객체들을 삭제하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>Session.delete()</literal> will remove an object's state from the "
"database. Your application, however, can still hold a reference to a deleted "
"object. It is best to think of <literal>delete()</literal> as making a "
"persistent instance, transient."
msgstr ""
"<literal>Session.delete()</literal>는 데이터베이스로부터 객체의 상태를 제거"
"할 것이다. 물론 당신의 어플리케이션은 여전히 detached 객체에 대한 참조를 소유"
"할 것이다. 영속 인스턴스를 transient로 만들 때 <literal>delete()</literal>를 "
"생각하는 것이 최상이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can delete objects in any order, without risk of foreign key constraint "
"violations. It is still possible to violate a <literal>NOT NULL</literal> "
"constraint on a foreign key column by deleting objects in the wrong order, e."
"g. if you delete the parent, but forget to delete the children."
msgstr ""
"당신은 foreign 키 컨스트레인트 위배들에 대한 위험성 없이 당신이 좋아하는 어"
"떤 순서로 객체들을 삭제할 수도 있다. 잘못된 순서로 객체들을 삭제함으로써 "
"foreign 키 컬럼에 대한 <literal>NOT NULL</literal> 컨스트레인트를 위배할 가능"
"성이 여전히 존재한다. 예를 들어, 당신이 부모를 삭제하지만, 그 자식들을 삭제하"
"는 것을 잊은 경우."

#. Tag: title
#, no-c-format
msgid "Replicating object between two different datastores"
msgstr "두 개의 다른 데이터저장소들 사이에 객체들을 복제하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is sometimes useful to be able to take a graph of persistent instances "
"and make them persistent in a different datastore, without regenerating "
"identifier values."
msgstr ""
"영속 인스턴스들의 그래프를 취하고 식별자 값들을 다시 생성시키지 않고서 그것들"
"을 다른 저장소 속에 영속화 시키는 것을 가능하도록 만드는 것이 종종 유용하다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>ReplicationMode</literal> determines how <literal>replicate()</"
"literal> will deal with conflicts with existing rows in the database:"
msgstr ""
"<literal>ReplicationMode</literal>는 <literal>replicate()</literal>가 데이터"
"베이스 내에 있는 기존의 행들과의 충돌을 처리하게될 방법을 결정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>ReplicationMode.IGNORE</literal>: ignores the object when there is "
"an existing database row with the same identifier"
msgstr ""
"<literal>ReplicationMode.IGNORE</literal> - 동일한 식별자를 가진 기존 데이터"
"베이스 행이 존재할 경우에 그 객체를 무시한다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>ReplicationMode.OVERWRITE</literal>: overwrites any existing "
"database row with the same identifier"
msgstr ""
"<literal>ReplicationMode.OVERWRITE</literal> - 동일한 식별자를 가진 어떤 기존"
"의 데이터베이스 행을 덮어 쓴다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>ReplicationMode.EXCEPTION</literal>: throws an exception if there "
"is an existing database row with the same identifier"
msgstr ""
"<literal>ReplicationMode.EXCEPTION</literal> - 만일 동일한 식별자를 가진 기"
"존 데이터베이스 행이 존재할 경우에 예외상황을 던진다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>ReplicationMode.LATEST_VERSION</literal>: overwrites the row if its "
"version number is earlier than the version number of the object, or ignore "
"the object otherwise"
msgstr ""
"<literal>ReplicationMode.LATEST_VERSION</literal> - 행의 버전 번호가 객체의 "
"버전 번호 보다 이전의 것이면 덮어쓰고, 그 밖의 경우에 그 객체를 무시한다"

#. Tag: para
#, no-c-format
msgid ""
"Usecases for this feature include reconciling data entered into different "
"database instances, upgrading system configuration information during "
"product upgrades, rolling back changes made during non-ACID transactions and "
"more."
msgstr ""
"이 특징의 쓰임새들은 다른 데이터베이스 인스턴스들 속으로 입력된 데이터 일치시"
"키기, 제품 업그레이드 동안에 시스템 구성 정보 업데이트 하기, non-ACID 트랜잭"
"션들 동안에 행해진 변경들을 롤백시키기 등을 포함한다."

#. Tag: title
#, no-c-format
msgid "Flushing the Session"
msgstr "Session을 flush 시키기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Sometimes the <literal>Session</literal> will execute the SQL statements "
"needed to synchronize the JDBC connection's state with the state of objects "
"held in memory. This process, called <emphasis>flush</emphasis>, occurs by "
"default at the following points:"
msgstr ""
"시간이 지남에 따라 <literal>Session</literal>은 JDBC 커넥션의 상태와 메모리 "
"내에 보관된 객체들의 상태를 동기화 시키는데 필요한 SQL 문장들을 실행시킬 것이"
"다. 이 프로세스 <emphasis>flush</emphasis>는 다음 시점들에서 디폴트로 발생한"
"다"

#. Tag: para
#, no-c-format
msgid "before some query executions"
msgstr "몇몇 질의들이 실행되기 전에"

#. Tag: para
#, no-c-format
msgid "from <literal>org.hibernate.Transaction.commit()</literal>"
msgstr "<literal>org.hibernate.Transaction.commit()</literal> 시점에서"

#. Tag: para
#, no-c-format
msgid "from <literal>Session.flush()</literal>"
msgstr "<literal>Session.flush()</literal> 시점에서"

#. Tag: para
#, fuzzy, no-c-format
msgid "The SQL statements are issued in the following order:"
msgstr "SQL 문장들이 다음 순서로 실행 명령이 내려진다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"all entity insertions in the same order the corresponding objects were saved "
"using <literal>Session.save()</literal>"
msgstr ""
"대응하는 객체들이 <literal>Session.save()</literal>를 사용하여 저장되었던 것"
"과 같은 순서로, 모든 엔티티 삽입들"

#. Tag: para
#, no-c-format
msgid "all entity updates"
msgstr "모든 엔티티 업데이트들"

#. Tag: para
#, no-c-format
msgid "all collection deletions"
msgstr "모든 콜렉션 삭제들"

#. Tag: para
#, no-c-format
msgid "all collection element deletions, updates and insertions"
msgstr "모든 콜렉션 요소 삭제들, 업데이트들 그리고 삽입들"

#. Tag: para
#, no-c-format
msgid "all collection insertions"
msgstr "모든 콜렉션 삽입들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"all entity deletions in the same order the corresponding objects were "
"deleted using <literal>Session.delete()</literal>"
msgstr ""
"대응하는 객체들이 <literal>Session.delete()</literal>를 사용하여 삭제되었던 "
"것과 같은 순서로 모든 엔티티 삭제들."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"An exception is that objects using <literal>native</literal> ID generation "
"are inserted when they are saved."
msgstr ""
"(한가지 예외는 객체들이 저장될 때 <literal>native</literal> ID 생성을 사용하"
"는 객체들이 insert 되는 점이다.)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Except when you explicitly <literal>flush()</literal>, there are absolutely "
"no guarantees about <emphasis>when</emphasis> the <literal>Session</literal> "
"executes the JDBC calls, only the <emphasis>order</emphasis> in which they "
"are executed. However, Hibernate does guarantee that the <literal>Query.list"
"(..)</literal> will never return stale or incorrect data."
msgstr ""
"당신이 명시적으로 <literal>flush()</literal> 시킬 때를 제외하면, "
"<literal>Session</literal>이 JDBC 호출들을 실행시키는 <emphasis>시점</"
"emphasis>, 그것들이 실행되는 <emphasis>순서</emphasis>만을 절대적으로 보장하"
"지는 않는다. 하지만 Hibernate는 <literal>Query.list(..)</literal>가 실효성이 "
"없는 데이터를 결코 반환하지 않을 것임을 보장하거나; 그것들이 잘못된 데이터도 "
"반환하지 않을 것임을 보장한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is possible to change the default behavior so that flush occurs less "
"frequently. The <literal>FlushMode</literal> class defines three different "
"modes: only flush at commit time when the Hibernate <literal>Transaction</"
"literal> API is used, flush automatically using the explained routine, or "
"never flush unless <literal>flush()</literal> is called explicitly. The last "
"mode is useful for long running units of work, where a <literal>Session</"
"literal> is kept open and disconnected for a long time (see <xref linkend="
"\"transactions-optimistic-longsession\" />)."
msgstr ""
"flush가 너무 자주 발생하지 않도록 디폴트 행위를 변경하는 것이 가능하다. "
"<literal>FlushMode</literal> 클래스는 세 개의 다른 모드들을 정의한다: 오직 커"
"밋 시(그리고 Hibernate <literal>Transaction</literal> API가 사용될 때에만) "
"flush 모드, 설명된 루틴을 사용하는 자동적인 flush 모드, 또는 <literal>flush()"
"</literal>가 명시적으로 호출되지 않는 한 flush 시키지 않는 모드. 마지막 모드"
"는 오래 동안 실행되는 작업 단위에 대해 유용하고, 여기서 <literal>Session</"
"literal>은 열려진채로 유지되고 오랜 시간 동안 연결이 해제된 채로 유지된다. "
"(<xref linkend=\"transactions-optimistic-longsession\"/>를 보라)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"During flush, an exception might occur (e.g. if a DML operation violates a "
"constraint). Since handling exceptions involves some understanding of "
"Hibernate's transactional behavior, we discuss it in <xref linkend="
"\"transactions\" />."
msgstr ""
"flush 동안에, 하나의 예외상황이 발생할 수도 있다(예를 들면. 만일 DML 오퍼레이"
"션이 컨스트레인트를 위반할 경우). 예외상황들을 처리하는 것은 Hibernatem의 트"
"랜잭션 특징에 관한 어떤 이해를 수반하며, 우리는 <xref linkend=\"transactions"
"\"/>에서 그것을 논의한다."

#. Tag: title
#, no-c-format
msgid "Transitive persistence"
msgstr "Transitive persistence(전이 영속)"

#. Tag: para
#, no-c-format
msgid ""
"It is quite cumbersome to save, delete, or reattach individual objects, "
"especially if you deal with a graph of associated objects. A common case is "
"a parent/child relationship. Consider the following example:"
msgstr ""
"특히 당신이 연관된 객체들의 그래프를 다룰 경우에, 특히 개별 객체들을 저장하"
"고, 삭제하거나, 재첨부시키는 것이 꽤 번거롭다. 공통된 경우는 하나의 부모/자"
"식 관계이다. 다음 예제를 검토하자:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If the children in a parent/child relationship would be value typed (e.g. a "
"collection of addresses or strings), their life cycle would depend on the "
"parent and no further action would be required for convenient \"cascading\" "
"of state changes. When the parent is saved, the value-typed child objects "
"are saved and when the parent is deleted, the children will be deleted, etc. "
"This works for operations such as the removal of a child from the "
"collection. Since value-typed objects cannot have shared references, "
"Hibernate will detect this and delete the child from the database."
msgstr ""
"만일 부모/자식 관계에서 자식들이 값(value) 타입(예를 들면. 주소들 또는 문자열"
"들을 가진 하나의 콜렉션)일 경우, 그것들의 생명주기는 부모에 의존할 것이고 상"
"태 변경들에 대해 편리한 \"케스케이딩\"에 더 이상의 액션이 필요하지 않을 것이"
"다. 만일 부모가 저장될 때, 값(value)-타입의 자식 객체들도 마찬가지로 저장되"
"고, 부모가 삭제될 때, 자식들이 삭제될 것이다. 이것은 심지어 콜렉션으로부터 하"
"나의 자식을 제거하는 그런 오퍼레이션들에 대해서도 동작한다; Hibernate는 이것"
"을 검출하고, 값(value)-타입의 객체들은 참조를 공유할 수 없으므로, 데이터베이"
"스로부터 그 자식을 삭제시킨다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Now consider the same scenario with parent and child objects being entities, "
"not value-types (e.g. categories and items, or parent and child cats). "
"Entities have their own life cycle and support shared references. Removing "
"an entity from the collection does not mean it can be deleted), and there is "
"by default no cascading of state from one entity to any other associated "
"entities. Hibernate does not implement <emphasis>persistence by "
"reachability</emphasis> by default."
msgstr ""
"이제 값(value) 타입이 아닌, 엔티티들인 부모와 자식 객체들을 가진 동일한 시나"
"리오를 검토하자(예를 들면. 카테고리들과 아이템들, 또는 부모 고양이나 자식 고"
"양이). 엔티티들은 그것들 자신의 생명주기를 갖고, 공유된 참조들을 지원하고 (따"
"라서 콜렉션으로부터 하나의 엔티티를 제거하는 것은 그것이 삭제될 수 있음을 의"
"미하지 않는다), 그리고 디폴트로 하나의 엔티티로부터 어떤 다른 연관된 엔티티들"
"로의 상태의 케스케이딩은 존재하지 않는다. Hibernate는 디폴트로 <emphasis>도달"
"가능성에 의한 영속성(persistence by reachability)</emphasis>을 구현하지 않는"
"다."

#. Tag: para
#, no-c-format
msgid ""
"For each basic operation of the Hibernate session - including "
"<literal>persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), "
"evict(), replicate()</literal> - there is a corresponding cascade style. "
"Respectively, the cascade styles are named <literal>create, merge, save-"
"update, delete, lock, refresh, evict, replicate</literal>. If you want an "
"operation to be cascaded along an association, you must indicate that in the "
"mapping document. For example:"
msgstr ""
"- <literal>persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), "
"evict(), replicate()</literal>를 포함하는- Hibernate 세션에 대한 각각의 기본 "
"오퍼레이션에 대해서 하나의 대응하는 케스케이딩 스타일이 존재한다. 케스케이드 "
"스타일들 각각은 <literal>create, merge, save-update, delete, lock, refresh, "
"evict, replicate</literal>로 명명된다. 만일 당신이 하나의 오퍼레이션이 하나"
"의 연관에 따라 케스케이딩되는 것을 원할 경우, 당신은 매핑 문서 내에 그것을 지"
"시해야 한다. 예를 들면:"

#. Tag: para
#, no-c-format
msgid "Cascade styles my be combined:"
msgstr "케스케이딩 스타일들이 결합될 수도 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can even use <literal>cascade=\"all\"</literal> to specify that "
"<emphasis>all</emphasis> operations should be cascaded along the "
"association. The default <literal>cascade=\"none\"</literal> specifies that "
"no operations are to be cascaded."
msgstr ""
"당신은 <emphasis>모든</emphasis> 오퍼레이션들이 그 연관에 따라 케스케이드 되"
"어야 함을 지정하는데 <literal>cascade=\"all\"</literal>을 사용할 수도 있다. "
"디폴트<literal>cascade=\"none\"</literal>은 오퍼레이션들이 케스케이드 되지 않"
"을 것임을 지정한다."

#. Tag: para
#, no-c-format
msgid ""
"A special cascade style, <literal>delete-orphan</literal>, applies only to "
"one-to-many associations, and indicates that the <literal>delete()</literal> "
"operation should be applied to any child object that is removed from the "
"association."
msgstr ""
"특정한 케스케이드 스타일인, <literal>delete-orphan</literal>은 오직 one-to-"
"many 연관들에만 적용되고, <literal>delete()</literal> 오퍼레이션이 그 연관으"
"로부터 제거되는 임의의 자식 객체에 적용되어야 함을 나타낸다."

#. Tag: para
#, no-c-format
msgid "Recommendations:"
msgstr "권장사항들 :"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It does not usually make sense to enable cascade on a <literal>&lt;many-to-"
"one&gt;</literal> or <literal>&lt;many-to-many&gt;</literal> association. "
"Cascade is often useful for <literal>&lt;one-to-one&gt;</literal> and "
"<literal>&lt;one-to-many&gt;</literal> associations."
msgstr ""
"하나의 <literal>&lt;many-to-one&gt;</literal> 또는 <literal>&lt;many-to-"
"many&gt;</literal> 연관에 대해 케스케이드를 가능하게 하는 것은 대개 의미가 없"
"다. 케스케이드는 <literal>&lt;one-to-one&gt;</literal> 연관과 <literal>&lt;"
"one-to-many&gt;</literal> 연관에 대해 종종 유용하다."

#. Tag: para
#, no-c-format
msgid ""
"If the child object's lifespan is bounded by the lifespan of the parent "
"object, make it a <emphasis>life cycle object</emphasis> by specifying "
"<literal>cascade=\"all,delete-orphan\"</literal>."
msgstr ""
"만일 자식 객체의 수명이 그 부모 객체의 수명에 묶여져 있을 경우, "
"<literal>cascade=\"all,delete-orphan\"</literal>을 지정함으로써 그것을 "
"<emphasis>생명 주기 객체</emphasis>로 만들어라."

#. Tag: para
#, no-c-format
msgid ""
"Otherwise, you might not need cascade at all. But if you think that you will "
"often be working with the parent and children together in the same "
"transaction, and you want to save yourself some typing, consider using "
"<literal>cascade=\"persist,merge,save-update\"</literal>."
msgstr ""
"그 밖의 경우, 당신은 케스케이드를 전혀 필요로 하지 않을 수 있다. 그러나 만일 "
"당신이 동일한 트랜잭션 내에서 부모와 자식에 대해 자주 함께 작업하게 될 것이"
"라 생각되고, 당신 스스로 타이핑 하는 것을 절약하고자 원할 경우, "
"<literal>cascade=\"persist,merge,save-update\"</literal>를 사용하는 것을 고려"
"하라."

#. Tag: para
#, no-c-format
msgid ""
"Mapping an association (either a single valued association, or a collection) "
"with <literal>cascade=\"all\"</literal> marks the association as a "
"<emphasis>parent/child</emphasis> style relationship where save/update/"
"delete of the parent results in save/update/delete of the child or children."
msgstr ""
"<literal>cascade=\"all\"</literal>을 가진 (단일 값 연관이든 하나의 콜렉션이"
"든) 하나의 연관을 매핑시키는 것은 그 연관을 부모의 저장/업데이트/삭제가 자식 "
"또는 자식들의 저장/업데이트/삭제로 귀결되는 <emphasis>부모/자식</emphasis> 스"
"타일의 관계로 마크한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Furthermore, a mere reference to a child from a persistent parent will "
"result in save/update of the child. This metaphor is incomplete, however. A "
"child which becomes unreferenced by its parent is <emphasis>not</emphasis> "
"automatically deleted, except in the case of a <literal>&lt;one-to-many&gt;</"
"literal> association mapped with <literal>cascade=\"delete-orphan\"</"
"literal>. The precise semantics of cascading operations for a parent/child "
"relationship are as follows:"
msgstr ""
"게다가, 하나의 영속 부모로부터 하나의 자식에 대한 단순한 참조는 자식의 저장/"
"업데이트로 귀결될 것이다. 하지만 이 메타포는 불완전하다. 그것의 부모에 의해 "
"참조 해제되는 자식은 <literal>cascade=\"delete-orphan\"</literal>으로 매핑된 "
"하나의 <literal>&lt;one-to-many&gt;</literal> 연관의 경우를 제외하면, 자동적"
"으로 삭제되지 <emphasis>않는다</emphasis>. 하나의 부모/자식 관계에 대한 케스"
"케이딩 오퍼레이션의 정확한 의미는 다음과 같다:"

#. Tag: para
#, no-c-format
msgid ""
"If a parent is passed to <literal>persist()</literal>, all children are "
"passed to <literal>persist()</literal>"
msgstr ""
"만일 부모가 <literal>persist()</literal>에 전달될 경우, 모든 자식들이 "
"<literal>persist()</literal>에 전달된다"

#. Tag: para
#, no-c-format
msgid ""
"If a parent is passed to <literal>merge()</literal>, all children are passed "
"to <literal>merge()</literal>"
msgstr ""
"만일 부모가 <literal>merge()</literal>에 전달될 경우, 모든 자식들이 "
"<literal>merge()</literal>에 전달된다"

#. Tag: para
#, no-c-format
msgid ""
"If a parent is passed to <literal>save()</literal>, <literal>update()</"
"literal> or <literal>saveOrUpdate()</literal>, all children are passed to "
"<literal>saveOrUpdate()</literal>"
msgstr ""
"만일 부모가 <literal>save()</literal>, <literal>update()</literal> 또는 "
"<literal>saveOrUpdate()</literal>에 전달될 경우, 모든 자식들이 "
"<literal>saveOrUpdate()</literal>에 전달된다"

#. Tag: para
#, no-c-format
msgid ""
"If a transient or detached child becomes referenced by a persistent parent, "
"it is passed to <literal>saveOrUpdate()</literal>"
msgstr ""
"만일 transient 또는 detached 자식이 영속 부모에 의해 참조될 경우, 그것은 "
"<literal>saveOrUpdate()</literal>에 전달된다"

#. Tag: para
#, no-c-format
msgid ""
"If a parent is deleted, all children are passed to <literal>delete()</"
"literal>"
msgstr ""
"만일 부모가 삭제될 경우, 모든 자식들이 <literal>delete()</literal>에 전달된다"

#. Tag: para
#, no-c-format
msgid ""
"If a child is dereferenced by a persistent parent, <emphasis>nothing special "
"happens</emphasis> - the application should explicitly delete the child if "
"necessary - unless <literal>cascade=\"delete-orphan\"</literal>, in which "
"case the \"orphaned\" child is deleted."
msgstr ""
"만일 자식이 영속 부모에 의해 참조 해제 될 경우, <literal>cascade=\"delete-"
"orphan\"</literal>이 아닌 한, <emphasis>특별한 어떤 것도 발생하지 않는다</"
"emphasis> - 어플리케이션은 필요한 경우에 자식을 명시적으로 삭제해야 한다 -, "
"<literal>cascade=\"delete-orphan\"</literal>인 경우에 \"orphaned(고아)\"인 경"
"우 자식이 삭제된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Finally, note that cascading of operations can be applied to an object graph "
"at <emphasis>call time</emphasis> or at <emphasis>flush time</emphasis>. All "
"operations, if enabled, are cascaded to associated entities reachable when "
"the operation is executed. However, <literal>save-update</literal> and "
"<literal>delete-orphan</literal> are transitive for all associated entities "
"reachable during flush of the <literal>Session</literal>."
msgstr ""
"마지막으로 오퍼레이션들의 케스케이딩이 <emphasis>호출 시점</emphasis>에서 또"
"는 <emphasis>flush 시점</emphasis>에서 객체 그래프에 적용될 수 있음을 노트하"
"라. 이용 가능할 경우에 모든 오퍼레이션들은 그 오퍼레이션이 실행될 때 도달 가"
"능한 연관된 엔티티들에 대해 케스케이드 된다. 하지만 <literal>save-upate</"
"literal>와 <literal>delete-orphan</literal>은 <literal>Session</literal>의 "
"flush 동안에 도달 가능한 모든 연관된 엔티티들에 대해 이행적(transitive)이다."

#. Tag: title
#, no-c-format
msgid "Using metadata"
msgstr "메타데이터 사용하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate requires a rich meta-level model of all entity and value types. "
"This model can be useful to the application itself. For example, the "
"application might use Hibernate's metadata to implement a \"smart\" deep-"
"copy algorithm that understands which objects should be copied (eg. mutable "
"value types) and which objects that should not (e.g. immutable value types "
"and, possibly, associated entities)."
msgstr ""
"Hibernate는 모든 엔티티와 값(value) 타입들을 가진 매우 풍부한 메타-레벨 모형"
"을 필요로 한다. 시간이 지남에 따라, 이 모형은 어플리케이션 그 자체에 매우 유"
"용하다. 예를 들어, 어플리케이션은 어느 객체들이 복사되어야 하는지(예를 들면 "
"가변적인 값(value) 타입들) 그리고 어느 것이 복사되지 말아야 하는지(예를 들"
"면, 불변의 value 타입들과 가능한 연관된 엔티티들)를 인지하는 \"스마트\" deep-"
"copy 알고리즘을 구현하는데 Hibernate의 메타데이터를 사용할 수도 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate exposes metadata via the <literal>ClassMetadata</literal> and "
"<literal>CollectionMetadata</literal> interfaces and the <literal>Type</"
"literal> hierarchy. Instances of the metadata interfaces can be obtained "
"from the <literal>SessionFactory</literal>."
msgstr ""
"Hibernate는 <literal>ClassMetadata</literal> 인터페이스와 "
"<literal>CollectionMetadata</literal> 인터페이스 그리고 <literal>Type</"
"literal> 계층구조를 통해 메타데이터를 노출시킨다. 메타데이터 인터페이스들의 "
"인스턴스들은 <literal>SessionFactory</literal>로부터 얻어질 수도 있다."

#~ msgid "UPDATE"
#~ msgstr "UPDATE"

#~ msgid "DELETE"
#~ msgstr "DELETE"

#~ msgid "state management"
#~ msgstr "상태 관리"

#~ msgid "statements"
#~ msgstr "문장들"

#~ msgid "Connection"
#~ msgstr "session.connection()"

#~ msgid "session.connection()"
#~ msgstr "Connection"
