# translation of performance.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# Michael H. Smith <mhideo@redhat.com>, 2007.
# Glaucia Cintra <gcintra@redhat.com>, 2007.
msgid ""
msgstr ""
"Project-Id-Version: performance\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:15\n"
"PO-Revision-Date: 2010-03-18 14:45+1000\n"
"Last-Translator: \n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Improving performance"
msgstr "Aumentando o desempenho"

#. Tag: title
#, no-c-format
msgid "Fetching strategies"
msgstr "Estratégias de Busca "

#. Tag: para
#, no-c-format
msgid ""
"Hibernate uses a <emphasis>fetching strategy</emphasis> to retrieve "
"associated objects if the application needs to navigate the association. "
"Fetch strategies can be declared in the O/R mapping metadata, or over-ridden "
"by a particular HQL or <literal>Criteria</literal> query."
msgstr ""
"Uma <emphasis>estratégia de busca</emphasis> é a estratégia que o Hibernate "
"irá usar para recuperar objetos associados se a aplicação precisar navegar "
"pela associação. Estratégias de Busca podem ser declaradas nos metadados de "
"mapeamento O/R, ou sobrescritos por uma consulta HQL ou consulta com "
"<literal>Criteria</literal>. "

#. Tag: para
#, no-c-format
msgid "Hibernate3 defines the following fetching strategies:"
msgstr "Hibernate3 define as seguintes estratégias de busca:"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Join fetching</emphasis>: Hibernate retrieves the associated "
"instance or collection in the same <literal>SELECT</literal>, using an "
"<literal>OUTER JOIN</literal>."
msgstr ""
"<emphasis>Join fetching</emphasis> - o Hibernate busca o objeto ou coleção "
"associada no mesmo <literal>SELECT</literal>, usando um <literal>OUTER JOIN</"
"literal>. "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Select fetching</emphasis>: a second <literal>SELECT</literal> is "
"used to retrieve the associated entity or collection. Unless you explicitly "
"disable lazy fetching by specifying <literal>lazy=\"false\"</literal>, this "
"second select will only be executed when you access the association."
msgstr ""
"<emphasis>Select fetching</emphasis> - um segundo <literal>SELECT</literal> "
"é usado para buscar a entidade ou coleção associada. A menos que você "
"desabilite a busca lazy, especificando <literal>lazy=\"false\"</literal>, "
"esse segundo SELECT será executado apenas quando você acessar a associação. "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Subselect fetching</emphasis>: a second <literal>SELECT</literal> "
"is used to retrieve the associated collections for all entities retrieved in "
"a previous query or fetch. Unless you explicitly disable lazy fetching by "
"specifying <literal>lazy=\"false\"</literal>, this second select will only "
"be executed when you access the association."
msgstr ""
"<emphasis>Subselect fetching</emphasis> - um segundo <literal>SELECT</"
"literal> será usado para recuperar as coleções associadas de todas as "
"entidades recuperadas em uma consulta ou busca anterior. A menos que você "
"desabilite a busca lazy especificando <literal>lazy=\"false\"</literal>, "
"esse segundo SELECT será executado apenas quando você acessar a associação.  "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Batch fetching</emphasis>: an optimization strategy for select "
"fetching. Hibernate retrieves a batch of entity instances or collections in "
"a single <literal>SELECT</literal> by specifying a list of primary or "
"foreign keys."
msgstr ""
"<emphasis>Batch fetching</emphasis> - uma opção de otimização para "
"selecionar a busca. O Hibernate recupera um lote de instâncias ou entidades "
"usando um único <literal>SELECT</literal>, especificando uma lista de chaves "
"primárias ou chaves externas."

#. Tag: para
#, no-c-format
msgid "Hibernate also distinguishes between:"
msgstr "O Hibernate distingue também entre:"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Immediate fetching</emphasis>: an association, collection or "
"attribute is fetched immediately when the owner is loaded."
msgstr ""
"<emphasis>Immediate fetching</emphasis> - uma associação, coleção ou função "
"é imediatamente recuperada, quando o proprietário for carregado. "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Lazy collection fetching</emphasis>: a collection is fetched when "
"the application invokes an operation upon that collection. This is the "
"default for collections."
msgstr ""
"<emphasis>Lazy collection fetching</emphasis> - a coleção é recuperada "
"quando a aplicação invoca uma operação sobre aquela coleção. Esse é o padrão "
"para coleções."

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>\"Extra-lazy\" collection fetching</emphasis>: individual elements "
"of the collection are accessed from the database as needed. Hibernate tries "
"not to fetch the whole collection into memory unless absolutely needed. It "
"is suitable for large collections."
msgstr ""
"<emphasis>\"Extra-lazy\" collection fetching</emphasis> - elementos "
"individuais de uma coleção são acessados a partir do banco de dados quando "
"necessário. O Hibernate tenta não buscar a coleção inteira dentro da memória "
"a menos que seja absolutamente necessário. Isto é indicado para coleções "
"muito grandes."

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Proxy fetching</emphasis>: a single-valued association is fetched "
"when a method other than the identifier getter is invoked upon the "
"associated object."
msgstr ""
"<emphasis>Proxy fetching</emphasis>: uma associação de um valor é carregada "
"quando um método diferente do getter do identificador é invocado sobre o "
"objeto associado."

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>\"No-proxy\" fetching</emphasis>: a single-valued association is "
"fetched when the instance variable is accessed. Compared to proxy fetching, "
"this approach is less lazy; the association is fetched even when only the "
"identifier is accessed. It is also more transparent, since no proxy is "
"visible to the application. This approach requires buildtime bytecode "
"instrumentation and is rarely necessary."
msgstr ""
"<emphasis>\"No-proxy\" fetching</emphasis> - uma associação de um único "
"valor é recuperada quando a variável da instância é acessada. Comparada à "
"busca proxy, esse método é menos preguiçoso (lazy); a associação é buscada "
"até mesmo quando somente o identificador é acessado. Ela é mais "
"transparente, já que não há proxies visíveis para a aplicação. Esse método "
"requer instrumentação de bytecodes em build-time e é raramente necessário."

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Lazy attribute fetching</emphasis>: an attribute or single valued "
"association is fetched when the instance variable is accessed. This approach "
"requires buildtime bytecode instrumentation and is rarely necessary."
msgstr ""
"<emphasis>Lazy attribute fetching</emphasis>: um atributo ou associação de "
"um valor é buscado quanto a varíavel da instância é acessada. Esse método "
"requer instrumentação de bytecodes em build-time e é raramente necessário."

#. Tag: para
#, no-c-format
msgid ""
"We have two orthogonal notions here: <emphasis>when</emphasis> is the "
"association fetched and <emphasis>how</emphasis> is it fetched. It is "
"important that you do not confuse them. We use <literal>fetch</literal> to "
"tune performance. We can use <literal>lazy</literal> to define a contract "
"for what data is always available in any detached instance of a particular "
"class."
msgstr ""
"Nós temos aqui duas noções ortogonais: <emphasis>quando</emphasis> a "
"associação é buscada e <emphasis>como</emphasis> ela é buscada. É importante "
"que você não os confuda. Nós usamos <literal>fetch</literal> para ajustar o "
"desempenho. Podemos usar <literal>lazy</literal> para definir um contrato "
"para qual dado é sempre disponível em qualquer instância desconectada de uma "
"classe particular."

#. Tag: title
#, no-c-format
msgid "Working with lazy associations"
msgstr "Trabalhando com associações preguiçosas (lazy)"

#. Tag: para
#, no-c-format
msgid ""
"By default, Hibernate3 uses lazy select fetching for collections and lazy "
"proxy fetching for single-valued associations. These defaults make sense for "
"most associations in the majority of applications."
msgstr ""
"Por padrão, o Hibernate3 usa busca preguiçosa para coleções e busca "
"preguiçosa com proxy para associações de um valor. Esses padrões fazem "
"sentido para quase todas as associações em quase todas a aplicações. "

#. Tag: para
#, no-c-format
msgid ""
"If you set <literal>hibernate.default_batch_fetch_size</literal>, Hibernate "
"will use the batch fetch optimization for lazy fetching. This optimization "
"can also be enabled at a more granular level."
msgstr ""
"Se você ajustar <literal>hibernate. default_batch_fetch_size</literal>, o "
"Hibernate irá usar otimização de busca em lote para a busca preguiçosa. Essa "
"otimização pode ser também habilitada em um nível mais fino."

#. Tag: para
#, no-c-format
msgid ""
"Please be aware that access to a lazy association outside of the context of "
"an open Hibernate session will result in an exception. For example:"
msgstr ""
"Perceba que o acesso a associações preguiçosas fora do contexto de uma "
"sessão aberta do Hibernate irá resultar numa exceção. Por exemplo:"

#. Tag: para
#, no-c-format
msgid ""
"Since the permissions collection was not initialized when the "
"<literal>Session</literal> was closed, the collection will not be able to "
"load its state. <emphasis>Hibernate does not support lazy initialization for "
"detached objects</emphasis>. This can be fixed by moving the code that reads "
"from the collection to just before the transaction is committed."
msgstr ""
"Como a coleção de permissões não foi inicializada quando a <literal>Session</"
"literal> for fechada, a coleção não poderá carregar o seu estado. "
"<emphasis>O Hibernate não suporta inicialização preguiçosa para objetos "
"desconectados</emphasis>. Para consertar isso, é necessário mover o código "
"que carrega a coleção para logo antes da transação ser submetida. "

#. Tag: para
#, no-c-format
msgid ""
"Alternatively, you can use a non-lazy collection or association, by "
"specifying <literal>lazy=\"false\"</literal> for the association mapping. "
"However, it is intended that lazy initialization be used for almost all "
"collections and associations. If you define too many non-lazy associations "
"in your object model, Hibernate will fetch the entire database into memory "
"in every transaction."
msgstr ""
"Alternativamente, nós podemos usar uma coleção ou associação não preguiçosa, "
"especificando <literal>lazy=\"false\"</literal> para o mapeamento da "
"associação. Porém, é pretendido que a inicialização preguiçosa seja usada "
"por quase todas as coleções e associações. Se você definir muitas "
"associações não preguiçosas em seu modelo de objetos, o Hibernate irá "
"precisar buscar no banco de dados inteiro da memória em cada transação."

#. Tag: para
#, no-c-format
msgid ""
"On the other hand, you can use join fetching, which is non-lazy by nature, "
"instead of select fetching in a particular transaction. We will now explain "
"how to customize the fetching strategy. In Hibernate3, the mechanisms for "
"choosing a fetch strategy are identical for single-valued associations and "
"collections."
msgstr ""
"Por outro lado, nós geralmente escolhemos a busca de união (que não é "
"preguiçosa por natureza) ao invés do selecionar busca em uma transação "
"particular. Nós agora veremos como customizar a estratégia de busca. No "
"Hibernate3, os mecanismos para escolher a estratégia de busca são idênticos "
"para as associações de valor único e para coleções."

#. Tag: title
#, no-c-format
msgid "Tuning fetch strategies"
msgstr "Personalizando as estratégias de busca"

#. Tag: para
#, no-c-format
msgid ""
"Select fetching (the default) is extremely vulnerable to N+1 selects "
"problems, so we might want to enable join fetching in the mapping document:"
msgstr ""
"O padrão selecionar busca, é extremamente vunerável aos problemas de seleção "
"N+1, então habilitaremos a busca de união no documento de mapeamento:"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>fetch</literal> strategy defined in the mapping document "
"affects:"
msgstr ""
"A estratégia de <literal>fetch</literal> definida no documento de mapeamento "
"afeta:"

#. Tag: para
#, no-c-format
msgid "retrieval via <literal>get()</literal> or <literal>load()</literal>"
msgstr "recupera via <literal>get()</literal> ou <literal>load()</literal>"

#. Tag: para
#, no-c-format
msgid "retrieval that happens implicitly when an association is navigated"
msgstr ""
"Recuperações que acontecem implicitamente quando navegamos por uma associação"

#. Tag: para
#, no-c-format
msgid "<literal>Criteria</literal> queries"
msgstr "consultas por <literal>Criteria</literal> "

#. Tag: para
#, no-c-format
msgid "HQL queries if <literal>subselect</literal> fetching is used"
msgstr "consultas HQL se a busca por <literal>subselect</literal> for usada"

#. Tag: para
#, no-c-format
msgid ""
"Irrespective of the fetching strategy you use, the defined non-lazy graph is "
"guaranteed to be loaded into memory. This might, however, result in several "
"immediate selects being used to execute a particular HQL query."
msgstr ""
"Independentemente da estratégia de busca que você usar, o gráfico não "
"preguiçoso definido será certamente carregado na memória. Note que isso irá "
"resultar em diversas seleções imediatas sendo usadas para rodar uma consulta "
"HQL em particular."

#. Tag: para
#, no-c-format
msgid ""
"Usually, the mapping document is not used to customize fetching. Instead, we "
"keep the default behavior, and override it for a particular transaction, "
"using <literal>left join fetch</literal> in HQL. This tells Hibernate to "
"fetch the association eagerly in the first select, using an outer join. In "
"the <literal>Criteria</literal> query API, you would use "
"<literal>setFetchMode(FetchMode.JOIN)</literal>."
msgstr ""
"Geralmente, não usamos documentos de mapeamento para customizar as buscas. "
"Ao invés disso, nós deixamos o comportamento padrão e sobrescrevemos isso em "
"uma transação em particular, usando <literal>left join fetch</literal> no "
"HQL. Isso diz ao Hibernate para buscar a associação inteira no primeiro "
"select, usando uma união externa. Na API de busca <literal>Criteria</"
"literal>, você irá usar <literal>setFetchMode(FetchMode.JOIN)</literal>."

#. Tag: para
#, no-c-format
msgid ""
"If you want to change the fetching strategy used by <literal>get()</literal> "
"or <literal>load()</literal>, you can use a <literal>Criteria</literal> "
"query. For example:"
msgstr ""
"Se você quiser mudar a estratégia de busca usada pelo <literal>get()</"
"literal> ou <literal>load()</literal>, simplesmente use uma consulta por "
"<literal>Criteria</literal>, por exemplo: "

#. Tag: para
#, no-c-format
msgid ""
"This is Hibernate's equivalent of what some ORM solutions call a \"fetch plan"
"\"."
msgstr ""
"Isto é o equivalente do Hibernate para o que algumas soluções ORM chamam de "
"\"plano de busca\"."

#. Tag: para
#, no-c-format
msgid ""
"A completely different approach to problems with N+1 selects is to use the "
"second-level cache."
msgstr ""
"Um meio totalmente diferente de evitar problemas com selects N+1 é usar um "
"cache de segundo nível. "

#. Tag: title
#, no-c-format
msgid "Single-ended association proxies"
msgstr "Proxies de associação final único"

#. Tag: para
#, no-c-format
msgid ""
"Lazy fetching for collections is implemented using Hibernate's own "
"implementation of persistent collections. However, a different mechanism is "
"needed for lazy behavior in single-ended associations. The target entity of "
"the association must be proxied. Hibernate implements lazy initializing "
"proxies for persistent objects using runtime bytecode enhancement which is "
"accessed via the CGLIB library."
msgstr ""
"A recuperação preguiçosa para coleções é implementada usando uma "
"implementação própria do Hibernate para coleções persistentes. Porém, é "
"necessário um mecanismo diferente para comportamento preguiçoso em "
"associações de final único. A entidade alvo da associação precisa usar um "
"proxy. O Hibernate implementa proxies para inicialização preguiçosa em "
"objetos persistentes usando manipulação de bytecode, através da excelente "
"biblioteca CGLIB. "

#. Tag: para
#, no-c-format
msgid ""
"At startup, Hibernate3 generates proxies by default for all persistent "
"classes and uses them to enable lazy fetching of <literal>many-to-one</"
"literal> and <literal>one-to-one</literal> associations."
msgstr ""
"Por padrão, o Hibernate3 gera proxies (na inicialização) para todas as "
"classes persistentes que os usem para habilitar recuperação preguiçosa de "
"associações <literal>many-to-one</literal> e <literal>one-to-one</literal>. "

#. Tag: para
#, no-c-format
msgid ""
"The mapping file may declare an interface to use as the proxy interface for "
"that class, with the <literal>proxy</literal> attribute. By default, "
"Hibernate uses a subclass of the class. <emphasis>The proxied class must "
"implement a default constructor with at least package visibility. This "
"constructor is recommended for all persistent classes</emphasis>."
msgstr ""
"O arquivo de mapeamento deve declarar uma interface para usar como interface "
"de proxy para aquela classe, com a função <literal>proxy</literal>. Por "
"padrão, o Hibernate usa uma subclasse dessa classe. <emphasis>Note que a "
"classe a ser usada via proxy precisa implementar o construtor padrão com "
"pelo menos visibilidade de package. Nós recomendamos esse construtor para "
"todas as classes persistentes</emphasis>."

#. Tag: para
#, no-c-format
msgid ""
"There are potential problems to note when extending this approach to "
"polymorphic classes.For example:"
msgstr ""
"Existe alguns truques que você deve saber quando estender esse comportamento "
"para classes polimórficas. Por exemplo:"

#. Tag: para
#, no-c-format
msgid ""
"Firstly, instances of <literal>Cat</literal> will never be castable to "
"<literal>DomesticCat</literal>, even if the underlying instance is an "
"instance of <literal>DomesticCat</literal>:"
msgstr ""
"Primeiramente, instâncias de <literal>Cat</literal> nunca serão convertidas "
"para <literal>DomesticCat</literal>, mesmo que a instância em questão seja "
"uma instância de <literal>DomesticCat</literal>:"

#. Tag: para
#, no-c-format
msgid "Secondly, it is possible to break proxy <literal>==</literal>:"
msgstr "E, segundo, é possível quebrar o proxy <literal>==</literal>:"

#. Tag: para
#, no-c-format
msgid ""
"However, the situation is not quite as bad as it looks. Even though we now "
"have two references to different proxy objects, the underlying instance will "
"still be the same object:"
msgstr ""
"Porém a situação não é tão ruim como parece. Mesmo quando temos duas "
"referências para objetos proxies diferentes, a instância adjacente será do "
"mesmo objeto:"

#. Tag: para
#, no-c-format
msgid ""
"Third, you cannot use a CGLIB proxy for a <literal>final</literal> class or "
"a class with any <literal>final</literal> methods."
msgstr ""
"E por terceiro, você não pode usar um proxy CGLIB em uma classe "
"<literal>final</literal> ou com quaisquer métodos <literal>final</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Finally, if your persistent object acquires any resources upon instantiation "
"(e.g. in initializers or default constructor), then those resources will "
"also be acquired by the proxy. The proxy class is an actual subclass of the "
"persistent class."
msgstr ""
"Finalmente, se o seu objeto persistente adquirir qualquer recurso durante a "
"instanciação (ex. em inicializadores ou construtor padrão), então esses "
"recursos serão adquiridos pelo proxy também. A classe de proxy é uma "
"subclasse da classe persistente. "

#. Tag: para
#, no-c-format
msgid ""
"These problems are all due to fundamental limitations in Java's single "
"inheritance model. To avoid these problems your persistent classes must each "
"implement an interface that declares its business methods. You should "
"specify these interfaces in the mapping file where <literal>CatImpl</"
"literal> implements the interface <literal>Cat</literal> and "
"<literal>DomesticCatImpl</literal> implements the interface "
"<literal>DomesticCat</literal>. For example:"
msgstr ""
"Esses problemas se dão devido à limitação originária do modelo de herança "
"simples do Java. Se você quiser evitar esses problemas em suas classes "
"persistentes você deve implementar uma interface que declare seus métodos "
"comerciais. Você deve especificar essas interfaces no arquivo de mapeamento "
"onde <literal>CatImpl</literal> implementa a interface <literal>Cat</"
"literal> e <literal>DomesticCatImpl</literal> implementa a interface "
"<literal>DomesticCat</literal>. Por exemplo: "

#. Tag: para
#, no-c-format
msgid ""
"Then proxies for instances of <literal>Cat</literal> and "
"<literal>DomesticCat</literal> can be returned by <literal>load()</literal> "
"or <literal>iterate()</literal>."
msgstr ""
"Então, os proxies para instâncias de <literal>Cat</literal> e  "
"<literal>DomesticCat</literal> podem ser retornadas pelo <literal>load()</"
"literal> ou <literal>iterate()</literal>."

#. Tag: title
#, no-c-format
msgid "Note"
msgstr "Nota"

#. Tag: para
#, no-c-format
msgid "<literal>list()</literal> does not usually return proxies."
msgstr "<literal>list()</literal> normalmente retorna proxies."

#. Tag: para
#, no-c-format
msgid ""
"Relationships are also lazily initialized. This means you must declare any "
"properties to be of type <literal>Cat</literal>, not <literal>CatImpl</"
"literal>."
msgstr ""
"Relacionamentos são também inicializados de forma preguiçosa. Isso significa "
"que você precisa declarar qualquer propriedade como sendo do tipo "
"<literal>Cat</literal>, e não <literal>CatImpl</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Certain operations do <emphasis>not</emphasis> require proxy initialization:"
msgstr ""
"Algumas operações <emphasis>não</emphasis> requerem inicialização por proxy: "

#. Tag: para
#, no-c-format
msgid ""
"<literal>equals()</literal>: if the persistent class does not override "
"<literal>equals()</literal>"
msgstr ""
"<literal>equals()</literal>: se a classe persistente não sobrescrever "
"<literal>equals()</literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>hashCode()</literal>: if the persistent class does not override "
"<literal>hashCode()</literal>"
msgstr ""
"<literal>hashCode()</literal>: se a classe persistente não sobrescrever "
"<literal>hashCode()</literal>"

#. Tag: para
#, no-c-format
msgid "The identifier getter method"
msgstr "O método getter do identificador"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate will detect persistent classes that override <literal>equals()</"
"literal> or <literal>hashCode()</literal>."
msgstr ""
"O Hibernate irá detectar classes persistentes que sobrescrevem "
"<literal>equals()</literal> ou <literal>hashCode()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"By choosing <literal>lazy=\"no-proxy\"</literal> instead of the default "
"<literal>lazy=\"proxy\"</literal>, you can avoid problems associated with "
"typecasting. However, buildtime bytecode instrumentation is required, and "
"all operations will result in immediate proxy initialization."
msgstr ""
"Escolhendo <literal>lazy=\"no-proxy\"</literal> ao invés do padrão "
"<literal>lazy=\"proxy\"</literal>, podemos evitar problemas associados com "
"typecasting. Porém, iremos precisar de instrumentação de bytecode em tempo "
"de compilação e todas as operações irão resultar em inicializações de proxy "
"imediatas. "

#. Tag: title
#, no-c-format
msgid "Initializing collections and proxies"
msgstr "Inicializando coleções e proxies"

#. Tag: para
#, no-c-format
msgid ""
"A <literal>LazyInitializationException</literal> will be thrown by Hibernate "
"if an uninitialized collection or proxy is accessed outside of the scope of "
"the <literal>Session</literal>, i.e., when the entity owning the collection "
"or having the reference to the proxy is in the detached state."
msgstr ""
"Será lançada uma <literal>LazyInitializationException</literal> se uma "
"coleção não inicializada ou proxy for acessado fora do escopo da "
"<literal>Session</literal>, isto é, quando a entidade que contém a coleção "
"ou que possua a referência ao proxy estiver no estado desanexado. "

#. Tag: para
#, no-c-format
msgid ""
"Sometimes a proxy or collection needs to be initialized before closing the "
"<literal>Session</literal>. You can force initialization by calling "
"<literal>cat.getSex()</literal> or <literal>cat.getKittens().size()</"
"literal>, for example. However, this can be confusing to readers of the code "
"and it is not convenient for generic code."
msgstr ""
"Algumas vezes precisamos garantir que o proxy ou coleção é inicializado "
"antes de fechar a <literal>Session</literal>. Claro que sempre podemos "
"forçar a inicialização chamando <literal>cat.getSex()</literal> ou "
"<literal>cat.getKittens().size()</literal>, por exemplo. Mas isto parece "
"confuso para quem lê o código e não é conveniente para códigos genéricos. "

#. Tag: para
#, no-c-format
msgid ""
"The static methods <literal>Hibernate.initialize()</literal> and "
"<literal>Hibernate.isInitialized()</literal>, provide the application with a "
"convenient way of working with lazily initialized collections or proxies. "
"<literal>Hibernate.initialize(cat)</literal> will force the initialization "
"of a proxy, <literal>cat</literal>, as long as its <literal>Session</"
"literal> is still open. <literal>Hibernate.initialize( cat.getKittens() )</"
"literal> has a similar effect for the collection of kittens."
msgstr ""
"Os métodos estáticos <literal>Hibernate.initialize()</literal> e "
"<literal>Hibernate.isInitialized()</literal> favorecem a aplicação para "
"trabalhar com coleções ou proxies inicializados de forma preguiçosa. O "
"<literal>Hibernate.initialize(cat)</literal> irá forçar a inicialização de "
"um proxy, <literal>cat</literal>, contanto que a <literal>Session</literal> "
"esteja ainda aberta. <literal>Hibernate.initialize (cat.getKittens() )</"
"literal> tem um efeito similar para a coleção de kittens. "

#. Tag: para
#, no-c-format
msgid ""
"Another option is to keep the <literal>Session</literal> open until all "
"required collections and proxies have been loaded. In some application "
"architectures, particularly where the code that accesses data using "
"Hibernate, and the code that uses it are in different application layers or "
"different physical processes, it can be a problem to ensure that the "
"<literal>Session</literal> is open when a collection is initialized. There "
"are two basic ways to deal with this issue:"
msgstr ""
"Uma outra opção é manter a <literal>Session</literal> aberta até que todas "
"as coleções e os proxies necessários sejam carregados. Em algumas "
"arquiteturas de aplicações, particularmente onde o código que acessa os "
"dados usando Hibernate e o código que os usa, se encontram em diferentes "
"camadas da aplicação ou diferentes processos físicos, será um problema "
"garantir que a <literal>Session</literal> esteja aberta quando uma coleção "
"for inicializada. Existem dois caminhos básicos para lidar com esse "
"problema: "

#. Tag: para
#, no-c-format
msgid ""
"In a web-based application, a servlet filter can be used to close the "
"<literal>Session</literal> only at the end of a user request, once the "
"rendering of the view is complete (the <emphasis>Open Session in View</"
"emphasis> pattern). Of course, this places heavy demands on the correctness "
"of the exception handling of your application infrastructure. It is vitally "
"important that the <literal>Session</literal> is closed and the transaction "
"ended before returning to the user, even when an exception occurs during "
"rendering of the view. See the Hibernate Wiki for examples of this \"Open "
"Session in View\" pattern."
msgstr ""
"Em uma aplicações web, um filtro servlet pode ser usado para fechar a "
"<literal>Session</literal> somente no final da requisição do usuário, quando "
"a renderização da view estiver completa (o modelo <emphasis>Abrir Sessão em "
"View</emphasis>). Claro, que isto demanda uma exatidão no manuseio de "
"exceções na infraestrutura de sua aplicação. É extremamente importante que a "
"<literal>Session</literal> seja fechada e a transação terminada antes de "
"retornar para o usuário, mesmo que uma exceção ocorra durante a renderização "
"da view. Veja o Wiki do Hibernate para exemplos do pattern \"Abrir Sessão em "
"View\"."

#. Tag: para
#, no-c-format
msgid ""
"In an application with a separate business tier, the business logic must "
"\"prepare\" all collections that the web tier needs before returning. This "
"means that the business tier should load all the data and return all the "
"data already initialized to the presentation/web tier that is required for a "
"particular use case. Usually, the application calls <literal>Hibernate."
"initialize()</literal> for each collection that will be needed in the web "
"tier (this call must occur before the session is closed) or retrieves the "
"collection eagerly using a Hibernate query with a <literal>FETCH</literal> "
"clause or a <literal>FetchMode.JOIN</literal> in <literal>Criteria</"
"literal>. This is usually easier if you adopt the <emphasis>Command</"
"emphasis> pattern instead of a <emphasis>Session Facade</emphasis>."
msgstr ""
"Em uma aplicação com uma camada de negócios separada, a lógica de negócios "
"deve \"preparar\" todas as coleções que serão usadas pela camada web antes "
"de retornar. Isto sgnifica que a camada de negócios deve carregar todos os "
"dados e retorná-los já inicializados para a camada de apresentação que é "
"representada para um caso de uso particular. Geralmente, a aplicação chama "
"<literal>Hibernate.initialize()</literal> para cada coleção que será usada "
"pela camada web (essa chamada deve ocorrer antes da sessão ser fechada) ou "
"retorna a coleção usando uma consulta Hibernate com uma cláusula "
"<literal>FETCH</literal> ou um <literal>FetchMode.JOIN</literal> na "
"<literal>Criteria</literal>. Fica muito mais fácil se você adotar o modelo "
"<emphasis>Command</emphasis> ao invés do <emphasis>Session Facade</"
"emphasis>. "

#. Tag: para
#, no-c-format
msgid ""
"You can also attach a previously loaded object to a new <literal>Session</"
"literal> with <literal>merge()</literal> or <literal>lock()</literal> before "
"accessing uninitialized collections or other proxies. Hibernate does not, "
"and certainly <emphasis>should</emphasis> not, do this automatically since "
"it would introduce impromptu transaction semantics."
msgstr ""
"Você também pode anexar um objeto previamente carregado em uma nova "
"<literal>Session</literal><literal>merge()</literal> ou <literal>lock()</"
"literal> antes de acessar coleções não inicializadas (ou outros proxies). O "
"Hibernate não faz e certamente <literal>não deve</literal> fazer isso "
"automaticamente, pois isso introduziria semântica em transações  impromptu."

#. Tag: para
#, no-c-format
msgid ""
"Sometimes you do not want to initialize a large collection, but still need "
"some information about it, like its size, for example, or a subset of the "
"data."
msgstr ""
"Às vezes você não quer inicializar uma coleção muito grande, mas precisa de "
"algumas informações, como o mesmo tamanho, ou um subconjunto de seus dados."

#. Tag: para
#, no-c-format
msgid ""
"You can use a collection filter to get the size of a collection without "
"initializing it:"
msgstr ""
"Você pode usar um filtro de coleção para saber seu tamanho sem inicializá-la:"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>createFilter()</literal> method is also used to efficiently "
"retrieve subsets of a collection without needing to initialize the whole "
"collection:"
msgstr ""
"O método <literal>createFilter()</literal> é usado também para retornar "
"algus dados de uma coleção eficientemente sem precisar inicializar a coleção "
"inteira:"

#. Tag: title
#, no-c-format
msgid "Using batch fetching"
msgstr "Usando busca em lote"

#. Tag: para
#, no-c-format
msgid ""
"Using batch fetching, Hibernate can load several uninitialized proxies if "
"one proxy is accessed. Batch fetching is an optimization of the lazy select "
"fetching strategy. There are two ways you can configure batch fetching: on "
"the class level and the collection level."
msgstr ""
"O Hibernate pode fazer uso eficiente de busca em lote, ou seja o Hibernate "
"pode carregar diversos proxies não inicializados, se um proxy for acessado "
"(ou coleções). A busca em lote é uma otimização da estratégia da busca de "
"seleção lazy. Existem duas maneiras para você usar a busca em lote: no nível "
"da classe ou no nível da coleção."

#. Tag: para
#, no-c-format
msgid ""
"Batch fetching for classes/entities is easier to understand. Consider the "
"following example: at runtime you have 25 <literal>Cat</literal> instances "
"loaded in a <literal>Session</literal>, and each <literal>Cat</literal> has "
"a reference to its <literal>owner</literal>, a <literal>Person</literal>. "
"The <literal>Person</literal> class is mapped with a proxy, <literal>lazy="
"\"true\"</literal>. If you now iterate through all cats and call "
"<literal>getOwner()</literal> on each, Hibernate will, by default, execute "
"25 <literal>SELECT</literal> statements to retrieve the proxied owners. You "
"can tune this behavior by specifying a <literal>batch-size</literal> in the "
"mapping of <literal>Person</literal>:"
msgstr ""
"A recuperação em lote para classes/entidades é mais fácil de entender. "
"Imagine que você tem a seguinte situação em tempo de execução: você tem 25 "
"instâncias de <literal>Cat</literal> carregadas em uma <literal>Session</"
"literal>, cada <literal>Cat</literal> possui uma referência ao seu "
"<literal>owner</literal>, que é da classe <literal>Person</literal>. A "
"classe <literal>Person</literal> é mapeada com um proxy, <literal>lazy=\"true"
"\"</literal>. Se você interar sobre todos os Cat's e chamar <literal>getOwner"
"()</literal> em cada, o Hibernate irá por padrão executar 25 comandos "
"<literal>SELECT()</literal>, para buscar os proxies de owners. Você pode "
"melhorar esse comportamento especificando um <literal>batch-size</literal> "
"no mapeamento da classe <literal>Person</literal>: "

#. Tag: para
#, no-c-format
msgid ""
"Hibernate will now execute only three queries: the pattern is 10, 10, 5."
msgstr ""
"O Hibernate irá executar agora apenas três consultas; o padrão é 10, 10, 5."

#. Tag: para
#, no-c-format
msgid ""
"You can also enable batch fetching of collections. For example, if each "
"<literal>Person</literal> has a lazy collection of <literal>Cat</literal>s, "
"and 10 persons are currently loaded in the <literal>Session</literal>, "
"iterating through all persons will generate 10 <literal>SELECT</literal>s, "
"one for every call to <literal>getCats()</literal>. If you enable batch "
"fetching for the <literal>cats</literal> collection in the mapping of "
"<literal>Person</literal>, Hibernate can pre-fetch collections:"
msgstr ""
"Você também pode habilitar busca em lote de uma coleção. Por exemplo, se "
"cada <literal>Person</literal> tem uma coleção preguiçosa de <literal>Cat</"
"literal>s e 10 persons estão já carregadas em uma <literal>Session</"
"literal>, serão gerados 10 <literal>SELECT</literal>s ao se interar todas as "
"persons, um para cada chamada de <literal>getCats()</literal>. Se você "
"habilitar busca em lote para a coleção de <literal>cats</literal> no "
"mapeamento da classe <literal>Person</literal>, o Hibernate pode fazer uma "
"pré carga das coleções:"

#. Tag: para
#, no-c-format
msgid ""
"With a <literal>batch-size</literal> of 3, Hibernate will load 3, 3, 3, 1 "
"collections in four <literal>SELECT</literal>s. Again, the value of the "
"attribute depends on the expected number of uninitialized collections in a "
"particular <literal>Session</literal>."
msgstr ""
"Com um <literal>batch-size</literal> de 3, o Hibernate irá carregar 3, 3, 3, "
"1 coleções em 4 <literal>SELECT</literal>s. Novamente, o valor da função "
"depende do número esperado de coleções não inicializadas em determinada "
"<literal>Session</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Batch fetching of collections is particularly useful if you have a nested "
"tree of items, i.e. the typical bill-of-materials pattern. However, a "
"<emphasis>nested set</emphasis> or a <emphasis>materialized path</emphasis> "
"might be a better option for read-mostly trees."
msgstr ""
"A busca em lote de coleções é particularmente útil quando você tem uma "
"árvore encadeada de ítens, ex.: o típico padrão bill-of-materials (Se bem "
"que um <emphasis>conjunto encadeado</emphasis> ou <emphasis>caminho "
"materializado</emphasis> pode ser uma opção melhor para árvores com mais "
"leitura."

#. Tag: title
#, no-c-format
msgid "Using subselect fetching"
msgstr "Usando busca de subseleção"

#. Tag: para
#, no-c-format
msgid ""
"If one lazy collection or single-valued proxy has to be fetched, Hibernate "
"will load all of them, re-running the original query in a subselect. This "
"works in the same way as batch-fetching but without the piecemeal loading."
msgstr ""
"Se uma coleção ou proxy simples precisa ser recuperado, o Hibernate carrega "
"todos eles rodando novamente a consulta original em uma subseleção. Isso "
"funciona da mesma maneira que busca em lote, sem carregar tanto."

#. Tag: title
#, no-c-format
msgid "Fetch profiles"
msgstr "Perfis de Busca "

#. Tag: para
#, no-c-format
msgid ""
"Another way to affect the fetching strategy for loading associated objects "
"is through something called a fetch profile, which is a named configuration "
"associated with the <interfacename>org.hibernate.SessionFactory</"
"interfacename> but enabled, by name, on the <interfacename>org.hibernate."
"Session</interfacename>. Once enabled on a <interfacename>org.hibernate."
"Session</interfacename>, the fetch profile wull be in affect for that "
"<interfacename>org.hibernate.Session</interfacename> until it is explicitly "
"disabled."
msgstr ""
"Outra forma de afetar a estratégia de busca para o carregamento de objetos "
"associados é através do chamado perfil de busca, que é uma associação de "
"configuração de nomeada com o <interfacename>org.hibernate.SessionFactory</"
"interfacename>, porém ativado pelo nome no <interfacename>org.hibernate."
"Session</interfacename>. Uma vez ativado no <interfacename>org.hibernate."
"Session</interfacename>, o perfil de busca será afetado pelo "
"<interfacename>org.hibernate.Session</interfacename> até que o mesmo seja "
"completamente desativado."

#. Tag: para
#, no-c-format
msgid ""
"So what does that mean? Well lets explain that by way of an example. Say we "
"have the following mappings:"
msgstr ""
"O que isto significa? A explicação será através de um exemplo. Vamos dizer "
"que nós temos os seguintes mapeamentos:"

#. Tag: para
#, no-c-format
msgid ""
"Now normally when you get a reference to a particular customer, that "
"customer's set of orders will be lazy meaning we will not yet have loaded "
"those orders from the database. Normally this is a good thing. Now lets say "
"that you have a certain use case where it is more efficient to load the "
"customer and their orders together. One way certainly is to use \"dynamic "
"fetching\" strategies via an HQL or criteria queries. But another option is "
"to use a fetch profile to achieve that. Just add the following to your "
"mapping:"
msgstr ""
"Normalmente, quando você recebe uma referência para um cliente em "
"particular, o conjunto do cliente de pedidos será lento, significando que "
"nós ainda não baixamos estes pedidos a partir do banco de dados. Na maioria "
"das vezes isto é bom. Agora vamos imaginar que você possui um determinado "
"caso de uso, onde é mais eficiente carregar o cliente e outros pedidos "
"juntos. Uma maneira correta é utilizar as estratégias de \"busca dinâmica\" "
"através de um HQL ou consultas de critério. Entretanto, outra opção é usar "
"um perfil de busca para atingir o mesmo objeto. Apenas adicione o seguinte a "
"seu mapeamento:"

#. Tag: para
#, no-c-format
msgid "or even:"
msgstr "ou ainda:"

#. Tag: para
#, no-c-format
msgid ""
"Now the following code will actually load both the customer <emphasis>and "
"their orders</emphasis>:"
msgstr ""
"Agora que o código seguinte irá carregar ambos cliente <emphasis>e outros "
"pedidos</emphasis>:"

#. Tag: para
#, no-c-format
msgid ""
"Currently only join style fetch profiles are supported, but they plan is to "
"support additional styles. See <ulink url=\"http://opensource.atlassian.com/"
"projects/hibernate/browse/HHH-3414\">HHH-3414</ulink> for details."
msgstr ""
"Apenas os perfis de busca em estilo são suportados, mas planeja-se o suporte "
"de estilos adicionais. Consulte <ulink url=\"http://opensource.atlassian.com/"
"projects/hibernate/browse/HHH-3414\">HHH-3414</ulink> para maiores detalhes."

#. Tag: title
#, no-c-format
msgid "Using lazy property fetching"
msgstr "Usando busca preguiçosa de propriedade"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate3 supports the lazy fetching of individual properties. This "
"optimization technique is also known as <emphasis>fetch groups</emphasis>. "
"Please note that this is mostly a marketing feature; optimizing row reads is "
"much more important than optimization of column reads. However, only loading "
"some properties of a class could be useful in extreme cases. For example, "
"when legacy tables have hundreds of columns and the data model cannot be "
"improved."
msgstr ""
"O Hibernate3 suporta a busca lazy de propriedades individuais. Essa técnica "
"de otimização é também conhecida como <emphasis>grupos de busca</emphasis>. "
"Veja que esta é mais uma característica de marketing já que na prática, é "
"mais importante a otimização nas leituras dos registros do que na leitura "
"das colunas. Porém, carregar apenas algumas propriedades de uma classe pode "
"ser útil em casos extremos, onde tabelas legadas podem ter centenas de "
"colunas e o modelo de dados não pode ser melhorado."

#. Tag: para
#, no-c-format
msgid ""
"To enable lazy property loading, set the <literal>lazy</literal> attribute "
"on your particular property mappings:"
msgstr ""
"Para habilitar a carga de propriedade lazy, é preciso ajustar a função "
"<literal>lazy</literal> no seu mapeamento de propriedade:"

#. Tag: para
#, no-c-format
msgid ""
"Lazy property loading requires buildtime bytecode instrumentation. If your "
"persistent classes are not enhanced, Hibernate will ignore lazy property "
"settings and return to immediate fetching."
msgstr ""
"A carga de propriedades lazy requer instrumentação de bytecode. Se suas "
"classes persistentes não forem melhoradas, o Hibernate irá ignorar "
"silenciosamente essa configuração e usará a busca imediata."

#. Tag: para
#, no-c-format
msgid "For bytecode instrumentation, use the following Ant task:"
msgstr "Para instrumentação de bytecode, use a seguinte tarefa do Ant:"

#. Tag: para
#, no-c-format
msgid ""
"A different way of avoiding unnecessary column reads, at least for read-only "
"transactions, is to use the projection features of HQL or Criteria queries. "
"This avoids the need for buildtime bytecode processing and is certainly a "
"preferred solution."
msgstr ""
"Uma forma diferente de evitar leitura de coluna desnecessária, ao menos para "
"transações de somente leitura, deve-se usar os recursos de projeção do HQL "
"ou consultas por Critério. Isto evita a necessidade de processamento de "
"bytecode em build-time e é certamente uma melhor solução."

#. Tag: para
#, no-c-format
msgid ""
"You can force the usual eager fetching of properties using <literal>fetch "
"all properties</literal> in HQL."
msgstr ""
"Você pode forçar a busca antecipada comum de propriedades usando "
"<literal>buscar todas as propriedades</literal> no HQL."

#. Tag: title
#, no-c-format
msgid "The Second Level Cache"
msgstr "O Cachê de Segundo Nível"

#. Tag: para
#, no-c-format
msgid ""
"A Hibernate <literal>Session</literal> is a transaction-level cache of "
"persistent data. It is possible to configure a cluster or JVM-level "
"(<literal>SessionFactory</literal>-level) cache on a class-by-class and "
"collection-by-collection basis. You can even plug in a clustered cache. Be "
"aware that caches are not aware of changes made to the persistent store by "
"another application. They can, however, be configured to regularly expire "
"cached data."
msgstr ""
"Uma <literal>Session</literal> do Hibernate é um cache de nível transacional "
"de dados persistentes. É possível configurar um cluster ou um cache de nível "
"JVM (nível <literal>SessionFactory</literal>) em uma estrutura classe por "
"classe e coleção por coleção. Você pode até mesmo plugar em um cache em "
"cluster. Tenha cuidado, pois os caches nunca sabem das mudanças feitas em "
"armazenamento persistente por um outro aplicativo. No entanto, eles podem "
"ser configurados para dados em cache vencido regularmente."

#. Tag: para
#, no-c-format
msgid ""
"You have the option to tell Hibernate which caching implementation to use by "
"specifying the name of a class that implements <literal>org.hibernate.cache."
"CacheProvider</literal> using the property <literal>hibernate.cache."
"provider_class</literal>. Hibernate is bundled with a number of built-in "
"integrations with the open-source cache providers that are listed below. You "
"can also implement your own and plug it in as outlined above. Note that "
"versions prior to 3.2 use EhCache as the default cache provider."
msgstr ""
"Você tem a opção de informar o Hibernate sobre qual implementação de cache "
"utilizar, especificando o nome de uma classe que implementa <literal>org."
"hibernate.cache.CacheProvider</literal> usando a propriedade "
"<literal>hibernate.cache.provider_class</literal>. O Hibernate vem envolvido "
"com um número de integrações construídas com provedores de cache de fonte "
"aberta (listados abaixo). Além disso, você pode implementar seu próprio e "
"plugá-lo como mencionado acima. Note que as versões anteriores ao padrão 3.2 "
"utilizam EhCache como provedor de cache padrão. "

#. Tag: title
#, no-c-format
msgid "Cache Providers"
msgstr "Provedores de Cache "

#. Tag: entry
#, no-c-format
msgid "Cache"
msgstr "Cache"

#. Tag: entry
#, no-c-format
msgid "Provider class"
msgstr "Classe de provedor"

#. Tag: entry
#, no-c-format
msgid "Type"
msgstr "Tipo"

#. Tag: entry
#, no-c-format
msgid "Cluster Safe"
msgstr "Segurança de Cluster"

#. Tag: entry
#, no-c-format
msgid "Query Cache Supported"
msgstr "Cache de Consulta Suportado"

#. Tag: entry
#, no-c-format
msgid "Hashtable (not intended for production use)"
msgstr "Hashtable (não recomendado para uso de produção)"

#. Tag: entry
#, no-c-format
msgid "<literal>org.hibernate.cache.HashtableCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.HashtableCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "memory"
msgstr "memória"

#. Tag: entry
#, no-c-format
msgid "yes"
msgstr "sim"

#. Tag: entry
#, no-c-format
msgid "EHCache"
msgstr "EHCache"

#. Tag: entry
#, no-c-format
msgid "<literal>org.hibernate.cache.EhCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.EhCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "memory, disk"
msgstr "memória, disco"

#. Tag: entry
#, no-c-format
msgid "OSCache"
msgstr "OSCache"

#. Tag: entry
#, no-c-format
msgid "<literal>org.hibernate.cache.OSCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.OSCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "SwarmCache"
msgstr "SwarmCache"

#. Tag: entry
#, no-c-format
msgid "<literal>org.hibernate.cache.SwarmCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.SwarmCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "clustered (ip multicast)"
msgstr "clustered (ip multicast)"

#. Tag: entry
#, no-c-format
msgid "yes (clustered invalidation)"
msgstr "sim (invalidação em cluster)"

#. Tag: entry
#, no-c-format
msgid "JBoss Cache 1.x"
msgstr "JBoss Cache 1.x"

#. Tag: entry
#, no-c-format
msgid "<literal>org.hibernate.cache.TreeCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.TreeCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "clustered (ip multicast), transactional"
msgstr "(ip multicast) em cluster, transacional"

#. Tag: entry
#, no-c-format
msgid "yes (replication)"
msgstr "sim (replicação)"

#. Tag: entry
#, no-c-format
msgid "yes (clock sync req.)"
msgstr "sim (solicitação de sync. de relógio)"

#. Tag: entry
#, no-c-format
msgid "JBoss Cache 2"
msgstr "JBoss Cache 2"

#. Tag: entry
#, no-c-format
msgid "<literal>org.hibernate.cache.jbc.JBossCacheRegionFactory</literal>"
msgstr "<literal>org.hibernate.cache.jbc.JBossCacheRegionFactory</literal>"

#. Tag: entry
#, no-c-format
msgid "yes (replication or invalidation)"
msgstr "sim (invalidação ou replicação)"

#. Tag: title
#, no-c-format
msgid "Cache mappings"
msgstr "Mapeamento de Cache"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>&lt;cache&gt;</literal> element of a class or collection "
"mapping has the following form:"
msgstr ""
"O elemento <literal>&lt;cache&gt;</literal> de uma classe ou mapeamento de "
"coleção possui a seguinte forma:"

#. Tag: para
#, no-c-format
msgid ""
"<literal>usage</literal> (required) specifies the caching strategy: "
"<literal>transactional</literal>, <literal>read-write</literal>, "
"<literal>nonstrict-read-write</literal> or <literal>read-only</literal>"
msgstr ""
"<literal>uso</literal> (solicitado) especifica a estratégia de cache: "
"<literal>transacional</literal>, <literal>leitura-escrita</literal>, "
"<literal>leitura-escrita não estrito</literal> ou <literal>somente leitura</"
"literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>region</literal> (optional: defaults to the class or collection "
"role name): specifies the name of the second level cache region"
msgstr ""
"<literal>region</literal> (opcional: padrão à classe ou nome papel da "
"coleção): especifica o nome da região do cache de segundo nível"

#. Tag: para
#, no-c-format
msgid ""
"<literal>include</literal> (optional: defaults to <literal>all</literal>) "
"<literal>non-lazy</literal>: specifies that properties of the entity mapped "
"with <literal>lazy=\"true\"</literal> cannot be cached when attribute-level "
"lazy fetching is enabled"
msgstr ""
"<literal>include</literal> (opcional: padrão para <literal>all</literal>) "
"<literal>non-lazy</literal>: especifica que a propriedade da entidade "
"mapeada com <literal>lazy=\"true\"</literal> pode não estar em cache quando "
"o nível da função busca lazy for habilitada"

#. Tag: para
#, no-c-format
msgid ""
"Alternatively, you can specify <literal>&lt;class-cache&gt;</literal> and "
"<literal>&lt;collection-cache&gt;</literal> elements in <literal>hibernate."
"cfg.xml</literal>."
msgstr ""
"De forma alternativa, você poderá especificar os elementos <literal>&lt;"
"class-cache&gt;</literal> e <literal>&lt;collection-cache&gt;</literal> em "
"<literal>hibernate.cfg.xml</literal>."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>usage</literal> attribute specifies a <emphasis>cache "
"concurrency strategy</emphasis>."
msgstr ""
"A função <literal>uso </literal> especifica uma <emphasis>estratégia de "
"concorrência de cache</emphasis>."

#. Tag: title
#, no-c-format
msgid "Strategy: read only"
msgstr "Estratégia: somente leitura"

#. Tag: para
#, no-c-format
msgid ""
"If your application needs to read, but not modify, instances of a persistent "
"class, a <literal>read-only</literal> cache can be used. This is the "
"simplest and optimal performing strategy. It is even safe for use in a "
"cluster."
msgstr ""
"Se sua aplicação precisar ler mas nunca modificar instâncias de uma classe "
"persistente, pode-se utilizar um cache de <literal>read-only</literal>. Esta "
"é a estratégia de desempenho mais simples e melhor. É também perfeitamente "
"seguro para uso em um cluster."

#. Tag: title
#, no-c-format
msgid "Strategy: read/write"
msgstr "Estratégia: leitura/escrita"

#. Tag: para
#, no-c-format
msgid ""
"If the application needs to update data, a <literal>read-write</literal> "
"cache might be appropriate. This cache strategy should never be used if "
"serializable transaction isolation level is required. If the cache is used "
"in a JTA environment, you must specify the property <literal>hibernate."
"transaction.manager_lookup_class</literal> and naming a strategy for "
"obtaining the JTA <literal>TransactionManager</literal>. In other "
"environments, you should ensure that the transaction is completed when "
"<literal>Session.close()</literal> or <literal>Session.disconnect()</"
"literal> is called. If you want to use this strategy in a cluster, you "
"should ensure that the underlying cache implementation supports locking. The "
"built-in cache providers <emphasis>do not</emphasis> support locking."
msgstr ""
"Se a aplicação precisar atualizar dados, um cache de <literal>read-write</"
"literal> pode ser mais apropriado. Esta estratégia de cache nunca deve ser "
"usada se solicitado um nível de isolação de transação serializável. Se o "
"cache for usado em um ambiente JTA, você deve especificar a propriedade "
"<literal>hibernate.transaction.manager_lookup_class</literal>, nomeando uma "
"estratégia por obter o <literal>TransactionManager</literal> JTA. Em outros "
"ambientes, você deve assegurar que a transação está completa quando a "
"<literal>Session.close()</literal> ou <literal>Session.disconnect()</"
"literal> for chamada. Se desejar utilizar esta estratégia em um cluster, "
"você deve assegurar que a implementação de cache adjacente suporta o "
"bloqueio. Os provedores de cache built-in <emphasis>não</emphasis> suportam "
"o bloqueamento."

#. Tag: title
#, no-c-format
msgid "Strategy: nonstrict read/write"
msgstr "Estratégia: leitura/escrita não estrita"

#. Tag: para
#, no-c-format
msgid ""
"If the application only occasionally needs to update data (i.e. if it is "
"extremely unlikely that two transactions would try to update the same item "
"simultaneously), and strict transaction isolation is not required, a "
"<literal>nonstrict-read-write</literal> cache might be appropriate. If the "
"cache is used in a JTA environment, you must specify <literal>hibernate."
"transaction.manager_lookup_class</literal>. In other environments, you "
"should ensure that the transaction is completed when <literal>Session.close()"
"</literal> or <literal>Session.disconnect()</literal> is called."
msgstr ""
"Se a aplicação somente precisa atualizar dados ocasionalmente (ou seja, se "
"for extremamente improvável que as duas transações tentem atualizar o mesmo "
"ítem simultaneamente) e não for requerido uma isolação de transação estrita, "
"o uso deum cache de <literal>nonstrict-read-write</literal> pode ser mais "
"apropriado. Se um cache é usado em ambiente JTA, você deverá especificar o "
"<literal>hibernate.transaction.manager_lookup_class</literal>. Em outros "
"ambientes, você deve assegurar que a transação está completa quando a "
"<literal>Session.close()</literal> ou <literal>Session.disconnect()</"
"literal> for chamada."

#. Tag: title
#, no-c-format
msgid "Strategy: transactional"
msgstr "Estratégia: transacional"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>transactional</literal> cache strategy provides support for "
"fully transactional cache providers such as JBoss TreeCache. Such a cache "
"can only be used in a JTA environment and you must specify "
"<literal>hibernate.transaction.manager_lookup_class</literal>."
msgstr ""
"A estratégia de cache <literal>transactional</literal> provê suporte para "
"provedores de cache transacional completo como o JBoss TreeCache. Tal cache, "
"deve ser usado somente em um ambiente JTA e você deverá especificar o "
"<literal>hibernate.transaction.manager_lookup_class</literal>."

#. Tag: title
#, no-c-format
msgid "Cache-provider/concurrency-strategy compatibility"
msgstr "Compatibilidade de Estratégia de Concorrência de Cache Provedor"

#. Tag: para
#, no-c-format
msgid ""
"None of the cache providers support all of the cache concurrency strategies."
msgstr ""
"Nenhum provedor de cache suporta todas as estratégias de concorrência de "
"cache. "

#. Tag: para
#, no-c-format
msgid ""
"The following table shows which providers are compatible with which "
"concurrency strategies."
msgstr ""
"A seguinte tabela mostra qual provedor é compatível com qual estratégia de "
"concorrência. "

#. Tag: title
#, no-c-format
msgid "Cache Concurrency Strategy Support"
msgstr "Suporte de Estratégia de Concorrência de Cache"

#. Tag: entry
#, no-c-format
msgid "read-only"
msgstr "somente leitura"

#. Tag: entry
#, no-c-format
msgid "nonstrict-read-write"
msgstr "leitura-escrita não estrita"

#. Tag: entry
#, no-c-format
msgid "read-write"
msgstr "leitura-escrita"

#. Tag: entry
#, no-c-format
msgid "transactional"
msgstr "transacional"

#. Tag: title
#, no-c-format
msgid "Managing the caches"
msgstr "Gerenciando os caches"

#. Tag: para
#, no-c-format
msgid ""
"Whenever you pass an object to <literal>save()</literal>, <literal>update()</"
"literal> or <literal>saveOrUpdate()</literal>, and whenever you retrieve an "
"object using <literal>load()</literal>, <literal>get()</literal>, "
"<literal>list()</literal>, <literal>iterate()</literal> or <literal>scroll()"
"</literal>, that object is added to the internal cache of the "
"<literal>Session</literal>."
msgstr ""
"Quando passar um objeto para <literal>save()</literal>, <literal>update()</"
"literal> ou <literal>saveOrUpdate()</literal> e quando recuperar um objeto "
"usando um <literal>load()</literal>, <literal>get()</literal>, <literal>list"
"()</literal>, <literal>iterate()</literal> ou <literal>scroll()</literal>, "
"este objeto será adicionado ao cache interno da <literal>Session</literal>."

#. Tag: para
#, no-c-format
msgid ""
"When <literal>flush()</literal> is subsequently called, the state of that "
"object will be synchronized with the database. If you do not want this "
"synchronization to occur, or if you are processing a huge number of objects "
"and need to manage memory efficiently, the <literal>evict()</literal> method "
"can be used to remove the object and its collections from the first-level "
"cache."
msgstr ""
"Quando o <literal>flush()</literal> for subsequentemente chamado, o estado "
"deste objeto será sincronizado com o banco de dados. Se você não desejar que "
"esta sincronização aconteça ou se você estiver processando uma grande "
"quantidade de objetos e precisar gerenciar a memória de forma eficiente, o "
"método <literal>evict()</literal> pode ser usado para remover o objeto de "
"suas coleções de cache de primeiro nível."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>Session</literal> also provides a <literal>contains()</literal> "
"method to determine if an instance belongs to the session cache."
msgstr ""
"A <literal>Session</literal> também oferece um método<literal>contains()</"
"literal> para determinar se uma instância pertence ao cache de sessão."

#. Tag: para
#, no-c-format
msgid ""
"To evict all objects from the session cache, call <literal>Session.clear()</"
"literal>"
msgstr ""
"Para despejar completamente todos os objetos do cache de Sessão, chame "
"<literal>Session.clear()</literal>"

#. Tag: para
#, no-c-format
msgid ""
"For the second-level cache, there are methods defined on "
"<literal>SessionFactory</literal> for evicting the cached state of an "
"instance, entire class, collection instance or entire collection role."
msgstr ""
"Para o cache de segundo nível, existem métodos definidos na "
"<literal>SessionFactory</literal> para despejar o estado de cache de uma "
"instância, classe inteira, instância de coleção ou papel de coleção inteiro."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>CacheMode</literal> controls how a particular session interacts "
"with the second-level cache:"
msgstr ""
"O <literal>CacheMode</literal> controla como uma sessão em particular "
"interage com o cache de segundo nível:"

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.NORMAL</literal>: will read items from and write items to "
"the second-level cache"
msgstr ""
"<literal>CacheMode.NORMAL</literal> - lê e escreve itens ao cache de segundo "
"nível."

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.GET</literal>: will read items from the second-level "
"cache. Do not write to the second-level cache except when updating data"
msgstr ""
"<literal>CacheMode.GET</literal>: itens de leitura do cache de segundo "
"nível. Não escreve ao cache de segundo nível, exceto quando atualizar dados."

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.PUT</literal>: will write items to the second-level "
"cache. Do not read from the second-level cache"
msgstr ""
"<literal>CacheMode.PUT</literal>: escreve itens ao cache de segundo nível. "
"Não lê a partir do cache de segundo nível."

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.REFRESH</literal>: will write items to the second-level "
"cache. Do not read from the second-level cache. Bypass the effect of "
"<literal>hibernate.cache.use_minimal_puts</literal> forcing a refresh of the "
"second-level cache for all items read from the database"
msgstr ""
"<literal>CacheMode.REFRESH</literal>: escreve itens ao cache de segundo "
"nível, mas não lê a partir do cache de segundo nível. Passa o efeito de "
"<literal>hibernate.cache.use_minimal_puts</literal>, forçando uma "
"atualização do cache de segundo nível para que todos os itens leiam a partir "
"do banco de dados. "

#. Tag: para
#, no-c-format
msgid ""
"To browse the contents of a second-level or query cache region, use the "
"<literal>Statistics</literal> API:"
msgstr ""
"Para navegar o conteúdo do segundo nível ou região de cache de consulta, use "
"o<literal>Statistics</literal> API:"

#. Tag: para
#, no-c-format
msgid ""
"You will need to enable statistics and, optionally, force Hibernate to keep "
"the cache entries in a more readable format:"
msgstr ""
"Você precisará habilitar estatísticas e, opcionalmente, forçar o Hibernate a "
"manter as entradas de cache em um formato mais compreensível: "

#. Tag: title
#, no-c-format
msgid "The Query Cache"
msgstr "O Cache de Consulta"

#. Tag: para
#, no-c-format
msgid ""
"Query result sets can also be cached. This is only useful for queries that "
"are run frequently with the same parameters."
msgstr ""
"O conjunto de resultado de consulta pode também estar em cache. Isto é útil, "
"somente para consultas que são rodadas freqüentemente com os mesmos "
"parâmetros. "

#. Tag: title
#, no-c-format
msgid "Enabling query caching"
msgstr "Ativação do cache de consulta"

#. Tag: para
#, no-c-format
msgid ""
"Caching of query results introduces some overhead in terms of your "
"applications normal transactional processing. For example, if you cache "
"results of a query against Person Hibernate will need to keep track of when "
"those results should be invalidated because changes have been committed "
"against Person. That, coupled with the fact that most applications simply "
"gain no benefit from caching query results, leads Hibernate to disable "
"caching of query results by default. To use query caching, you will first "
"need to enable the query cache:"
msgstr ""
"A aplicação do cache nos resultados de consulta introduz alguns resultados "
"referentes o seu processamento transacional normal de aplicações. Por "
"exemplo, se você realizar o cache nos resultados de uma consulta do Person "
"Hibernate, você precisará acompanhar quando estes resultados deverão ser "
"inválidos devido alterações salvas no Person. Tudo isto, acompanhado com o "
"fato de que a maioria dos aplicativos não recebem benefício algum ao "
"realizar o cache nos resultados da consulta, levando o Hibernate a desativar "
"o cache de resultados de consulta por padrão. Para uso do cache de consulta, "
"você primeiro precisa ativar o cache de consulta:"

#. Tag: para
#, no-c-format
msgid "This setting creates two new cache regions:"
msgstr "Esta configuração cria duas novas regiões de cache:"

#. Tag: para
#, no-c-format
msgid ""
"<classname>org.hibernate.cache.StandardQueryCache</classname>, holding the "
"cached query results"
msgstr ""
"<classname>org.hibernate.cache.StandardQueryCache</classname>, mantendo os "
"resultados da consulta com cache."

#. Tag: para
#, no-c-format
msgid ""
"<classname>org.hibernate.cache.UpdateTimestampsCache</classname>, holding "
"timestamps of the most recent updates to queryable tables. These are used to "
"validate the results as they are served from the query cache."
msgstr ""
"<classname>org.hibernate.cache.UpdateTimestampsCache</classname>, mantém os "
"timestamps das atualizações mais recentes para tabelas consultáveis. Elas "
"são usadas para validar os resultados uma vez que elas são servidas a partir "
"do cache de consulta."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you configure your underlying cache implementation to use expiry or "
"timeouts is is very important that the cache timeout of the underlying cache "
"region for the UpdateTimestampsCache be set to a higher value than the "
"timeouts of any of the query caches. In fact, we recommend that the the "
"UpdateTimestampsCache region not be configured for expiry at all. Note, in "
"particular, that an LRU cache expiry policy is never appropriate."
msgstr ""
"Se você configurar sua implementação de cache adjacente para usar expirar ou "
"intervalo, é bastante importante que o intervalo do cache da região de cache "
"adjacente para o UpdateTimestampsCache seja coonfigurado num valor mais alto "
"que os intervalos de qualquer um dos caches de consulta. Na realidade, nós "
"recomendamos que a região UpdateTimestampsCache não seja configurada para "
"expirar. Perceba que uma política expirar do cache LRU nunca será apropriada."

#. Tag: para
#, no-c-format
msgid ""
"As mentioned above, most queries do not benefit from caching or their "
"results. So by default, individual queries are not cached even after "
"enabling query caching. To enable results caching for a particular query, "
"call <literal>org.hibernate.Query.setCacheable(true)</literal>. This call "
"allows the query to look for existing cache results or add its results to "
"the cache when it is executed."
msgstr ""
"Conforme mencionado acima, a maioria das consultas não se beneficiam do "
"cache ou de seus resultados. Portanto por padrão, as consultas individuais "
"não estão em cache mesmo depois de ativar o cache de consulta. Para "
"habilitar o caching de resultados, chame <literal>org.hibernate.Query."
"setCacheable(true)</literal>. Esta chamada permite que a consulta procure "
"por resultados de caches existentes ou adicione seus resultados ao cache "
"quando for executado. "

#. Tag: para
#, no-c-format
msgid ""
"The query cache does not cache the state of the actual entities in the "
"cache; it caches only identifier values and results of value type. For this "
"reaso, the query cache should always be used in conjunction with the second-"
"level cache for those entities expected to be cached as part of a query "
"result cache (just as with collection caching)."
msgstr ""
"O cache de consulta não realiza o cache ao estado de entidades atuais no "
"cache, ele apenas realiza o cache nos valores identificadores e resultados "
"do tipo de valor. Por esta razão, o cache de consulta deve sempre ser usado "
"em conjunção com o cache de segundo nível para as entidades esperadas a "
"sofrerem o cache como parte de um cache de resultado de consulta (apenas com "
"o cache de coleção)."

#. Tag: title
#, no-c-format
msgid "Query cache regions"
msgstr "Regiões de cache de consulta"

#. Tag: para
#, no-c-format
msgid ""
"If you require fine-grained control over query cache expiration policies, "
"you can specify a named cache region for a particular query by calling "
"<literal>Query.setCacheRegion()</literal>."
msgstr ""
"Se você solicitar um controle de granulado fino com políticas de validade do "
"cache de consulta, você poderá especificar uma região de cache nomeada para "
"uma consulta em particular, chamando <literal>Query.setCacheRegion()</"
"literal>."

#. Tag: para
#, no-c-format
msgid ""
"If you want to force the query cache to refresh one of its regions "
"(disregard any cached results it finds there) you can use <literal>org."
"hibernate.Query.setCacheMode(CacheMode.REFRESH)</literal>. In conjunction "
"with the region you have defined for the given query, Hibernate will "
"selectively force the results cached in that particular region to be "
"refreshed. This is particularly useful in cases where underlying data may "
"have been updated via a separate process and is a far more efficient "
"alternative to bulk eviction of the region via <literal>org.hibernate."
"SessionFactory.evictQueries()</literal>."
msgstr ""
"Se você quiser forçar um cache de consulta para uma atualização de sua "
"região (independente de quaisquer resultados com cache encontrados nesta "
"região), você poderá usar <literal>org.hibernate.Query.setCacheMode"
"(CacheMode.REFRESH)</literal>. Juntamente com a região que você definiu para "
"o cache gerado, o Hibernate seletivamente forçará os resultados com cache, "
"naquela região particular a ser atualizada. Isto é particularmente útil em "
"casos onde dados adjacentes podem ter sido atualizados através de um "
"processo em separado , além de ser uma alternativa mais eficiente se "
"aplicada ao despejo de uma região de cache através de "
"<literal>SessionFactory.evictQueries()</literal>."

#. Tag: title
#, no-c-format
msgid "Understanding Collection performance"
msgstr "Entendendo o desempenho da Coleção"

#. Tag: para
#, no-c-format
msgid ""
"In the previous sections we have covered collections and their applications. "
"In this section we explore some more issues in relation to collections at "
"runtime."
msgstr ""
"Nas seções anteriores nós descrevemos as coleções e seus aplicativos. Nesta "
"seção nós exploraremos mais problemas em relação às coleções no período de "
"execução."

#. Tag: title
#, no-c-format
msgid "Taxonomy"
msgstr "Taxonomia"

#. Tag: para
#, no-c-format
msgid "Hibernate defines three basic kinds of collections:"
msgstr "O Hibernate define três tipos básicos de coleções:"

#. Tag: para
#, no-c-format
msgid "collections of values"
msgstr "Coleções de valores"

#. Tag: para
#, no-c-format
msgid "one-to-many associations"
msgstr "Associações um-para-muitos "

#. Tag: para
#, no-c-format
msgid "many-to-many associations"
msgstr "Associações muitos-para-muitos "

#. Tag: para
#, no-c-format
msgid ""
"This classification distinguishes the various table and foreign key "
"relationships but does not tell us quite everything we need to know about "
"the relational model. To fully understand the relational structure and "
"performance characteristics, we must also consider the structure of the "
"primary key that is used by Hibernate to update or delete collection rows. "
"This suggests the following classification:"
msgstr ""
"A classificação distingue as diversas tabelas e relacionamento de chave "
"externa, mas não nos diz tudo que precisamos saber sobre o modelo "
"relacional. Para entender completamente a estrutura relacional e as "
"características de desempenho, devemos também considerar a estrutura da "
"chave primária que é usada pelo Hibernate para atualizar ou deletar linhas "
"de coleções. Isto sugere a seguinte classificação:"

#. Tag: para
#, no-c-format
msgid "indexed collections"
msgstr "Coleções indexadas"

#. Tag: para
#, no-c-format
msgid "sets"
msgstr "conjuntos"

#. Tag: para
#, no-c-format
msgid "bags"
msgstr "Bags"

#. Tag: para
#, no-c-format
msgid ""
"All indexed collections (maps, lists, and arrays) have a primary key "
"consisting of the <literal>&lt;key&gt;</literal> and <literal>&lt;index&gt;</"
"literal> columns. In this case, collection updates are extremely efficient. "
"The primary key can be efficiently indexed and a particular row can be "
"efficiently located when Hibernate tries to update or delete it."
msgstr ""
"Todas as coleções indexadas (mapas, listas, matrizes) possuem uma chave "
"primária, que consiste em colunas <literal>&lt;key&gt;</literal> e "
"<literal>&lt;index&gt;</literal>. Neste caso, as atualizações de coleção são "
"geralmente muito eficientes. A chave primária pode ser indexada de forma "
"eficiente e uma linha em particular pode ser localizada de forma eficiente "
"quando o Hibernate tentar atualizar ou deletá-la. "

#. Tag: para
#, no-c-format
msgid ""
"Sets have a primary key consisting of <literal>&lt;key&gt;</literal> and "
"element columns. This can be less efficient for some types of collection "
"element, particularly composite elements or large text or binary fields, as "
"the database may not be able to index a complex primary key as efficiently. "
"However, for one-to-many or many-to-many associations, particularly in the "
"case of synthetic identifiers, it is likely to be just as efficient. If you "
"want <literal>SchemaExport</literal> to actually create the primary key of a "
"<literal>&lt;set&gt;</literal>, you must declare all columns as <literal>not-"
"null=\"true\"</literal>."
msgstr ""
"Os conjuntos possuem uma chave primária que consiste em <literal>&lt;key&gt;"
"</literal> e colunas de elemento. Isto pode ser menos eficiente para alguns "
"tipos de elementos de coleções, especialmente elementos compostos ou textos "
"grandes ou ainda campos binários. O banco de dados pode não ser capaz de "
"indexar uma chave primária complexa de forma tão eficiente. Por um outro "
"lado, para associações um-para-muitos ou muitos-para-muitos, especialmente "
"no caso de identificadores sintáticos, é bem provável que seja tão eficiente "
"quanto. Se você quiser que o <literal>SchemaExport</literal> crie para você "
"uma chave primária de um <literal>&lt;set&gt;</literal> você deverá declarar "
"todas as colunas como <literal>not-null=\"true\"</literal>."

#. Tag: para
#, no-c-format
msgid ""
"<literal>&lt;idbag&gt;</literal> mappings define a surrogate key, so they "
"are efficient to update. In fact, they are the best case."
msgstr ""
"Os mapeamentos <literal>&lt;idbag&gt;</literal> definem uma chave "
"substituta, para que elas sejam sempre muito eficientes ao atualizar. Na "
"verdade, este é o melhor caso. "

#. Tag: para
#, no-c-format
msgid ""
"Bags are the worst case since they permit duplicate element values and, as "
"they have no index column, no primary key can be defined. Hibernate has no "
"way of distinguishing between duplicate rows. Hibernate resolves this "
"problem by completely removing in a single <literal>DELETE</literal> and "
"recreating the collection whenever it changes. This can be inefficient."
msgstr ""
"As Bags são os piores casos. Como uma bag permite duplicar valores de "
"elementos e não possui coluna de índice, não se deve definir nenhuma chave "
"primária. O Hibernate não tem como distinguir entre linhas duplicadas. O "
"Hibernate resolve este problema, removendo completamente em um único "
"<literal>DELETE</literal> e recria a coleção quando mudar. Isto pode ser "
"bastante ineficiente."

#. Tag: para
#, no-c-format
msgid ""
"For a one-to-many association, the \"primary key\" may not be the physical "
"primary key of the database table. Even in this case, the above "
"classification is still useful. It reflects how Hibernate \"locates\" "
"individual rows of the collection."
msgstr ""
"Note que para uma associação um-para-muitos, a chave primária pode não ser a "
"chave primária física da tabela do banco de dados, mas mesmo neste caso, a "
"classificação acima é ainda útil. Isto reflete como o Hibernate \"localiza\" "
"linhas individuais da coleção."

#. Tag: title
#, no-c-format
msgid ""
"Lists, maps, idbags and sets are the most efficient collections to update"
msgstr ""
"Listas, mapas, bags de id e conjuntos são coleções mais eficientes para "
"atualizar"

#. Tag: para
#, no-c-format
msgid ""
"From the discussion above, it should be clear that indexed collections and "
"sets allow the most efficient operation in terms of adding, removing and "
"updating elements."
msgstr ""
"A partir da discussão acima, deve ficar claro que as coleções indexadas e "
"conjuntos (geralmente) permitem uma operação mais eficente em termos de "
"adição, remoção e atualização de elementos.  "

#. Tag: para
#, no-c-format
msgid ""
"There is, arguably, one more advantage that indexed collections have over "
"sets for many-to-many associations or collections of values. Because of the "
"structure of a <literal>Set</literal>, Hibernate does not <literal>UPDATE</"
"literal> a row when an element is \"changed\". Changes to a <literal>Set</"
"literal> always work via <literal>INSERT</literal> and <literal>DELETE</"
"literal> of individual rows. Once again, this consideration does not apply "
"to one-to-many associations."
msgstr ""
"Existe ainda, mais uma vantagem, das coleções indexadas sob conjuntos para "
"associações muitos-para-muitos. Por causa da estrutura de um <literal>Set</"
"literal>, o Hibernate nunca utiliza o comando <literal>UPDATE</literal> em "
"uma linha quando um elemento é \"modificado\". As mudanças para o <literal> "
"Conjunto</literal> funcionam sempre através do comando <literal>INSERT</"
"literal> e <literal>DELETE</literal> de linhas individuais. Novamente, esta "
"consideração não se aplica às associações um para muitos. "

#. Tag: para
#, no-c-format
msgid ""
"After observing that arrays cannot be lazy, you can conclude that lists, "
"maps and idbags are the most performant (non-inverse) collection types, with "
"sets not far behind. You can expect sets to be the most common kind of "
"collection in Hibernate applications. This is because the \"set\" semantics "
"are most natural in the relational model."
msgstr ""
"Após observar que as matrizes não podem ser preguiçosas, nós concluimos que "
"as listas, mapas e bags de id são tipos de coleções com maior desempenho "
"(não inverso), com conjuntos que não ficam atrás. Espera-se que os conjuntos "
"sejam um tipo mais comum de coleção nas aplicações Hibernate. Isto porque as "
"semânticas \"conjunto\" são mais naturais em modelos relacionais. "

#. Tag: para
#, no-c-format
msgid ""
"However, in well-designed Hibernate domain models, most collections are in "
"fact one-to-many associations with <literal>inverse=\"true\"</literal>. For "
"these associations, the update is handled by the many-to-one end of the "
"association, and so considerations of collection update performance simply "
"do not apply."
msgstr ""
"No entanto, em modelos de domínio de Hibernate bem criados, geralmente vemos "
"que a maioria das coleções são de fato, associações um-para-muitos com "
"<literal>inverse=\"true\"</literal>. Para estas associações, a atualização é "
"manipulada pelo lado muitos-para-um de uma associação e portanto "
"considerações de desempenho de atualização de coleção simplesmente não se "
"aplicam a este caso.  "

#. Tag: title
#, no-c-format
msgid "Bags and lists are the most efficient inverse collections"
msgstr "As Bags e listas são as coleções de inversão mais eficientes."

#. Tag: para
#, no-c-format
msgid ""
"There is a particular case, however, in which bags, and also lists, are much "
"more performant than sets. For a collection with <literal>inverse=\"true\"</"
"literal>, the standard bidirectional one-to-many relationship idiom, for "
"example, we can add elements to a bag or list without needing to initialize "
"(fetch) the bag elements. This is because, unlike a <literal>set</literal>, "
"<literal>Collection.add()</literal> or <literal>Collection.addAll()</"
"literal> must always return true for a bag or <literal>List</literal>. This "
"can make the following common code much faster:"
msgstr ""
"Existe um caso em particular no qual as bags (e também as listas) possuem um "
"desempenho muito maior do que conjuntos. Para uma coleção com "
"<literal>inverse=\"true\"</literal>, o idioma de relacionamento um-para-um "
"bidirecional padrão, por exemplo, podemos adicionar elementos a uma bag ou "
"uma lista sem precisar inicializar (buscar) os elementos da bag. Isto "
"acontece porque a <literal>Collection.add()</literal> ou <literal>Collection."
"addAll()</literal> deve sempre retornar verdadeira para uma bag ou "
"<literal>List</literal>. Isto pode fazer que o código comum seguinte seja "
"muito mais rápido:"

#. Tag: title
#, no-c-format
msgid "One shot delete"
msgstr "Deletar uma vez"

#. Tag: para
#, no-c-format
msgid ""
"Deleting collection elements one by one can sometimes be extremely "
"inefficient. Hibernate knows not to do that in the case of an newly-empty "
"collection (if you called <literal>list.clear()</literal>, for example). In "
"this case, Hibernate will issue a single <literal>DELETE</literal>."
msgstr ""
"Às vezes, deletar elementos de coleção um por um pode ser extremamente "
"ineficiente. O Hibernate não é completamente burro, portanto ele sabe que "
"não deve fazer isso no caso de uma coleção que tenha sido esvaziada "
"recentemente (se você chamou <literal>list.clear()</literal>, por exemplo). "
"Neste caso, o Hibernate irá editar um único <literal>DELETE</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Suppose you added a single element to a collection of size twenty and then "
"remove two elements. Hibernate will issue one <literal>INSERT</literal> "
"statement and two <literal>DELETE</literal> statements, unless the "
"collection is a bag. This is certainly desirable."
msgstr ""
"Vamos supor que tenha adicionado um elemento único à uma coleção de tamanho "
"vinte e então remove dois elementos. O Hibernate irá editar uma instrução "
"<literal>INSERT</literal> e duas instruções <literal>DELETE</literal>, a não "
"ser que a coleção seja uma bag. Isto é certamente desejável."

#. Tag: para
#, no-c-format
msgid ""
"However, suppose that we remove eighteen elements, leaving two and then add "
"thee new elements. There are two possible ways to proceed"
msgstr ""
"No entanto, suponha que removamos dezoito elementos, deixando dois e então "
"adicionando três novos elementos. Existem duas formas possíveis de se "
"proceder:"

#. Tag: para
#, no-c-format
msgid "delete eighteen rows one by one and then insert three rows"
msgstr "delete dezoito linhas uma por uma e então insira três linhas"

#. Tag: para
#, no-c-format
msgid ""
"remove the whole collection in one SQL <literal>DELETE</literal> and insert "
"all five current elements one by one"
msgstr ""
"remova toda a coleção em um SQL <literal>DELETE</literal> e insira todos os "
"cinco elementos atuais, um por um"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate cannot know that the second option is probably quicker. It would "
"probably be undesirable for Hibernate to be that intuitive as such behavior "
"might confuse database triggers, etc."
msgstr ""
"O Hibernate não sabe que a segunda opção é provavelmente mais rápida neste "
"caso. O Hibernate não deseha saber a opção, uma vez que tal comportamento "
"deve confundir os triggers do banco de dados, etc."

#. Tag: para
#, no-c-format
msgid ""
"Fortunately, you can force this behavior (i.e. the second strategy) at any "
"time by discarding (i.e. dereferencing) the original collection and "
"returning a newly instantiated collection with all the current elements."
msgstr ""
"Felizmente, você pode forçar este comportamento (ou seja, uma segunda "
"estratégia) a qualquer momento, descartando (ou seja, desreferenciando) a "
"coleção original e retornando uma coleção recentemente instanciada com todos "
"os elementos atuais. "

#. Tag: para
#, no-c-format
msgid ""
"One-shot-delete does not apply to collections mapped <literal>inverse=\"true"
"\"</literal>."
msgstr ""
"É claro que, deletar somente uma vez, não se aplica às coleções mapeadas "
"<literal>inverse=\"true\"</literal>."

#. Tag: title
#, no-c-format
msgid "Monitoring performance"
msgstr "Monitorando desempenho"

#. Tag: para
#, no-c-format
msgid ""
"Optimization is not much use without monitoring and access to performance "
"numbers. Hibernate provides a full range of figures about its internal "
"operations. Statistics in Hibernate are available per "
"<literal>SessionFactory</literal>."
msgstr ""
"A otimização não é muito usada sem o monitoramento e acesso ao número de "
"desempenho. O Hibernate oferece uma grande variedade de números sobre suas "
"operações internas. Estatísticas em Hibernate estão disponíveis através do "
"<literal>SessionFactory</literal>."

#. Tag: title
#, no-c-format
msgid "Monitoring a SessionFactory"
msgstr "Monitorando uma SessionFactory"

#. Tag: para
#, no-c-format
msgid ""
"You can access <literal>SessionFactory</literal> metrics in two ways. Your "
"first option is to call <literal>sessionFactory.getStatistics()</literal> "
"and read or display the <literal>Statistics</literal> yourself."
msgstr ""
"Você poderá acessar as métricas da <literal>SessionFactory</literal> de duas "
"formas. Sua primeira opção é chamar a <literal>sessionFactory.getStatistics()"
"</literal> e ler ou dispôr as <literal>Estatísticas</literal> você mesmo."

#. Tag: para
#, no-c-format
msgid ""
"Hibernate can also use JMX to publish metrics if you enable the "
"<literal>StatisticsService</literal> MBean. You can enable a single MBean "
"for all your <literal>SessionFactory</literal> or one per factory. See the "
"following code for minimalistic configuration examples:"
msgstr ""
"O Hibernate também usa o JMX para publicar métricas se você habilitar o "
"MBean de <literal>StatisticsService</literal>. Você deve habiliar um MBean "
"único para todas as suas <literal>SessionFactory</literal> ou uma por "
"factory. Veja o seguinte código para exemplos de configurações "
"minimalísticos: "

#. Tag: para
#, no-c-format
msgid ""
"You can activate and deactivate the monitoring for a "
"<literal>SessionFactory</literal>:"
msgstr ""
"Você pode (des)ativar o monitoramento para uma <literal>SessionFactory</"
"literal>:"

#. Tag: para
#, no-c-format
msgid ""
"at configuration time, set <literal>hibernate.generate_statistics</literal> "
"to <literal>false</literal>"
msgstr ""
"no tempo de configuração, ajuste <literal>hibernate.generate_statistics</"
"literal> para <literal>falso</literal>"

#. Tag: para
#, no-c-format
msgid ""
"at runtime: <literal>sf.getStatistics().setStatisticsEnabled(true)</literal> "
"or <literal>hibernateStatsBean.setStatisticsEnabled(true)</literal>"
msgstr ""
"em tempo de espera: <literal>sf.getStatistics().setStatisticsEnabled(true)</"
"literal> ou <literal>hibernateStatsBean.setStatisticsEnabled(true)</literal>"

#. Tag: para
#, no-c-format
msgid ""
"Statistics can be reset programmatically using the <literal>clear()</"
"literal> method. A summary can be sent to a logger (info level) using the "
"<literal>logSummary()</literal> method."
msgstr ""
"As estatísticas podem ser reajsutadas de forma programática, usando o método "
"<literal>clear()</literal>. Um resumo pode ser enviado para o usuário (nível "
"de info) usando o método <literal>logSummary()</literal>. "

#. Tag: title
#, no-c-format
msgid "Metrics"
msgstr "Métricas"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate provides a number of metrics, from basic information to more "
"specialized information that is only relevant in certain scenarios. All "
"available counters are described in the <literal>Statistics</literal> "
"interface API, in three categories:"
msgstr ""
"O Hibernate oferece um número de métricas, desde informações bem básicas até "
"especializadas, somente relevantes a certos cenários. Todos os contadores "
"disponíveis estão descritos na API da interface <literal>Statistics</"
"literal>, em três categorias: "

#. Tag: para
#, no-c-format
msgid ""
"Metrics related to the general <literal>Session</literal> usage, such as "
"number of open sessions, retrieved JDBC connections, etc."
msgstr ""
"As métricas relacionadas ao uso da <literal>Sessão</literal>, tal como um "
"número de sessões em aberto, conexões JDBC recuperadas, etc."

#. Tag: para
#, no-c-format
msgid ""
"Metrics related to the entities, collections, queries, and caches as a whole "
"(aka global metrics)."
msgstr ""
"As métricas relacionadas às entidades, coleções, consultas e caches como um "
"todo (mais conhecido como métricas globais). "

#. Tag: para
#, no-c-format
msgid ""
"Detailed metrics related to a particular entity, collection, query or cache "
"region."
msgstr ""
"Métricas detalhadas relacionadas à uma entidade em particular, coleção, "
"consulta ou região de cache."

#. Tag: para
#, no-c-format
msgid ""
"For example, you can check the cache hit, miss, and put ratio of entities, "
"collections and queries, and the average time a query needs. Be aware that "
"the number of milliseconds is subject to approximation in Java. Hibernate is "
"tied to the JVM precision and on some platforms this might only be accurate "
"to 10 seconds."
msgstr ""
"Por exemplo, você pode verificar a coincidência de um cache, perder e "
"colocar a relação entre as entidades, colações e consultas e tempo médio que "
"uma consulta precisa. Esteja ciente de que o número de milisegundos é "
"sujeito a aproximação em Java. O Hibernate é preso à precisão do JVM, em "
"algumas plataformas a precisão chega a ser de 10 segundos. "

#. Tag: para
#, no-c-format
msgid ""
"Simple getters are used to access the global metrics (i.e. not tied to a "
"particular entity, collection, cache region, etc.). You can access the "
"metrics of a particular entity, collection or cache region through its name, "
"and through its HQL or SQL representation for queries. Please refer to the "
"<literal>Statistics</literal>, <literal>EntityStatistics</literal>, "
"<literal>CollectionStatistics</literal>, "
"<literal>SecondLevelCacheStatistics</literal>, and <literal>QueryStatistics</"
"literal> API Javadoc for more information. The following code is a simple "
"example:"
msgstr ""
"Os Getters simples são usados para acessar métricas globais (ou seja, não "
"presos à uma entidade em particular, coleção, região de cache, etc.) Você "
"pode acessar as métricas de uma entidade em particular, coleção ou região de "
"cache através de seu nome e através de sua representação de HQL ou SQL para "
"consultas. Por favor consulte a Javadoc API <literal>Statistics</literal>, "
"<literal>EntityStatistics</literal>, <literal>CollectionStatistics</"
"literal>, <literal>SecondLevelCacheStatistics</literal>, e "
"<literal>QueryStatistics</literal> para maiores informações. O seguinte "
"código mostra um exemplo simples:  "

#. Tag: para
#, no-c-format
msgid ""
"You can work on all entities, collections, queries and region caches, by "
"retrieving the list of names of entities, collections, queries and region "
"caches using the following methods: <literal>getQueries()</literal>, "
"<literal>getEntityNames()</literal>, <literal>getCollectionRoleNames()</"
"literal>, and <literal>getSecondLevelCacheRegionNames()</literal>."
msgstr ""
"Para trabalhar em todas as entidades, coleções, consultas e caches "
"regionais, você poderá recuperar os nomes de lista de entidades, coleções, "
"consultas e caches regionais com os seguintes métodos: <literal>getQueries()"
"</literal>, <literal>getEntityNames()</literal>, "
"<literal>getCollectionRoleNames()</literal>, e "
"<literal>getSecondLevelCacheRegionNames()</literal>. "
