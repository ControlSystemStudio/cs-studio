# translation of tutorial.po to
# Xi Huang <xhuang@redhat.com>, 2006.
# Xi HUANG <xhuang@redhat.com>, 2007, 2009.
# translation of Collection_Mapping.po to
msgid ""
msgstr ""
"Project-Id-Version: tutorial\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:16\n"
"PO-Revision-Date: 2010-03-16 09:56+1000\n"
"Last-Translator: Xi HUANG <xhuang@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Tutorial"
msgstr "教程"

#. Tag: para
#, no-c-format
msgid "Intended for new users, this chapter provides an step-by-step introduction to Hibernate, starting with a simple application using an in-memory database. The tutorial is based on an earlier tutorial developed by Michael Gloegl. All code is contained in the <filename>tutorials/web</filename> directory of the project source."
msgstr "面向新用户，从一个简单的使用内存数据库的例子开始，本章提供对 Hibernate 的逐步介绍。本教程基于 Michael Gloegl 早期编写的手册。所有代码都包含在 <filename>tutorials/web</filename> 目录下。"

#. Tag: para
#, no-c-format
msgid "This tutorial expects the user have knowledge of both Java and SQL. If you have a limited knowledge of JAVA or SQL, it is advised that you start with a good introduction to that technology prior to attempting to learn Hibernate."
msgstr "本教程期望用户具备 Java 和 SQL 知识。如果你这方面的知识有限，我们建议你在学习 Hibernate 之前先好好了解这些技术。"

#. Tag: para
#, no-c-format
msgid "The distribution contains another example application under the <filename>tutorial/eg</filename> project source directory."
msgstr "本版本在源代码目录 <filename>tutorial/eg</filename> 下还包含另外一个例程。"

#. Tag: title
#, no-c-format
msgid "Part 1 - The first Hibernate Application"
msgstr "第一部分 － 第一个 Hibernate 应用程序"

#. Tag: para
#, no-c-format
msgid "For this example, we will set up a small database application that can store events we want to attend and information about the host(s) of these events."
msgstr "在这个例子里，我们将设立一个小应用程序可以保存我们希望参加的活动（events）和这些活动主办方的相关信息。（译者注：在本教程的后面部分，我们将直接使用 event 而不是它的中文翻译“活动”，以免混淆。）"

#. Tag: para
#, no-c-format
msgid "Although you can use whatever database you feel comfortable using, we will use <ulink url=\"http://hsqldb.org/\">HSQLDB</ulink> (an in-memory, Java database) to avoid describing installation/setup of any particular database servers."
msgstr "虽然你可以使用任何数据库，我们还是用 <ulink url=\"http://hsqldb.org/\">HSQLDB</ulink>（一个用 Java 编写的内存数据库）来避免花费篇章对数据库服务器的安装/配置进行解释。"

#. Tag: title
#, no-c-format
msgid "Setup"
msgstr "设置"

#. Tag: para
#, no-c-format
msgid "The first thing we need to do is to set up the development environment. We will be using the \"standard layout\" advocated by alot of build tools such as <ulink url=\"http://maven.org\">Maven</ulink>. Maven, in particular, has a good resource describing this <ulink url=\"http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html\">layout</ulink>. As this tutorial is to be a web application, we will be creating and making use of <filename>src/main/java</filename>, <filename>src/main/resources</filename> and <filename>src/main/webapp</filename> directories."
msgstr "我们需要做的第一件事情是设置开发环境。我们将使用许多构建工具如 <ulink url=\"http://maven.org\">Maven</ulink> 所鼓吹的“标准格式”。特别是 Maven，它的资源对这个<ulink url=\"http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html\">格式（layout）</ulink>有着很好的描述。因为本教程使用的是 web 应用程序，我么将创建和使用 <filename>src/main/java</filename>、<filename>src/main/resources</filename> 和 <filename>src/main/webapp</filename> 目录。"

#. Tag: para
#, no-c-format
msgid "We will be using Maven in this tutorial, taking advantage of its transitive dependency management capabilities as well as the ability of many IDEs to automatically set up a project for us based on the maven descriptor."
msgstr "在本教程里我们将使用 Maven，利用其 transitive dependency 管理以及根据 Maven 描述符用 IDE 自动设置项目的能力。"

#. Tag: para
#, no-c-format
msgid "It is not a requirement to use Maven. If you wish to use something else to build this tutoial (such as Ant), the layout will remain the same. The only change is that you will need to manually account for all the needed dependencies. If you use something like <ulink url=\"http://ant.apache.org/ivy/\">Ivy</ulink> providing transitive dependency management you would still use the dependencies mentioned below. Otherwise, you'd need to grab <emphasis>all</emphasis> dependencies, both explicit and transitive, and add them to the project's classpath. If working from the Hibernate distribution bundle, this would mean <filename>hibernate3.jar</filename>, all artifacts in the <filename>lib/required</filename> directory and all files from either the <filename>lib/bytecode/cglib</filename> or <filename>lib/bytecode/javassist</filename> directory; additionally you will need both the servlet-api jar and one of the slf4j logging backends."
msgstr "Maven 并不要求这样。如果你希望使用其他技术来构建这个教程（如 Ant），格式将保持不变。唯一的改变是你将需要手工管理所有的依赖关系。如果你使用 <ulink url=\"http://ant.apache.org/ivy/\">Ivy</ulink> 来提供 transitive dependency 管理，你将仍然下面提到的依赖关系。否则，你将需要找到所有的依赖关系（显性的和过渡的）并把它们添加到项目的 classpath 里。如果使用 Hibernate 捆绑版本，这意味着 <filename>hibernate3.jar</filename>、<filename>lib/required</filename> 目录下的所有 artifact 和 <filename>lib/bytecode/cglib</filename> 或 <filename>lib/bytecode/javassist</filename> 下的所有文件，此外你将需要 servlet-api jar 和一个 slf4j 日志后台文件。  "

#. Tag: para
#, no-c-format
msgid "Save this file as <filename>pom.xml</filename> in the project root directory."
msgstr "把这个文件保存为项目根目录下的 <filename>pom.xml</filename>。"

#. Tag: title
#, no-c-format
msgid "The first class"
msgstr "第一个 class"

#. Tag: para
#, no-c-format
msgid "Next, we create a class that represents the event we want to store in the database; it is a simple JavaBean class with some properties:"
msgstr "接下来我们创建一个类，用来代表那些我们希望储存在数据库里的 event，这是一个具有一些属性的简单 JavaBean 类："

#. Tag: para
#, no-c-format
msgid "This class uses standard JavaBean naming conventions for property getter and setter methods, as well as private visibility for the fields. Although this is the recommended design, it is not required. Hibernate can also access fields directly, the benefit of accessor methods is robustness for refactoring."
msgstr "你可以看到这个类对属性的存取方法（getter and setter method）使用了标准 JavaBean 命名约定，同时把类属性（field）的访问级别设成私有的（private）。这是推荐的设计，但并不是必须的。Hibernate 也可以直接访问这些 field，而使用访问方法（accessor method）的好处是提供了重构时的健壮性（robustness）。"

#. Tag: para
#, no-c-format
msgid "The <literal>id</literal> property holds a unique identifier value for a particular event. All persistent entity classes (there are less important dependent classes as well) will need such an identifier property if we want to use the full feature set of Hibernate. In fact, most applications, especially web applications, need to distinguish objects by identifier, so you should consider this a feature rather than a limitation. However, we usually do not manipulate the identity of an object, hence the setter method should be private. Only Hibernate will assign identifiers when an object is saved. Hibernate can access public, private, and protected accessor methods, as well as public, private and protected fields directly. The choice is up to you and you can match it to fit your application design."
msgstr "对一特定的 event, <literal>id</literal> 属性持有唯一的标识符（identifier）的值。如果我们希望使用 Hibernate 提供的所有特性，那么所有的持久化实体（persistent entity）类（这里也包括一些次要依赖类）都需要一个这样的标识符属性。而事实上，大多数应用程序（特别是 web 应用程序）都需要通过标识符来区别对象，所以你应该考虑使用标识符属性而不是把它当作一种限制。然而，我们通常不会操作对象的标识（identity），因此它的 setter 方法的访问级别应该声明 private。这样当对象被保存的时候，只有 Hibernate 可以为它分配标识符值。你可看到Hibernate可以直接访问 public，private 和 protected 的访问方法和 field。所以选择哪种方式完全取决于你，你可以使你的选择与你的应用程序设计相吻合。 "

#. Tag: para
#, no-c-format
msgid "The no-argument constructor is a requirement for all persistent classes; Hibernate has to create objects for you, using Java Reflection. The constructor can be private, however package or public visibility is required for runtime proxy generation and efficient data retrieval without bytecode instrumentation."
msgstr "所有的持久化类（persistent classes）都要求有无参的构造器，因为 Hibernate 必须使用 Java 反射机制来为你创建对象。构造器（constructor）的访问级别可以是 private，然而当生成运行时代理（runtime proxy）的时候则要求使用至少是 package 级别的访问控制，这样在没有字节码指令（bytecode instrumentation）的情况下，从持久化类里获取数据会更有效率。 "

#. Tag: para
#, no-c-format
msgid "Save this file to the <filename>src/main/java/org/hibernate/tutorial/domain</filename> directory."
msgstr "把这个文件保存到 <filename>src/main/java/org/hibernate/tutorial/domain</filename> 目录下。"

#. Tag: title
#, no-c-format
msgid "The mapping file"
msgstr "映射文件"

#. Tag: para
#, no-c-format
msgid "Hibernate needs to know how to load and store objects of the persistent class. This is where the Hibernate mapping file comes into play. The mapping file tells Hibernate what table in the database it has to access, and what columns in that table it should use."
msgstr "Hibernate 需要知道怎样去加载（load）和存储（store）持久化类的对象。这正是 Hibernate 映射文件发挥作用的地方。映射文件告诉 Hibernate 它应该访问数据库（database）里面的哪个表（table）及应该使用表里面的哪些字段（column）。"

#. Tag: para
#, no-c-format
msgid "The basic structure of a mapping file looks like this:"
msgstr "一个映射文件的基本结构看起来像这样："

#. Tag: para
#, no-c-format
msgid "Hibernate DTD is sophisticated. You can use it for auto-completion of XML mapping elements and attributes in your editor or IDE. Opening up the DTD file in your text editor is the easiest way to get an overview of all elements and attributes, and to view the defaults, as well as some comments. Hibernate will not load the DTD file from the web, but first look it up from the classpath of the application. The DTD file is included in <filename>hibernate-core.jar</filename> (it is also included in the <filename>hibernate3.jar</filename>, if using the distribution bundle)."
msgstr "注意 Hibernate 的 DTD 是非常复杂的。你的编辑器或者 IDE 里使用它来自动完成那些用来映射的 XML 元素（element）和属性（attribute）。你也可以在文本编辑器里打开 DTD — 这是最简单的方式来概览所有的元素和 attribute，并查看它们的缺省值以及注释。注意 Hibernate 不会从 web 加载 DTD 文件，但它会首先在应用程序的 classpath 中查找。DTD 文件已包括在 <literal>hibernate3.jar</literal> 里，同时也在 Hibernate 发布包的 <literal>src/</literal> 目录下。 "

#. Tag: para
#, no-c-format
msgid "We will omit the DTD declaration in future examples to shorten the code. It is, of course, not optional."
msgstr "为缩短代码长度，在以后的例子里我们会省略 DTD 的声明。当然，在实际的应用程序中，DTD 声明是必需的。 "

#. Tag: para
#, no-c-format
msgid "Between the two <literal>hibernate-mapping</literal> tags, include a <literal>class</literal> element. All persistent entity classes (again, there might be dependent classes later on, which are not first-class entities) need a mapping to a table in the SQL database:"
msgstr "在 <literal>hibernate-mapping</literal> 标签（tag）之间, 含有一个 <literal>class</literal> 元素。所有的持久化实体类（再次声明，或许接下来会有依赖类，就是那些次要的实体）都需要一个这样的映射，来把类对象映射到 SQL 数据库里的表："

#. Tag: para
#, no-c-format
msgid "So far we have told Hibernate how to persist and load object of class <literal>Event</literal> to the table <literal>EVENTS</literal>. Each instance is now represented by a row in that table. Now we can continue by mapping the unique identifier property to the tables primary key. As we do not want to care about handling this identifier, we configure Hibernate's identifier generation strategy for a surrogate primary key column:"
msgstr "到目前为止，我们告诉了 Hibernate 怎样把 <literal>Events</literal> 类的对象持久化到数据库的 <literal>EVENTS</literal> 表里，以及怎样从 <literal>EVENTS</literal> 表加载到 <literal>Events</literal> 类的对象。每个实例对应着数据库表中的一行。现在我们将继续讨论有关唯一标识符属性到数据库表的映射。另外，由于我们不关心怎样处理这个标识符，我们就配置由 Hibernate 的标识符生成策略来产生代理主键字段："

#. Tag: para
#, no-c-format
msgid "The <literal>id</literal> element is the declaration of the identifier property. The <literal>name=\"id\"</literal> mapping attribute declares the name of the JavaBean property and tells Hibernate to use the <literal>getId()</literal> and <literal>setId()</literal> methods to access the property. The column attribute tells Hibernate which column of the <literal>EVENTS</literal> table holds the primary key value."
msgstr "<literal>id</literal> 元素是对 identifier 属性的声明。<literal>name=\"id\"</literal> 映射属性声明了 JavaBean 属性的名称并告诉 Hibernate 使用 <literal>getId()</literal> 和 <literal>setId()</literal> 方法来访问这个属性。column 属性告诉 Hibernate  <literal>EVENTS</literal> 表的哪个字段持有主键值。"

#. Tag: para
#, no-c-format
msgid "The nested <literal>generator</literal> element specifies the identifier generation strategy (aka how are identifier values generated?). In this case we choose <literal>native</literal>, which offers a level of portability depending on the configured database dialect. Hibernate supports database generated, globally unique, as well as application assigned, identifiers. Identifier value generation is also one of Hibernate's many extension points and you can plugin in your own strategy."
msgstr "嵌套的 <literal>generator</literal> 元素指定标识符的生成策略（也就是标识符值是怎么产生的）。在这个例子里，我们选择 <literal>native</literal>，它提供了取决于数据库方言的可移植性。Hibernate 数据库生成的、全局性唯一的以及应用程序分配的标识符。标识符值的生成也是 Hibernate 的扩展功能之一，你可以插入自己的策略。"

#. Tag: para
#, no-c-format
msgid "<literal>native</literal> is no longer consider the best strategy in terms of portability. for further discussion, see <xref linkend=\"portability-idgen\" />"
msgstr "从移植性来说，<literal>native</literal> 不再被认为是最好的策略。进一步的讨论，请参考 <xref linkend=\"portability-idgen\" />。 "

#. Tag: para
#, no-c-format
msgid "Lastly, we need to tell Hibernate about the remaining entity class properties. By default, no properties of the class are considered persistent:"
msgstr "最后我们在映射文件里面包含需要持久化属性的声明。默认情况下，类里面的属性都被视为非持久化的： "

#. Tag: para
#, no-c-format
msgid "Similar to the <literal>id</literal> element, the <literal>name</literal> attribute of the <literal>property</literal> element tells Hibernate which getter and setter methods to use. In this case, Hibernate will search for <literal>getDate()</literal>, <literal>setDate()</literal>, <literal>getTitle()</literal> and <literal>setTitle()</literal> methods."
msgstr "和 <literal>id</literal> 元素一样，<literal>property</literal> 元素的 <literal>name</literal> 属性告诉 Hibernate 使用哪个 getter 和 setter 方法。在此例中，Hibernate 会寻找 <literal>getDate()</literal>、<literal>setDate()</literal>、<literal>getTitle()</literal> 和 <literal>setTitle()</literal> 方法。 "

#. Tag: para
#, no-c-format
msgid "Why does the <literal>date</literal> property mapping include the <literal>column</literal> attribute, but the <literal>title</literal> does not? Without the <literal>column</literal> attribute, Hibernate by default uses the property name as the column name. This works for <literal>title</literal>, however, <literal>date</literal> is a reserved keyword in most databases so you will need to map it to a different name."
msgstr "为什么 <literal>date</literal> 属性的映射含有 <literal>column</literal> attribute，而 <literal>title</literal> 却没有？当没有设定 <literal>column</literal> attribute 的时候，Hibernate 缺省地使用 JavaBean 的属性名作为字段名。对于 <literal>title</literal>，这样工作得很好。然而，<literal>date</literal> 在多数的数据库里，是一个保留关键字，所以我们最好把它映射成一个不同的名字。 "

#. Tag: para
#, no-c-format
msgid "The <literal>title</literal> mapping also lacks a <literal>type</literal> attribute. The types declared and used in the mapping files are not Java data types; they are not SQL database types either. These types are called <emphasis>Hibernate mapping types</emphasis>, converters which can translate from Java to SQL data types and vice versa. Again, Hibernate will try to determine the correct conversion and mapping type itself if the <literal>type</literal> attribute is not present in the mapping. In some cases this automatic detection using Reflection on the Java class might not have the default you expect or need. This is the case with the <literal>date</literal> property. Hibernate cannot know if the property, which is of <literal>java.util.Date</literal>, should map to a SQL <literal>date</literal>, <literal>timestamp</literal>, or <literal>time</literal> column. Full date and time information is preserved by mapping the property with a <literal>timestamp</literal> converter."
msgstr "另一有趣的事情是 <literal>title</literal> 属性缺少一个 <literal>type</literal> attribute。我们在映射文件里声明并使用的类型，却不是我们期望的那样，是 Java 数据类型，同时也不是 SQL 数据库的数据类型。这些类型就是所谓的 Hibernate 映射类型<emphasis>（mapping types）</emphasis>，它们能把 Java 数据类型转换到 SQL 数据类型，反之亦然。再次重申，如果在映射文件中没有设置 <literal>type</literal> 属性的话，Hibernate 会自己试着去确定正确的转换类型和它的映射类型。在某些情况下这个自动检测机制（在 Java 类上使用反射机制）不会产生你所期待或需要的缺省值。<literal>date</literal> 属性就是个很好的例子，Hibernate 无法知道这个属性（<literal>java.util.Date</literal> 类型的）应该被映射成：SQL <literal>date</literal>，或 <literal>timestamp</literal>，还是 <literal>time</literal> 字段。在此例中，把这个属性映射成 <literal>timestamp</literal> 转换器，这样我们预留了日期和时间的全部信息。 "

#. Tag: para
#, no-c-format
msgid "Hibernate makes this mapping type determination using reflection when the mapping files are processed. This can take time and resources, so if startup performance is important you should consider explicitly defining the type to use."
msgstr "当处理映射文件时，Hibernate 用反射（reflection）来决定这个映射类型。这需要时间和资源，所以如果你注重启动性能，你应该考虑显性地定义所用的类型。"

#. Tag: para
#, no-c-format
msgid "Save this mapping file as <filename>src/main/resources/org/hibernate/tutorial/domain/Event.hbm.xml</filename>."
msgstr "把这个映射文件保存为 <filename>src/main/resources/org/hibernate/tutorial/domain/Event.hbm.xml</filename>。"

#. Tag: title
#, no-c-format
msgid "Hibernate configuration"
msgstr "Hibernate 配置"

#. Tag: para
#, no-c-format
msgid "At this point, you should have the persistent class and its mapping file in place. It is now time to configure Hibernate. First let's set up HSQLDB to run in \"server mode\""
msgstr "此时，你应该有了持久化类和它的映射文件。现在是配置 Hibernate 的时候了。首先让我们设立 HSQLDB 使其运行在“服务器模式”。"

#. Tag: para
#, no-c-format
msgid "We do this do that the data remains between runs."
msgstr "数据在程序运行期间需要保持有效。 "

#. Tag: para
#, no-c-format
msgid "We will utilize the Maven exec plugin to launch the HSQLDB server by running: <command> mvn exec:java -Dexec.mainClass=\"org.hsqldb.Server\" -Dexec.args=\"-database.0 file:target/data/tutorial\"</command> You will see it start up and bind to a TCP/IP socket; this is where our application will connect later. If you want to start with a fresh database during this tutorial, shutdown HSQLDB, delete all files in the <filename>target/data</filename> directory, and start HSQLDB again."
msgstr "在开发的根目录下创建一个 <literal>data</literal> 目录 － 这是 HSQL DB 存储数据文件的地方。此时在 data 目录中运行 <literal>java -classpath ../lib/hsqldb.jar org.hsqldb.Server</literal> 就可启动数据库。你可以在 log 中看到它的启动，及绑定到 TCP/IP 套接字，这正是我们的应用程序稍后会连接的地方。如果你希望在本例中运行一个全新的数据库，就在窗口中按下 <literal>CTRL + C</literal> 来关闭 HSQL 数据库，并删除 <literal>data/</literal> 目录下的所有文件，再重新启动 HSQL 数据库。 "

#. Tag: para
#, no-c-format
msgid "Hibernate will be connecting to the database on behalf of your application, so it needs to know how to obtain connections. For this tutorial we will be using a standalone connection pool (as opposed to a <interfacename>javax.sql.DataSource</interfacename>). Hibernate comes with support for two third-party open source JDBC connection pools: <ulink url=\"https://sourceforge.net/projects/c3p0\">c3p0</ulink> and <ulink url=\"http://proxool.sourceforge.net/\">proxool</ulink>. However, we will be using the Hibernate built-in connection pool for this tutorial."
msgstr "Hibernate 将为你的应用程序连接到数据库，所以它需要知道如何获取连接。在这个教程里，我们使用一个独立连接池（和 <interfacename>javax.sql.DataSource</interfacename> 相反）。Hibernate 支持两个第三方的开源 JDBC 连接池：<ulink url=\"https://sourceforge.net/projects/c3p0\">c3p0</ulink> 和 <ulink url=\"http://proxool.sourceforge.net/\">proxool</ulink>。然而，在本教程里我们将使用 Hibernate 内置的连接池。"

#. Tag: para
#, no-c-format
msgid "The built-in Hibernate connection pool is in no way intended for production use. It lacks several features found on any decent connection pool."
msgstr "嵌入的 Hibernate 连接池不用于产品环境。它缺乏连接池里的几个功能。"

#. Tag: para
#, no-c-format
msgid "For Hibernate's configuration, we can use a simple <literal>hibernate.properties</literal> file, a more sophisticated <literal>hibernate.cfg.xml</literal> file, or even complete programmatic setup. Most users prefer the XML configuration file:"
msgstr "为了保存 Hibernate 的配置，我们可以使用一个简单的 <literal>hibernate.properties</literal> 文件，或者一个稍微复杂的 <literal>hibernate.cfg.xml</literal>，甚至可以完全使用程序来配置 Hibernate。多数用户更喜欢使用 XML 配置文件： "

#. Tag: para
#, no-c-format
msgid "Notice that this configuration file specifies a different DTD"
msgstr "请注意，这个配置文件指定了一个不同的 DTD。"

#. Tag: para
#, no-c-format
msgid "You configure Hibernate's <literal>SessionFactory</literal>. SessionFactory is a global factory responsible for a particular database. If you have several databases, for easier startup you should use several <literal>&lt;session-factory&gt;</literal> configurations in several configuration files."
msgstr "注意这个 XML 配置使用了一个不同的 DTD。在这里，我们配置了 Hibernate 的<literal>SessionFactory</literal> — 一个关联于特定数据库全局的工厂（factory）。如果你要使用多个数据库，就要用多个的 <literal>&lt;session-factory&gt;</literal>，通常把它们放在多个配置文件中（为了更容易启动）。 "

#. Tag: para
#, no-c-format
msgid "The first four <literal>property</literal> elements contain the necessary configuration for the JDBC connection. The dialect <literal>property</literal> element specifies the particular SQL variant Hibernate generates."
msgstr "签名 4 个 <literal>property</literal> 元素包含了 JDBC 连接所必需的配置。方言 <literal>property</literal> 元素指定了 Hibernate 生成的特定 SQL 语句。"

#. Tag: para
#, no-c-format
msgid "In most cases, Hibernate is able to properly determine which dialect to use. See <xref linkend=\"portability-dialectresolver\" /> for more information."
msgstr "在大多数情况下，Hibernate 都能够正确地决定所使用的方言。更多信息请参考 <xref linkend=\"portability-dialectresolver\" />。 "

#. Tag: para
#, no-c-format
msgid "Hibernate's automatic session management for persistence contexts is particularly useful in this context. The <literal>hbm2ddl.auto</literal> option turns on automatic generation of database schemas directly into the database. This can also be turned off by removing the configuration option, or redirected to a file with the help of the <literal>SchemaExport</literal> Ant task. Finally, add the mapping file(s) for persistent classes to the configuration."
msgstr "最开始的 4 个 <literal>property</literal> 元素包含必要的 JDBC 连接信息。方言（dialect）的 <literal>property</literal> 元素指明 Hibernate 生成的特定 SQL 变量。你很快会看到，Hibernate 对持久化上下文的自动 session 管理就会派上用场。 打开 <literal>hbm2ddl.auto</literal> 选项将自动生成数据库模式（schema）－ 直接加入数据库中。当然这个选项也可以被关闭（通过去除这个配置选项）或者通过 Ant 任务 <literal>SchemaExport</literal> 的帮助来把数据库 schema 重定向到文件中。最后，在配置中为持久化类加入映射文件。 "

#. Tag: para
#, no-c-format
msgid "Save this file as <filename>hibernate.cfg.xml</filename> into the <filename>src/main/resources</filename> directory."
msgstr "把这个文件保存为 <filename>src/main/resources</filename> 目录下的 <filename>hibernate.cfg.xml</filename>。"

#. Tag: title
#, no-c-format
msgid "Building with Maven"
msgstr "用 Maven 构建  "

#. Tag: para
#, no-c-format
msgid "We will now build the tutorial with Maven. You will need to have Maven installed; it is available from the <ulink url=\"http://maven.apache.org/download.html\">Maven download page</ulink>. Maven will read the <filename>/pom.xml</filename> file we created earlier and know how to perform some basic project tasks. First, lets run the <literal>compile</literal> goal to make sure we can compile everything so far:"
msgstr "我们将用 Maven 构建这个教程。你将需要安装 Maven；你可以从 <ulink url=\"http://maven.apache.org/download.html\">Maven 下载页面</ulink>获得 Maven。Maen 将读取我们先前创建的 <filename>/pom.xml</filename> 并知道执行基本的项目任务。首先，让我们运行 <literal>compile</literal> 目标来确保我们可以编译到目前为止的所有程序："

#. Tag: title
#, no-c-format
msgid "Startup and helpers"
msgstr "启动和辅助类"

#. Tag: para
#, no-c-format
msgid "It is time to load and store some <literal>Event</literal> objects, but first you have to complete the setup with some infrastructure code. You have to startup Hibernate by building a global <interfacename>org.hibernate.SessionFactory</interfacename> object and storing it somewhere for easy access in application code. A <interfacename>org.hibernate.SessionFactory</interfacename> is used to obtain <interfacename>org.hibernate.Session</interfacename> instances. A <interfacename>org.hibernate.Session</interfacename> represents a single-threaded unit of work. The <interfacename>org.hibernate.SessionFactory</interfacename> is a thread-safe global object that is instantiated once."
msgstr "是时候来加载和储存一些 <literal>Event</literal> 对象了，但首先我们得编写一些基础的代码以完成设置。我们必须启动 Hibernate，此过程包括创建一个全局的 <literal>SessoinFactory</literal>，并把它储存在应用程序代码容易访问的地方。<literal>SessionFactory</literal> 可以创建并打开新的 <literal>Session</literal>。一个 <literal>Session</literal> 代表一个单线程的单元操作，<interfacename>org.hibernate.SessionFactory</interfacename> 则是个线程安全的全局对象，只需要被实例化一次。 "

#. Tag: para
#, no-c-format
msgid "We will create a <literal>HibernateUtil</literal> helper class that takes care of startup and makes accessing the <interfacename>org.hibernate.SessionFactory</interfacename> more convenient."
msgstr "我们将创建一个 <literal>HibernateUtil</literal> 辅助类（helper class）来负责启动 Hibernate 和更方便地操作 <interfacename>org.hibernate.SessionFactory</interfacename>。让我们来看一下它的实现："

#. Tag: para
#, no-c-format
msgid "Save this code as <filename>src/main/java/org/hibernate/tutorial/util/HibernateUtil.java</filename>"
msgstr "把这段代码保存为 <filename>src/main/java/org/hibernate/tutorial/util/HibernateUtil.java</filename>。"

#. Tag: para
#, no-c-format
msgid "This class not only produces the global <interfacename>org.hibernate.SessionFactory</interfacename> reference in its static initializer; it also hides the fact that it uses a static singleton. We might just as well have looked up the <interfacename>org.hibernate.SessionFactory</interfacename> reference from JNDI in an application server or any other location for that matter."
msgstr "这个类不但在它的静态初始化过程（仅当加载这个类的时候被 JVM 执行一次）中产生全局的 <interfacename>org.hibernate.SessionFactory</interfacename>，而且隐藏了它使用了静态 singleton 的事实。它也可能在应用程序服务器中的 JNDI 查找 <interfacename>org.hibernate.SessionFactory</interfacename>。"

#. Tag: para
#, no-c-format
msgid "If you give the <interfacename>org.hibernate.SessionFactory</interfacename> a name in your configuration, Hibernate will try to bind it to JNDI under that name after it has been built. Another, better option is to use a JMX deployment and let the JMX-capable container instantiate and bind a <literal>HibernateService</literal> to JNDI. Such advanced options are discussed later."
msgstr "如果你在配置文件中给 <interfacename>org.hibernate.SessionFactory</interfacename> 一个名字，在 它创建后，Hibernate 会试着把它绑定到 JNDI。要完全避免这样的代码，你也可以使用 JMX 部署，让具有 JMX 能力的容器来实例化 <literal>HibernateService</literal> 并把它绑定到 JNDI。这些高级可选项在后面的章节中会讨论到。"

#. Tag: para
#, no-c-format
msgid "You now need to configure a logging system. Hibernate uses commons logging and provides two choices: Log4j and JDK 1.4 logging. Most developers prefer Log4j: copy <literal>log4j.properties</literal> from the Hibernate distribution in the <literal>etc/</literal> directory to your <literal>src</literal> directory, next to <literal>hibernate.cfg.xml</literal>. If you prefer to have more verbose output than that provided in the example configuration, you can change the settings. By default, only the Hibernate startup message is shown on stdout."
msgstr "再次编译这个应用程序应该不会有问题。最后我们需要配置一个日志（logging)系统 — Hibernate 使用通用日志接口，允许你在 Log4j 和 JDK 1.4 日志之间进行选择。多数开发者更喜欢 Log4j：从 Hibernate 的发布包中（它在 <literal>etc/</literal> 目录下）拷贝 <literal>log4j.properties</literal> 到你的 <literal>src</literal> 目录，与 <literal>hibernate.cfg.xml</literal> 放在一起。看一下配置示例，如果你希望看到更加详细的输出信息，你可以修改配置。默认情况下，只有 Hibernate 的启动信息才会显示在标准输出上。 "

#. Tag: para
#, no-c-format
msgid "The tutorial infrastructure is complete and you are now ready to do some real work with Hibernate."
msgstr "示例的基本框架完成了 — 现在我们可以用 Hibernate 来做些真正的工作。 "

#. Tag: title
#, no-c-format
msgid "Loading and storing objects"
msgstr "加载并存储对象"

#. Tag: para
#, no-c-format
msgid "We are now ready to start doing some real worjk with Hibernate. Let's start by writing an <literal>EventManager</literal> class with a <literal>main()</literal> method:"
msgstr "我们终于可以使用 Hibernate 来加载和存储对象了，编写一个带有 <literal>main()</literal> 方法的 <literal>EventManager</literal> 类： "

#. Tag: para
#, no-c-format
msgid "In <literal>createAndStoreEvent()</literal> we created a new <literal>Event</literal> object and handed it over to Hibernate. At that point, Hibernate takes care of the SQL and executes an <literal>INSERT</literal> on the database."
msgstr "在 <literal>createAndStoreEvent()</literal> 来里我们创建了一个新的 <literal>Event</literal> 对象并把它传递给 Hibernate。现在 Hibernate 负责与 SQL 打交道，并把 <literal>INSERT</literal> 命令传给数据库。"

#. Tag: para
#, no-c-format
msgid "A <interface>org.hibernate.Session</interface> is designed to represent a single unit of work (a single atmoic piece of work to be performed). For now we will keep things simple and assume a one-to-one granularity between a Hibernate <interface>org.hibernate.Session</interface> and a database transaction. To shield our code from the actual underlying transaction system we use the Hibernate <interfacename>org.hibernate.Transaction</interfacename> API. In this particular case we are using JDBC-based transactional semantics, but it could also run with JTA."
msgstr "一个 <interface>org.hibernate.Session</interface> 就是个单一的工作单元。我们暂时让事情简单一些，并假设 Hibernate <interface>org.hibernate.Session</interface> 和数据库事务是一一对应的。为了让我们的代码从底层的事务系统中脱离出来（此例中是 JDBC，但也可能是 JTA），我们使用 <interfacename>org.hibernate.Transaction</interfacename> API。在这个例子里我们使用基于 JDBC 的事务性 semantic，但它也可以和 JTA 一起运行。"

#. Tag: para
#, no-c-format
msgid "What does <literal>sessionFactory.getCurrentSession()</literal> do? First, you can call it as many times and anywhere you like once you get hold of your <interfacename>org.hibernate.SessionFactory</interfacename>. The <literal>getCurrentSession()</literal> method always returns the \"current\" unit of work. Remember that we switched the configuration option for this mechanism to \"thread\" in our <filename>src/main/resources/hibernate.cfg.xml</filename>? Due to that setting, the context of a current unit of work is bound to the current Java thread that executes the application."
msgstr "<literal>sessionFactory.getCurrentSession()</literal> 是干什么的呢？首先，只要你持有 <interfacename>org.hibernate.SessionFactory</interfacename>，大可在任何时候、任何地点调用这个方法。<literal>getCurrentSession()</literal> 方法总会返回“当前的”工作单元。记得我们在 <filename>src/main/resources/hibernate.cfg.xml</filename> 中把这一配置选项调整为 \"thread\" 了吗？因此，因此，当前工作单元被绑定到当前执行我们应用程序的 Java 线程。但是，这并非是完全准确的,你还得考虑工作单元的生命周期范围（scope），它何时开始,又何时结束。"

#. Tag: para
#, no-c-format
msgid "Hibernate offers three methods of current session tracking. The \"thread\" based method is not intended for production use; it is merely useful for prototyping and tutorials such as this one. Current session tracking is discussed in more detail later on."
msgstr "Hibernate 提供三种跟踪当前会话的方法。基于“线程”的方法不适合于产品环境，它仅用于 prototyping 和教学用途。后面将更详细地讨论会话跟踪。"

#. Tag: para
#, no-c-format
msgid "A <interface>org.hibernate.Session</interface> begins when the first call to <literal>getCurrentSession()</literal> is made for the current thread. It is then bound by Hibernate to the current thread. When the transaction ends, either through commit or rollback, Hibernate automatically unbinds the <interface>org.hibernate.Session</interface> from the thread and closes it for you. If you call <literal>getCurrentSession()</literal> again, you get a new <interface>org.hibernate.Session</interface> and can start a new unit of work."
msgstr "<interface>org.hibernate.Session</interface> 在第一次被使用的时候，即第一次调用 <literal>getCurrentSession()</literal> 的时候,其生命周期就开始。然后它被 Hibernate 绑定到当前线程。当事务结束的时候，不管是提交还是回滚，Hibernate 会自动把 <interface>org.hibernate.Session</interface> 从当前线程剥离，并且关闭它。假若你再次调用 <literal>getCurrentSession()</literal>，你会得到一个新的 <interface>org.hibernate.Session</interface>，并且开始一个新的工作单元。"

#. Tag: para
#, no-c-format
msgid "Related to the unit of work scope, should the Hibernate <interface>org.hibernate.Session</interface> be used to execute one or several database operations? The above example uses one <interface>org.hibernate.Session</interface> for one operation. However this is pure coincidence; the example is just not complex enough to show any other approach. The scope of a Hibernate <interface>org.hibernate.Session</interface> is flexible but you should never design your application to use a new Hibernate <interface>org.hibernate.Session</interface> for <emphasis>every</emphasis> database operation. Even though it is used in the following examples, consider <emphasis>session-per-operation</emphasis> an anti-pattern. A real web application is shown later in the tutorial which will help illustrate this."
msgstr "和工作单元的生命周期这个话题相关，Hibernate <interface>org.hibernate.Session</interface> 是否被应该用来执行多次数据库操作？上面的例子对每一次操作使用了一个 <interface>org.hibernate.Session</interface>，这完全是巧合，这个例子不是很复杂，无法展示其他方式。Hibernate <interface>org.hibernate.Session</interface> 的生命周期可以很灵活，但是你绝不要把你的应用程序设计成为<emphasis>每一次</emphasis>数据库操作都用一个新的 Hibernate <interface>org.hibernate.Session</interface>。因此就算下面的例子（它们都很简单）中你可以看到这种用法，记住<emphasis>每次操作一个 session</emphasis> 是一个反模式。在本教程的后面会展示一个真正的（web）程序。"

#. Tag: para
#, no-c-format
msgid "See <xref linkend=\"transactions\" /> for more information about transaction handling and demarcation. The previous example also skipped any error handling and rollback."
msgstr "关于事务处理及事务边界界定的详细信息，请参看 <xref linkend=\"transactions\" /> 。在上面的例子中，我们也忽略了所有的错误与回滚的处理。 "

#. Tag: para
#, no-c-format
msgid "To run this, we will make use of the Maven exec plugin to call our class with the necessary classpath setup: <command>mvn exec:java -Dexec.mainClass=\"org.hibernate.tutorial.EventManager\" -Dexec.args=\"store\"</command>"
msgstr "要运行它，我们将使用 Maven exec 插件以及必要的 classpath 设置来进行调用：<command>mvn exec:java -Dexec.mainClass=\"org.hibernate.tutorial.EventManager\" -Dexec.args=\"store\"</command>。"

#. Tag: para
#, no-c-format
msgid "You may need to perform <command>mvn compile</command> first."
msgstr "你可能需要先执行 <command>mvn compile</command>。"

#. Tag: para
#, no-c-format
msgid "You should see Hibernate starting up and, depending on your configuration, lots of log output. Towards the end, the following line will be displayed:"
msgstr "你应该会看到，编译以后，Hibernate 根据你的配置启动，并产生一大堆的输出日志。在日志最后你会看到下面这行： "

#. Tag: para
#, no-c-format
msgid "This is the <literal>INSERT</literal> executed by Hibernate."
msgstr "执行 HQL <literal>INSERT</literal> 语句的例子如下： "

#. Tag: para
#, no-c-format
msgid "To list stored events an option is added to the main method:"
msgstr "我们想要列出所有已经被存储的 events，就要增加一个条件分支选项到 main 方法中："

#. Tag: para
#, no-c-format
msgid "A new <literal>listEvents() method is also added</literal>:"
msgstr "我们也增加一个新的 <literal>listEvents()</literal> 方法： "

#. Tag: para
#, no-c-format
msgid "Here, we are using a Hibernate Query Language (HQL) query to load all existing <literal>Event</literal> objects from the database. Hibernate will generate the appropriate SQL, send it to the database and populate <literal>Event</literal> objects with the data. You can create more complex queries with HQL. See <xref linkend=\"queryhql\" /> for more information."
msgstr "我们在这里是用一个 HQL（Hibernate Query Language－Hibernate查询语言）查询语句来从数据库中加载所有存在的 <literal>Event</literal> 对象。Hibernate 会生成适当的 SQL，把它发送到数据库，并操作从查询得到数据的 <literal>Event</literal> 对象。当然，你可以使用 HQL 来创建更加复杂的查询。更多信息请参考 <xref linkend=\"queryhql\"/>。 "

#. Tag: para
#, no-c-format
msgid "Now we can call our new functionality, again using the Maven exec plugin: <command>mvn exec:java -Dexec.mainClass=\"org.hibernate.tutorial.EventManager\" -Dexec.args=\"list\"</command>"
msgstr "现在我们可以再次用 Maven exec plugin - <command>mvn exec:java -Dexec.mainClass=\"org.hibernate.tutorial.EventManager\" -Dexec.args=\"list\"</command> 调用新的功能了。"

#. Tag: title
#, no-c-format
msgid "Part 2 - Mapping associations"
msgstr "第二部分 － 关联映射"

#. Tag: para
#, no-c-format
msgid "So far we have mapped a single persistent entity class to a table in isolation. Let's expand on that a bit and add some class associations. We will add people to the application and store a list of events in which they participate."
msgstr "我们已经映射了一个持久化实体类到表上。让我们在这个基础上增加一些类之间的关联。首先我们往应用程序里增加人（people）的概念，并存储他们所参与的一个 Event 列表。（译者注：与 Event 一样，我们在后面将直接使用 person 来表示“人”而不是它的中文翻译） "

#. Tag: title
#, no-c-format
msgid "Mapping the Person class"
msgstr "映射 Person 类"

#. Tag: para
#, no-c-format
msgid "The first cut of the <literal>Person</literal> class looks like this:"
msgstr "最初简单的 <literal>Person</literal> 类： "

#. Tag: para
#, no-c-format
msgid "Save this to a file named <filename>src/main/java/org/hibernate/tutorial/domain/Person.java</filename>"
msgstr "把它保存为文件 <filename>src/main/java/org/hibernate/tutorial/domain/Person.java</filename>。"

#. Tag: para
#, no-c-format
msgid "Next, create the new mapping file as <filename>src/main/resources/org/hibernate/tutorial/domain/Person.hbm.xml</filename>"
msgstr "然后，创建新的映射文件 <filename>src/main/resources/org/hibernate/tutorial/domain/Person.hbm.xml</filename>。"

#. Tag: para
#, no-c-format
msgid "Finally, add the new mapping to Hibernate's configuration:"
msgstr "最后，把新的映射加入到 Hibernate 的配置中："

#. Tag: para
#, no-c-format
msgid "Create an association between these two entities. Persons can participate in events, and events have participants. The design questions you have to deal with are: directionality, multiplicity, and collection behavior."
msgstr "现在我们在这两个实体之间创建一个关联。显然，persons 可以参与一系列 events，而 events 也有不同的参加者（persons）。我们需要处理的设计问题是关联方向（directionality），阶数（multiplicity）和集合（collection）的行为。 "

#. Tag: title
#, no-c-format
msgid "A unidirectional Set-based association"
msgstr "单向 Set-based 的关联"

#. Tag: para
#, no-c-format
msgid "By adding a collection of events to the <literal>Person</literal> class, you can easily navigate to the events for a particular person, without executing an explicit query - by calling <literal>Person#getEvents</literal>. Multi-valued associations are represented in Hibernate by one of the Java Collection Framework contracts; here we choose a <interfacename>java.util.Set</interfacename> because the collection will not contain duplicate elements and the ordering is not relevant to our examples:"
msgstr "我们将向 <literal>Person</literal> 类增加一连串的 events。那样，通过调用 <literal>aPerson.getEvents()</literal>，就可以轻松地导航到特定 person 所参与的 events，而不用去执行一个显式的查询。我们使用 Java 的集合类（collection）：<literal>Set</literal>，因为 set 不包含重复的元素及与我们无关的排序。 "

#. Tag: para
#, no-c-format
msgid "Before mapping this association, let's consider the other side. We could just keep this unidirectional or create another collection on the <literal>Event</literal>, if we wanted to be able to navigate it from both directions. This is not necessary, from a functional perspective. You can always execute an explicit query to retrieve the participants for a particular event. This is a design choice left to you, but what is clear from this discussion is the multiplicity of the association: \"many\" valued on both sides is called a <emphasis>many-to-many</emphasis> association. Hence, we use Hibernate's many-to-many mapping:"
msgstr "在映射这个关联之前，先考虑一下此关联的另外一端。很显然，我们可以保持这个关联是单向的。或者，我们可以在 <literal>Event</literal> 里创建另外一个集合，如果希望能够双向地导航，如：<literal>anEvent.getParticipants()</literal>。从功能的角度来说，这并不是必须的。因为你总可以显式地执行一个查询，以获得某个特定 event 的所有参与者。这是个在设计时需要做出的选择，完全由你来决定，但此讨论中关于关联的阶数是清楚的：即两端都是“多”值的，我们把它叫做<emphasis>多对多（many-to-many）</emphasis>关联。因而，我们使用 Hibernate 的多对多映射： "

#. Tag: para
#, no-c-format
msgid "Hibernate supports a broad range of collection mappings, a <literal>set</literal> being most common. For a many-to-many association, or <emphasis>n:m</emphasis> entity relationship, an association table is required. Each row in this table represents a link between a person and an event. The table name is decalred using the <literal>table</literal> attribute of the <literal>set</literal> element. The identifier column name in the association, for the person side, is defined with the <literal>key</literal> element, the column name for the event's side with the <literal>column</literal> attribute of the <literal>many-to-many</literal>. You also have to tell Hibernate the class of the objects in your collection (the class on the other side of the collection of references)."
msgstr "Hibernate 支持各种各样的集合映射，<literal>&lt;set&gt;</literal> 使用的最为普遍。对于多对多关联（或叫 <emphasis>n:m</emphasis> 实体关系）, 需要一个关联表（association table）。<literal>表</literal>里面的每一行代表从 person 到 event 的一个关联。表名是由 <literal>set</literal> 元素的 <literal>table</literal> 属性配置的。关联里面的标识符字段名，对于 person 的一端，是由 <literal>&lt;key&gt;</literal> 元素定义，而 event 一端的字段名是由 <literal>&lt;many-to-many&gt;</literal> 元素的 <literal>column</literal> 属性定义。你也必须告诉 Hibernate 集合中对象的类（也就是位于这个集合所代表的关联另外一端的类）。 "

#. Tag: para
#, no-c-format
msgid "The database schema for this mapping is therefore:"
msgstr "因而这个映射的数据库 schema 是："

#. Tag: title
#, no-c-format
msgid "Working the association"
msgstr "使关联工作"

#. Tag: para
#, no-c-format
msgid "Now we will bring some people and events together in a new method in <literal>EventManager</literal>:"
msgstr "我们把一些 people 和 events 一起放到 <literal>EventManager</literal> 的新方法中： "

#. Tag: para
#, no-c-format
msgid "After loading a <literal>Person</literal> and an <literal>Event</literal>, simply modify the collection using the normal collection methods. There is no explicit call to <literal>update()</literal> or <literal>save()</literal>; Hibernate automatically detects that the collection has been modified and needs to be updated. This is called <emphasis>automatic dirty checking</emphasis>. You can also try it by modifying the name or the date property of any of your objects. As long as they are in <emphasis>persistent</emphasis> state, that is, bound to a particular Hibernate <interfacename>org.hibernate.Session</interfacename>, Hibernate monitors any changes and executes SQL in a write-behind fashion. The process of synchronizing the memory state with the database, usually only at the end of a unit of work, is called <emphasis>flushing</emphasis>. In our code, the unit of work ends with a commit, or rollback, of the database transaction."
msgstr "在加载一 <literal>Person</literal> 和 <literal>Event</literal> 后，使用普通的集合方法就可容易地修改我们定义的集合。如你所见，没有显式的 <literal>update()</literal> 或 <literal>save()</literal>，Hibernate 会自动检测到集合已经被修改并需要更新回数据库。这叫做自动脏检查（<emphasis>automatic dirty checking</emphasis>），你也可以尝试修改任何对象的 name 或者 date 属性，只要他们处于<emphasis>持久化</emphasis>状态，也就是被绑定到某个 Hibernate 的 <literal>Session</literal> 上（如：他们刚刚在一个单元操作被加载或者保存），Hibernate 监视任何改变并在后台隐式写的方式执行 SQL。同步内存状态和数据库的过程，通常只在单元操作结束的时候发生，称此过程为清理缓存<emphasis>（flushing）</emphasis>。在我们的代码中，工作单元由数据库事务的提交（或者回滚）来结束——这是由 <literal>CurrentSessionContext</literal> 类的 <literal>thread</literal> 配置选项定义的。 "

#. Tag: para
#, no-c-format
msgid "You can load person and event in different units of work. Or you can modify an object outside of a <interfacename>org.hibernate.Session</interfacename>, when it is not in persistent state (if it was persistent before, this state is called <emphasis>detached</emphasis>). You can even modify a collection when it is detached:"
msgstr "当然，你也可以在不同的单元操作里面加载 person 和 event。或在 <literal>Session</literal> 以外修改不是处在持久化（persistent）状态下的对象（如果该对象以前曾经被持久化，那么我们称这个状态为<emphasis>脱管（detached）</emphasis>）。你甚至可以在一个集合被脱管时修改它： "

#. Tag: para
#, no-c-format
msgid "The call to <literal>update</literal> makes a detached object persistent again by binding it to a new unit of work, so any modifications you made to it while detached can be saved to the database. This includes any modifications (additions/deletions) you made to a collection of that entity object."
msgstr "对 <literal>update</literal> 的调用使一个脱管对象重新持久化，你可以说它被绑定到一个新的单元操作上，所以在脱管状态下对它所做的任何修改都会被保存到数据库里。这也包括你对这个实体对象的集合所作的任何改动（增加/删除）。 "

#. Tag: para
#, no-c-format
msgid "This is not much use in our example, but it is an important concept you can incorporate into your own application. Complete this exercise by adding a new action to the main method of the <literal>EventManager</literal> and call it from the command line. If you need the identifiers of a person and an event - the <literal>save()</literal> method returns it (you might have to modify some of the previous methods to return that identifier):"
msgstr "这对我们当前的情形不是很有用，但它是非常重要的概念，你可以把它融入到你自己的应用程序设计中。在<literal>EventManager</literal>的 main 方法中添加一个新的动作，并从命令行运行它来完成我们所做的练习。如果你需要 person 及 event 的标识符 — 那就用 <literal>save()</literal> 方法返回它（你可能需要修改前面的一些方法来返回那个标识符）： "

#. Tag: para
#, no-c-format
msgid "This is an example of an association between two equally important classes : two entities. As mentioned earlier, there are other classes and types in a typical model, usually \"less important\". Some you have already seen, like an <literal>int</literal> or a <classname>java.lang.String</classname>. We call these classes <emphasis>value types</emphasis>, and their instances <emphasis>depend</emphasis> on a particular entity. Instances of these types do not have their own identity, nor are they shared between entities. Two persons do not reference the same <literal>firstname</literal> object, even if they have the same first name. Value types cannot only be found in the JDK , but you can also write dependent classes yourself such as an <literal>Address</literal> or <literal>MonetaryAmount</literal> class. In fact, in a Hibernate application all JDK classes are considered value types."
msgstr "上面是个关于两个同等重要的实体类间关联的例子。像前面所提到的那样，在特定的模型中也存在其它的类和类型，这些类和类型通常是“次要的”。你已看到过其中的一些，像 <literal>int</literal> 或 <literal>String</literal>。我们称这些类为<emphasis>值类型（value type）</emphasis>，它们的实例<emphasis>依赖（depend）</emphasis>在某个特定的实体上。这些类型的实例没有它们自己的标识（identity），也不能在实体间被共享（比如，两个 person 不能引用同一个 <literal>firstname</literal> 对象，即使他们有相同的 first name）。当然，值类型并不仅仅在 JDK 中存在（事实上，在一个 Hibernate 应用程序中，所有的 JDK 类都被视为值类型），而且你也可以编写你自己的依赖类，例如 <literal>Address</literal>，<literal>MonetaryAmount</literal>。 "

#. Tag: para
#, no-c-format
msgid "You can also design a collection of value types. This is conceptually different from a collection of references to other entities, but looks almost the same in Java."
msgstr "你也可以设计一个值类型的集合，这在概念上与引用其它实体的集合有很大的不同，但是在 Java 里面看起来几乎是一样的。 "

#. Tag: title
#, no-c-format
msgid "Collection of values"
msgstr "值类型的集合"

#. Tag: para
#, no-c-format
msgid "Let's add a collection of email addresses to the <literal>Person</literal> entity. This will be represented as a <interfacename>java.util.Set</interfacename> of <classname>java.lang.String</classname> instances:"
msgstr "让我们在 <literal>Person</literal> 实体里添加一个电子邮件的集合。这将以 <classname>java.lang.String</classname> 实例的 <interfacename>java.util.Set</interfacename> 出现："

#. Tag: para
#, no-c-format
msgid "The mapping of this <literal>Set</literal> is as follows:"
msgstr "这个 <literal>Set</literal> 的映射如下："

#. Tag: para
#, no-c-format
msgid "The difference compared with the earlier mapping is the use of the <literal>element</literal> part which tells Hibernate that the collection does not contain references to another entity, but is rather a collection whose elements are values types, here specifically of type <literal>string</literal>. The lowercase name tells you it is a Hibernate mapping type/converter. Again the <literal>table</literal> attribute of the <literal>set</literal> element determines the table name for the collection. The <literal>key</literal> element defines the foreign-key column name in the collection table. The <literal>column</literal> attribute in the <literal>element</literal> element defines the column name where the email address values will actually be stored."
msgstr "比较这次和此前映射的差别，主要在于 <literal>element</literal> 部分，这次并没有包含对其它实体引用的集合，而是元素类型为 <literal>String</literal> 的集合（在映射中使用小写的名字”string“是向你表明它是一个 Hibernate 的映射类型或者类型转换器）。和之前一样，<literal>set</literal> 元素的 <literal>table</literal> 属性决定了用于集合的表名。<literal>key</literal> 元素定义了在集合表中外键的字段名。<literal>element</literal> 元素的 <literal>column</literal> 属性定义用于实际保存 <literal>String</literal> 值的字段名。 "

#. Tag: para
#, no-c-format
msgid "Here is the updated schema:"
msgstr "看一下修改后的数据库 schema。 "

#. Tag: para
#, no-c-format
msgid "You can see that the primary key of the collection table is in fact a composite key that uses both columns. This also implies that there cannot be duplicate email addresses per person, which is exactly the semantics we need for a set in Java."
msgstr "你可以看到集合表的主键实际上是个复合主键，同时使用了两个字段。这也暗示了对于同一个 person 不能有重复的 email 地址，这正是 Java 里面使用 Set 时候所需要的语义（Set 里元素不能重复）。"

#. Tag: para
#, no-c-format
msgid "You can now try to add elements to this collection, just like we did before by linking persons and events. It is the same code in Java:"
msgstr "你现在可以试着把元素加入到这个集合，就像我们在之前关联 person 和 event 的那样。其实现的 Java 代码是相同的： "

#. Tag: para
#, no-c-format
msgid "This time we did not use a <emphasis>fetch</emphasis> query to initialize the collection. Monitor the SQL log and try to optimize this with an eager fetch."
msgstr "这次我们没有使用 <emphasis>fetch</emphasis> 查询来初始化集合。因此，调用其 getter 方法会触发另一附加的 select 来初始化集合，这样我们才能把元素添加进去。检查 SQL log，试着通过预先抓取来优化它。 "

#. Tag: title
#, no-c-format
msgid "Bi-directional associations"
msgstr "双向关联"

#. Tag: para
#, no-c-format
msgid "Next you will map a bi-directional association. You will make the association between person and event work from both sides in Java. The database schema does not change, so you will still have many-to-many multiplicity."
msgstr "接下来我们将映射双向关联（bi-directional association）— 在 Java 里让 person 和 event 可以从关联的任何一端访问另一端。当然，数据库 schema 没有改变，我们仍然需要多对多的阶数。一个关系型数据库要比网络编程语言更加灵活，所以它并不需要任何像导航方向（navigation direction）的东西 — 数据可以用任何可能的方式进行查看和获取。 "

#. Tag: para
#, no-c-format
msgid "A relational database is more flexible than a network programming language, in that it does not need a navigation direction; data can be viewed and retrieved in any possible way."
msgstr "关系型数据库比网络编程语言更为灵活，因为它不需要方向导航，其数据可以用任何可能的方式进行查看和提取。"

#. Tag: para
#, no-c-format
msgid "First, add a collection of participants to the <literal>Event</literal> class:"
msgstr "首先，把一个参与者（person）的集合加入 <literal>Event</literal> 类中： "

#. Tag: para
#, no-c-format
msgid "Now map this side of the association in <literal>Event.hbm.xml</literal>."
msgstr "在 <literal>Event.hbm.xml</literal> 里面也映射这个关联。 "

#. Tag: para
#, no-c-format
msgid "These are normal <literal>set</literal> mappings in both mapping documents. Notice that the column names in <literal>key</literal> and <literal>many-to-many</literal> swap in both mapping documents. The most important addition here is the <literal>inverse=\"true\"</literal> attribute in the <literal>set</literal> element of the <literal>Event</literal>'s collection mapping."
msgstr "如你所见，两个映射文件里都有普通的 <literal>set</literal> 映射。注意在两个映射文件中，互换了 <literal>key</literal> 和 <literal>many-to-many</literal> 的字段名。这里最重要的是 <literal>Event</literal> 映射文件里增加了 <literal>set</literal> 元素的 <literal>inverse=\"true\"</literal> 属性。 "

#. Tag: para
#, no-c-format
msgid "What this means is that Hibernate should take the other side, the <literal>Person</literal> class, when it needs to find out information about the link between the two. This will be a lot easier to understand once you see how the bi-directional link between our two entities is created."
msgstr "这意味着在需要的时候，Hibernate 能在关联的另一端 — <literal>Person</literal> 类得到两个实体间关联的信息。这将会极大地帮助你理解双向关联是如何在两个实体间被创建的。 "

#. Tag: title
#, no-c-format
msgid "Working bi-directional links"
msgstr "使双向连起来"

#. Tag: para
#, no-c-format
msgid "First, keep in mind that Hibernate does not affect normal Java semantics. How did we create a link between a <literal>Person</literal> and an <literal>Event</literal> in the unidirectional example? You add an instance of <literal>Event</literal> to the collection of event references, of an instance of <literal>Person</literal>. If you want to make this link bi-directional, you have to do the same on the other side by adding a <literal>Person</literal> reference to the collection in an <literal>Event</literal>. This process of \"setting the link on both sides\" is absolutely necessary with bi-directional links."
msgstr "首先请记住，Hibernate 并不影响通常的 Java 语义。 在单向关联的例子中，我们是怎样在 <literal>Person</literal> 和 <literal>Event</literal> 之间创建联系的？我们把 <literal>Event</literal> 实例添加到 <literal>Person</literal> 实例内的 event 引用集合里。因此很显然，如果我们要让这个关联可以双向地工作，我们需要在另外一端做同样的事情 － 把 <literal>Person</literal> 实例加入 <literal>Event</literal> 类内的 Person 引用集合。这“在关联的两端设置联系”是完全必要的而且你都得这么做。 "

#. Tag: para
#, no-c-format
msgid "Many developers program defensively and create link management methods to correctly set both sides (for example, in <literal>Person</literal>):"
msgstr "许多开发人员防御式地编程，创建管理关联的方法来保证正确的设置了关联的两端，比如在 <literal>Person</literal> 里： "

#. Tag: para
#, no-c-format
msgid "The get and set methods for the collection are now protected. This allows classes in the same package and subclasses to still access the methods, but prevents everybody else from altering the collections directly. Repeat the steps for the collection on the other side."
msgstr "注意现在对于集合的 get 和 set 方法的访问级别是 protected — 这允许在位于同一个包（package）中的类以及继承自这个类的子类可以访问这些方法，但禁止其他任何人的直接访问，避免了集合内容的混乱。你应尽可能地在另一端也把集合的访问级别设成 protected。 "

#. Tag: para
#, no-c-format
msgid "What about the <literal>inverse</literal> mapping attribute? For you, and for Java, a bi-directional link is simply a matter of setting the references on both sides correctly. Hibernate, however, does not have enough information to correctly arrange SQL <literal>INSERT</literal> and <literal>UPDATE</literal> statements (to avoid constraint violations). Making one side of the association <literal>inverse</literal> tells Hibernate to consider it a <emphasis>mirror</emphasis> of the other side. That is all that is necessary for Hibernate to resolve any issues that arise when transforming a directional navigation model to a SQL database schema. The rules are straightforward: all bi-directional associations need one side as <literal>inverse</literal>. In a one-to-many association it has to be the many-side, and in many-to-many association you can select either side."
msgstr "<literal>inverse</literal> 映射属性究竟表示什么呢？对于你和 Java 来说，一个双向关联仅仅是在两端简单地正确设置引用。然而，Hibernate 并没有足够的信息去正确地执行 <literal>INSERT</literal> 和 <literal>UPDATE</literal> 语句（以避免违反数据库约束），所以它需要一些帮助来正确的处理双向关联。把关联的一端设置为 <literal>inverse</literal> 将告诉 Hibernate 忽略关联的这一端，把这端看成是另外一端的一个<emphasis>镜象（mirror）</emphasis>。这就是所需的全部信息，Hibernate 利用这些信息来处理把一个有向导航模型转移到数据库 schema 时的所有问题。你只需要记住这个直观的规则：所有的双向关联需要有一端被设置为 <literal>inverse</literal>。在一对多关联中它必须是代表多（many）的那端。而在多对多（many-to-many）关联中，你可以任意选取一端，因为两端之间并没有差别。 "

#. Tag: title
#, no-c-format
msgid "Part 3 - The EventManager web application"
msgstr "第三部分 - EventManager web 应用程序"

#. Tag: para
#, no-c-format
msgid "A Hibernate web application uses <literal>Session</literal> and <literal>Transaction</literal> almost like a standalone application. However, some common patterns are useful. You can now write an <literal>EventManagerServlet</literal>. This servlet can list all events stored in the database, and it provides an HTML form to enter new events."
msgstr "Hibernate web 应用程序使用 <literal>Session</literal> 和 <literal>Transaction</literal> 的方式几乎和独立应用程序是一样的。但是，有一些常见的模式（pattern）非常有用。现在我们编写一个 <literal>EventManagerServlet</literal>。这个 servlet 可以列出数据库中保存的所有的 events，还提供一个 HTML 表单来增加新的 events。 "

#. Tag: title
#, no-c-format
msgid "Writing the basic servlet"
msgstr "编写基本的 servlet"

#. Tag: para
#, no-c-format
msgid "First we need create our basic processing servlet. Since our servlet only handles HTTP <literal>GET</literal> requests, we will only implement the <literal>doGet()</literal> method:"
msgstr "这个 servlet 只处理 HTTP <literal>GET</literal> 请求，因此，我们要实现的是 <literal>doGet()</literal> 方法： "

#. Tag: para
#, no-c-format
msgid "Save this servlet as <filename>src/main/java/org/hibernate/tutorial/web/EventManagerServlet.java</filename>"
msgstr "把这个 servlet 保存为 <filename>src/main/java/org/hibernate/tutorial/web/EventManagerServlet.java</filename>。"

#. Tag: para
#, no-c-format
msgid "The pattern applied here is called <emphasis>session-per-request</emphasis>. When a request hits the servlet, a new Hibernate <literal>Session</literal> is opened through the first call to <literal>getCurrentSession()</literal> on the <literal>SessionFactory</literal>. A database transaction is then started. All data access occurs inside a transaction irrespective of whether the data is read or written. Do not use the auto-commit mode in applications."
msgstr "我们称这里应用的模式为每次请求一个 session<emphasis>(session-per-request)</emphasis>。当有请求到达这个 servlet 的时候，通过对 <literal>SessionFactory</literal> 的第一次调用，打开一个新的 Hibernate <literal>Session</literal>。然后启动一个数据库事务 — 所有的数据访问都是在事务中进行，不管是读还是写（我们在应用程序中不使用 auto-commit 模式）。 "

#. Tag: para
#, no-c-format
msgid "Do <emphasis>not</emphasis> use a new Hibernate <literal>Session</literal> for every database operation. Use one Hibernate <literal>Session</literal> that is scoped to the whole request. Use <literal>getCurrentSession()</literal>, so that it is automatically bound to the current Java thread."
msgstr "<emphasis>不要</emphasis>为每次数据库操作都使用一个新的 Hibernate <literal>Session</literal>。将 Hibernate <literal>Session</literal> 的范围设置为整个请求。要用 <literal>getCurrentSession()</literal>，这样它自动会绑定到当前 Java 线程。"

#. Tag: para
#, no-c-format
msgid "Next, the possible actions of the request are processed and the response HTML is rendered. We will get to that part soon."
msgstr "下一步，对请求的可能动作进行处理，渲染出反馈的 HTML。我们很快就会涉及到那部分。 "

#. Tag: para
#, no-c-format
msgid "Finally, the unit of work ends when processing and rendering are complete. If any problems occurred during processing or rendering, an exception will be thrown and the database transaction rolled back. This completes the <literal>session-per-request</literal> pattern. Instead of the transaction demarcation code in every servlet, you could also write a servlet filter. See the Hibernate website and Wiki for more information about this pattern called <emphasis>Open Session in View</emphasis>. You will need it as soon as you consider rendering your view in JSP, not in a servlet."
msgstr "最后，当处理与渲染都结束的时候，这个工作单元就结束了。假若在处理或渲染的时候有任何错误发生，会抛出一个异常，回滚数据库事务。这样，<literal>session-per-request</literal> 模式就完成了。为了避免在每个 servlet 中都编写事务边界界定的代码，可以考虑写一个 servlet 过滤器（filter）来更好地解决。关于这一模式的更多信息，请参阅 Hibernate 网站和 Wiki，这一模式叫做 <emphasis>Open Session in View</emphasis> — 只要你考虑用JSP来渲染你的视图（view），而不是在servlet中，你就会很快用到它。 "

#. Tag: title
#, no-c-format
msgid "Processing and rendering"
msgstr "处理与渲染"

#. Tag: para
#, no-c-format
msgid "Now you can implement the processing of the request and the rendering of the page."
msgstr "我们来实现处理请求以及渲染页面的工作。 "

#. Tag: para
#, no-c-format
msgid "This coding style, with a mix of Java and HTML, would not scale in a more complex application&mdash;keep in mind that we are only illustrating basic Hibernate concepts in this tutorial. The code prints an HTML header and a footer. Inside this page, an HTML form for event entry and a list of all events in the database are printed. The first method is trivial and only outputs HTML:"
msgstr "必须承认，这种编码风格把 Java 和 HTML 混在一起，在更复杂的应用程序里不应该大量使用 — 记住，在本章里我们仅仅是展示了 Hibernate 的基本概念。这段代码打印出了 HTML 页眉和页脚，在这个页面里，还打印了一个输入 events 条目的表单单并列出了数据库里的有的 events。第一个方法微不足道，仅仅是输出 HTML："

#. Tag: para
#, no-c-format
msgid "The <literal>listEvents()</literal> method uses the Hibernate <literal>Session</literal> bound to the current thread to execute a query:"
msgstr "<literal>listEvents()</literal> 方法使用绑定到当前线程的 Hibernate <literal>Session</literal> 来执行查询："

#. Tag: para
#, no-c-format
msgid "Finally, the <literal>store</literal> action is dispatched to the <literal>createAndStoreEvent()</literal> method, which also uses the <literal>Session</literal> of the current thread:"
msgstr "最后，<literal>store</literal> 动作会被导向到 <literal>createAndStoreEvent()</literal> 方法，它也使用当前线程的 <literal>Session</literal>："

#. Tag: para
#, no-c-format
msgid "The servlet is now complete. A request to the servlet will be processed in a single <literal>Session</literal> and <literal>Transaction</literal>. As earlier in the standalone application, Hibernate can automatically bind these objects to the current thread of execution. This gives you the freedom to layer your code and access the <literal>SessionFactory</literal> in any way you like. Usually you would use a more sophisticated design and move the data access code into data access objects (the DAO pattern). See the Hibernate Wiki for more examples."
msgstr "大功告成，这个 servlet 写完了。Hibernate 会在单一的 <literal>Session</literal> 和 <literal>Transaction</literal> 中处理到达的 servlet 请求。如同在前面的独立应用程序中那样，Hibernate 可以自动的把这些对象绑定到当前运行的线程中。这给了你用任何你喜欢的方式来对代码分层及访问 <literal>SessionFactory</literal> 的自由。通常，你会用更加完备的设计，把数据访问代码转移到数据访问对象中（DAO 模式）。请参见 Hibernate Wiki，那里有更多的例子。 "

#. Tag: title
#, no-c-format
msgid "Deploying and testing"
msgstr "部署与测试"

#. Tag: para
#, no-c-format
msgid "To deploy this application for testing we must create a Web ARchive (WAR). First we must define the WAR descriptor as <filename>src/main/webapp/WEB-INF/web.xml</filename>"
msgstr "要部署这个应用程序以进行测试，我们必须出具一个 Web ARchive (WAR)。首先我们必须定义 WAR 描述符为 <filename>src/main/webapp/WEB-INF/web.xml</filename>。"

#. Tag: para
#, no-c-format
msgid "To build and deploy call <literal>mvn package</literal> in your project directory and copy the <filename>hibernate-tutorial.war</filename> file into your Tomcat <filename>webapps</filename> directory."
msgstr "在你的开发目录中，调用 <literal>ant war</literal> 来构建、打包，然后把 <literal>hibernate-tutorial.war</literal> 文件拷贝到你的 tomcat 的 <literal>webapps</literal> 目录下。假若你还没安装 Tomcat，就去下载一个，按照指南来安装。对此应用的发布，你不需要修改任何 Tomcat 的配置。 "

#. Tag: para
#, no-c-format
msgid "If you do not have Tomcat installed, download it from <ulink url=\"http://tomcat.apache.org/\" /> and follow the installation instructions. Our application requires no changes to the standard Tomcat configuration."
msgstr "如果你还没有安装 Tomcat，请从 <ulink url=\"http://tomcat.apache.org/\" /> 下载并按照安装说明进行安装。我们的应用程序不需要对标准的 Tomcat 配置进行修改。 "

#. Tag: para
#, no-c-format
msgid "Once deployed and Tomcat is running, access the application at <literal>http://localhost:8080/hibernate-tutorial/eventmanager</literal>. Make sure you watch the Tomcat log to see Hibernate initialize when the first request hits your servlet (the static initializer in <literal>HibernateUtil</literal> is called) and to get the detailed output if any exceptions occurs."
msgstr "在部署完，启动 Tomcat 之后，通过 <literal>http://localhost:8080/hibernate-tutorial/eventmanager</literal> 进行访问你的应用，在第一次 servlet 请求发生时，请在 Tomcat log 中确认你看到 Hibernate 被初始化了（<literal>HibernateUtil</literal> 的静态初始化器被调用），假若有任何异常抛出，也可以看到详细的输出。"

#. Tag: title
#, no-c-format
msgid "Summary"
msgstr "总结"

#. Tag: para
#, no-c-format
msgid "This tutorial covered the basics of writing a simple standalone Hibernate application and a small web application. More tutorials are available from the Hibernate <ulink url=\"http://hibernate.org\">website</ulink>."
msgstr "本章覆盖了如何编写一个简单独立的 Hibernate 命令行应用程序及小型的 Hibernate web 应用程序的基本要素。更多的教程可以在 <ulink url=\"http://hibernate.org\">website</ulink> 上找到。"

#~ msgid ""
#~ "<![CDATA[<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n"
#~ "         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
#~ "         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://"
#~ "maven.apache.org/xsd/maven-4.0.0.xsd\">\n"
#~ "\n"
#~ "    <modelVersion>4.0.0</modelVersion>\n"
#~ "\n"
#~ "    <groupId>org.hibernate.tutorials</groupId>\n"
#~ "    <artifactId>hibernate-tutorial</artifactId>\n"
#~ "    <version>1.0.0-SNAPSHOT</version>\n"
#~ "    <name>First Hibernate Tutorial</name>\n"
#~ "\n"
#~ "    <build>\n"
#~ "         <!-- we dont want the version to be part of the generated war "
#~ "file name -->\n"
#~ "         <finalName>${artifactId}</finalName>\n"
#~ "    </build>\n"
#~ "\n"
#~ "    <dependencies>\n"
#~ "        <dependency>\n"
#~ "            <groupId>org.hibernate</groupId>\n"
#~ "            <artifactId>hibernate-core</artifactId>\n"
#~ "        </dependency>\n"
#~ "\n"
#~ "        <!-- Because this is a web app, we also have a dependency on the "
#~ "servlet api. -->\n"
#~ "        <dependency>\n"
#~ "            <groupId>javax.servlet</groupId>\n"
#~ "            <artifactId>servlet-api</artifactId>\n"
#~ "        </dependency>\n"
#~ "\n"
#~ "        <!-- Hibernate uses slf4j for logging, for our purposes here use "
#~ "the simple backend -->\n"
#~ "        <dependency>\n"
#~ "            <groupId>org.slf4j</groupId>\n"
#~ "            <artifactId>slf4j-simple</artifactId>\n"
#~ "        </dependency>\n"
#~ "\n"
#~ "        <!-- Hibernate gives you a choice of bytecode providers between "
#~ "cglib and javassist -->\n"
#~ "        <dependency>\n"
#~ "            <groupId>javassist</groupId>\n"
#~ "            <artifactId>javassist</artifactId>\n"
#~ "        </dependency>\n"
#~ "    </dependencies>\n"
#~ "\n"
#~ "</project>]]>"
#~ msgstr ""
#~ "<![CDATA[<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n"
#~ "         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
#~ "         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://"
#~ "maven.apache.org/xsd/maven-4.0.0.xsd\">\n"
#~ "\n"
#~ "    <modelVersion>4.0.0</modelVersion>\n"
#~ "\n"
#~ "    <groupId>org.hibernate.tutorials</groupId>\n"
#~ "    <artifactId>hibernate-tutorial</artifactId>\n"
#~ "    <version>1.0.0-SNAPSHOT</version>\n"
#~ "    <name>First Hibernate Tutorial</name>\n"
#~ "\n"
#~ "    <build>\n"
#~ "         <!-- we dont want the version to be part of the generated war "
#~ "file name -->\n"
#~ "         <finalName>${artifactId}</finalName>\n"
#~ "    </build>\n"
#~ "\n"
#~ "    <dependencies>\n"
#~ "        <dependency>\n"
#~ "            <groupId>org.hibernate</groupId>\n"
#~ "            <artifactId>hibernate-core</artifactId>\n"
#~ "        </dependency>\n"
#~ "\n"
#~ "        <!-- Because this is a web app, we also have a dependency on the "
#~ "servlet api. -->\n"
#~ "        <dependency>\n"
#~ "            <groupId>javax.servlet</groupId>\n"
#~ "            <artifactId>servlet-api</artifactId>\n"
#~ "        </dependency>\n"
#~ "\n"
#~ "        <!-- Hibernate uses slf4j for logging, for our purposes here use "
#~ "the simple backend -->\n"
#~ "        <dependency>\n"
#~ "            <groupId>org.slf4j</groupId>\n"
#~ "            <artifactId>slf4j-simple</artifactId>\n"
#~ "        </dependency>\n"
#~ "\n"
#~ "        <!-- Hibernate gives you a choice of bytecode providers between "
#~ "cglib and javassist -->\n"
#~ "        <dependency>\n"
#~ "            <groupId>javassist</groupId>\n"
#~ "            <artifactId>javassist</artifactId>\n"
#~ "        </dependency>\n"
#~ "    </dependencies>\n"
#~ "\n"
#~ "</project>]]>"
#~ msgid ""
#~ "<![CDATA[package org.hibernate.tutorial.domain;\n"
#~ "\n"
#~ "import java.util.Date;\n"
#~ "\n"
#~ "public class Event {\n"
#~ "    private Long id;\n"
#~ "\n"
#~ "    private String title;\n"
#~ "    private Date date;\n"
#~ "\n"
#~ "    public Event() {}\n"
#~ "\n"
#~ "    public Long getId() {\n"
#~ "        return id;\n"
#~ "    }\n"
#~ "\n"
#~ "    private void setId(Long id) {\n"
#~ "        this.id = id;\n"
#~ "    }\n"
#~ "\n"
#~ "    public Date getDate() {\n"
#~ "        return date;\n"
#~ "    }\n"
#~ "\n"
#~ "    public void setDate(Date date) {\n"
#~ "        this.date = date;\n"
#~ "    }\n"
#~ "\n"
#~ "    public String getTitle() {\n"
#~ "        return title;\n"
#~ "    }\n"
#~ "\n"
#~ "    public void setTitle(String title) {\n"
#~ "        this.title = title;\n"
#~ "    }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[package org.hibernate.tutorial.domain;\n"
#~ "\n"
#~ "import java.util.Date;\n"
#~ "\n"
#~ "public class Event {\n"
#~ "    private Long id;\n"
#~ "\n"
#~ "    private String title;\n"
#~ "    private Date date;\n"
#~ "\n"
#~ "    public Event() {}\n"
#~ "\n"
#~ "    public Long getId() {\n"
#~ "        return id;\n"
#~ "    }\n"
#~ "\n"
#~ "    private void setId(Long id) {\n"
#~ "        this.id = id;\n"
#~ "    }\n"
#~ "\n"
#~ "    public Date getDate() {\n"
#~ "        return date;\n"
#~ "    }\n"
#~ "\n"
#~ "    public void setDate(Date date) {\n"
#~ "        this.date = date;\n"
#~ "    }\n"
#~ "\n"
#~ "    public String getTitle() {\n"
#~ "        return title;\n"
#~ "    }\n"
#~ "\n"
#~ "    public void setTitle(String title) {\n"
#~ "        this.title = title;\n"
#~ "    }\n"
#~ "}]]>"
#~ msgid ""
#~ "<![CDATA[<?xml version=\"1.0\"?>\n"
#~ "<!DOCTYPE hibernate-mapping PUBLIC\n"
#~ "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
#~ "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
#~ "\n"
#~ "<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
#~ "[...]\n"
#~ "</hibernate-mapping>]]>"
#~ msgstr ""
#~ "<![CDATA[<?xml version=\"1.0\"?>\n"
#~ "<!DOCTYPE hibernate-mapping PUBLIC\n"
#~ "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
#~ "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
#~ "\n"
#~ "<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
#~ "[...]\n"
#~ "</hibernate-mapping>]]>"
#~ msgid ""
#~ "<![CDATA[<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
#~ "\n"
#~ "    <class name=\"Event\" table=\"EVENTS\">\n"
#~ "\n"
#~ "    </class>\n"
#~ "\n"
#~ "</hibernate-mapping>]]>"
#~ msgstr ""
#~ "<![CDATA[<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
#~ "\n"
#~ "    <class name=\"Event\" table=\"EVENTS\">\n"
#~ "\n"
#~ "    </class>\n"
#~ "\n"
#~ "</hibernate-mapping>]]>"
#~ msgid ""
#~ "<![CDATA[<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
#~ "\n"
#~ "    <class name=\"Event\" table=\"EVENTS\">\n"
#~ "        <id name=\"id\" column=\"EVENT_ID\">\n"
#~ "            <generator class=\"native\"/>\n"
#~ "        </id>\n"
#~ "    </class>\n"
#~ "\n"
#~ "</hibernate-mapping>]]>"
#~ msgstr ""
#~ "<![CDATA[<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
#~ "\n"
#~ "    <class name=\"Event\" table=\"EVENTS\">\n"
#~ "        <id name=\"id\" column=\"EVENT_ID\">\n"
#~ "            <generator class=\"native\"/>\n"
#~ "        </id>\n"
#~ "    </class>\n"
#~ "\n"
#~ "</hibernate-mapping>]]>"
#~ msgid ""
#~ "<![CDATA[\n"
#~ "<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
#~ "\n"
#~ "    <class name=\"Event\" table=\"EVENTS\">\n"
#~ "        <id name=\"id\" column=\"EVENT_ID\">\n"
#~ "            <generator class=\"native\"/>\n"
#~ "        </id>\n"
#~ "        <property name=\"date\" type=\"timestamp\" column=\"EVENT_DATE\"/"
#~ ">\n"
#~ "        <property name=\"title\"/>\n"
#~ "    </class>\n"
#~ "\n"
#~ "</hibernate-mapping>]]>"
#~ msgstr ""
#~ "<![CDATA[\n"
#~ "<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
#~ "\n"
#~ "    <class name=\"Event\" table=\"EVENTS\">\n"
#~ "        <id name=\"id\" column=\"EVENT_ID\">\n"
#~ "            <generator class=\"native\"/>\n"
#~ "        </id>\n"
#~ "        <property name=\"date\" type=\"timestamp\" column=\"EVENT_DATE\"/"
#~ ">\n"
#~ "        <property name=\"title\"/>\n"
#~ "    </class>\n"
#~ "\n"
#~ "</hibernate-mapping>]]>"
#~ msgid ""
#~ "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
#~ "<!DOCTYPE hibernate-configuration PUBLIC\n"
#~ "        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n"
#~ "        \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"
#~ "\">\n"
#~ "\n"
#~ "<hibernate-configuration>\n"
#~ "\n"
#~ "    <session-factory>\n"
#~ "\n"
#~ "        <!-- Database connection settings -->\n"
#~ "        <property name=\"connection.driver_class\">org.hsqldb.jdbcDriver</"
#~ "property>\n"
#~ "        <property name=\"connection.url\">jdbc:hsqldb:hsql://localhost</"
#~ "property>\n"
#~ "        <property name=\"connection.username\">sa</property>\n"
#~ "        <property name=\"connection.password\"></property>\n"
#~ "\n"
#~ "        <!-- JDBC connection pool (use the built-in) -->\n"
#~ "        <property name=\"connection.pool_size\">1</property>\n"
#~ "\n"
#~ "        <!-- SQL dialect -->\n"
#~ "        <property name=\"dialect\">org.hibernate.dialect.HSQLDialect</"
#~ "property>\n"
#~ "\n"
#~ "        <!-- Enable Hibernate's automatic session context management -->\n"
#~ "        <property name=\"current_session_context_class\">thread</"
#~ "property>\n"
#~ "\n"
#~ "        <!-- Disable the second-level cache  -->\n"
#~ "        <property name=\"cache.provider_class\">org.hibernate.cache."
#~ "NoCacheProvider</property>\n"
#~ "\n"
#~ "        <!-- Echo all executed SQL to stdout -->\n"
#~ "        <property name=\"show_sql\">true</property>\n"
#~ "\n"
#~ "        <!-- Drop and re-create the database schema on startup -->\n"
#~ "        <property name=\"hbm2ddl.auto\">update</property>\n"
#~ "\n"
#~ "        <mapping resource=\"org/hibernate/tutorial/domain/Event.hbm.xml\"/"
#~ ">\n"
#~ "\n"
#~ "    </session-factory>\n"
#~ "\n"
#~ "</hibernate-configuration>]]>"
#~ msgstr ""
#~ "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
#~ "<!DOCTYPE hibernate-configuration PUBLIC\n"
#~ "        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n"
#~ "        \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"
#~ "\">\n"
#~ "\n"
#~ "<hibernate-configuration>\n"
#~ "\n"
#~ "    <session-factory>\n"
#~ "\n"
#~ "        <!-- Database connection settings -->\n"
#~ "        <property name=\"connection.driver_class\">org.hsqldb.jdbcDriver</"
#~ "property>\n"
#~ "        <property name=\"connection.url\">jdbc:hsqldb:hsql://localhost</"
#~ "property>\n"
#~ "        <property name=\"connection.username\">sa</property>\n"
#~ "        <property name=\"connection.password\"></property>\n"
#~ "\n"
#~ "        <!-- JDBC connection pool (use the built-in) -->\n"
#~ "        <property name=\"connection.pool_size\">1</property>\n"
#~ "\n"
#~ "        <!-- SQL dialect -->\n"
#~ "        <property name=\"dialect\">org.hibernate.dialect.HSQLDialect</"
#~ "property>\n"
#~ "\n"
#~ "        <!-- Enable Hibernate's automatic session context management -->\n"
#~ "        <property name=\"current_session_context_class\">thread</"
#~ "property>\n"
#~ "\n"
#~ "        <!-- Disable the second-level cache  -->\n"
#~ "        <property name=\"cache.provider_class\">org.hibernate.cache."
#~ "NoCacheProvider</property>\n"
#~ "\n"
#~ "        <!-- Echo all executed SQL to stdout -->\n"
#~ "        <property name=\"show_sql\">true</property>\n"
#~ "\n"
#~ "        <!-- Drop and re-create the database schema on startup -->\n"
#~ "        <property name=\"hbm2ddl.auto\">update</property>\n"
#~ "\n"
#~ "        <mapping resource=\"org/hibernate/tutorial/domain/Event.hbm.xml\"/"
#~ ">\n"
#~ "\n"
#~ "    </session-factory>\n"
#~ "\n"
#~ "</hibernate-configuration>]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[package org.hibernate.tutorial.util;\n"
#~ "\n"
#~ "import org.hibernate.SessionFactory;\n"
#~ "import org.hibernate.cfg.Configuration;\n"
#~ "\n"
#~ "public class HibernateUtil {\n"
#~ "\n"
#~ "    private static final SessionFactory sessionFactory = "
#~ "buildSessionFactory();\n"
#~ "\n"
#~ "    private static SessionFactory buildSessionFactory() {\n"
#~ "        try {\n"
#~ "            // Create the SessionFactory from hibernate.cfg.xml\n"
#~ "            return new Configuration().configure().buildSessionFactory"
#~ "();\n"
#~ "        }\n"
#~ "        catch (Throwable ex) {\n"
#~ "            // Make sure you log the exception, as it might be swallowed\n"
#~ "            System.err.println(\"Initial SessionFactory creation failed."
#~ "\" + ex);\n"
#~ "            throw new ExceptionInInitializerError(ex);\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    public static SessionFactory getSessionFactory() {\n"
#~ "        return sessionFactory;\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "package util;\n"
#~ "\n"
#~ "import org.hibernate.*;\n"
#~ "import org.hibernate.cfg.*;\n"
#~ "\n"
#~ "public class HibernateUtil {\n"
#~ "\n"
#~ "    private static final SessionFactory sessionFactory;\n"
#~ "\n"
#~ "    static {\n"
#~ "        try {\n"
#~ "            // Create the SessionFactory from hibernate.cfg.xml\n"
#~ "            sessionFactory = new Configuration().configure()."
#~ "buildSessionFactory();\n"
#~ "        } catch (Throwable ex) {\n"
#~ "            // Make sure you log the exception, as it might be swallowed\n"
#~ "            System.err.println(\"Initial SessionFactory creation failed."
#~ "\" + ex);\n"
#~ "            throw new ExceptionInInitializerError(ex);\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    public static SessionFactory getSessionFactory() {\n"
#~ "        return sessionFactory;\n"
#~ "    }\n"
#~ "\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[package org.hibernate.tutorial;\n"
#~ "\n"
#~ "import org.hibernate.Session;\n"
#~ "\n"
#~ "import java.util.*;\n"
#~ "\n"
#~ "import org.hibernate.tutorial.domain.Event;\n"
#~ "import org.hibernate.tutorial.util.HibernateUtil;\n"
#~ "\n"
#~ "public class EventManager {\n"
#~ "\n"
#~ "    public static void main(String[] args) {\n"
#~ "        EventManager mgr = new EventManager();\n"
#~ "\n"
#~ "        if (args[0].equals(\"store\")) {\n"
#~ "            mgr.createAndStoreEvent(\"My Event\", new Date());\n"
#~ "        }\n"
#~ "\n"
#~ "        HibernateUtil.getSessionFactory().close();\n"
#~ "    }\n"
#~ "\n"
#~ "    private void createAndStoreEvent(String title, Date theDate) {\n"
#~ "        Session session = HibernateUtil.getSessionFactory()."
#~ "getCurrentSession();\n"
#~ "        session.beginTransaction();\n"
#~ "\n"
#~ "        Event theEvent = new Event();\n"
#~ "        theEvent.setTitle(title);\n"
#~ "        theEvent.setDate(theDate);\n"
#~ "        session.save(theEvent);\n"
#~ "\n"
#~ "        session.getTransaction().commit();\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "package events;\n"
#~ "import org.hibernate.Session;\n"
#~ "\n"
#~ "import java.util.Date;\n"
#~ "\n"
#~ "import util.HibernateUtil;\n"
#~ "\n"
#~ "public class EventManager {\n"
#~ "\n"
#~ "    public static void main(String[] args) {\n"
#~ "        EventManager mgr = new EventManager();\n"
#~ "\n"
#~ "        if (args[0].equals(\"store\")) {\n"
#~ "            mgr.createAndStoreEvent(\"My Event\", new Date());\n"
#~ "        }\n"
#~ "\n"
#~ "        HibernateUtil.getSessionFactory().close();\n"
#~ "    }\n"
#~ "\n"
#~ "    private void createAndStoreEvent(String title, Date theDate) {\n"
#~ "\n"
#~ "        Session session = HibernateUtil.getSessionFactory()."
#~ "getCurrentSession();\n"
#~ "\n"
#~ "        session.beginTransaction();\n"
#~ "\n"
#~ "        Event theEvent = new Event();\n"
#~ "        theEvent.setTitle(title);\n"
#~ "        theEvent.setDate(theDate);\n"
#~ "\n"
#~ "        session.save(theEvent);\n"
#~ "\n"
#~ "        session.getTransaction().commit();\n"
#~ "    }\n"
#~ "\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[[java] Hibernate: insert into EVENTS (EVENT_DATE, title, "
#~ "EVENT_ID) values (?, ?, ?)]]>"
#~ msgstr ""
#~ "[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values "
#~ "(?, ?, ?)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[        if (args[0].equals(\"store\")) {\n"
#~ "            mgr.createAndStoreEvent(\"My Event\", new Date());\n"
#~ "        }\n"
#~ "        else if (args[0].equals(\"list\")) {\n"
#~ "            List events = mgr.listEvents();\n"
#~ "            for (int i = 0; i < events.size(); i++) {\n"
#~ "                Event theEvent = (Event) events.get(i);\n"
#~ "                System.out.println(\n"
#~ "                        \"Event: \" + theEvent.getTitle() + \" Time: \" + "
#~ "theEvent.getDate()\n"
#~ "                );\n"
#~ "            }\n"
#~ "        }]]>"
#~ msgstr ""
#~ "if (args[0].equals(\"store\")) {\n"
#~ "    mgr.createAndStoreEvent(\"My Event\", new Date());\n"
#~ "}\n"
#~ "else if (args[0].equals(\"list\")) {\n"
#~ "    List events = mgr.listEvents();\n"
#~ "    for (int i = 0; i &lt; events.size(); i++) {\n"
#~ "        Event theEvent = (Event) events.get(i);\n"
#~ "        System.out.println(\"Event: \" + theEvent.getTitle() +\n"
#~ "                           \" Time: \" + theEvent.getDate());\n"
#~ "    }\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[    private List listEvents() {\n"
#~ "        Session session = HibernateUtil.getSessionFactory()."
#~ "getCurrentSession();\n"
#~ "        session.beginTransaction();\n"
#~ "        List result = session.createQuery(\"from Event\").list();\n"
#~ "        session.getTransaction().commit();\n"
#~ "        return result;\n"
#~ "    }]]>"
#~ msgstr ""
#~ "private List listEvents() {\n"
#~ "\n"
#~ "    Session session = HibernateUtil.getSessionFactory().getCurrentSession"
#~ "();\n"
#~ "\n"
#~ "    session.beginTransaction();\n"
#~ "\n"
#~ "    List result = session.createQuery(\"from Event\").list();\n"
#~ "\n"
#~ "    session.getTransaction().commit();\n"
#~ "\n"
#~ "    return result;\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[package org.hibernate.tutorial.domain;\n"
#~ "\n"
#~ "public class Person {\n"
#~ "\n"
#~ "    private Long id;\n"
#~ "    private int age;\n"
#~ "    private String firstname;\n"
#~ "    private String lastname;\n"
#~ "\n"
#~ "    public Person() {}\n"
#~ "\n"
#~ "    // Accessor methods for all properties, private setter for 'id'\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "package events;\n"
#~ "\n"
#~ "public class Person {\n"
#~ "\n"
#~ "    private Long id;\n"
#~ "    private int age;\n"
#~ "    private String firstname;\n"
#~ "    private String lastname;\n"
#~ "\n"
#~ "    public Person() {}\n"
#~ "\n"
#~ "    // Accessor methods for all properties, private setter for 'id'\n"
#~ "\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
#~ "\n"
#~ "    <class name=\"Person\" table=\"PERSON\">\n"
#~ "        <id name=\"id\" column=\"PERSON_ID\">\n"
#~ "            <generator class=\"native\"/>\n"
#~ "        </id>\n"
#~ "        <property name=\"age\"/>\n"
#~ "        <property name=\"firstname\"/>\n"
#~ "        <property name=\"lastname\"/>\n"
#~ "    </class>\n"
#~ "\n"
#~ "</hibernate-mapping>]]>"
#~ msgstr ""
#~ "&lt;hibernate-mapping&gt;\n"
#~ "\n"
#~ "    &lt;class name=\"events.Person\" table=\"PERSON\"&gt;\n"
#~ "        &lt;id name=\"id\" column=\"PERSON_ID\"&gt;\n"
#~ "            &lt;generator class=\"native\"/&gt;\n"
#~ "        &lt;/id&gt;\n"
#~ "        &lt;property name=\"age\"/&gt;\n"
#~ "        &lt;property name=\"firstname\"/&gt;\n"
#~ "        &lt;property name=\"lastname\"/&gt;\n"
#~ "    &lt;/class&gt;\n"
#~ "\n"
#~ "&lt;/hibernate-mapping&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<mapping resource=\"events/Event.hbm.xml\"/>\n"
#~ "<mapping resource=\"events/Person.hbm.xml\"/>]]>"
#~ msgstr ""
#~ "&lt;mapping resource=\"events/Event.hbm.xml\"/&gt;\n"
#~ "&lt;mapping resource=\"events/Person.hbm.xml\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[public class Person {\n"
#~ "\n"
#~ "    private Set events = new HashSet();\n"
#~ "\n"
#~ "    public Set getEvents() {\n"
#~ "        return events;\n"
#~ "    }\n"
#~ "\n"
#~ "    public void setEvents(Set events) {\n"
#~ "        this.events = events;\n"
#~ "    }\n"
#~ "}]]>"
#~ msgstr ""
#~ "public class Person {\n"
#~ "\n"
#~ "    private Set events = new HashSet();\n"
#~ "\n"
#~ "    public Set getEvents() {\n"
#~ "        return events;\n"
#~ "    }\n"
#~ "\n"
#~ "    public void setEvents(Set events) {\n"
#~ "        this.events = events;\n"
#~ "    }\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Person\" table=\"PERSON\">\n"
#~ "    <id name=\"id\" column=\"PERSON_ID\">\n"
#~ "        <generator class=\"native\"/>\n"
#~ "    </id>\n"
#~ "    <property name=\"age\"/>\n"
#~ "    <property name=\"firstname\"/>\n"
#~ "    <property name=\"lastname\"/>\n"
#~ "\n"
#~ "    <set name=\"events\" table=\"PERSON_EVENT\">\n"
#~ "        <key column=\"PERSON_ID\"/>\n"
#~ "        <many-to-many column=\"EVENT_ID\" class=\"Event\"/>\n"
#~ "    </set>\n"
#~ "\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"events.Person\" table=\"PERSON\"&gt;\n"
#~ "    &lt;id name=\"id\" column=\"PERSON_ID\"&gt;\n"
#~ "        &lt;generator class=\"native\"/&gt;\n"
#~ "    &lt;/id&gt;\n"
#~ "    &lt;property name=\"age\"/&gt;\n"
#~ "    &lt;property name=\"firstname\"/&gt;\n"
#~ "    &lt;property name=\"lastname\"/&gt;\n"
#~ "\n"
#~ "    &lt;set name=\"events\" table=\"PERSON_EVENT\"&gt;\n"
#~ "        &lt;key column=\"PERSON_ID\"/&gt;\n"
#~ "        &lt;many-to-many column=\"EVENT_ID\" class=\"events.Event\"/&gt;\n"
#~ "    &lt;/set&gt;\n"
#~ "\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[\n"
#~ "    _____________        __________________\n"
#~ "   |             |      |                  |       _____________\n"
#~ "   |   EVENTS    |      |   PERSON_EVENT   |      |             |\n"
#~ "   |_____________|      |__________________|      |    PERSON   |\n"
#~ "   |             |      |                  |      |_____________|\n"
#~ "   | *EVENT_ID   | <--> | *EVENT_ID        |      |             |\n"
#~ "   |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  |\n"
#~ "   |  TITLE      |      |__________________|      |  AGE        |\n"
#~ "   |_____________|                                |  FIRSTNAME  |\n"
#~ "                                                  |  LASTNAME   |\n"
#~ "                                                  |_____________|\n"
#~ " ]]>"
#~ msgstr ""
#~ "_____________        __________________\n"
#~ "   |             |      |                  |       _____________\n"
#~ "   |   EVENTS    |      |   PERSON_EVENT   |      |             |\n"
#~ "   |_____________|      |__________________|      |    PERSON   |\n"
#~ "   |             |      |                  |      |_____________|\n"
#~ "   | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |\n"
#~ "   |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  |\n"
#~ "   |  TITLE      |      |__________________|      |  AGE        |\n"
#~ "   |_____________|                                |  FIRSTNAME  |\n"
#~ "                                                  |  LASTNAME   |\n"
#~ "                                                  |_____________|"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[    private void addPersonToEvent(Long personId, Long eventId) "
#~ "{\n"
#~ "        Session session = HibernateUtil.getSessionFactory()."
#~ "getCurrentSession();\n"
#~ "        session.beginTransaction();\n"
#~ "\n"
#~ "        Person aPerson = (Person) session.load(Person.class, personId);\n"
#~ "        Event anEvent = (Event) session.load(Event.class, eventId);\n"
#~ "        aPerson.getEvents().add(anEvent);\n"
#~ "\n"
#~ "        session.getTransaction().commit();\n"
#~ "    }]]>"
#~ msgstr ""
#~ "private void addPersonToEvent(Long personId, Long eventId) {\n"
#~ "\n"
#~ "    Session session = HibernateUtil.getSessionFactory().getCurrentSession"
#~ "();\n"
#~ "    session.beginTransaction();\n"
#~ "\n"
#~ "    Person aPerson = (Person) session.load(Person.class, personId);\n"
#~ "    Event anEvent = (Event) session.load(Event.class, eventId);\n"
#~ "\n"
#~ "    aPerson.getEvents().add(anEvent);\n"
#~ "\n"
#~ "    session.getTransaction().commit();\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[    private void addPersonToEvent(Long personId, Long eventId) "
#~ "{\n"
#~ "        Session session = HibernateUtil.getSessionFactory()."
#~ "getCurrentSession();\n"
#~ "        session.beginTransaction();\n"
#~ "\n"
#~ "        Person aPerson = (Person) session\n"
#~ "                .createQuery(\"select p from Person p left join fetch p."
#~ "events where p.id = :pid\")\n"
#~ "                .setParameter(\"pid\", personId)\n"
#~ "                .uniqueResult(); // Eager fetch the collection so we can "
#~ "use it detached\n"
#~ "        Event anEvent = (Event) session.load(Event.class, eventId);\n"
#~ "\n"
#~ "        session.getTransaction().commit();\n"
#~ "\n"
#~ "        // End of first unit of work\n"
#~ "\n"
#~ "        aPerson.getEvents().add(anEvent); // aPerson (and its collection) "
#~ "is detached\n"
#~ "\n"
#~ "        // Begin second unit of work\n"
#~ "\n"
#~ "        Session session2 = HibernateUtil.getSessionFactory()."
#~ "getCurrentSession();\n"
#~ "        session2.beginTransaction();\n"
#~ "        session2.update(aPerson); // Reattachment of aPerson\n"
#~ "\n"
#~ "        session2.getTransaction().commit();\n"
#~ "    }]]>"
#~ msgstr ""
#~ "private void addPersonToEvent(Long personId, Long eventId) {\n"
#~ "\n"
#~ "    Session session = HibernateUtil.getSessionFactory().getCurrentSession"
#~ "();\n"
#~ "    session.beginTransaction();\n"
#~ "\n"
#~ "    Person aPerson = (Person) session\n"
#~ "            .createQuery(\"select p from Person p left join fetch p."
#~ "events where p.id = :pid\")\n"
#~ "            .setParameter(\"pid\", personId)\n"
#~ "            .uniqueResult(); // Eager fetch the collection so we can use "
#~ "it detached\n"
#~ "\n"
#~ "    Event anEvent = (Event) session.load(Event.class, eventId);\n"
#~ "\n"
#~ "    session.getTransaction().commit();\n"
#~ "\n"
#~ "    // End of first unit of work\n"
#~ "\n"
#~ "    aPerson.getEvents().add(anEvent); // aPerson (and its collection) is "
#~ "detached\n"
#~ "\n"
#~ "    // Begin second unit of work\n"
#~ "\n"
#~ "    Session session2 = HibernateUtil.getSessionFactory().getCurrentSession"
#~ "();\n"
#~ "    session2.beginTransaction();\n"
#~ "\n"
#~ "    session2.update(aPerson); // Reattachment of aPerson\n"
#~ "\n"
#~ "    session2.getTransaction().commit();\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[        else if (args[0].equals(\"addpersontoevent\")) {\n"
#~ "            Long eventId = mgr.createAndStoreEvent(\"My Event\", new Date"
#~ "());\n"
#~ "            Long personId = mgr.createAndStorePerson(\"Foo\", \"Bar\");\n"
#~ "            mgr.addPersonToEvent(personId, eventId);\n"
#~ "            System.out.println(\"Added person \" + personId + \" to event "
#~ "\" + eventId);\n"
#~ "        }]]>"
#~ msgstr ""
#~ "else if (args[0].equals(\"addpersontoevent\")) {\n"
#~ "    Long eventId = mgr.createAndStoreEvent(\"My Event\", new Date());\n"
#~ "    Long personId = mgr.createAndStorePerson(\"Foo\", \"Bar\");\n"
#~ "    mgr.addPersonToEvent(personId, eventId);\n"
#~ "    System.out.println(\"Added person \" + personId + \" to event \" + "
#~ "eventId);\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[    private Set emailAddresses = new HashSet();\n"
#~ "\n"
#~ "    public Set getEmailAddresses() {\n"
#~ "        return emailAddresses;\n"
#~ "    }\n"
#~ "\n"
#~ "    public void setEmailAddresses(Set emailAddresses) {\n"
#~ "        this.emailAddresses = emailAddresses;\n"
#~ "    }]]>"
#~ msgstr ""
#~ "private Set emailAddresses = new HashSet();\n"
#~ "\n"
#~ "public Set getEmailAddresses() {\n"
#~ "    return emailAddresses;\n"
#~ "}\n"
#~ "\n"
#~ "public void setEmailAddresses(Set emailAddresses) {\n"
#~ "    this.emailAddresses = emailAddresses;\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[        <set name=\"emailAddresses\" table=\"PERSON_EMAIL_ADDR"
#~ "\">\n"
#~ "            <key column=\"PERSON_ID\"/>\n"
#~ "            <element type=\"string\" column=\"EMAIL_ADDR\"/>\n"
#~ "        </set>]]>"
#~ msgstr ""
#~ "&lt;set name=\"emailAddresses\" table=\"PERSON_EMAIL_ADDR\"&gt;\n"
#~ "    &lt;key column=\"PERSON_ID\"/&gt;\n"
#~ "    &lt;element type=\"string\" column=\"EMAIL_ADDR\"/&gt;\n"
#~ "&lt;/set&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[\n"
#~ "  _____________        __________________\n"
#~ " |             |      |                  |       _____________\n"
#~ " |   EVENTS    |      |   PERSON_EVENT   |      |             |       "
#~ "___________________\n"
#~ " |_____________|      |__________________|      |    PERSON   |      "
#~ "|                   |\n"
#~ " |             |      |                  |      |_____________|      | "
#~ "PERSON_EMAIL_ADDR |\n"
#~ " | *EVENT_ID   | <--> | *EVENT_ID        |      |             |      |"
#~ "___________________|\n"
#~ " |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  | <--> |  "
#~ "*PERSON_ID       |\n"
#~ " |  TITLE      |      |__________________|      |  AGE        |      |  "
#~ "*EMAIL_ADDR      |\n"
#~ " |_____________|                                |  FIRSTNAME  |      |"
#~ "___________________|\n"
#~ "                                                |  LASTNAME   |\n"
#~ "                                                |_____________|\n"
#~ " ]]>"
#~ msgstr ""
#~ "_____________        __________________\n"
#~ " |             |      |                  |       _____________\n"
#~ " |   EVENTS    |      |   PERSON_EVENT   |      |             |       "
#~ "___________________\n"
#~ " |_____________|      |__________________|      |    PERSON   |      "
#~ "|                   |\n"
#~ " |             |      |                  |      |_____________|      | "
#~ "PERSON_EMAIL_ADDR |\n"
#~ " | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             "
#~ "|      |___________________|\n"
#~ " |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  | "
#~ "&lt;--&gt; |  *PERSON_ID       |\n"
#~ " |  TITLE      |      |__________________|      |  AGE        |      |  "
#~ "*EMAIL_ADDR      |\n"
#~ " |_____________|                                |  FIRSTNAME  |      |"
#~ "___________________|\n"
#~ "                                                |  LASTNAME   |\n"
#~ "                                                |_____________|"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[    private void addEmailToPerson(Long personId, String "
#~ "emailAddress) {\n"
#~ "        Session session = HibernateUtil.getSessionFactory()."
#~ "getCurrentSession();\n"
#~ "        session.beginTransaction();\n"
#~ "\n"
#~ "        Person aPerson = (Person) session.load(Person.class, personId);\n"
#~ "        // adding to the emailAddress collection might trigger a lazy "
#~ "load of the collection\n"
#~ "        aPerson.getEmailAddresses().add(emailAddress);\n"
#~ "\n"
#~ "        session.getTransaction().commit();\n"
#~ "    }]]>"
#~ msgstr ""
#~ "private void addEmailToPerson(Long personId, String emailAddress) {\n"
#~ "\n"
#~ "    Session session = HibernateUtil.getSessionFactory().getCurrentSession"
#~ "();\n"
#~ "    session.beginTransaction();\n"
#~ "\n"
#~ "    Person aPerson = (Person) session.load(Person.class, personId);\n"
#~ "\n"
#~ "    // The getEmailAddresses() might trigger a lazy load of the "
#~ "collection\n"
#~ "    aPerson.getEmailAddresses().add(emailAddress);\n"
#~ "\n"
#~ "    session.getTransaction().commit();\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[    private Set participants = new HashSet();\n"
#~ "\n"
#~ "    public Set getParticipants() {\n"
#~ "        return participants;\n"
#~ "    }\n"
#~ "\n"
#~ "    public void setParticipants(Set participants) {\n"
#~ "        this.participants = participants;\n"
#~ "    }]]>"
#~ msgstr ""
#~ "private Set participants = new HashSet();\n"
#~ "\n"
#~ "public Set getParticipants() {\n"
#~ "    return participants;\n"
#~ "}\n"
#~ "\n"
#~ "public void setParticipants(Set participants) {\n"
#~ "    this.participants = participants;\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[        <set name=\"participants\" table=\"PERSON_EVENT\" "
#~ "inverse=\"true\">\n"
#~ "            <key column=\"EVENT_ID\"/>\n"
#~ "            <many-to-many column=\"PERSON_ID\" class=\"events.Person\"/>\n"
#~ "        </set>]]>"
#~ msgstr ""
#~ "&lt;set name=\"participants\" table=\"PERSON_EVENT\" inverse=\"true"
#~ "\"&gt;\n"
#~ "    &lt;key column=\"EVENT_ID\"/&gt;\n"
#~ "    &lt;many-to-many column=\"PERSON_ID\" class=\"events.Person\"/&gt;\n"
#~ "&lt;/set&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[    protected Set getEvents() {\n"
#~ "        return events;\n"
#~ "    }\n"
#~ "\n"
#~ "    protected void setEvents(Set events) {\n"
#~ "        this.events = events;\n"
#~ "    }\n"
#~ "\n"
#~ "    public void addToEvent(Event event) {\n"
#~ "        this.getEvents().add(event);\n"
#~ "        event.getParticipants().add(this);\n"
#~ "    }\n"
#~ "\n"
#~ "    public void removeFromEvent(Event event) {\n"
#~ "        this.getEvents().remove(event);\n"
#~ "        event.getParticipants().remove(this);\n"
#~ "    }]]>"
#~ msgstr ""
#~ "protected Set getEvents() {\n"
#~ "    return events;\n"
#~ "}\n"
#~ "\n"
#~ "protected void setEvents(Set events) {\n"
#~ "    this.events = events;\n"
#~ "}\n"
#~ "\n"
#~ "public void addToEvent(Event event) {\n"
#~ "    this.getEvents().add(event);\n"
#~ "    event.getParticipants().add(this);\n"
#~ "}\n"
#~ "\n"
#~ "public void removeFromEvent(Event event) {\n"
#~ "    this.getEvents().remove(event);\n"
#~ "    event.getParticipants().remove(this);\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[package org.hibernate.tutorial.web;\n"
#~ "\n"
#~ "// Imports\n"
#~ "\n"
#~ "public class EventManagerServlet extends HttpServlet {\n"
#~ "\n"
#~ "    protected void doGet(\n"
#~ "            HttpServletRequest request,\n"
#~ "            HttpServletResponse response) throws ServletException, "
#~ "IOException {\n"
#~ "\n"
#~ "        SimpleDateFormat dateFormatter = new SimpleDateFormat( \"dd.MM."
#~ "yyyy\" );\n"
#~ "\n"
#~ "        try {\n"
#~ "            // Begin unit of work\n"
#~ "            HibernateUtil.getSessionFactory().getCurrentSession()."
#~ "beginTransaction();\n"
#~ "\n"
#~ "            // Process request and render page...\n"
#~ "\n"
#~ "            // End unit of work\n"
#~ "            HibernateUtil.getSessionFactory().getCurrentSession()."
#~ "getTransaction().commit();\n"
#~ "        }\n"
#~ "        catch (Exception ex) {\n"
#~ "            HibernateUtil.getSessionFactory().getCurrentSession()."
#~ "getTransaction().rollback();\n"
#~ "            if ( ServletException.class.isInstance( ex ) ) {\n"
#~ "                throw ( ServletException ) ex;\n"
#~ "            }\n"
#~ "            else {\n"
#~ "                throw new ServletException( ex );\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "protected void doGet(HttpServletRequest request,\n"
#~ "                     HttpServletResponse response)\n"
#~ "        throws ServletException, IOException {\n"
#~ "\n"
#~ "    SimpleDateFormat dateFormatter = new SimpleDateFormat(\"dd.MM.yyyy"
#~ "\");\n"
#~ "\n"
#~ "    try {\n"
#~ "        // Begin unit of work\n"
#~ "        HibernateUtil.getSessionFactory()\n"
#~ "                .getCurrentSession().beginTransaction();\n"
#~ "\n"
#~ "        // Process request and render page...\n"
#~ "\n"
#~ "        // End unit of work\n"
#~ "        HibernateUtil.getSessionFactory()\n"
#~ "                .getCurrentSession().getTransaction().commit();\n"
#~ "\n"
#~ "    } catch (Exception ex) {\n"
#~ "        HibernateUtil.getSessionFactory()\n"
#~ "                .getCurrentSession().getTransaction().rollback();\n"
#~ "        throw new ServletException(ex);\n"
#~ "    }\n"
#~ "\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[        // Write HTML header\n"
#~ "        PrintWriter out = response.getWriter();\n"
#~ "        out.println(\"<html><head><title>Event Manager</title></"
#~ "head><body>\");\n"
#~ "\n"
#~ "        // Handle actions\n"
#~ "        if ( \"store\".equals(request.getParameter(\"action\")) ) {\n"
#~ "\n"
#~ "            String eventTitle = request.getParameter(\"eventTitle\");\n"
#~ "            String eventDate = request.getParameter(\"eventDate\");\n"
#~ "\n"
#~ "            if ( \"\".equals(eventTitle) || \"\".equals(eventDate) ) {\n"
#~ "                out.println(\"<b><i>Please enter event title and date.</"
#~ "i></b>\");\n"
#~ "            }\n"
#~ "            else {\n"
#~ "                createAndStoreEvent(eventTitle, dateFormatter.parse"
#~ "(eventDate));\n"
#~ "                out.println(\"<b><i>Added event.</i></b>\");\n"
#~ "            }\n"
#~ "        }\n"
#~ "\n"
#~ "        // Print page\n"
#~ "       printEventForm(out);\n"
#~ "       listEvents(out, dateFormatter);\n"
#~ "\n"
#~ "       // Write HTML footer\n"
#~ "       out.println(\"</body></html>\");\n"
#~ "       out.flush();\n"
#~ "       out.close();]]>"
#~ msgstr ""
#~ "// Write HTML header\n"
#~ "PrintWriter out = response.getWriter();\n"
#~ "out.println(\"&lt;html&gt;&lt;head&gt;&lt;title&gt;Event Manager&lt;/"
#~ "title&gt;&lt;/head&gt;&lt;body&gt;\");\n"
#~ "\n"
#~ "// Handle actions\n"
#~ "if ( \"store\".equals(request.getParameter(\"action\")) ) {\n"
#~ "\n"
#~ "    String eventTitle = request.getParameter(\"eventTitle\");\n"
#~ "    String eventDate = request.getParameter(\"eventDate\");\n"
#~ "\n"
#~ "    if ( \"\".equals(eventTitle) || \"\".equals(eventDate) ) {\n"
#~ "        out.println(\"&lt;b&gt;&lt;i&gt;Please enter event title and date."
#~ "&lt;/i&gt;&lt;/b&gt;\");\n"
#~ "    } else {\n"
#~ "        createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));\n"
#~ "        out.println(\"&lt;b&gt;&lt;i&gt;Added event.&lt;/i&gt;&lt;/b&gt;"
#~ "\");\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Print page\n"
#~ "printEventForm(out);\n"
#~ "listEvents(out, dateFormatter);\n"
#~ "\n"
#~ "// Write HTML footer\n"
#~ "out.println(\"&lt;/body&gt;&lt;/html&gt;\");\n"
#~ "out.flush();\n"
#~ "out.close();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[    private void printEventForm(PrintWriter out) {\n"
#~ "        out.println(\"<h2>Add new event:</h2>\");\n"
#~ "        out.println(\"<form>\");\n"
#~ "        out.println(\"Title: <input name='eventTitle' length='50'/><br/>"
#~ "\");\n"
#~ "        out.println(\"Date (e.g. 24.12.2009): <input name='eventDate' "
#~ "length='10'/><br/>\");\n"
#~ "        out.println(\"<input type='submit' name='action' value='store'/>"
#~ "\");\n"
#~ "        out.println(\"</form>\");\n"
#~ "    }]]>"
#~ msgstr ""
#~ "private void printEventForm(PrintWriter out) {\n"
#~ "    out.println(\"&lt;h2&gt;Add new event:&lt;/h2&gt;\");\n"
#~ "    out.println(\"&lt;form&gt;\");\n"
#~ "    out.println(\"Title: &lt;input name='eventTitle' length='50'/&gt;&lt;"
#~ "br/&gt;\");\n"
#~ "    out.println(\"Date (e.g. 24.12.2009): &lt;input name='eventDate' "
#~ "length='10'/&gt;&lt;br/&gt;\");\n"
#~ "    out.println(\"&lt;input type='submit' name='action' value='store'/&gt;"
#~ "\");\n"
#~ "    out.println(\"&lt;/form&gt;\");\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[    private void listEvents(PrintWriter out, SimpleDateFormat "
#~ "dateFormatter) {\n"
#~ "\n"
#~ "        List result = HibernateUtil.getSessionFactory()\n"
#~ "                .getCurrentSession().createCriteria(Event.class).list();\n"
#~ "        if (result.size() > 0) {\n"
#~ "            out.println(\"<h2>Events in database:</h2>\");\n"
#~ "            out.println(\"<table border='1'>\");\n"
#~ "            out.println(\"<tr>\");\n"
#~ "            out.println(\"<th>Event title</th>\");\n"
#~ "            out.println(\"<th>Event date</th>\");\n"
#~ "            out.println(\"</tr>\");\n"
#~ "            Iterator it = result.iterator();\n"
#~ "            while (it.hasNext()) {\n"
#~ "                Event event = (Event) it.next();\n"
#~ "                out.println(\"<tr>\");\n"
#~ "                out.println(\"<td>\" + event.getTitle() + \"</td>\");\n"
#~ "                out.println(\"<td>\" + dateFormatter.format(event.getDate"
#~ "()) + \"</td>\");\n"
#~ "                out.println(\"</tr>\");\n"
#~ "            }\n"
#~ "            out.println(\"</table>\");\n"
#~ "        }\n"
#~ "    }]]>"
#~ msgstr ""
#~ "private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) "
#~ "{\n"
#~ "\n"
#~ "    List result = HibernateUtil.getSessionFactory()\n"
#~ "                    .getCurrentSession().createCriteria(Event.class).list"
#~ "();\n"
#~ "    if (result.size() &gt; 0) {\n"
#~ "        out.println(\"&lt;h2&gt;Events in database:&lt;/h2&gt;\");\n"
#~ "        out.println(\"&lt;table border='1'&gt;\");\n"
#~ "        out.println(\"&lt;tr&gt;\");\n"
#~ "        out.println(\"&lt;th&gt;Event title&lt;/th&gt;\");\n"
#~ "        out.println(\"&lt;th&gt;Event date&lt;/th&gt;\");\n"
#~ "        out.println(\"&lt;/tr&gt;\");\n"
#~ "        for (Iterator it = result.iterator(); it.hasNext();) {\n"
#~ "            Event event = (Event) it.next();\n"
#~ "            out.println(\"&lt;tr&gt;\");\n"
#~ "            out.println(\"&lt;td&gt;\" + event.getTitle() + \"&lt;/td&gt;"
#~ "\");\n"
#~ "            out.println(\"&lt;td&gt;\" + dateFormatter.format(event."
#~ "getDate()) + \"&lt;/td&gt;\");\n"
#~ "            out.println(\"&lt;/tr&gt;\");\n"
#~ "        }\n"
#~ "        out.println(\"&lt;/table&gt;\");\n"
#~ "    }\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[    protected void createAndStoreEvent(String title, Date "
#~ "theDate) {\n"
#~ "        Event theEvent = new Event();\n"
#~ "        theEvent.setTitle(title);\n"
#~ "        theEvent.setDate(theDate);\n"
#~ "\n"
#~ "        HibernateUtil.getSessionFactory()\n"
#~ "                .getCurrentSession().save(theEvent);\n"
#~ "    }]]>"
#~ msgstr ""
#~ "protected void createAndStoreEvent(String title, Date theDate) {\n"
#~ "    Event theEvent = new Event();\n"
#~ "    theEvent.setTitle(title);\n"
#~ "    theEvent.setDate(theDate);\n"
#~ "\n"
#~ "    HibernateUtil.getSessionFactory()\n"
#~ "                    .getCurrentSession().save(theEvent);\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
#~ "<web-app version=\"2.4\"\n"
#~ "    xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n"
#~ "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
#~ "    xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun."
#~ "com/xml/ns/j2ee/web-app_2_4.xsd\">\n"
#~ "\n"
#~ "    <servlet>\n"
#~ "        <servlet-name>Event Manager</servlet-name>\n"
#~ "        <servlet-class>org.hibernate.tutorial.web.EventManagerServlet</"
#~ "servlet-class>\n"
#~ "    </servlet>\n"
#~ "\n"
#~ "    <servlet-mapping>\n"
#~ "        <servlet-name>Event Manager</servlet-name>\n"
#~ "        <url-pattern>/eventmanager</url-pattern>\n"
#~ "    </servlet-mapping>\n"
#~ "</web-app>]]>"
#~ msgstr ""
#~ "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n"
#~ "&lt;web-app version=\"2.4\"\n"
#~ "    xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n"
#~ "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
#~ "    xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee\n"
#~ "        http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt;\n"
#~ "\n"
#~ "    &lt;servlet&gt;\n"
#~ "        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;\n"
#~ "        &lt;servlet-class&gt;events.EventManagerServlet&lt;/servlet-"
#~ "class&gt;\n"
#~ "    &lt;/servlet&gt;\n"
#~ "\n"
#~ "    &lt;servlet-mapping&gt;\n"
#~ "        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;\n"
#~ "        &lt;url-pattern&gt;/eventmanager&lt;/url-pattern&gt;\n"
#~ "    &lt;/servlet-mapping&gt;\n"
#~ "&lt;/web-app&gt;"

