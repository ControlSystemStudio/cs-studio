# translation of basic_mapping.po to
# Xi Huang <xhuang@redhat.com>, 2006.
# Xi HUANG <xhuang@redhat.com>, 2007, 2009.
# translation of Collection_Mapping.po to
msgid ""
msgstr ""
"Project-Id-Version: basic_mapping\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:15\n"
"PO-Revision-Date: 2010-03-15 08:56+1000\n"
"Last-Translator: Xi HUANG <xhuang@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Basic O/R Mapping"
msgstr "对象/关系数据库映射基础（Basic O/R Mapping）"

#. Tag: title
#, no-c-format
msgid "Mapping declaration"
msgstr "映射定义（Mapping declaration）"

#. Tag: para
#, no-c-format
msgid "Object/relational mappings are usually defined in an XML document. The mapping document is designed to be readable and hand-editable. The mapping language is Java-centric, meaning that mappings are constructed around persistent class declarations and not table declarations."
msgstr "对象和关系数据库之间的映射通常是用一个 XML 文档来定义的。这个映射文档被设计为易读的，并且可以手工修改。映射语言是以 Java 为中心，这意味着映射文档是按照持久化类的定义来创建的，而非表的定义。 "

#. Tag: para
#, no-c-format
msgid "Please note that even though many Hibernate users choose to write the XML by hand, a number of tools exist to generate the mapping document. These include XDoclet, Middlegen and AndroMDA."
msgstr "请注意，虽然很多 Hibernate 用户选择手写 XML 映射文档，但也有一些工具可以用来生成映射文档，包括 XDoclet、Middlegen 和 AndroMDA。"

#. Tag: para
#, no-c-format
msgid "Here is an example mapping:"
msgstr "下面是一个映射的例子："

#. Tag: para
#, no-c-format
msgid "We will now discuss the content of the mapping document. We will only describe, however, the document elements and attributes that are used by Hibernate at runtime. The mapping document also contains some extra optional attributes and elements that affect the database schemas exported by the schema export tool (for example, the <literal> not-null</literal> attribute)."
msgstr "我们现在开始讨论映射文档的内容。我们只描述 Hibernate 在运行时用到的文档元素和属性。映射文档还包括一些额外的可选属性和元素，它们在使用 schema 导出工具的时候会影响导出的数据库 schema 结果（比如，<literal>not-null</literal> 属性）。"

#. Tag: title
#, no-c-format
msgid "Doctype"
msgstr "Doctype"

#. Tag: para
#, no-c-format
msgid "All XML mappings should declare the doctype shown. The actual DTD can be found at the URL above, in the directory <literal>hibernate-x.x.x/src/org/hibernate </literal>, or in <literal>hibernate3.jar</literal>. Hibernate will always look for the DTD in its classpath first. If you experience lookups of the DTD using an Internet connection, check the DTD declaration against the contents of your classpath."
msgstr "所有的 XML 映射都需要定义如上所示的 doctype。DTD 可以从上述 URL 中获取，也可以从 <literal>hibernate-x.x.x/src/org/hibernate </literal> 目录中、或 <literal>hibernate.jar</literal> 文件中找到。Hibernate 总是会首先在它的 classptah 中搜索 DTD 文件。如果你发现它是通过连接 Internet 查找 DTD 文件，就对照你的 classpath 目录检查 XML 文件里的 DTD 声明。"

#. Tag: title
#, no-c-format
msgid "EntityResolver"
msgstr "EntityResolver"

#. Tag: para
#, no-c-format
msgid "Hibernate will first attempt to resolve DTDs in its classpath. It does this is by registering a custom <literal>org.xml.sax.EntityResolver</literal> implementation with the SAXReader it uses to read in the xml files. This custom <literal>EntityResolver</literal> recognizes two different systemId namespaces:"
msgstr "Hibernate 首先试图在其 classpath 中解析 DTD。这是依靠在系统中注册的 <literal>org.xml.sax.EntityResolver</literal> 的一个具体实现，SAXReader 依靠它来读取 xml 文件。这个自定义的 <literal>EntityResolver</literal> 能辨认两种不同的 systenId 命名空间："

#. Tag: para
#, no-c-format
msgid "a <literal>hibernate namespace</literal> is recognized whenever the resolver encounters a systemId starting with <literal>http://hibernate.sourceforge.net/</literal>. The resolver attempts to resolve these entities via the classloader which loaded the Hibernate classes."
msgstr "若 resolver 遇到了一个以 <literal>http://hibernate.sourceforge.net/</literal> 为开头的 systemId，它会辨认出是 <literal>hibernate namespace</literal>，resolver 就试图通过加载 Hibernate 类的 classloader 来查找这些实体。 "

#. Tag: para
#, no-c-format
msgid "a <literal>user namespace</literal> is recognized whenever the resolver encounters a systemId using a <literal>classpath://</literal> URL protocol. The resolver will attempt to resolve these entities via (1) the current thread context classloader and (2) the classloader which loaded the Hibernate classes."
msgstr "若 resolver 遇到了一个使用 <literal>classpath://</literal> URL 协议的 systemId，它会辨认出这是 <literal>user namespace</literal>，resolver 试图通过（1) 当前线程上下文的 classloader 和（2) 加载 Hibernate class 的 classloader 来查找这些实体。"

#. Tag: para
#, no-c-format
msgid "The following is an example of utilizing user namespacing:"
msgstr "下面是一个使用用户命名空间（user namespace）的例子："

#. Tag: para
#, no-c-format
msgid "Where <literal>types.xml</literal> is a resource in the <literal>your.domain</literal> package and contains a custom <link linkend=\"mapping-types-custom\">typedef</link>."
msgstr "这里的 <literal>types.xml</literal> 是 <literal>your.domain</literal> 包中的一个资源，它包含了一个自定义的 <link linkend=\"mapping-types-custom\">typedef</link>。 "

#. Tag: title
#, no-c-format
msgid "Hibernate-mapping"
msgstr "Hibernate-mapping"

#. Tag: para
#, no-c-format
msgid "This element has several optional attributes. The <literal>schema</literal> and <literal>catalog</literal> attributes specify that tables referred to in this mapping belong to the named schema and/or catalog. If they are specified, tablenames will be qualified by the given schema and catalog names. If they are missing, tablenames will be unqualified. The <literal>default-cascade</literal> attribute specifies what cascade style should be assumed for properties and collections that do not specify a <literal>cascade</literal> attribute. By default, the <literal>auto-import</literal> attribute allows you to use unqualified class names in the query language."
msgstr "这个元素包括一些可选的属性。<literal>schema</literal> 和 <literal>catalog</literal> 属性， 指明了这个映射所连接（refer）的表所在的 schema 和/或 catalog 名称。假若指定了这个属性，表名会加上所指定的 schema 和 catalog 的名字扩展为全限定名。假若没有指定，表名就不会使用全限定名。<literal>default-cascade</literal> 指定了未明确注明 <literal>cascade</literal> 属性的 Java 属性和 集合类 Hibernate 会采取什么样的默认级联风格。<literal>auto-import</literal> 属性默认让我们在查询语言中可以使用非全限定名的类名。"

#. Tag: para
#, no-c-format
msgid "<literal>schema</literal> (optional): the name of a database schema."
msgstr "<literal>schema</literal>（可选）：数据库 schema 的名称。"

#. Tag: para
#, no-c-format
msgid "<literal>catalog</literal> (optional): the name of a database catalog."
msgstr "<literal>catalog</literal>（可选）：数据库 catalog 的名称。 "

#. Tag: para
#, no-c-format
msgid "<literal>default-cascade</literal> (optional - defaults to <literal>none</literal>): a default cascade style."
msgstr "<literal>default-cascade</literal>（可选 — 默认为 <literal>none</literal>）：默认的级联风格。 "

#. Tag: para
#, no-c-format
msgid "<literal>default-access</literal> (optional - defaults to <literal>property</literal>): the strategy Hibernate should use for accessing all properties. It can be a custom implementation of <literal>PropertyAccessor</literal>."
msgstr "<literal>default-access</literal>（可选 — 默认为 <literal>property</literal>）：Hibernate 用来访问所有属性的策略。可以通过实现 <literal>PropertyAccessor</literal> 接口自定义。 "

#. Tag: para
#, no-c-format
msgid "<literal>default-lazy</literal> (optional - defaults to <literal>true</literal>): the default value for unspecified <literal>lazy</literal> attributes of class and collection mappings."
msgstr "<literal>default-lazy</literal>（可选 — 默认为 <literal>true</literal>）：指定了未明确注明 <literal>lazy</literal> 属性的 Java 属性和集合类，Hibernate 会采取什么样的默认加载风格。 "

#. Tag: para
#, no-c-format
msgid "<literal>auto-import</literal> (optional - defaults to <literal>true</literal>): specifies whether we can use unqualified class names of classes in this mapping in the query language."
msgstr "<literal>auto-import</literal>（可选 — 默认为 <literal>true</literal>）：指定我们是否可以在查询语言中使用非全限定的类名（仅限于本映射文件中的类）。 "

#. Tag: para
#, no-c-format
msgid "<literal>package</literal> (optional): specifies a package prefix to use for unqualified class names in the mapping document."
msgstr "<literal>package</literal>（可选）：指定一个包前缀，如果在映射文档中没有指定全限定的类名，就使用这个作为包名。 "

#. Tag: para
#, no-c-format
msgid "If you have two persistent classes with the same unqualified name, you should set <literal>auto-import=\"false\"</literal>. An exception will result if you attempt to assign two classes to the same \"imported\" name."
msgstr "假若你有两个持久化类，它们的非全限定名是一样的（就是两个类的名字一样，所在的包不一样 — 译者注），你应该设置 <literal>auto-import=\"false\"</literal>。如果你把一个“导入过”的名字同时对应两个类，Hibernate 会抛出一个异常。"

#. Tag: para
#, no-c-format
msgid "The <literal>hibernate-mapping</literal> element allows you to nest several persistent <literal>&lt;class&gt;</literal> mappings, as shown above. It is, however, good practice (and expected by some tools) to map only a single persistent class, or a single class hierarchy, in one mapping file and name it after the persistent superclass. For example, <literal>Cat.hbm.xml</literal>, <literal>Dog.hbm.xml</literal>, or if using inheritance, <literal>Animal.hbm.xml</literal>."
msgstr "注意 <literal>hibernate-mapping</literal> 元素允许你嵌套多个如上所示的 <literal>&lt;class&gt;</literal> 映射。但是最好的做法（也许一些工具需要的）是一个持久化类（或一个类的继承层次）对应一个映射文件，并以持久化的超类名称命名，例如：<literal>Cat.hbm.xml</literal>、<literal>Dog.hbm.xml</literal>，或者如果使用继承，<literal>Animal.hbm.xml</literal>。"

#. Tag: title
#, no-c-format
msgid "Class"
msgstr "类"

#. Tag: para
#, no-c-format
msgid "You can declare a persistent class using the <literal>class</literal> element. For example:"
msgstr "你可以使用 <literal>class</literal> 元素来定义一个持久化类。例如："

#. Tag: para
#, no-c-format
msgid "<literal>name</literal> (optional): the fully qualified Java class name of the persistent class or interface. If this attribute is missing, it is assumed that the mapping is for a non-POJO entity."
msgstr "<literal>name</literal>（可选）：持久化类（或者接口）的 Java 全限定名。 如果这个属性不存在，Hibernate 将假定这是一个非 POJO 的实体映射。 "

#. Tag: para
#, no-c-format
msgid "<literal>table</literal> (optional - defaults to the unqualified class name): the name of its database table."
msgstr "<literal>table</literal>（可选 — 默认是类的非全限定名）：对应的数据库表名。 "

#. Tag: para
#, no-c-format
msgid "<literal>discriminator-value</literal> (optional - defaults to the class name): a value that distinguishes individual subclasses that is used for polymorphic behavior. Acceptable values include <literal>null</literal> and <literal>not null</literal>."
msgstr "<literal>discriminator-value</literal>（可选 — 默认和类名一样）：一个用于区分不同的子类的值，在多态行为时使用。它可以接受的值包括 <literal>null</literal> 和 <literal>not null</literal>。 "

#. Tag: para
#, no-c-format
msgid "<literal>mutable</literal> (optional - defaults to <literal>true</literal>): specifies that instances of the class are (not) mutable."
msgstr "<literal>mutable</literal>（可选，默认值为 <literal>true</literal>）：表明该类的实例是可变的或者不可变的。 "

#. Tag: para
#, no-c-format
msgid "<literal>schema</literal> (optional): overrides the schema name specified by the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr "<literal>schema</literal>（可选）：覆盖在根 <literal>&lt;hibernate-mapping&gt;</literal> 元素中指定的 schema 名字。 "

#. Tag: para
#, no-c-format
msgid "<literal>catalog</literal> (optional): overrides the catalog name specified by the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr "<literal>catalog</literal>（可选）：覆盖在根 <literal>&lt;hibernate-mapping&gt;</literal> 元素中指定的 catalog 名字。 "

#. Tag: para
#, no-c-format
msgid "<literal>proxy</literal> (optional): specifies an interface to use for lazy initializing proxies. You can specify the name of the class itself."
msgstr "<literal>proxy</literal>（可选）：指定一个接口，在延迟装载时作为代理使用。你可以在这里使用该类自己的名字。 "

#. Tag: para
#, no-c-format
msgid "<literal>dynamic-update</literal> (optional - defaults to <literal>false</literal>): specifies that <literal>UPDATE</literal> SQL should be generated at runtime and can contain only those columns whose values have changed."
msgstr "<literal>dynamic-update</literal>（可选，默认为 <literal>false</literal>）：指定用于 <literal>UPDATE</literal> 的 SQL 将会在运行时动态生成，并且只更新那些改变过的字段。 "

#. Tag: para
#, no-c-format
msgid "<literal>dynamic-insert</literal> (optional - defaults to <literal>false</literal>): specifies that <literal>INSERT</literal> SQL should be generated at runtime and contain only the columns whose values are not null."
msgstr "<literal>dynamic-insert</literal>（可选，默认为 <literal>false</literal>）：指定用于 <literal>INSERT</literal> 的 SQL 将会在运行时动态生成，并且只包含那些非空值字段。 "

#. Tag: para
#, no-c-format
msgid "<literal>select-before-update</literal> (optional - defaults to <literal>false</literal>): specifies that Hibernate should <emphasis>never</emphasis> perform an SQL <literal>UPDATE</literal> unless it is certain that an object is actually modified. Only when a transient object has been associated with a new session using <literal>update()</literal>, will Hibernate perform an extra SQL <literal>SELECT</literal> to determine if an <literal>UPDATE</literal> is actually required."
msgstr "<literal>select-before-update</literal>（可选，默认为 <literal>false</literal>）：指定 Hibernate 除非确定对象真正被修改了（如果该值为 true — 译注），否则<emphasis>不会</emphasis>执行 SQL <literal>UPDATE</literal> 操作。在特定场合（实际上，它只在一个瞬时对象（transient object）关联到一个新的 session 中时执行的 update() 中生效），这说明 Hibernate 会在 <literal>UPDATE</literal> 之前执行一次额外的 SQL <literal>SELECT</literal> 操作来决定是否确实需要执行 <literal>UPDATE</literal>。"

#. Tag: para
#, no-c-format
msgid "<literal>polymorphism</literal> (optional - defaults to <literal>implicit</literal>): determines whether implicit or explicit query polymorphism is used."
msgstr "<literal>polymorphism（多态）</literal>（可选，默认值为 <literal>implicit （隐式）</literal>）：界定是隐式还是显式的使用多态查询（这只在 Hibernate 的具体表继承策略中用到 — 译注）。 "

#. Tag: para
#, no-c-format
msgid "<literal>where</literal> (optional): specifies an arbitrary SQL <literal>WHERE</literal> condition to be used when retrieving objects of this class."
msgstr "<literal>where</literal>（可选）指定一个附加的 SQL <literal>WHERE</literal> 条件，在抓取这个类的对象时会一直增加这个条件。 "

#. Tag: para
#, no-c-format
msgid "<literal>persister</literal> (optional): specifies a custom <literal>ClassPersister</literal>."
msgstr "<literal>persister</literal>（可选）：指定一个定制的 <literal>ClassPersister</literal>。 "

#. Tag: para
#, no-c-format
msgid "<literal>batch-size</literal> (optional - defaults to <literal>1</literal>): specifies a \"batch size\" for fetching instances of this class by identifier."
msgstr "<literal>batch-size</literal>（可选,默认是 <literal>1</literal>）指定一个用于 根据标识符（identifier）抓取实例时使用的 \"batch size\"（批次抓取数量）。 "

#. Tag: para
#, no-c-format
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>version</literal>): determines the optimistic locking strategy."
msgstr "<literal>optimistic-lock（乐观锁定）</literal>（可选，默认是 <literal>version</literal>）：决定乐观锁定的策略。 "

#. Tag: para
#, no-c-format
msgid "<literal>lazy</literal> (optional): lazy fetching can be disabled by setting <literal>lazy=\"false\"</literal>."
msgstr "<literal>lazy</literal>（可选）：通过设置 <literal>lazy=\"false\"</literal>，所有的延迟加载（Lazy fetching）功能将被全部禁用（disabled）。"

#. Tag: para
#, no-c-format
msgid "<literal>entity-name</literal> (optional - defaults to the class name): Hibernate3 allows a class to be mapped multiple times, potentially to different tables. It also allows entity mappings that are represented by Maps or XML at the Java level. In these cases, you should provide an explicit arbitrary name for the entity. See <xref linkend=\"persistent-classes-dynamicmodels\" /> and <xref linkend=\"xml\" /> for more information."
msgstr "<literal>entity-name</literal>（可选，默认为类名）：Hibernate3 允许一个类进行多次映射（前提是映射到不同的表），并且允许使用 Maps 或 XML 代替 Java 层次的实体映射（也就是实现动态领域模型，不用写持久化类－译注）。更多信息请看 <xref linkend=\"persistent-classes-dynamicmodels\"/> 和 <xref linkend=\"xml\"/>。 "

#. Tag: para
#, no-c-format
msgid "<literal>check</literal> (optional): an SQL expression used to generate a multi-row <emphasis>check</emphasis> constraint for automatic schema generation."
msgstr "<literal>check</literal>（可选）：这是一个 SQL 表达式， 用于为自动生成的 schema 添加多行（multi-row）约束<emphasis>检查</emphasis>。 "

#. Tag: para
#, no-c-format
msgid "<literal>rowid</literal> (optional): Hibernate can use ROWIDs on databases. On Oracle, for example, Hibernate can use the <literal>rowid</literal> extra column for fast updates once this option has been set to <literal>rowid</literal>. A ROWID is an implementation detail and represents the physical location of a stored tuple."
msgstr "<literal>rowid</literal>（可选）：Hibernate 可以使用数据库支持的所谓的 ROWIDs，例如：Oracle 数据库，如果你设置这个可选的 <literal>rowid</literal>，Hibernate 可以使用额外的字段 <literal>rowid</literal> 实现快速更新。ROWID 是这个功能实现的重点，它代表了一个存储元组（tuple）的物理位置。 "

#. Tag: para
#, no-c-format
msgid "<literal>subselect</literal> (optional): maps an immutable and read-only entity to a database subselect. This is useful if you want to have a view instead of a base table. See below for more information."
msgstr "<literal>subselect</literal>（可选）：它将一个不可变（immutable）并且只读的实体映射到一个数据库的子查询中。当你想用视图代替一张基本表的时候，这是有用的，但最好不要这样做。更多的介绍请看下面内容。 "

#. Tag: para
#, no-c-format
msgid "<literal>abstract</literal> (optional): is used to mark abstract superclasses in <literal>&lt;union-subclass&gt;</literal> hierarchies."
msgstr "<literal>abstract</literal>（可选）：用于在 <literal>&lt;union-subclass&gt;</literal> 的层次结构（hierarchies）中标识抽象超类。"

#. Tag: para
#, no-c-format
msgid "It is acceptable for the named persistent class to be an interface. You can declare implementing classes of that interface using the <literal>&lt;subclass&gt;</literal> element. You can persist any <emphasis>static</emphasis> inner class. Specify the class name using the standard form i.e. <literal>e.g.Foo$Bar</literal>."
msgstr "若指明的持久化类实际上是一个接口，这也是完全可以接受的。之后你可以用元素 <literal>&lt;subclass&gt;</literal> 来指定该接口的实际实现类。你可以持久化任何 <emphasis>static</emphasis>（静态的）内部类。你应该使用标准的类名格式来指定类名，比如：<literal>Foo$Bar</literal>。"

#. Tag: para
#, no-c-format
msgid "Immutable classes, <literal>mutable=\"false\"</literal>, cannot be updated or deleted by the application. This allows Hibernate to make some minor performance optimizations."
msgstr "不可变类，<literal>mutable=\"false\"</literal> 不可以被应用程序更新或者删除。这允许 Hibernate 实现一些小小的性能优化。"

#. Tag: para
#, no-c-format
msgid "The optional <literal>proxy</literal> attribute enables lazy initialization of persistent instances of the class. Hibernate will initially return CGLIB proxies that implement the named interface. The persistent object will load when a method of the proxy is invoked. See \"Initializing collections and proxies\" below."
msgstr "可选的 <literal>proxy</literal> 属性允许延迟加载类的持久化实例。Hibernate 开始会返回实现了这个命名接口的 CGLIB 代理。当代理的某个方法被实际调用的时候，真实的持久化对象才会被装载。参见下面的“用于延迟装载的代理”。 "

#. Tag: para
#, no-c-format
msgid "<emphasis>Implicit</emphasis> polymorphism means that instances of the class will be returned by a query that names any superclass or implemented interface or class, and that instances of any subclass of the class will be returned by a query that names the class itself. <emphasis>Explicit</emphasis> polymorphism means that class instances will be returned only by queries that explicitly name that class. Queries that name the class will return only instances of subclasses mapped inside this <literal>&lt;class&gt;</literal> declaration as a <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal>. For most purposes, the default <literal>polymorphism=\"implicit\"</literal> is appropriate. Explicit polymorphism is useful when two different classes are mapped to the same table This allows a \"lightweight\" class that contains a subset of the table columns."
msgstr "<emphasis>Implicit</emphasis>（隐式）的多态是指，如果查询时给出的是任何超类、该类实现的接口或者该类的名字，都会返回这个类的实例；如果查询中给出的是子类的名字，则会返回子类的实例。<emphasis>Explicit</emphasis>（显式）的多态是指，只有在查询时给出明确的该类名字时才会返回这个类的实例； 同时只有在这个 <literal>&lt;class&gt;</literal> 的定义中作为 <literal>&lt;subclass&gt;</literal> 或者 <literal>&lt;joined-subclass&gt;</literal> 出现的子类，才会可能返回。在大多数情况下，默认的 <literal>polymorphism=\"implicit\"</literal> 都是合适的。显式的多态在有两个不同的类映射到同一个表的时候很有用。（允许一个“轻量级”的类，只包含部分表字段）。 "

#. Tag: para
#, no-c-format
msgid "The <literal>persister</literal> attribute lets you customize the persistence strategy used for the class. You can, for example, specify your own subclass of <literal>org.hibernate.persister.EntityPersister</literal>, or you can even provide a completely new implementation of the interface <literal>org.hibernate.persister.ClassPersister</literal> that implements, for example, persistence via stored procedure calls, serialization to flat files or LDAP. See <literal>org.hibernate.test.CustomPersister</literal> for a simple example of \"persistence\" to a <literal>Hashtable</literal>."
msgstr "<literal>persister</literal> 属性可以让你定制这个类使用的持久化策略。你可以指定你自己实现 <literal>org.hibernate.persister.EntityPersister</literal> 的子类，你甚至可以完全从头开始编写一个 <literal>org.hibernate.persister.ClassPersister</literal> 接口的实现，比如是用储存过程调用、序列化到文件或者 LDAP 数据库来实现。参阅 <literal>org.hibernate.test.CustomPersister</literal>，这是持久化到 <literal>Hashtable</literal> 的一个简单例子。 "

#. Tag: para
#, no-c-format
msgid "The <literal>dynamic-update</literal> and <literal>dynamic-insert</literal> settings are not inherited by subclasses, so they can also be specified on the <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal> elements. Although these settings can increase performance in some cases, they can actually decrease performance in others."
msgstr "请注意 <literal>dynamic-update</literal> 和 <literal>dynamic-insert</literal> 的设置并不会继承到子类，所以在 <literal>&lt;subclass&gt;</literal> 或者 <literal>&lt;joined-subclass&gt;</literal> 元素中可能需要再次设置。这些设置在某些情况下能够提高效率，而其他情况下则反而可能降低性能。"

#. Tag: para
#, no-c-format
msgid "Use of <literal>select-before-update</literal> will usually decrease performance. It is useful to prevent a database update trigger being called unnecessarily if you reattach a graph of detached instances to a <literal>Session</literal>."
msgstr "使用 <literal>select-before-update</literal> 通常会降低性能。如果你重新连接一个脱管（detached）对象实例 到一个 <literal>Session</literal> 中时，它可以防止数据库不必要的触发 update。这就很有用了。"

#. Tag: para
#, no-c-format
msgid "If you enable <literal>dynamic-update</literal>, you will have a choice of optimistic locking strategies:"
msgstr "如果你打开了<literal>dynamic-update</literal>，你可以选择几种乐观锁定的策略："

#. Tag: para
#, no-c-format
msgid "<literal>version</literal>: check the version/timestamp columns"
msgstr "<literal>version（版本检查）</literal>：检查 version/timestamp 字段"

#. Tag: para
#, no-c-format
msgid "<literal>all</literal>: check all columns"
msgstr "<literal>all（全部）</literal>：检查全部字段"

#. Tag: para
#, no-c-format
msgid "<literal>dirty</literal>: check the changed columns, allowing some concurrent updates"
msgstr "<literal>dirty（脏检查）</literal>：只检察修改过的字段，允许某些并行更新"

#. Tag: para
#, no-c-format
msgid "<literal>none</literal>: do not use optimistic locking"
msgstr "<literal>none（不检查）</literal>：不使用乐观锁定"

#. Tag: para
#, no-c-format
msgid "It is <emphasis>strongly</emphasis> recommended that you use version/timestamp columns for optimistic locking with Hibernate. This strategy optimizes performance and correctly handles modifications made to detached instances (i.e. when <literal>Session.merge()</literal> is used)."
msgstr "我们<emphasis>强烈</emphasis>建议你在 Hibernate 中使用 version/timestamp 字段来进行乐观锁定。这个选择可以优化性能，且能够处理对脱管实例的修改（例如：在使用 <literal>Session.merge()</literal> 的时候）。"

#. Tag: para
#, no-c-format
msgid "There is no difference between a view and a base table for a Hibernate mapping. This is transparent at the database level, although some DBMS do not support views properly, especially with updates. Sometimes you want to use a view, but you cannot create one in the database (i.e. with a legacy schema). In this case, you can map an immutable and read-only entity to a given SQL subselect expression:"
msgstr "对 Hibernate 映射来说视图和表是没有区别的，这是因为它们在数据层都是透明的（ 注意：一些数据库不支持视图属性，特别是更新的时候）。有时你想使用视图，但却不能在数据库中创建它（例如：在遗留的 schema 中）。这样的话，你可以映射一个不可变的（immutable）并且是 只读的实体到一个给定的 SQL 子查询表达式： "

#. Tag: para
#, no-c-format
msgid "Declare the tables to synchronize this entity with, ensuring that auto-flush happens correctly and that queries against the derived entity do not return stale data. The <literal>&lt;subselect&gt;</literal> is available both as an attribute and a nested mapping element."
msgstr "定义这个实体用到的表为同步（synchronize），确保自动刷新（auto-flush）正确执行，并且依赖原实体的查询不会返回过期数据。在属性元素和嵌套映射元素中都可使用 <literal>&lt;subselect&gt;</literal>。"

#. Tag: title
#, no-c-format
msgid "id"
msgstr "id"

#. Tag: para
#, no-c-format
msgid "Mapped classes <emphasis>must</emphasis> declare the primary key column of the database table. Most classes will also have a JavaBeans-style property holding the unique identifier of an instance. The <literal>&lt;id&gt;</literal> element defines the mapping from that property to the primary key column."
msgstr "被映射的类<emphasis>必须</emphasis>定义对应数据库表主键字段。大多数类有一个 JavaBeans 风格的属性， 为每一个实例包含唯一的标识。<literal>&lt;id&gt;</literal> 元素定义了该属性到数据库表主键字段的映射。"

#. Tag: para
#, no-c-format
msgid "<literal>name</literal> (optional): the name of the identifier property."
msgstr "<literal>name</literal>（可选）：标识属性的名字。 "

#. Tag: para
#, no-c-format
msgid "<literal>type</literal> (optional): a name that indicates the Hibernate type."
msgstr "<literal>type</literal>（可选）：一个 Hibernate 类型的名字。"

#. Tag: para
#, no-c-format
msgid "<literal>column</literal> (optional - defaults to the property name): the name of the primary key column."
msgstr "<literal>column</literal>（可选 — 默认为属性名）：主键字段的名字。 "

#. Tag: para
#, no-c-format
msgid "<literal>unsaved-value</literal> (optional - defaults to a \"sensible\" value): an identifier property value that indicates an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session."
msgstr "<literal>unsaved-value</literal>（可选 — 默认为一个切合实际（sensible）的值）：一个特定的标识属性值，用来标志该实例是刚刚创建的，尚未保存。这可以把这种实例和从以前的 session 中装载过（可能又做过修改--译者注）但未再次持久化的实例区分开来。 "

#. Tag: para
#, no-c-format
msgid "<literal>access</literal> (optional - defaults to <literal>property</literal>): the strategy Hibernate should use for accessing the property value."
msgstr "<literal>access</literal>（可选 — 默认为 <literal>property</literal>）：Hibernate 用来访问属性值的策略。 "

#. Tag: para
#, no-c-format
msgid "If the <literal>name</literal> attribute is missing, it is assumed that the class has no identifier property."
msgstr "如果 <literal>name</literal> 属性不存在，会认为这个类没有标识属性。"

#. Tag: para
#, no-c-format
msgid "The <literal>unsaved-value</literal> attribute is almost never needed in Hibernate3."
msgstr "<literal>unsaved-value</literal> 属性在 Hibernate3 中几乎不再需要。"

#. Tag: para
#, no-c-format
msgid "There is an alternative <literal>&lt;composite-id&gt;</literal> declaration that allows access to legacy data with composite keys. Its use is strongly discouraged for anything else."
msgstr "还有一个另外的 <literal>&lt;composite-id&gt;</literal> 定义可以访问旧式的多主键数据。我们非常不鼓励使用这种方式。"

#. Tag: title
#, no-c-format
msgid "Generator"
msgstr "Generator"

#. Tag: para
#, no-c-format
msgid "The optional <literal>&lt;generator&gt;</literal> child element names a Java class used to generate unique identifiers for instances of the persistent class. If any parameters are required to configure or initialize the generator instance, they are passed using the <literal>&lt;param&gt;</literal> element."
msgstr "可选的 <literal>&lt;generator&gt;</literal> 子元素是一个 Java 类的名字，用来为该持久化类的实例生成唯一的标识。如果这个生成器实例需要某些配置值或者初始化参数，用 <literal>&lt;param&gt;</literal> 元素来传递。"

#. Tag: para
#, no-c-format
msgid "All generators implement the interface <literal>org.hibernate.id.IdentifierGenerator</literal>. This is a very simple interface. Some applications can choose to provide their own specialized implementations, however, Hibernate provides a range of built-in implementations. The shortcut names for the built-in generators are as follows:"
msgstr "所有的生成器都实现 <literal>org.hibernate.id.IdentifierGenerator</literal> 接口。这是一个非常简单的接口；某些应用程序可以选择提供他们自己特定的实现。当然，Hibernate 提供了很多内置的实现。下面是一些内置生成器的快捷名字：  "

#. Tag: term
#, no-c-format
msgid "<literal>increment</literal>"
msgstr "<literal>increment</literal>"

#. Tag: para
#, no-c-format
msgid "generates identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal> that are unique only when no other process is inserting data into the same table. <emphasis>Do not use in a cluster.</emphasis>"
msgstr "用于为 <literal>long</literal>, <literal>short</literal> 或者 <literal>int</literal> 类型生成 唯一标识。只有在没有其他进程往同一张表中插入数据时才能使用。<emphasis>在集群下不要使用。</emphasis>"

#. Tag: term
#, no-c-format
msgid "<literal>identity</literal>"
msgstr "<literal>identity</literal>"

#. Tag: para
#, no-c-format
msgid "supports identity columns in DB2, MySQL, MS SQL Server, Sybase and HypersonicSQL. The returned identifier is of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>."
msgstr "对 DB2，MySQL，MS SQL Server，Sybase 和 HypersonicSQL 的内置标识字段提供支持。返回的标识符是 <literal>long</literal>，<literal>short</literal> 或者 <literal>int</literal> 类型的。"

#. Tag: term
#, no-c-format
msgid "<literal>sequence</literal>"
msgstr "<literal>sequence</literal>"

#. Tag: para
#, no-c-format
msgid "uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator in Interbase. The returned identifier is of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>"
msgstr "在 DB2，PostgreSQL，Oracle，SAP DB，McKoi 中使用序列（sequence）， 而在 Interbase 中使用生成器（generator）。返回的标识符是 <literal>long</literal>，<literal>short</literal> 或者 <literal>int</literal> 类型的。"

#. Tag: term
#, no-c-format
msgid "<literal>hilo</literal>"
msgstr "<literal>hilo</literal>"

#. Tag: para
#, no-c-format
msgid "uses a hi/lo algorithm to efficiently generate identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>, given a table and column (by default <literal>hibernate_unique_key</literal> and <literal>next_hi</literal> respectively) as a source of hi values. The hi/lo algorithm generates identifiers that are unique only for a particular database."
msgstr "使用一个高/低位算法高效的生成 <literal>long</literal>，<literal>short</literal> 或者 <literal>int</literal> 类型的标识符。给定一个表和字段（默认分别是 <literal>hibernate_unique_key</literal> 和 <literal>next_hi</literal>）作为高位值的来源。高/低位算法生成的标识符只在一个特定的数据库中是唯一的。"

#. Tag: term
#, no-c-format
msgid "<literal>seqhilo</literal>"
msgstr "<literal>seqhilo</literal>"

#. Tag: para
#, no-c-format
msgid "uses a hi/lo algorithm to efficiently generate identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>, given a named database sequence."
msgstr "使用一个高/低位算法来高效的生成 <literal>long</literal>，<literal>short</literal> 或者 <literal>int</literal> 类型的标识符，给定一个数据库序列（sequence)的名字。"

#. Tag: term
#, no-c-format
msgid "<literal>uuid</literal>"
msgstr "<literal>uuid</literal>"

#. Tag: para
#, no-c-format
msgid "uses a 128-bit UUID algorithm to generate identifiers of type string that are unique within a network (the IP address is used). The UUID is encoded as a string of 32 hexadecimal digits in length."
msgstr "用一个 128-bit 的 UUID 算法生成字符串类型的标识符，这在一个网络中是唯一的（使用了 IP 地址）。UUID 被编码为一个 32 位 16 进制数字的字符串。 "

#. Tag: term
#, no-c-format
msgid "<literal>guid</literal>"
msgstr "<literal>guid</literal>"

#. Tag: para
#, no-c-format
msgid "uses a database-generated GUID string on MS SQL Server and MySQL."
msgstr "在 MS SQL Server 和 MySQL 中使用数据库生成的 GUID 字符串。"

#. Tag: term
#, no-c-format
msgid "<literal>native</literal>"
msgstr "<literal>native</literal>"

#. Tag: para
#, no-c-format
msgid "selects <literal>identity</literal>, <literal>sequence</literal> or <literal>hilo</literal> depending upon the capabilities of the underlying database."
msgstr "根据底层数据库的能力选择 <literal>identity</literal>、<literal>sequence</literal> 或者 <literal>hilo</literal> 中的一个。"

#. Tag: term
#, no-c-format
msgid "<literal>assigned</literal>"
msgstr "<literal>assigned</literal>"

#. Tag: para
#, no-c-format
msgid "lets the application assign an identifier to the object before <literal>save()</literal> is called. This is the default strategy if no <literal>&lt;generator&gt;</literal> element is specified."
msgstr "让应用程序在调用 <literal>save()</literal> 之前为对象分配一个标识符。这是 <literal>&lt;generator&gt;</literal> 元素没有指定时的默认生成策略。"

#. Tag: term
#, no-c-format
msgid "<literal>select</literal>"
msgstr "<literal>select</literal>"

#. Tag: para
#, no-c-format
msgid "retrieves a primary key, assigned by a database trigger, by selecting the row by some unique key and retrieving the primary key value."
msgstr "通过数据库触发器选择一些唯一主键的行并返回主键值来分配一个主键。 "

#. Tag: term
#, no-c-format
msgid "<literal>foreign</literal>"
msgstr "<literal>foreign</literal>"

#. Tag: para
#, no-c-format
msgid "uses the identifier of another associated object. It is usually used in conjunction with a <literal>&lt;one-to-one&gt;</literal> primary key association."
msgstr "使用另外一个相关联的对象的标识符。它通常和 <literal>&lt;one-to-one&gt;</literal> 联合起来使用。"

#. Tag: term
#, no-c-format
msgid "<literal>sequence-identity</literal>"
msgstr "<literal>sequence-identity</literal>"

#. Tag: para
#, no-c-format
msgid "a specialized sequence generation strategy that utilizes a database sequence for the actual value generation, but combines this with JDBC3 getGeneratedKeys to return the generated identifier value as part of the insert statement execution. This strategy is only supported on Oracle 10g drivers targeted for JDK 1.4. Comments on these insert statements are disabled due to a bug in the Oracle drivers."
msgstr "一种特别的序列生成策略，它使用数据库序列来生成实际值，但将它和 JDBC3 的 getGeneratedKeys 结合在一起，使得在插入语句执行的时候就返回生成的值。目前为止只有面向 JDK 1.4 的 Oracle 10g 驱动支持这一策略。由于 Oracle 驱动程序的一个 bug，这些插入语句的注释被关闭了。"

#. Tag: title
#, no-c-format
msgid "Hi/lo algorithm"
msgstr "高/低位算法（Hi/Lo Algorithm）"

#. Tag: para
#, no-c-format
msgid "The <literal>hilo</literal> and <literal>seqhilo</literal> generators provide two alternate implementations of the hi/lo algorithm. The first implementation requires a \"special\" database table to hold the next available \"hi\" value. Where supported, the second uses an Oracle-style sequence."
msgstr "<literal>hilo</literal> 和 <literal>seqhilo</literal> 生成器给出了两种 hi/lo 算法的实现， 这是一种很令人满意的标识符生成算法。第一种实现需要一个“特殊”的数据库表来保存下一个可用的“hi”值。 第二种实现使用一个 Oracle 风格的序列（在被支持的情况下）。 "

#. Tag: para
#, no-c-format
msgid "Unfortunately, you cannot use <literal>hilo</literal> when supplying your own <literal>Connection</literal> to Hibernate. When Hibernate uses an application server datasource to obtain connections enlisted with JTA, you must configure the <literal>hibernate.transaction.manager_lookup_class</literal>."
msgstr "可惜的是，你在为 Hibernate 自行提供 <literal>Connection</literal> 时无法使用 <literal>hilo</literal>。 当 Hibernate 使用 JTA 获取应用服务器的数据源连接时，你必须正确地配置 <literal>hibernate.transaction.manager_lookup_class</literal>。"

#. Tag: title
#, no-c-format
msgid "UUID algorithm"
msgstr "UUID 算法（UUID Algorithm ）"

#. Tag: para
#, no-c-format
msgid "The UUID contains: IP address, startup time of the JVM that is accurate to a quarter second, system time and a counter value that is unique within the JVM. It is not possible to obtain a MAC address or memory address from Java code, so this is the best option without using JNI."
msgstr "UUID 包含：IP 地址、JVM 的启动时间（精确到 1/4 秒）、系统时间和一个计数器值（在 JVM 中唯一）。 在 Java 代码中不可能获得 MAC 地址或者内存地址，所以这已经是我们在不使用 JNI 的前提下的能做的最好实现了。"

#. Tag: title
#, no-c-format
msgid "Identity columns and sequences"
msgstr "标识字段和序列（Identity columns and Sequences）"

#. Tag: para
#, no-c-format
msgid "For databases that support identity columns (DB2, MySQL, Sybase, MS SQL), you can use <literal>identity</literal> key generation. For databases that support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you can use <literal>sequence</literal> style key generation. Both of these strategies require two SQL queries to insert a new object. For example:"
msgstr "对于内部支持标识字段的数据库（DB2、MySQL、Sybase 和 MS SQL），你可以使用 <literal>identity</literal> 关键字生成。对于内部支持序列的数据库（DB2、Oracle、PostgreSQL、Interbase、McKoi 和 SAP DB），你可以使用 <literal>sequence</literal> 风格的关键字生成。这两种方式对于插入一个新的对象都需要两次 SQL 查询。例如："

#. Tag: para
#, no-c-format
msgid "For cross-platform development, the <literal>native</literal> strategy will, depending on the capabilities of the underlying database, choose from the <literal>identity</literal>, <literal>sequence</literal> and <literal>hilo</literal> strategies."
msgstr "对于跨平台开发，<literal>native</literal> 策略会从 <literal>identity</literal>、<literal>sequence</literal> 和 <literal>hilo</literal> 中进行选择，选择哪一个，这取决于底层数据库的支持能力。"

#. Tag: title
#, no-c-format
msgid "Assigned identifiers"
msgstr "程序分配的标识符（Assigned Identifiers）"

#. Tag: para
#, no-c-format
msgid "If you want the application to assign identifiers, as opposed to having Hibernate generate them, you can use the <literal>assigned</literal> generator. This special generator uses the identifier value already assigned to the object's identifier property. The generator is used when the primary key is a natural key instead of a surrogate key. This is the default behavior if you do not specify a <literal>&lt;generator&gt;</literal> element."
msgstr "如果你需要应用程序分配一个标示符（而非 Hibernate 来生成），你可以使用 <literal>assigned</literal> 生成器。这种特殊的生成器会使用已经分配给对象的标识符属性的标识符值。 这个生成器使用一个自然键（natural key，有商业意义的列－译注）作为主键，而不是使用一个代理键（ surrogate key，没有商业意义的列－译注）。这是没有指定 <literal>&lt;generator&gt;</literal> 元素时的默认行为。"

#. Tag: para
#, no-c-format
msgid "The <literal>assigned</literal> generator makes Hibernate use <literal>unsaved-value=\"undefined\"</literal>. This forces Hibernate to go to the database to determine if an instance is transient or detached, unless there is a version or timestamp property, or you define <literal>Interceptor.isUnsaved()</literal>."
msgstr "当选择 <literal>assigned</literal> 生成器时，除非有一个 version 或 timestamp 属性，或者你定义了 <literal>Interceptor.isUnsaved()</literal>，否则需要让 Hiberante 使用 <literal>unsaved-value=\"undefined\"</literal>，强制 Hibernatet 查询数据库来确定一个实例是瞬时的（transient） 还是脱管的（detached）。"

#. Tag: title
#, no-c-format
msgid "Primary keys assigned by triggers"
msgstr "触发器实现的主键生成器（Primary keys assigned by triggers）"

#. Tag: para
#, no-c-format
msgid "Hibernate does not generate DDL with triggers. It is for legacy schemas only."
msgstr "仅仅用于遗留的 schema 中（Hibernate 不能用触发器生成 DDL）。"

#. Tag: para
#, no-c-format
msgid "In the above example, there is a unique valued property named <literal>socialSecurityNumber</literal>. It is defined by the class, as a natural key and a surrogate key named <literal>person_id</literal>, whose value is generated by a trigger."
msgstr "在上面的例子中，类定义了一个命名为 <literal>socialSecurityNumber</literal> 的具有唯一值的属性，它是一个自然键（natural key），命名为 <literal>person_id</literal> 的代理键（surrogate key）的值由触发器生成。"

#. Tag: title
#, no-c-format
msgid "Enhanced identifier generators"
msgstr "增强的标识符生成器"

#. Tag: para
#, no-c-format
msgid "Starting with release 3.2.3, there are 2 new generators which represent a re-thinking of 2 different aspects of identifier generation. The first aspect is database portability; the second is optimization Optimization means that you do not have to query the database for every request for a new identifier value. These two new generators are intended to take the place of some of the named generators described above, starting in 3.3.x. However, they are included in the current releases and can be referenced by FQN."
msgstr "从 3.2.3 版本开始，有两个代表不同标识符生成概念的新的生成器。第一个概念是数据库移植性；第二个是优化。优化表示你不需对每个新标识符的请求都查询数据库。从 3.3.x 开始，这两个新的生成器都是用来取代上面所述的生成器的。然而，它们也包括在当前版本里且可以由 FQN 进行引用。"

#. Tag: para
#, no-c-format
msgid "The first of these new generators is <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</literal> which is intended, firstly, as a replacement for the <literal>sequence</literal> generator and, secondly, as a better portability generator than <literal>native</literal>. This is because <literal>native</literal> generally chooses between <literal>identity</literal> and <literal>sequence</literal> which have largely different semantics that can cause subtle issues in applications eyeing portability. <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</literal>, however, achieves portability in a different manner. It chooses between a table or a sequence in the database to store its incrementing values, depending on the capabilities of the dialect being used. The difference between this and <literal>native</literal> is that table-based and sequence-based storage have the same exact semantic. In fact, sequences are exactly what Hibernate tries to emulate with its table-based generators. This generator has a number of configuration parameters:"
msgstr "这些生成器的第一个是 <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</literal>，首先，它是作为 <literal>sequence</literal> 生成器的替代物，其次，它是比 <literal>native</literal> 具有更好移植性的生成器。这是因为 <literal>native</literal> 通常在 <literal>identity</literal> 和 <literal>sequence</literal> 之间选择，它有差别很大的 semantic，在移植时会导致潜在的问题。然而，<literal>org.hibernate.id.enhanced.SequenceStyleGenerator</literal> 以不同的方式实现移植性。它根据所使用的方言的能力，在数据库表或序列之间选择以存储其增量。这和 <literal>native</literal> 的区别是基于表或序列的存储具有恰好相同的 semantic。实际上，序列就是 Hibernate 试图用基于表的生成器来模拟的。这个生成器有如下的配置参数："

#. Tag: para
#, no-c-format
msgid "<literal>sequence_name</literal> (optional, defaults to <literal>hibernate_sequence</literal>): the name of the sequence or table to be used."
msgstr "<literal>sequence_name</literal>（可选 — 默认为 <literal>hibernate_sequence</literal>）：序列或表的名字"

#. Tag: para
#, no-c-format
msgid "<literal>initial_value</literal> (optional, defaults to <literal>1</literal>): the initial value to be retrieved from the sequence/table. In sequence creation terms, this is analogous to the clause typically named \"STARTS WITH\"."
msgstr "<literal>initial_value</literal>（可选，默认为 <literal>1</literal>）：从序列/表里获取的初始值。按照序列创建的术语，这等同于子句 \"STARTS WITH\"。"

#. Tag: para
#, no-c-format
msgid "<literal>increment_size</literal> (optional - defaults to <literal>1</literal>): the value by which subsequent calls to the sequence/table should differ. In sequence creation terms, this is analogous to the clause typically named \"INCREMENT BY\"."
msgstr "<literal>increment_size</literal>（可选 - 缺省为 <literal>1</literal>）：对序列/表的调用应该区分的值。按照序列创建的术语，这等同于子句 \"INCREMENT BY\"。"

#. Tag: para
#, no-c-format
msgid "<literal>force_table_use</literal> (optional - defaults to <literal>false</literal>): should we force the use of a table as the backing structure even though the dialect might support sequence?"
msgstr "<literal>force_table_use</literal>（可选 - 缺省为 <literal>false</literal>）：即使方言可能支持序列，是否也应该强制把表用作后台结构。"

#. Tag: para
#, no-c-format
msgid "<literal>value_column</literal> (optional - defaults to <literal>next_val</literal>): only relevant for table structures, it is the name of the column on the table which is used to hold the value."
msgstr "<literal>value_column</literal>（可选 - 缺省为 <literal>next_val</literal>）：只和表结构相关，它是用于保存值的字段的名称。"

#. Tag: para
#, no-c-format
msgid "<literal>optimizer</literal> (optional - defaults to <literal>none</literal>): See <xref linkend=\"mapping-declaration-id-enhanced-optimizers\" />"
msgstr "<literal>optimizer</literal>（可选 — 默认是<literal>none</literal>）：请参考 <xref linkend=\"mapping-declaration-id-enhanced-optimizers\" />。"

#. Tag: para
#, no-c-format
msgid "The second of these new generators is <literal>org.hibernate.id.enhanced.TableGenerator</literal>, which is intended, firstly, as a replacement for the <literal>table</literal> generator, even though it actually functions much more like <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal>, and secondly, as a re-implementation of <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal> that utilizes the notion of pluggable optimizers. Essentially this generator defines a table capable of holding a number of different increment values simultaneously by using multiple distinctly keyed rows. This generator has a number of configuration parameters:"
msgstr "新生成器的第二个是 <literal>org.hibernate.id.enhanced.TableGenerator</literal>，它的目的首先是替代 <literal>table</literal> 生成器，即使它实际上比 <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal> 功能要强得多；其次，作为利用可插拔 optimizer 的 <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal> 的替代品。基本上这个生成器定义了一个可以利用多个不同的键值记录存储大量不同增量值的表。这个生成器有如下的配置参数："

#. Tag: para
#, no-c-format
msgid "<literal>table_name</literal> (optional - defaults to <literal>hibernate_sequences</literal>): the name of the table to be used."
msgstr "<literal>table_name</literal>（可选 — 默认是 <literal>hibernate_sequences</literal>）：所用的表的名称。"

#. Tag: para
#, no-c-format
msgid "<literal>value_column_name</literal> (optional - defaults to <literal>next_val</literal>): the name of the column on the table that is used to hold the value."
msgstr "<literal>value_column_name</literal>（可选 — 默认为 <literal>next_val</literal>）：用于存储这些值的表的字段的名字。"

#. Tag: para
#, no-c-format
msgid "<literal>segment_column_name</literal> (optional - defaults to <literal>sequence_name</literal>): the name of the column on the table that is used to hold the \"segment key\". This is the value which identifies which increment value to use."
msgstr "<literal>segment_column_name</literal>（可选，默认为 <literal>sequence_name</literal>）：用于保存 \"segment key\" 的字段的名称。这是标识使用哪个增量值的值。"

#. Tag: para
#, no-c-format
msgid "<literal>segment_value</literal> (optional - defaults to <literal>default</literal>): The \"segment key\" value for the segment from which we want to pull increment values for this generator."
msgstr "<literal>segment_value</literal>（可选，默认为 <literal>default</literal>）：我们为这个生成器获取增量值的 segment 的 \"segment key\"。"

#. Tag: para
#, no-c-format
msgid "<literal>segment_value_length</literal> (optional - defaults to <literal>255</literal>): Used for schema generation; the column size to create this segment key column."
msgstr "<literal>segment_value_length</literal>（可选 — 默认为 <literal>255</literal>）：用于 schema 生成；创建 Segment Key 字段的字段大小。"

#. Tag: para
#, no-c-format
msgid "<literal>initial_value</literal> (optional - defaults to <literal>1</literal>): The initial value to be retrieved from the table."
msgstr "<literal>initial_value</literal>（可选 — 默认是 <literal>1</literal>）：从表里获取的初始值。"

#. Tag: para
#, no-c-format
msgid "<literal>increment_size</literal> (optional - defaults to <literal>1</literal>): The value by which subsequent calls to the table should differ."
msgstr "<literal>increment_size</literal>（可选 — 默认是 <literal>1</literal>）：对表随后的调用应该区分的值。"

#. Tag: para
#, no-c-format
msgid "<literal>optimizer</literal> (optional - defaults to <literal></literal>): See <xref linkend=\"mapping-declaration-id-enhanced-optimizers\" />"
msgstr "<literal>optimizer</literal>（可选 — 默认是 <literal> </literal>）：请参考 <xref linkend=\"mapping-declaration-id-enhanced-optimizers\" />。"

#. Tag: title
#, no-c-format
msgid "Identifier generator optimization"
msgstr "标识符生成器的优化"

#. Tag: para
#, no-c-format
msgid "For identifier generators that store values in the database, it is inefficient for them to hit the database on each and every call to generate a new identifier value. Instead, you can group a bunch of them in memory and only hit the database when you have exhausted your in-memory value group. This is the role of the pluggable optimizers. Currently only the two enhanced generators (<xref linkend=\"mapping-declaration-id-enhanced\" /> support this operation."
msgstr "对于在数据库里存储值的标识符生成器，生成新标识符时的每次调用都访问数据库是低效的。因此，你可以把它们在内存里分组并只有在快用光内存时才访问数据库。这是可插拔 optimizer 的任务。目前只有两个增强型的生成器支持这个操作（<xref linkend=\"mapping-declaration-id-enhanced\"/>）。 "

#. Tag: para
#, no-c-format
msgid "<literal>none</literal> (generally this is the default if no optimizer was specified): this will not perform any optimizations and hit the database for each and every request."
msgstr "<literal>none</literal>（如果没有指定 optimizer，通常这是缺省配置）：这不会执行任何优化，在每次请求时都访问数据库。"

#. Tag: para
#, no-c-format
msgid "<literal>hilo</literal>: applies a hi/lo algorithm around the database retrieved values. The values from the database for this optimizer are expected to be sequential. The values retrieved from the database structure for this optimizer indicates the \"group number\". The <literal>increment_size</literal> is multiplied by that value in memory to define a group \"hi value\"."
msgstr "<literal>hilo</literal>：对从数据库获取的值应用 hi/lo 算法。用于这个 optimizer 的从数据库获取的值应该是有序的。它们表明“组编号”。<literal>increment_size</literal> 将乘以内存里的值来定义组的“hi 值”。"

#. Tag: para
#, no-c-format
msgid "<literal>pooled</literal>: as with the case of <literal>hilo</literal>, this optimizer attempts to minimize the number of hits to the database. Here, however, we simply store the starting value for the \"next group\" into the database structure rather than a sequential value in combination with an in-memory grouping algorithm. Here, <literal>increment_size</literal> refers to the values coming from the database."
msgstr "<literal>pooled</literal>：和 <literal>hilo</literal> 一样，这个 optimizer 试图最小化对数据库的访问。然而，我们只是简单地把“下一组”的起始值而不是把序列值和分组算法的组合存入到数据库结构里。在这里，<literal>increment_size</literal> 表示数据库里的值。"

#. Tag: title
#, no-c-format
msgid "composite-id"
msgstr "composite-id"

#. Tag: para
#, no-c-format
msgid "A table with a composite key can be mapped with multiple properties of the class as identifier properties. The <literal>&lt;composite-id&gt;</literal> element accepts <literal>&lt;key-property&gt;</literal> property mappings and <literal>&lt;key-many-to-one&gt;</literal> mappings as child elements."
msgstr "如果表使用联合主键，你可以映射类的多个属性为标识符属性。<literal>&lt;composite-id&gt;</literal> 元素接受 <literal>&lt;key-property&gt;</literal> 属性映射和 <literal>&lt;key-many-to-one&gt;</literal> 属性映射作为子元素。 "

#. Tag: para
#, no-c-format
msgid "The persistent class <emphasis>must</emphasis> override <literal>equals()</literal> and <literal>hashCode()</literal> to implement composite identifier equality. It must also implement <literal>Serializable</literal>."
msgstr "你的持久化类<emphasis>必须</emphasis>覆盖 <literal>equals()</literal> 和 <literal>hashCode()</literal> 方法，来实现组合的标识符的相等判断。实现 <literal>Serializable</literal> 接口也是必须的。"

#. Tag: para
#, no-c-format
msgid "Unfortunately, this approach means that a persistent object is its own identifier. There is no convenient \"handle\" other than the object itself. You must instantiate an instance of the persistent class itself and populate its identifier properties before you can <literal>load()</literal> the persistent state associated with a composite key. We call this approach an <emphasis>embedded</emphasis> composite identifier, and discourage it for serious applications."
msgstr "不幸的是，这种组合关键字的方法意味着一个持久化类是它自己的标识。除了对象自己之外，没有什么方便的“把手”可用。你必须初始化持久化类的实例，填充它的标识符属性，再 <literal>load()</literal> 组合关键字关联的持久状态。我们把这种方法称为 <emphasis>embedded（嵌入式）</emphasis>的组合标识符，在重要的应用中不鼓励使用这种用法。 "

#. Tag: para
#, no-c-format
msgid "A second approach is what we call a <emphasis>mapped</emphasis> composite identifier, where the identifier properties named inside the <literal>&lt;composite-id&gt;</literal> element are duplicated on both the persistent class and a separate identifier class."
msgstr "第二种方法我们称为 <emphasis>mapped（映射式）</emphasis>组合标识符（mapped composite identifier），<literal>&lt;composite-id&gt;</literal> 元素中列出的标识属性不但在持久化类出现，还形成一个独立的标识符类。"

#. Tag: para
#, no-c-format
msgid "In this example, both the composite identifier class, <literal>MedicareId</literal>, and the entity class itself have properties named <literal>medicareNumber</literal> and <literal>dependent</literal>. The identifier class must override <literal>equals()</literal> and <literal>hashCode()</literal> and implement <literal>Serializable</literal>. The main disadvantage of this approach is code duplication."
msgstr "在这个例子中，组合标识符类 <literal>MedicareId</literal> 和实体类都含有 <literal>medicareNumber</literal> 和 <literal>dependent</literal> 属性。标识符类必须重载 <literal>equals()</literal> 和 <literal>hashCode()</literal> 并且实现 <literal>Serializable</literal> 接口。这种方法的缺点是出现了明显的代码重复。"

#. Tag: para
#, no-c-format
msgid "The following attributes are used to specify a mapped composite identifier:"
msgstr "下面列出的属性是用来指定一个映射式组合标识符的："

#. Tag: para
#, no-c-format
msgid "<literal>mapped</literal> (optional - defaults to <literal>false</literal>): indicates that a mapped composite identifier is used, and that the contained property mappings refer to both the entity class and the composite identifier class."
msgstr "<literal>mapped</literal>（可选，默认为 <literal>false</literal>）：指明使用一个映射式组合标识符，其包含的属性映射同时在实体类和组合标识符类中出现。 "

#. Tag: para
#, no-c-format
msgid "<literal>class</literal> (optional - but required for a mapped composite identifier): the class used as a composite identifier."
msgstr "<literal>class</literal>（可选,但对映射式组合标识符必须指定）：作为组合标识符类使用的类名。"

#. Tag: para
#, no-c-format
msgid "We will describe a third, even more convenient approach, where the composite identifier is implemented as a component class in <xref linkend=\"components-compositeid\" />. The attributes described below apply only to this alternative approach:"
msgstr "在 <xref linkend=\"components-compositeid\"/> 一节中,我们会描述第三种方式,那就是把组合标识符实现为一个组件（component）类,这是更方便的方法。下面的属性仅对第三种方法有效： "

#. Tag: para
#, no-c-format
msgid "<literal>name</literal> (optional - required for this approach): a property of component type that holds the composite identifier. Please see chapter 9 for more information."
msgstr "<literal>name</literal>（可选,但对这种方法而言必须）：包含此组件标识符的组件类型的名字（参阅第 9 章）。"

#. Tag: para
#, no-c-format
msgid "<literal>access</literal> (optional - defaults to <literal>property</literal>): the strategy Hibernate uses for accessing the property value."
msgstr "<literal>access</literal>（可选 — 默认为 <literal>property</literal>）：Hibernate 用来访问属性值的策略。 "

#. Tag: para
#, no-c-format
msgid "<literal>class</literal> (optional - defaults to the property type determined by reflection): the component class used as a composite identifier. Please see the next section for more information."
msgstr "<literal>class</literal>（可选 — 默认会用反射来自动判定属性类型 ）：用来作为组合标识符的组件类的类名（参阅下一节）。 "

#. Tag: para
#, no-c-format
msgid "The third approach, an <emphasis>identifier component</emphasis>, is recommended for almost all applications."
msgstr "第三种方式，被称为 <emphasis>identifier component（标识符组件）</emphasis>是我们对几乎所有应用都推荐使用的方式。 "

#. Tag: title
#, no-c-format
msgid "Discriminator"
msgstr "鉴别器（discriminator） "

#. Tag: para
#, no-c-format
msgid "The <literal>&lt;discriminator&gt;</literal> element is required for polymorphic persistence using the table-per-class-hierarchy mapping strategy. It declares a discriminator column of the table. The discriminator column contains marker values that tell the persistence layer what subclass to instantiate for a particular row. A restricted set of types can be used: <literal>string</literal>, <literal>character</literal>, <literal>integer</literal>, <literal>byte</literal>, <literal>short</literal>, <literal>boolean</literal>, <literal>yes_no</literal>, <literal>true_false</literal>."
msgstr "在\"一棵对象继承树对应一个表\"的策略中，<literal>&lt;discriminator&gt;</literal> 元素是必需的，它定义了表的鉴别器字段。鉴别器字段包含标志值，用于告知持久化层应该为某个特定的行创建哪一个子类的实例。如下这些受到限制的类型可以使用：<literal>string</literal>、<literal>character</literal>、<literal>integer</literal>、<literal>byte</literal>、<literal>short</literal>、<literal>boolean</literal>、<literal>yes_no</literal>、<literal>true_false</literal>。"

#. Tag: para
#, no-c-format
msgid "<literal>column</literal> (optional - defaults to <literal>class</literal>): the name of the discriminator column."
msgstr "<literal>column</literal>（可选 — 默认为 <literal>class</literal>）discriminator 器字段的名字。"

#. Tag: para
#, no-c-format
msgid "<literal>type</literal> (optional - defaults to <literal>string</literal>): a name that indicates the Hibernate type"
msgstr "<literal>type</literal>（可选 — 默认为 <literal>string</literal>）一个 Hibernate 字段类型的名字 "

#. Tag: para
#, no-c-format
msgid "<literal>force</literal> (optional - defaults to <literal>false</literal>): \"forces\" Hibernate to specify the allowed discriminator values, even when retrieving all instances of the root class."
msgstr "<literal>force(强制)</literal>（可选 — 默认为 <literal>false</literal>）\"强制\" Hibernate 指定允许的鉴别器值,即使当取得的所有实例都是根类的。 "

#. Tag: para
#, no-c-format
msgid "<literal>insert</literal> (optional - defaults to <literal>true</literal>): set this to <literal>false</literal> if your discriminator column is also part of a mapped composite identifier. It tells Hibernate not to include the column in SQL <literal>INSERTs</literal>."
msgstr "<literal>insert</literal>（可选 - 默认为<literal>true</literal>）如果你的鉴别器字段也是映射为复合标识（composite identifier）的一部分，则需将这个值设为 <literal>false</literal>。（告诉 Hibernate 在做 SQL <literal>INSERT</literal> 时不包含该列） "

#. Tag: para
#, no-c-format
msgid "<literal>formula</literal> (optional): an arbitrary SQL expression that is executed when a type has to be evaluated. It allows content-based discrimination."
msgstr "<literal>formula</literal>（可选）一个 SQL 表达式，在类型判断（判断是父类还是具体子类 — 译注）时执行。可用于基于内容的鉴别器。 "

#. Tag: para
#, no-c-format
msgid "Actual values of the discriminator column are specified by the <literal>discriminator-value</literal> attribute of the <literal>&lt;class&gt;</literal> and <literal>&lt;subclass&gt;</literal> elements."
msgstr "鉴别器字段的实际值是根据 <literal>&lt;class&gt;</literal> 和 <literal>&lt;subclass&gt;</literal> 元素中的 <literal>discriminator-value</literal> 属性得来的。"

#. Tag: para
#, no-c-format
msgid "The <literal>force</literal> attribute is only useful if the table contains rows with \"extra\" discriminator values that are not mapped to a persistent class. This will not usually be the case."
msgstr "<literal>force</literal> 属性仅仅在这种情况下有用的：表中包含没有被映射到持久化类的附加辨别器值。这种情况不会经常遇到。 "

#. Tag: para
#, no-c-format
msgid "The <literal>formula</literal> attribute allows you to declare an arbitrary SQL expression that will be used to evaluate the type of a row. For example:"
msgstr "使用 <literal>formula</literal> 属性你可以定义一个 SQL 表达式，用来判断一行数据的类型。"

#. Tag: title
#, no-c-format
msgid "Version (optional)"
msgstr "版本（version）（可选） "

#. Tag: para
#, no-c-format
msgid "The <literal>&lt;version&gt;</literal> element is optional and indicates that the table contains versioned data. This is particularly useful if you plan to use <emphasis>long transactions</emphasis>. See below for more information:"
msgstr "<literal>&lt;version&gt;</literal> 元素是可选的，表明表中包含附带版本信息的数据。这在你准备使用<emphasis> 长事务（long transactions）</emphasis>的时候特别有用。下面是更多信息："

#. Tag: para
#, no-c-format
msgid "<literal>column</literal> (optional - defaults to the property name): the name of the column holding the version number."
msgstr "<literal>column</literal>（可选 — 默认为属性名）：指定持有版本号的字段名。 "

#. Tag: para
#, no-c-format
msgid "<literal>name</literal>: the name of a property of the persistent class."
msgstr "<literal>name</literal>：持久化类的属性名。 "

#. Tag: para
#, no-c-format
msgid "<literal>type</literal> (optional - defaults to <literal>integer</literal>): the type of the version number."
msgstr "<literal>type</literal>（可选 — 默认是 <literal>integer</literal>）：版本号的类型。 "

#. Tag: para
#, no-c-format
msgid "<literal>access</literal> (optional - defaults to <literal>property</literal>): the strategy Hibernate uses to access the property value."
msgstr "<literal>access</literal>（可选 — 默认为 <literal>property</literal>）：Hibernate 用来访问属性值的策略。 "

#. Tag: para
#, no-c-format
msgid "<literal>unsaved-value</literal> (optional - defaults to <literal>undefined</literal>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <literal>Undefined</literal> specifies that the identifier property value should be used."
msgstr "<literal>unsaved-value</literal>（可选 — 默认是 <literal>undefined</literal>）：用于标明某个实例时刚刚被实例化的（尚未保存）版本属性值，依靠这个值就可以把这种情况 和已经在先前的 session 中保存或装载的脱管（detached）实例区分开来。（<literal>undefined</literal> 指明应被使用的标识属性值。） "

#. Tag: para
#, no-c-format
msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): specifies that this version property value is generated by the database. See the discussion of <link linkend=\"mapping-generated\">generated properties</link> for more information."
msgstr "<literal>generated</literal>（可选 — 默认是 <literal>never</literal>）：表明此版本属性值是否实际上是由数据库生成的。请参阅  <link linkend=\"mapping-generated\">generated properties</link> 部分的讨论。 "

#. Tag: para
#, no-c-format
msgid "<literal>insert</literal> (optional - defaults to <literal>true</literal>): specifies whether the version column should be included in SQL insert statements. It can be set to <literal>false</literal> if the database column is defined with a default value of <literal>0</literal>."
msgstr "<literal>insert</literal>（可选 — 默认是 <literal>true</literal>）：表明此版本列应该包含在 SQL 插入语句中。只有当数据库字段有默认值 <literal>0</literal> 的时候，才可以设置为 <literal>false</literal>。 "

#. Tag: para
#, no-c-format
msgid "Version numbers can be of Hibernate type <literal>long</literal>, <literal>integer</literal>, <literal>short</literal>, <literal>timestamp</literal> or <literal>calendar</literal>."
msgstr "版本号必须是以下类型：<literal>long</literal>、<literal>integer</literal>、<literal>short</literal>、<literal>timestamp</literal> 或者 <literal>calendar</literal>。"

#. Tag: para
#, no-c-format
msgid "A version or timestamp property should never be null for a detached instance. Hibernate will detect any instance with a null version or timestamp as transient, irrespective of what other <literal>unsaved-value</literal> strategies are specified. <emphasis>Declaring a nullable version or timestamp property is an easy way to avoid problems with transitive reattachment in Hibernate. It is especially useful for people using assigned identifiers or composite keys</emphasis>."
msgstr "一个脱管（detached）实例的 version 或 timestamp 属性不能为空（null），因为 Hibernate 不管  <literal>unsaved-value</literal> 被指定为何种策略，它将任何属性为空的 version 或 timestamp 实例看作为瞬时（transient）实例。 <emphasis>避免 Hibernate 中的传递重附（transitive reattachment）问题的一个简单方法是 定义一个不能为空的 version 或 timestamp 属性，特别是在人们使用程序分配的标识符（assigned identifiers） 或复合主键时非常有用</emphasis>。"

#. Tag: title
#, no-c-format
msgid "Timestamp (optional)"
msgstr "timestamp（可选) "

#. Tag: para
#, no-c-format
msgid "The optional <literal>&lt;timestamp&gt;</literal> element indicates that the table contains timestamped data. This provides an alternative to versioning. Timestamps are a less safe implementation of optimistic locking. However, sometimes the application might use the timestamps in other ways."
msgstr "可选的 <literal>&lt;timestamp&gt;</literal> 元素指明了表中包含时间戳数据。这用来作为版本的替代。时间戳本质上是一种对乐观锁定的一种不是特别安全的实现。当然，有时候应用程序可能在其他方面使用时间戳。 "

#. Tag: para
#, no-c-format
msgid "<literal>column</literal> (optional - defaults to the property name): the name of a column holding the timestamp."
msgstr "<literal>column</literal>（可选 — 默认为属性名）：存有时间戳的字段名。 "

#. Tag: para
#, no-c-format
msgid "<literal>name</literal>: the name of a JavaBeans style property of Java type <literal>Date</literal> or <literal>Timestamp</literal> of the persistent class."
msgstr "<literal>name</literal>：在持久化类中的 JavaBeans 风格的属性名，其 Java 类型是 <literal>Date</literal> 或者 <literal>Timestamp</literal> 的。 "

#. Tag: para
#, no-c-format
msgid "<literal>unsaved-value</literal> (optional - defaults to <literal>null</literal>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <literal>Undefined</literal> specifies that the identifier property value should be used."
msgstr "<literal>unsaved-value</literal>（可选 — 默认是 <literal>null</literal>）：用于标明某个实例时刚刚被实例化的（尚未保存）版本属性值，依靠这个值就可以把这种情况和已经在先前的 session 中保存或装载的脱管（detached）实例区分开来。（<literal>undefined</literal> 指明使用标识属性值进行这种判断。） "

#. Tag: para
#, no-c-format
msgid "<literal>source</literal> (optional - defaults to <literal>vm</literal>): Where should Hibernate retrieve the timestamp value from? From the database, or from the current JVM? Database-based timestamps incur an overhead because Hibernate must hit the database in order to determine the \"next value\". It is safer to use in clustered environments. Not all <literal>Dialects</literal> are known to support the retrieval of the database's current timestamp. Others may also be unsafe for usage in locking due to lack of precision (Oracle 8, for example)."
msgstr "<literal>source</literal>（可选 — 默认是 <literal>vm</literal>）：Hibernate 如何才能获取到时间戳的值呢？从数据库，还是当前 JVM？从数据库获取会带来一些负担，因为 Hibernate 必须访问数据库来获得“下一个值”，但是在集群环境中会更安全些。还要注意，并不是所有的 <literal>Dialect（方言）</literal>都支持获得数据库的当前时间戳的，而支持的数据库中又有一部分因为精度不足，用于锁定是不安全的（例如 Oracle 8）。 "

#. Tag: para
#, no-c-format
msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): specifies that this timestamp property value is actually generated by the database. See the discussion of <link linkend=\"mapping-generated\">generated properties</link> for more information."
msgstr "<literal>generated</literal>（可选 - 默认是 <literal>never</literal>）：指出时间戳值是否实际上是由数据库生成的。请参阅 <link linkend=\"mapping-generated\">generated properties</link> 的讨论。 "

#. Tag: title
#, no-c-format
msgid "Note"
msgstr "注意"

#. Tag: para
#, no-c-format
msgid "<literal>&lt;Timestamp&gt;</literal> is equivalent to <literal>&lt;version type=\"timestamp\"&gt;</literal>. And <literal>&lt;timestamp source=\"db\"&gt;</literal> is equivalent to <literal>&lt;version type=\"dbtimestamp\"&gt;</literal>"
msgstr "注意，<literal>&lt;timestamp&gt;</literal> 和 <literal>&lt;version type=\"timestamp\"&gt;</literal> 是等价的。并且 <literal>&lt;timestamp source=\"db\"&gt;</literal> 和 <literal>&lt;version type=\"dbtimestamp\"&gt;</literal> 是等价的。 "

#. Tag: title
#, no-c-format
msgid "Property"
msgstr "Property"

#. Tag: para
#, no-c-format
msgid "The <literal>&lt;property&gt;</literal> element declares a persistent JavaBean style property of the class."
msgstr "<literal>&lt;property&gt;</literal> 元素为类定义了一个持久化的、JavaBean 风格的属性。 "

#. Tag: para
#, no-c-format
msgid "<literal>name</literal>: the name of the property, with an initial lowercase letter."
msgstr "<literal>name</literal>：属性的名字，以小写字母开头。"

#. Tag: para
#, no-c-format
msgid "<literal>column</literal> (optional - defaults to the property name): the name of the mapped database table column. This can also be specified by nested <literal>&lt;column&gt;</literal> element(s)."
msgstr "<literal>column</literal>（可选 — 默认为属性名字）：对应的数据库字段名。 也可以通过嵌套的 <literal>&lt;column&gt;</literal> 元素指定。 "

#. Tag: para
#, no-c-format
msgid "<literal>update, insert</literal> (optional - defaults to <literal>true</literal>): specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal> allows a pure \"derived\" property whose value is initialized from some other property that maps to the same column(s), or by a trigger or other application."
msgstr "<literal>update, insert</literal>（可选 — 默认为 <literal>true</literal>）： 表明用于　<literal>UPDATE</literal> 和/或 <literal>INSERT</literal> 的 SQL 语句中是否包含这个被映射了的字段。这二者如果都设置为 <literal>false</literal> 则表明这是一个“外源性（derived）”的属性，它的值来源于映射到同一个（或多个） 字段的某些其他属性，或者通过一个 trigger（触发器）或其他程序生成。 "

#. Tag: para
#, no-c-format
msgid "<literal>formula</literal> (optional): an SQL expression that defines the value for a <emphasis>computed</emphasis> property. Computed properties do not have a column mapping of their own."
msgstr "<literal>formula</literal>（可选）：一个 SQL 表达式，定义了这个<emphasis>计算 （computed）</emphasis> 属性的值。计算属性没有和它对应的数据库字段。"

#. Tag: para
#, no-c-format
msgid "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): specifies that this property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation."
msgstr "<literal>lazy</literal>（可选 — 默认为 <literal>false</literal>）：指定 指定实例变量第一次被访问时，这个属性是否延迟抓取（fetched lazily）（ 需要运行时字节码增强）。 "

#. Tag: para
#, no-c-format
msgid "<literal>unique</literal> (optional): enables the DDL generation of a unique constraint for the columns. Also, allow this to be the target of a <literal>property-ref</literal>."
msgstr "<literal>unique</literal>（可选）：使用 DDL 为该字段添加唯一的约束。同样，允许它作为 <literal>property-ref</literal> 引用的目标。 "

#. Tag: para
#, no-c-format
msgid "<literal>not-null</literal> (optional): enables the DDL generation of a nullability constraint for the columns."
msgstr "<literal>not-null</literal>（可选）：使用 DDL 为该字段添加可否为空（nullability）的约束。 "

#. Tag: para
#, no-c-format
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty."
msgstr "<literal>optimistic-lock</literal>（可选 — 默认为 <literal>true</literal>）：指定这个属性在做更新时是否需要获得乐观锁定（optimistic lock）。换句话说，它决定这个属性发生脏数据时版本（version）的值是否增长。 "

#. Tag: para
#, no-c-format
msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): specifies that this property value is actually generated by the database. See the discussion of <link linkend=\"mapping-generated\">generated properties</link> for more information."
msgstr "<literal>generated</literal>（可选 — 默认为 <literal>never</literal>）：表明此属性值是否实际上是由数据库生成的。请参阅 <link linkend=\"mapping-generated\">generated properties</link> 的讨论。 "

#. Tag: para
#, no-c-format
msgid "<emphasis>typename</emphasis> could be:"
msgstr "<emphasis>typename</emphasis> 可以是如下几种："

#. Tag: para
#, no-c-format
msgid "The name of a Hibernate basic type: <literal>integer, string, character, date, timestamp, float, binary, serializable, object, blob</literal> etc."
msgstr "Hibernate 基本类型名（比如：<literal>integer, string, character,date, timestamp, float, binary, serializable, object, blob</literal>）。 "

#. Tag: para
#, no-c-format
msgid "The name of a Java class with a default basic type: <literal>int, float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</literal> etc."
msgstr "一个 Java 类的名字，这个类属于一种默认基础类型（比如：<literal>int, float,char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</literal>)。 "

#. Tag: para
#, no-c-format
msgid "The name of a serializable Java class."
msgstr "一个可以序列化的 Java 类的名字。"

#. Tag: para
#, no-c-format
msgid "The class name of a custom type: <literal>com.illflow.type.MyCustomType</literal> etc."
msgstr "一个自定义类型的类的名字。（比如：<literal>com.illflow.type.MyCustomType</literal>)。 "

#. Tag: para
#, no-c-format
msgid "If you do not specify a type, Hibernate will use reflection upon the named property and guess the correct Hibernate type. Hibernate will attempt to interpret the name of the return class of the property getter using, in order, rules 2, 3, and 4. In certain cases you will need the <literal>type</literal> attribute. For example, to distinguish between <literal>Hibernate.DATE</literal> and <literal>Hibernate.TIMESTAMP</literal>, or to specify a custom type."
msgstr "如果你没有指定类型，Hibernarte 会使用反射来得到这个名字的属性，以此来猜测正确的 Hibernate 类型。Hibernate 会按照规则 2，3，4 的顺序对属性读取器（getter方法）的返回类进行解释。然而，这还不够。 在某些情况下你仍然需要 <literal>type</literal> 属性。（比如，为了区别<literal>Hibernate.DATE</literal> 和<literal>Hibernate.TIMESTAMP</literal>,或者为了指定一个自定义类型。） "

#. Tag: para
#, no-c-format
msgid "The <literal>access</literal> attribute allows you to control how Hibernate accesses the property at runtime. By default, Hibernate will call the property get/set pair. If you specify <literal>access=\"field\"</literal>, Hibernate will bypass the get/set pair and access the field directly using reflection. You can specify your own strategy for property access by naming a class that implements the interface <literal>org.hibernate.property.PropertyAccessor</literal>."
msgstr "<literal>access</literal> 属性用来让你控制 Hibernate 如何在运行时访问属性。在默认情况下，Hibernate 会使用属性的 get/set 方法对（pair）。如果你指明 <literal>access=\"field\"</literal>，Hibernate 会忽略 get/set 方法对，直接使用反射来访问成员变量。你也可以指定你自己的策略，这就需要你自己实现 <literal>org.hibernate.property.PropertyAccessor</literal> 接口，再在 access 中设置你自定义策略类的名字。 "

#. Tag: para
#, no-c-format
msgid "A powerful feature is derived properties. These properties are by definition read-only. The property value is computed at load time. You declare the computation as an SQL expression. This then translates to a <literal>SELECT</literal> clause subquery in the SQL query that loads an instance:"
msgstr "衍生属性（derive propertie）是一个特别强大的特征。这些属性应该定义为只读，属性值在装载时计算生成。 你用一个 SQL 表达式生成计算的结果，它会在这个实例转载时翻译成一个 SQL 查询的 <literal>SELECT</literal> 子查询语句。 "

#. Tag: para
#, no-c-format
msgid "You can reference the entity table by not declaring an alias on a particular column. This would be <literal>customerId</literal> in the given example. You can also use the nested <literal>&lt;formula&gt;</literal> mapping element if you do not want to use the attribute."
msgstr "注意，你可以使用实体自己的表，而不用为这个特别的列定义别名（上面例子中的 <literal>customerId</literal>）。同时注意，如果你不喜欢使用属性， 你可以使用嵌套的 <literal>&lt;formula&gt;</literal> 映射元素。 "

#. Tag: title
#, no-c-format
msgid "Many-to-one"
msgstr "多对一（many-to-one） "

#. Tag: para
#, no-c-format
msgid "An ordinary association to another persistent class is declared using a <literal>many-to-one</literal> element. The relational model is a many-to-one association; a foreign key in one table is referencing the primary key column(s) of the target table."
msgstr "通过 <literal>many-to-one</literal> 元素,可以定义一种常见的与另一个持久化类的关联。这种关系模型是多对一关联（实际上是一个对象引用－译注）：这个表的一个外键引用目标表的主键字段。 "

#. Tag: para
#, no-c-format
msgid "<literal>name</literal>: the name of the property."
msgstr "<literal>name</literal>：属性名。"

#. Tag: para
#, no-c-format
msgid "<literal>column</literal> (optional): the name of the foreign key column. This can also be specified by nested <literal>&lt;column&gt;</literal> element(s)."
msgstr "<literal>column</literal>（可选）：外键字段的名称。也可以通过嵌套的  <literal>&lt;column&gt;</literal> 指定。 "

#. Tag: para
#, no-c-format
msgid "<literal>class</literal> (optional - defaults to the property type determined by reflection): the name of the associated class."
msgstr "<literal>class</literal>（可选 — 默认是通过反射得到的属性类型）：被关联的类的名字。  "

#. Tag: para
#, no-c-format
msgid "<literal>cascade</literal> (optional): specifies which operations should be cascaded from the parent object to the associated object."
msgstr "<literal>cascade（级联）</literal>（可选）表明操作是否从父对象级联到被关联的对象。 "

#. Tag: para
#, no-c-format
msgid "<literal>fetch</literal> (optional - defaults to <literal>select</literal>): chooses between outer-join fetching or sequential select fetching."
msgstr "<literal>fetch</literal>（可选 — 默认为 <literal>select</literal>）：在外连接抓取（outer-join fetching）和序列选择抓取（sequential select fetching）两者中选择其一。 "

#. Tag: para
#, no-c-format
msgid "<literal>update, insert</literal> (optional - defaults to <literal>true</literal>): specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal> allows a pure \"derived\" association whose value is initialized from another property that maps to the same column(s), or by a trigger or other application."
msgstr "<literal>update, insert</literal>（可选 — 默认为 <literal>true</literal>）指定对应的字段是否包含在用于 <literal>UPDATE</literal> 和/或 <literal>INSERT</literal> 的 SQL 语句中。如果二者都是<literal>false</literal>,则这是一个纯粹的 “外源性（derived）”关联，它的值是通过映射到同一个（或多个）字段的某些其他属性得到 或者通过 trigger（触发器）、或其他程序生成。 "

#. Tag: para
#, no-c-format
msgid "<literal>property-ref</literal> (optional): the name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used."
msgstr "<literal>property-ref</literal>：（可选）被关联到此外键的类中的对应属性的名字。如果没有指定，被关联类的主键将被使用。 "

#. Tag: para
#, no-c-format
msgid "<literal>unique</literal> (optional): enables the DDL generation of a unique constraint for the foreign-key column. By allowing this to be the target of a <literal>property-ref</literal>, you can make the association multiplicity one-to-one."
msgstr "<literal>unique</literal>（可选）：使用 DDL 为外键字段生成一个唯一约束。此外， 这也可以用作 <literal>property-ref</literal> 的目标属性。这使关联同时具有一对一的效果。 "

#. Tag: para
#, no-c-format
msgid "<literal>not-null</literal> (optional): enables the DDL generation of a nullability constraint for the foreign key columns."
msgstr "<literal>not-null</literal>（可选）：使用 DDL 为外键字段生成一个非空约束。 "

#. Tag: para
#, no-c-format
msgid "<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): by default, single point associations are proxied. <literal>lazy=\"no-proxy\"</literal> specifies that the property should be fetched lazily when the instance variable is first accessed. This requires build-time bytecode instrumentation. <literal>lazy=\"false\"</literal> specifies that the association will always be eagerly fetched."
msgstr "<literal>lazy</literal>（可选 — 默认为 <literal>proxy</literal>）：默认情况下，单点关联是经过代理的。<literal>lazy=\"no-proxy\"</literal> 指定此属性应该在实例变量第一次被访问时应该延迟抓取（fetche lazily）（需要运行时字节码的增强）。<literal>lazy=\"false\"</literal> 指定此关联总是被预先抓取。 "

#. Tag: para
#, no-c-format
msgid "<literal>not-found</literal> (optional - defaults to <literal>exception</literal>): specifies how foreign keys that reference missing rows will be handled. <literal>ignore</literal> will treat a missing row as a null association."
msgstr "<literal>not-found</literal>（可选 - 默认为<literal>exception</literal>）：指定如何处理引用缺失行的外键：<literal>ignore</literal> 会把缺失的行作为一个空关联处理。 "

#. Tag: para
#, no-c-format
msgid "<literal>entity-name</literal> (optional): the entity name of the associated class."
msgstr "<literal>entity-name</literal>（可选）：被关联的类的实体名。 "

#. Tag: para
#, no-c-format
msgid "<literal>formula</literal> (optional): an SQL expression that defines the value for a <emphasis>computed</emphasis> foreign key."
msgstr "<literal>formula</literal>（可选）：SQL 表达式，用于定义 <emphasis>computed（计算出的）</emphasis>外键值。"

#. Tag: para
#, no-c-format
msgid "Setting a value of the <literal>cascade</literal> attribute to any meaningful value other than <literal>none</literal> will propagate certain operations to the associated object. The meaningful values are divided into three categories. First, basic operations, which include: <literal>persist, merge, delete, save-update, evict, replicate, lock and refresh</literal>; second, special values: <literal>delete-orphan</literal>; and third,<literal>all</literal> comma-separated combinations of operation names: <literal>cascade=\"persist,merge,evict\"</literal> or <literal>cascade=\"all,delete-orphan\"</literal>. See <xref linkend=\"objectstate-transitive\" /> for a full explanation. Note that single valued, many-to-one and one-to-one, associations do not support orphan delete."
msgstr "<literal>cascade</literal> 属性设置为除了<literal>none</literal> 以外任何有意义的值，它将把特定的操作传递到关联对象中。这个值就代表着 Hibernate 基本操作的名称，<literal>persist, merge, delete, save-update, evict, replicate, lock, refresh</literal>，以及特别的值 <literal>delete-orphan</literal> 和 <literal>all</literal>，并且可以用逗号分隔符来组合这些操作，例如，<literal>cascade=\"persist,merge,evict\"</literal> 或  <literal>cascade=\"all,delete-orphan\"</literal>。更全面的解释请参考 <xref linkend=\"objectstate-transitive\"/>。注意，单值关联（many-to-one 和 one-to-one 关联）不支持删除孤儿（orphan delete，删除不再被引用的值）。 "

#. Tag: para
#, no-c-format
msgid "Here is an example of a typical <literal>many-to-one</literal> declaration:"
msgstr "一个典型的简单 <literal>many-to-one</literal> 定义例子： "

#. Tag: para
#, no-c-format
msgid "The <literal>property-ref</literal> attribute should only be used for mapping legacy data where a foreign key refers to a unique key of the associated table other than the primary key. This is a complicated and confusing relational model. For example, if the <literal>Product</literal> class had a unique serial number that is not the primary key. The <literal>unique</literal> attribute controls Hibernate's DDL generation with the SchemaExport tool."
msgstr "<literal>property-ref</literal> 属性只应该用来对付遗留下来的数据库系统，可能有外键指向对方关联表的是个非主键字段（但是应该是一个惟一关键字）的情况下。这是一种十分丑陋的关系模型。比如说，假设 <literal>Product</literal> 类有一个惟一的序列号，它并不是主键。（<literal>unique</literal> 属性控制 Hibernate 通过 SchemaExport 工具进行的 DDL 生成。） "

#. Tag: para
#, no-c-format
msgid "Then the mapping for <literal>OrderItem</literal> might use:"
msgstr "那么关于 <literal>OrderItem</literal> 的映射可能是："

#. Tag: para
#, no-c-format
msgid "This is not encouraged, however."
msgstr "当然，我们决不鼓励这种用法。 "

#. Tag: para
#, no-c-format
msgid "If the referenced unique key comprises multiple properties of the associated entity, you should map the referenced properties inside a named <literal>&lt;properties&gt;</literal> element."
msgstr "如果被引用的唯一主键由关联实体的多个属性组成，你应该在名称为 <literal>&lt;properties&gt;</literal> 的元素 里面映射所有关联的属性。"

#. Tag: para
#, no-c-format
msgid "If the referenced unique key is the property of a component, you can specify a property path:"
msgstr "假若被引用的唯一主键是组件的属性，你可以指定属性路径： "

#. Tag: title
#, no-c-format
msgid "One-to-one"
msgstr "一对一 "

#. Tag: para
#, no-c-format
msgid "A one-to-one association to another persistent class is declared using a <literal>one-to-one</literal> element."
msgstr "持久化对象之间一对一的关联关系是通过 <literal>one-to-one</literal> 元素定义的。"

#. Tag: para
#, no-c-format
msgid "<literal>constrained</literal> (optional): specifies that a foreign key constraint on the primary key of the mapped table and references the table of the associated class. This option affects the order in which <literal>save()</literal> and <literal>delete()</literal> are cascaded, and determines whether the association can be proxied. It is also used by the schema export tool."
msgstr "<literal>constrained（约束）</literal>（可选）表明该类对应的表对应的数据库表，和被关联的对象所对应的数据库表之间，通过一个外键引用对主键进行约束。这个选项影响 <literal>save()</literal> 和 <literal>delete()</literal> 在级联执行时的先后顺序以及决定该关联能否被委托（也在 schema export tool 中被使用）。 "

#. Tag: para
#, no-c-format
msgid "<literal>property-ref</literal> (optional): the name of a property of the associated class that is joined to the primary key of this class. If not specified, the primary key of the associated class is used."
msgstr "<literal>property-ref</literal>：（可选）指定关联类的属性名，这个属性将会和本类的主键相对应。如果没有指定，会使用对方关联类的主键。 "

#. Tag: para
#, no-c-format
msgid "<literal>formula</literal> (optional): almost all one-to-one associations map to the primary key of the owning entity. If this is not the case, you can specify another column, columns or expression to join on using an SQL formula. See <literal>org.hibernate.test.onetooneformula</literal> for an example."
msgstr "<literal>formula </literal>（可选）：绝大多数一对一的关联都指向其实体的主键。在一些少见的情况中，你可能会指向其他的一个或多个字段，或者是一个表达式，这些情况下，你可以用一个 SQL 公式来表示。（可以在 org.hibernate.test.onetooneformula 找到例子） "

#. Tag: para
#, no-c-format
msgid "<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): by default, single point associations are proxied. <literal>lazy=\"no-proxy\"</literal> specifies that the property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. <literal>lazy=\"false\"</literal> specifies that the association will always be eagerly fetched. <emphasis>Note that if <literal>constrained=\"false\"</literal>, proxying is impossible and Hibernate will eagerly fetch the association</emphasis>."
msgstr "<literal>lazy</literal>（可选 — 默认为 <literal>proxy</literal>）：默认情况下，单点关联是经过代理的。<literal>lazy=\"no-proxy\"</literal>指定此属性应该在实例变量第一次被访问时应该延迟抓取（fetche lazily）（需要运行时字节码的增强）。 <literal>lazy=\"false\"</literal>指定此关联总是被预先抓取。<emphasis>注意，如果<literal>constrained=\"false\"</literal>, 不可能使用代理，Hibernate会采取预先抓取</emphasis>。"

#. Tag: para
#, no-c-format
msgid "There are two varieties of one-to-one associations:"
msgstr "有两种不同的一对一关联： "

#. Tag: para
#, no-c-format
msgid "primary key associations"
msgstr "主键关联"

#. Tag: para
#, no-c-format
msgid "unique foreign key associations"
msgstr "惟一外键关联"

#. Tag: para
#, no-c-format
msgid "Primary key associations do not need an extra table column. If two rows are related by the association, then the two table rows share the same primary key value. To relate two objects by a primary key association, ensure that they are assigned the same identifier value."
msgstr "主键关联不需要额外的表字段；如果两行是通过这种一对一关系相关联的，那么这两行就共享同样的主关键字值。所以如果你希望两个对象通过主键一对一关联，你必须确认它们被赋予同样的标识值。"

#. Tag: para
#, no-c-format
msgid "For a primary key association, add the following mappings to <literal>Employee</literal> and <literal>Person</literal> respectively:"
msgstr "比如说，对下面的 <literal>Employee</literal> 和 <literal>Person</literal> 进行主键一对一关联："

#. Tag: para
#, no-c-format
msgid "Ensure that the primary keys of the related rows in the PERSON and EMPLOYEE tables are equal. You use a special Hibernate identifier generation strategy called <literal>foreign</literal>:"
msgstr "现在我们必须确保 PERSON 和 EMPLOYEE 中相关的字段是相等的。我们使用一个被成为 <literal>foreign</literal> 的特殊的 hibernate 标识符生成策略： "

#. Tag: para
#, no-c-format
msgid "A newly saved instance of <literal>Person</literal> is assigned the same primary key value as the <literal>Employee</literal> instance referred with the <literal>employee</literal> property of that <literal>Person</literal>."
msgstr "一个刚刚保存的 <literal>Person</literal> 实例被赋予和该 <literal>Person</literal> 的 <literal>employee</literal> 属性所指向的 <literal>Employee</literal> 实例同样的关键字值。 "

#. Tag: para
#, no-c-format
msgid "Alternatively, a foreign key with a unique constraint, from <literal>Employee</literal> to <literal>Person</literal>, can be expressed as:"
msgstr "另一种方式是一个外键和一个惟一关键字对应，上面的 <literal>Employee</literal> 和  <literal>Person</literal> 的例子，如果使用这种关联方式，可以表达成： "

#. Tag: para
#, no-c-format
msgid "This association can be made bidirectional by adding the following to the <literal>Person</literal> mapping:"
msgstr "如果在 <literal>Person</literal> 的映射加入下面几句，这种关联就是双向的： "

#. Tag: title
#, no-c-format
msgid "Natural-id"
msgstr "自然 ID（natural-id） "

#. Tag: para
#, no-c-format
msgid "Although we recommend the use of surrogate keys as primary keys, you should try to identify natural keys for all entities. A natural key is a property or combination of properties that is unique and non-null. It is also immutable. Map the properties of the natural key inside the <literal>&lt;natural-id&gt;</literal> element. Hibernate will generate the necessary unique key and nullability constraints and, as a result, your mapping will be more self-documenting."
msgstr "我们建议使用代用键（键值不具备实际意义）作为主键，我们仍然应该尝试为所有的实体采用自然的键值作为（附加——译者注）标示。自然键（natural key）是单个或组合属性，他们必须唯一且非空。如果它还是不可变的那就更理想了。在 <literal>&lt;natural-id&gt;</literal> 元素中列出自然键的属性。Hibernate 会帮你生成必须的唯一键值和非空约束，你的映射会更加的明显易懂（原文是 self-documenting，自我注解）。 "

#. Tag: para
#, no-c-format
msgid "It is recommended that you implement <literal>equals()</literal> and <literal>hashCode()</literal> to compare the natural key properties of the entity."
msgstr "我们强烈建议你实现 <literal>equals()</literal> 和 <literal>hashCode()</literal> 方法,来比较实体的自然键属性。 "

#. Tag: para
#, no-c-format
msgid "This mapping is not intended for use with entities that have natural primary keys."
msgstr "这一映射不是为了把自然键作为主键而准备的。 "

#. Tag: para
#, no-c-format
msgid "<literal>mutable</literal> (optional - defaults to <literal>false</literal>): by default, natural identifier properties are assumed to be immutable (constant)."
msgstr "<literal>mutable</literal>（可选，默认为 <literal>false</literal>）：默认情况下，自然标识属性被假定为不可变的（常量）。 "

#. Tag: title
#, no-c-format
msgid "Component and dynamic-component"
msgstr "组件（component）和动态组件（dynamic-component） "

#. Tag: para
#, no-c-format
msgid "The <literal>&lt;component&gt;</literal> element maps properties of a child object to columns of the table of a parent class. Components can, in turn, declare their own properties, components or collections. See the \"Component\" examples below:"
msgstr "<literal>&lt;component&gt;</literal> 元素把子对象的一些元素与父类对应的表的一些字段映射起来。然后组件可以定义它们自己的属性、组件或者集合。参见后面的“Components”一章。 "

#. Tag: para
#, no-c-format
msgid "<literal>class</literal> (optional - defaults to the property type determined by reflection): the name of the component (child) class."
msgstr "<literal>class</literal>（可选 — 默认为通过反射得到的属性类型）：组件（子）类的名字。 "

#. Tag: para
#, no-c-format
msgid "<literal>insert</literal>: do the mapped columns appear in SQL <literal>INSERTs</literal>?"
msgstr "<literal>insert</literal>：被映射的字段是否出现在 SQL 的 <literal>INSERT</literal> 语句中？ "

#. Tag: para
#, no-c-format
msgid "<literal>update</literal>: do the mapped columns appear in SQL <literal>UPDATEs</literal>?"
msgstr "<literal>update</literal>：被映射的字段是否出现在 SQL 的 <literal>UPDATE</literal> 语句中？ "

#. Tag: para
#, no-c-format
msgid "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): specifies that this component should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation."
msgstr "<literal>lazy</literal>（可选 — 默认是 <literal>false</literal>）：表明此组件应在实例变量第一次被访问的时候延迟加载（需要编译时字节码装置器）。"

#. Tag: para
#, no-c-format
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): specifies that updates to this component either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when this property is dirty."
msgstr "<literal>optimistic-lock</literal>（可选 — 默认是 <literal>true</literal>）：表明更新此组件是否需要获取乐观锁。换句话说，当这个属性变脏时，是否增加版本号（Version）。"

#. Tag: para
#, no-c-format
msgid "<literal>unique</literal> (optional - defaults to <literal>false</literal>): specifies that a unique constraint exists upon all mapped columns of the component."
msgstr "<literal>unique</literal>（可选 — 默认是 <literal>false</literal>）：表明组件映射的所有字段上都有唯一性约束。"

#. Tag: para
#, no-c-format
msgid "The child <literal>&lt;property&gt;</literal> tags map properties of the child class to table columns."
msgstr "其 <literal>&lt;property&gt;</literal> 子标签为子类的一些属性与表字段之间建立映射。"

#. Tag: para
#, no-c-format
msgid "The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;parent&gt;</literal> subelement that maps a property of the component class as a reference back to the containing entity."
msgstr "<literal>&lt;component&gt;</literal> 元素允许加入一个 <literal>&lt;parent&gt;</literal> 子元素，在组件类内部就可以有一个指向其容器的实体的反向引用。"

#. Tag: para
#, no-c-format
msgid "The <literal>&lt;dynamic-component&gt;</literal> element allows a <literal>Map</literal> to be mapped as a component, where the property names refer to keys of the map. See <xref linkend=\"components-dynamic\" /> for more information."
msgstr "<literal>&lt;dynamic-component&gt;</literal> 元素允许把一个 <literal>Map</literal> 映射为组件，其属性名对应 map 的键值。参见 <xref linkend=\"components-dynamic\"/>。 "

#. Tag: title
#, no-c-format
msgid "Properties"
msgstr "属性（Properties）"

#. Tag: para
#, no-c-format
msgid "The <literal>&lt;properties&gt;</literal> element allows the definition of a named, logical grouping of the properties of a class. The most important use of the construct is that it allows a combination of properties to be the target of a <literal>property-ref</literal>. It is also a convenient way to define a multi-column unique constraint. For example:"
msgstr "<literal>&lt;properties&gt;</literal> 元素允许定义一个命名的逻辑分组（grouping）包含一个类中的多个属性。这个元素最重要的用处是允许多个属性的组合作为 <literal>property-ref</literal> 的目标（target）。这也是定义多字段唯一约束的一种方便途径。例如："

#. Tag: para
#, no-c-format
msgid "<literal>name</literal>: the logical name of the grouping. It is <emphasis>not</emphasis> an actual property name."
msgstr "<literal>name</literal>：分组的逻辑名称 — <emphasis>不是</emphasis> 实际属性的名称。 "

#. Tag: para
#, no-c-format
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): specifies that updates to these properties either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when these properties are dirty."
msgstr "<literal>optimistic-lock</literal>（可选 — 默认是 <literal>true</literal>）：表明更新此组件是否需要获取乐观锁。换句话说，当这个属性变脏时，是否增加版本号（Version）。"

#. Tag: para
#, no-c-format
msgid "For example, if we have the following <literal>&lt;properties&gt;</literal> mapping:"
msgstr "例如，如果我们有如下的 <literal>&lt;properties&gt;</literal> 映射："

#. Tag: para
#, no-c-format
msgid "You might have some legacy data association that refers to this unique key of the <literal>Person</literal> table, instead of to the primary key:"
msgstr "然后，我们可能有一些遗留的数据关联，引用 <literal>Person</literal> 表的这个唯一键，而不是主键："

#. Tag: para
#, no-c-format
msgid "The use of this outside the context of mapping legacy data is not recommended."
msgstr "我们并不推荐这样使用，除非在映射遗留数据的情况下。 "

#. Tag: title
#, no-c-format
msgid "Subclass"
msgstr "子类（subclass） "

#. Tag: para
#, no-c-format
msgid "Polymorphic persistence requires the declaration of each subclass of the root persistent class. For the table-per-class-hierarchy mapping strategy, the <literal>&lt;subclass&gt;</literal> declaration is used. For example:"
msgstr "最后，多态持久化需要为父类的每个子类都进行定义。对于“每一棵类继承树对应一个表”的策略来说，就需要使用 <literal>&lt;subclass&gt;</literal> 定义。 "

#. Tag: para
#, no-c-format
msgid "<literal>name</literal>: the fully qualified class name of the subclass."
msgstr "<literal>name</literal>：子类的全限定名。 "

#. Tag: para
#, no-c-format
msgid "<literal>discriminator-value</literal> (optional - defaults to the class name): a value that distinguishes individual subclasses."
msgstr "<literal>discriminator-value（辨别标志）</literal>（可选 — 默认为类名）：一个用于区分每个独立的子类的值。 "

#. Tag: para
#, no-c-format
msgid "<literal>proxy</literal> (optional): specifies a class or interface used for lazy initializing proxies."
msgstr "<literal>proxy</literal>（可选）：指定一个类或者接口，在延迟装载时作为代理使用。 "

#. Tag: para
#, no-c-format
msgid "<literal>lazy</literal> (optional - defaults to <literal>true</literal>): setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr "<literal>lazy</literal>（可选，默认是 <literal>true</literal>）：设置为 <literal>lazy=\"false\"</literal> 禁止使用延迟装载。 "

#. Tag: para
#, no-c-format
msgid "Each subclass declares its own persistent properties and subclasses. <literal>&lt;version&gt;</literal> and <literal>&lt;id&gt;</literal> properties are assumed to be inherited from the root class. Each subclass in a hierarchy must define a unique <literal>discriminator-value</literal>. If this is not specified, the fully qualified Java class name is used."
msgstr "每个子类都应该定义它自己的持久化属性和子类。<literal>&lt;version&gt;</literal> 和 <literal>&lt;id&gt;</literal> 属性可以从根父类继承下来。在一棵继承树上的每个子类都必须定义一个唯一的 <literal>discriminator-value</literal>。如果没有指定，就会使用 Java 类的全限定名。 "

#. Tag: para
#, no-c-format
msgid "For information about inheritance mappings see <xref linkend=\"inheritance\" />."
msgstr "更多关于继承映射的信息，参考 <xref linkend=\"inheritance\"/>。 "

#. Tag: title
#, no-c-format
msgid "Joined-subclass"
msgstr "连接的子类（joined-subclass） "

#. Tag: para
#, no-c-format
msgid "Each subclass can also be mapped to its own table. This is called the table-per-subclass mapping strategy. An inherited state is retrieved by joining with the table of the superclass. To do this you use the <literal>&lt;joined-subclass&gt;</literal> element. For example:"
msgstr "此外，每个子类可能被映射到他自己的表中（每个子类一个表的策略）。被继承的状态通过和超类的表关联得到。我们使用 <literal>&lt;joined-subclass&gt;</literal> 元素。 "

#. Tag: para
#, no-c-format
msgid "<literal>table</literal>: the name of the subclass table."
msgstr "<literal>table</literal>：子类的表名。"

#. Tag: para
#, no-c-format
msgid "<literal>proxy</literal> (optional): specifies a class or interface to use for lazy initializing proxies."
msgstr "<literal>proxy</literal>（可选）：指定一个类或者接口，在延迟装载时作为代理使用。 "

#. Tag: para
#, no-c-format
msgid "<literal>lazy</literal> (optional, defaults to <literal>true</literal>): setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr "<literal>lazy</literal>（可选，默认是 <literal>true</literal>）：设置为 <literal>lazy=\"false\"</literal> 禁止使用延迟装载。 "

#. Tag: para
#, no-c-format
msgid "A discriminator column is not required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier using the <literal>&lt;key&gt;</literal> element. The mapping at the start of the chapter would then be re-written as:"
msgstr "这种映射策略不需要指定辨别标志（discriminator）字段。但是，每一个子类都必须使用 <literal>&lt;key&gt;</literal> 元素指定一个表字段来持有对象的标识符。本章开始的映射可以被用如下方式重写： "

#. Tag: title
#, no-c-format
msgid "Union-subclass"
msgstr "联合子类（union-subclass） "

#. Tag: para
#, no-c-format
msgid "A third option is to map only the concrete classes of an inheritance hierarchy to tables. This is called the table-per-concrete-class strategy. Each table defines all persistent states of the class, including the inherited state. In Hibernate, it is not necessary to explicitly map such inheritance hierarchies. You can map each class with a separate <literal>&lt;class&gt;</literal> declaration. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the <literal>&lt;union-subclass&gt;</literal> mapping. For example:"
msgstr "第三种选择是仅仅映射类继承树中具体类部分到表中（每个具体类一张表的策略）。其中，每张表定义了类的所有持久化状态，包括继承的状态。在 Hibernate 中，并不需要完全显式地映射这样的继承树。你可以简单地使用单独的 <literal>&lt;class&gt;</literal> 定义映射每个类。然而，如果你想使用多态关联（例如，一个对类继承树中超类的关联），你需要使用 <literal>&lt;union-subclass&gt;</literal> 映射。 "

#. Tag: para
#, no-c-format
msgid "No discriminator column or key column is required for this mapping strategy."
msgstr "这种映射策略不需要指定辨别标志（discriminator）字段。"

#. Tag: title
#, no-c-format
msgid "Join"
msgstr "连接（join） "

#. Tag: para
#, no-c-format
msgid "Using the <literal>&lt;join&gt;</literal> element, it is possible to map properties of one class to several tables that have a one-to-one relationship. For example:"
msgstr "使用 <literal>&lt;join&gt;</literal> 元素，假若在表之间存在一对一关联,可以将一个类的属性映射到多张表中。 "

#. Tag: para
#, no-c-format
msgid "<literal>table</literal>: the name of the joined table."
msgstr "<literal>table</literal>：被连接表的名称。 "

#. Tag: para
#, no-c-format
msgid "<literal>fetch</literal> (optional - defaults to <literal>join</literal>): if set to <literal>join</literal>, the default, Hibernate will use an inner join to retrieve a <literal>&lt;join&gt;</literal> defined by a class or its superclasses. It will use an outer join for a <literal>&lt;join&gt;</literal> defined by a subclass. If set to <literal>select</literal> then Hibernate will use a sequential select for a <literal>&lt;join&gt;</literal> defined on a subclass. This will be issued only if a row represents an instance of the subclass. Inner joins will still be used to retrieve a <literal>&lt;join&gt;</literal> defined by the class and its superclasses."
msgstr "<literal>fetch</literal>（可选 — 默认是 <literal>join</literal>）：如果设置为默认值 <literal>join</literal>，Hibernate 将使用一个内连接来得到这个类或其超类定义的 <literal>&lt;join&gt;</literal>，而使用一个外连接来得到其子类定义的 <literal>&lt;join&gt;</literal>。如果设置为 <literal>select</literal>，则 Hibernate 将为子类定义的 <literal>&lt;join&gt;</literal> 使用顺序选择。这仅在一行数据表示一个子类的对象的时候才会发生。对这个类和其超类定义的 <literal>&lt;join&gt;</literal>，依然会使用内连接得到。 "

#. Tag: para
#, no-c-format
msgid "<literal>inverse</literal> (optional - defaults to <literal>false</literal>): if enabled, Hibernate will not insert or update the properties defined by this join."
msgstr "<literal>inverse</literal>（可选 — 默认是 <literal>false</literal>）：如果打开，Hibernate 不会插入或者更新此连接定义的属性。 "

#. Tag: para
#, no-c-format
msgid "<literal>optional</literal> (optional - defaults to <literal>false</literal>): if enabled, Hibernate will insert a row only if the properties defined by this join are non-null. It will always use an outer join to retrieve the properties."
msgstr "<literal>optional</literal>（可选 — 默认是 <literal>false</literal>）：如果打开，Hibernate 只会在此连接定义的属性非空时插入一行数据，并且总是使用一个外连接来得到这些属性。 "

#. Tag: para
#, no-c-format
msgid "For example, address information for a person can be mapped to a separate table while preserving value type semantics for all properties:"
msgstr "例如，一个人（person）的地址（address）信息可以被映射到单独的表中（并保留所有属性的值类型语义）： "

#. Tag: para
#, no-c-format
msgid "This feature is often only useful for legacy data models. We recommend fewer tables than classes and a fine-grained domain model. However, it is useful for switching between inheritance mapping strategies in a single hierarchy, as explained later."
msgstr "此特性常常对遗留数据模型有用，我们推荐表个数比类个数少，以及细粒度的领域模型。然而，在单独的继承树上切换继承映射策略是有用的，后面会解释这点。 "

#. Tag: title
#, no-c-format
msgid "Key"
msgstr "Key"

#. Tag: para
#, no-c-format
msgid "The <literal>&lt;key&gt;</literal> element has featured a few times within this guide. It appears anywhere the parent mapping element defines a join to a new table that references the primary key of the original table. It also defines the foreign key in the joined table:"
msgstr "我们目前已经见到过 <literal>&lt;key&gt;</literal> 元素多次了。这个元素在父映射元素定义了对新表的连接，并且在被连接表中定义了一个外键引用原表的主键的情况下经常使用。 "

#. Tag: para
#, no-c-format
msgid "<literal>on-delete</literal> (optional - defaults to <literal>noaction</literal>): specifies whether the foreign key constraint has database-level cascade delete enabled."
msgstr "<literal>on-delete</literal>（可选，默认是 <literal>noaction</literal>）：表明外键关联是否打开数据库级别的级联删除。 "

#. Tag: para
#, no-c-format
msgid "<literal>property-ref</literal> (optional): specifies that the foreign key refers to columns that are not the primary key of the original table. It is provided for legacy data."
msgstr "<literal>property-ref</literal>（可选）：表明外键引用的字段不是原表的主键（提供给遗留数据）。 "

#. Tag: para
#, no-c-format
msgid "<literal>not-null</literal> (optional): specifies that the foreign key columns are not nullable. This is implied whenever the foreign key is also part of the primary key."
msgstr "<literal>not-null</literal>（可选）：表明外键的字段不可为空（这意味着无论何时外键都是主键的一部分）。 "

#. Tag: para
#, no-c-format
msgid "<literal>update</literal> (optional): specifies that the foreign key should never be updated. This is implied whenever the foreign key is also part of the primary key."
msgstr "<literal>update</literal>（可选）：表明外键决不应该被更新（这意味着无论何时外键都是主键的一部分）。 "

#. Tag: para
#, no-c-format
msgid "<literal>unique</literal> (optional): specifies that the foreign key should have a unique constraint. This is implied whenever the foreign key is also the primary key."
msgstr "<literal>unique</literal>（可选）：表明外键应有唯一性约束（这意味着无论何时外键都是主键的一部分）。 "

#. Tag: para
#, no-c-format
msgid "For systems where delete performance is important, we recommend that all keys should be defined <literal>on-delete=\"cascade\"</literal>. Hibernate uses a database-level <literal>ON CASCADE DELETE</literal> constraint, instead of many individual <literal>DELETE</literal> statements. Be aware that this feature bypasses Hibernate's usual optimistic locking strategy for versioned data."
msgstr "对那些看重删除性能的系统，我们推荐所有的键都应该定义为 <literal>on-delete=\"cascade\"</literal>，这样 Hibernate 将使用数据库级的 <literal>ON CASCADE DELETE</literal> 约束，而不是多个 <literal>DELETE</literal> 语句。注意，这个特性会绕过 Hibernate 通常对版本数据（versioned data）采用的乐观锁策略。 "

#. Tag: para
#, no-c-format
msgid "The <literal>not-null</literal> and <literal>update</literal> attributes are useful when mapping a unidirectional one-to-many association. If you map a unidirectional one-to-many association to a non-nullable foreign key, you <emphasis>must</emphasis> declare the key column using <literal>&lt;key not-null=\"true\"&gt;</literal>."
msgstr "<literal>not-null</literal> 和 <literal>update</literal> 属性在映射单向一对多关联的时候有用。如果你映射一个单向一对多关联到非空的（non-nullable）外键，你<emphasis>必须</emphasis> 用 <literal>&lt;key not-null=\"true\"&gt;</literal> 定义此键字段。 "

#. Tag: title
#, no-c-format
msgid "Column and formula elements"
msgstr "字段和规则元素（column and formula elements） "

#. Tag: para
#, no-c-format
msgid "Mapping elements which accept a <literal>column</literal> attribute will alternatively accept a <literal>&lt;column&gt;</literal> subelement. Likewise, <literal>&lt;formula&gt;</literal> is an alternative to the <literal>formula</literal> attribute. For example:"
msgstr "任何接受 <literal>column</literal> 属性的映射元素都可以选择接受 <literal>&lt;column&gt;</literal> 子元素。同样的，<literal>formula</literal> 子元素也可以替换 <literal>&lt;formula&gt;</literal> 属性。 "

#. Tag: para
#, no-c-format
msgid "Most of the attributes on <literal>column</literal> provide a means of tailoring the DDL during automatic schema generation. The <literal>read</literal> and <literal>write</literal> attributes allow you to specify custom SQL that Hibernate will use to access the column's value. For more on this, see the discussion of <link linkend=\"mapping-column-read-and-write\">column read and write expressions</link>."
msgstr "<literal>column</literal> 上的大多数属性都提供了在自动模式生成过程中对 DDL 进行裁剪的方法。<literal>read</literal> 和 <literal>write</literal> 属性允许你指定 Hibernate 用于访问字段值的自定义的 SQL。关于更多的内容，请参考 <link linkend=\"mapping-column-read-and-write\">column read and write expressions</link>。"

#. Tag: para
#, no-c-format
msgid "The <literal>column</literal> and <literal>formula</literal> elements can even be combined within the same property or association mapping to express, for example, exotic join conditions."
msgstr "<literal>column</literal> 和 <literal>formula</literal> 属性甚至可以在同一个属性或关联映射中被合并来表达，例如，一些奇异的连接条件。"

#. Tag: title
#, no-c-format
msgid "Import"
msgstr "引用（import） "

#. Tag: para
#, no-c-format
msgid "If your application has two persistent classes with the same name, and you do not want to specify the fully qualified package name in Hibernate queries, classes can be \"imported\" explicitly, rather than relying upon <literal>auto-import=\"true\"</literal>. You can also import classes and interfaces that are not explicitly mapped:"
msgstr "假设你的应用程序有两个同样名字的持久化类，但是你不想在 Hibernate 查询中使用他们的全限定名。除了依赖 <literal>auto-import=\"true\"</literal> 以外，类也可以被显式地“import（引用）”。你甚至可以引用没有被明确映射的类和接口。 "

#. Tag: para
#, no-c-format
msgid "<literal>class</literal>: the fully qualified class name of any Java class."
msgstr "<literal>class</literal>：任何 Java 类的全限定名。 "

#. Tag: para
#, no-c-format
msgid "<literal>rename</literal> (optional - defaults to the unqualified class name): a name that can be used in the query language."
msgstr "<literal>rename</literal>（可选 — 默认为类的全限定名）：在查询语句中可以使用的名字。 "

#. Tag: title
#, no-c-format
msgid "Any"
msgstr "Any"

#. Tag: para
#, no-c-format
msgid "There is one more type of property mapping. The <literal>&lt;any&gt;</literal> mapping element defines a polymorphic association to classes from multiple tables. This type of mapping requires more than one column. The first column contains the type of the associated entity. The remaining columns contain the identifier. It is impossible to specify a foreign key constraint for this kind of association. This is not the usual way of mapping polymorphic associations and you should use this only in special cases. For example, for audit logs, user session data, etc."
msgstr "这是属性映射的又一种类型。<literal>&lt;any&gt;</literal> 映射元素定义了一种从多个表到类的多态关联。这种类型的映射常常需要多于一个字段。第一个字段持有被关联实体的类型，其他的字段持有标识符。对这种类型的关联来说，不可能指定一个外键约束，所以这当然不是映射（多态）关联的通常的方式。你只应该在非常特殊的情况下使用它(比如，审计 log，用户会话数据等等)。 "

#. Tag: para
#, no-c-format
msgid "The <literal>meta-type</literal> attribute allows the application to specify a custom type that maps database column values to persistent classes that have identifier properties of the type specified by <literal>id-type</literal>. You must specify the mapping from values of the meta-type to class names."
msgstr "<literal>meta-type</literal> 属性使得应用程序能指定一个将数据库字段的值映射到持久化类的自定义类型。这个持久化类包含有用 <literal>id-type</literal> 指定的标识符属性。你必须指定从 meta-type 的值到类名的映射。 "

#. Tag: para
#, no-c-format
msgid "<literal>name</literal>: the property name."
msgstr "<literal>name</literal>：属性名"

#. Tag: para
#, no-c-format
msgid "<literal>id-type</literal>: the identifier type."
msgstr "<literal>id-type</literal>：标识符类型"

#. Tag: para
#, no-c-format
msgid "<literal>meta-type</literal> (optional - defaults to <literal>string</literal>): any type that is allowed for a discriminator mapping."
msgstr "<literal>meta-type</literal>（可选 -默认是 <literal>string</literal>）：允许辨别标志(discriminator)映射的任何类型。 "

#. Tag: para
#, no-c-format
msgid "<literal>cascade</literal> (optional- defaults to <literal>none</literal>): the cascade style."
msgstr "<literal>cascade</literal>（可选 — 默认是<literal>none</literal>）：级联的类型。"

#. Tag: para
#, no-c-format
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): specifies that updates to this property either do or do not require acquisition of the optimistic lock. It defines whether a version increment should occur if this property is dirty."
msgstr "<literal>optimistic-lock</literal>（可选 — 默认是 <literal>true</literal>）：表明更新此组件是否需要获取乐观锁。换句话说，当这个属性变脏时，是否增加版本号（Version）。"

#. Tag: title
#, no-c-format
msgid "Hibernate types"
msgstr "Hibernate 的类型 "

#. Tag: title
#, no-c-format
msgid "Entities and values"
msgstr "实体（Entities）和值（values）"

#. Tag: para
#, no-c-format
msgid "In relation to the persistence service, Java language-level objects are classified into two groups:"
msgstr "和持久化服务相比，Java 级别的对象分为两个组别："

#. Tag: para
#, no-c-format
msgid "An <emphasis>entity</emphasis> exists independently of any other objects holding references to the entity. Contrast this with the usual Java model, where an unreferenced object is garbage collected. Entities must be explicitly saved and deleted. Saves and deletions, however, can be <emphasis>cascaded</emphasis> from a parent entity to its children. This is different from the ODMG model of object persistence by reachability and corresponds more closely to how application objects are usually used in large systems. Entities support circular and shared references. They can also be versioned."
msgstr "<emphasis>实体entity</emphasis> 独立于任何持有实体引用的对象。与通常的 Java 模型相比，不再被引用的对象会被当作垃圾收集掉。实体必须被显式的保存和删除（除非保存和删除是从父实体向子实体引发的<emphasis>级联</emphasis>）。这和 ODMG 模型中关于对象通过可触及保持持久性有一些不同 — 比较起来更加接近应用程序对象通常在一个大系统中的使用方法。实体支持循环引用和交叉引用，它们也可以加上版本信息。 "

#. Tag: para
#, no-c-format
msgid "An entity's persistent state consists of references to other entities and instances of <emphasis>value</emphasis> types. Values are primitives: collections (not what is inside a collection), components and certain immutable objects. Unlike entities, values in particular collections and components, <emphasis>are</emphasis> persisted and deleted by reachability. Since value objects and primitives are persisted and deleted along with their containing entity, they cannot be independently versioned. Values have no independent identity, so they cannot be shared by two entities or collections."
msgstr "一个实体的持久状态包含指向其他实体和<emphasis>值</emphasis>类型实例的引用。值可以是原始类型，集合（不是集合中的对象），组件或者特定的不可变对象。与实体不同，值（特别是集合和组件）是通过可触及性来进行持久化和删除的。因为值对象（和原始类型数据）是随着包含他们的实体而被持久化和删除的，他们不能被独立的加上版本信息。值没有独立的标识，所以他们不能被两个实体或者集合共享。 "

#. Tag: para
#, no-c-format
msgid "Until now, we have been using the term \"persistent class\" to refer to entities. We will continue to do that. Not all user-defined classes with a persistent state, however, are entities. A <emphasis>component</emphasis> is a user-defined class with value semantics. A Java property of type <literal>java.lang.String</literal> also has value semantics. Given this definition, all types (classes) provided by the JDK have value type semantics in Java, while user-defined types can be mapped with entity or value type semantics. This decision is up to the application developer. An entity class in a domain model will normally have shared references to a single instance of that class, while composition or aggregation usually translates to a value type."
msgstr "直到现在，我们都一直使用术语“持久类”（persistent class）来代表实体。我们仍然会这么做。然而严格说来，不是所有的用户自定义的，带有持久化状态的类都是实体。<emphasis>组件</emphasis>就是用户自定义类，却是值语义的。<literal>java.lang.String</literal> 类型的 java 属性也是值语义的。给了这个定义以后，我们可以说所有 JDK 提供的类型（类）都是值类型的语义，而用于自定义类型可能被映射为实体类型或值类型语义。采用哪种类型的语义取决于开发人员。在领域模型中，寻找实体类的一个好线索是共享引用指向这个类的单一实例，而组合或聚合通常被转化为值类型。 "

#. Tag: para
#, no-c-format
msgid "We will revisit both concepts throughout this reference guide."
msgstr "我们会在本文档中重复碰到这两个概念。 "

#. Tag: para
#, no-c-format
msgid "The challenge is to map the Java type system, and the developers' definition of entities and value types, to the SQL/database type system. The bridge between both systems is provided by Hibernate. For entities, <literal>&lt;class&gt;</literal>, <literal>&lt;subclass&gt;</literal> and so on are used. For value types we use <literal>&lt;property&gt;</literal>, <literal>&lt;component&gt;</literal>etc., that usually have a <literal>type</literal> attribute. The value of this attribute is the name of a Hibernate <emphasis>mapping type</emphasis>. Hibernate provides a range of mappings for standard JDK value types out of the box. You can write your own mapping types and implement your own custom conversion strategies."
msgstr "挑战在于将 java 类型系统(和开发者定义的实体和值类型)映射到 SQL/数据库类型系统。Hibernate 提供了连接两个系统之间的桥梁：对于实体类型，我们使用 <literal>&lt;class&gt;</literal>，<literal>&lt;subclass&gt;</literal> 等等。对于值类型，我们使用 <literal>&lt;property&gt;</literal>，<literal>&lt;component&gt;</literal> 及其他，通常跟随着 <literal>type</literal> 属性。这个属性的值是Hibernate 的<emphasis>映射类型</emphasis>的名字。Hibernate 提供了许多现成的映射（标准的 JDK 值类型）。你也可以编写自己的映射类型并实现自定义的变换策略，随后我们会看到这点。 "

#. Tag: para
#, no-c-format
msgid "With the exception of collections, all built-in Hibernate types support null semantics."
msgstr "所有的 Hibernate 内建类型，除了 collections 以外，都支持空（null）语义。 "

#. Tag: title
#, no-c-format
msgid "Basic value types"
msgstr "基本值类型"

#. Tag: para
#, no-c-format
msgid "The built-in <emphasis>basic mapping types</emphasis> can be roughly categorized into the following:"
msgstr "内置的 <emphasis>basic mapping types</emphasis> 可以大致地分类为："

#. Tag: term
#, no-c-format
msgid "<literal>integer, long, short, float, double, character, byte, boolean, yes_no, true_false</literal>"
msgstr "<literal>integer, long, short, float, double, character, byte, boolean, yes_no, true_false</literal>"

#. Tag: para
#, no-c-format
msgid "Type mappings from Java primitives or wrapper classes to appropriate (vendor-specific) SQL column types. <literal>boolean, yes_no</literal> and <literal>true_false</literal> are all alternative encodings for a Java <literal>boolean</literal> or <literal>java.lang.Boolean</literal>."
msgstr "这些类型都对应 Java 的原始类型或者其封装类，来符合（特定厂商的）SQL 字段类型。<literal>boolean, yes_no</literal> 和 <literal>true_false</literal> 都是 Java 中 <literal>boolean</literal> 或者 <literal>java.lang.Boolean</literal> 的另外说法。"

#. Tag: term
#, no-c-format
msgid "<literal>string</literal>"
msgstr "<literal>string</literal>"

#. Tag: para
#, no-c-format
msgid "A type mapping from <literal>java.lang.String</literal> to <literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>)."
msgstr "从 <literal>java.lang.String</literal> 到 <literal>VARCHAR</literal>（或者 Oracle 的 <literal>VARCHAR2</literal>）的映射。"

#. Tag: term
#, no-c-format
msgid "<literal>date, time, timestamp</literal>"
msgstr "<literal>date, time, timestamp</literal>"

#. Tag: para
#, no-c-format
msgid "Type mappings from <literal>java.util.Date</literal> and its subclasses to SQL types <literal>DATE</literal>, <literal>TIME</literal> and <literal>TIMESTAMP</literal> (or equivalent)."
msgstr "从 <literal>java.util.Date</literal> 和其子类到 SQL 类型 <literal>DATE</literal>，<literal>TIME</literal> 和 <literal>TIMESTAMP</literal>（或等价类型）的映射。"

#. Tag: term
#, no-c-format
msgid "<literal>calendar, calendar_date</literal>"
msgstr "<literal>calendar, calendar_date</literal>"

#. Tag: para
#, no-c-format
msgid "Type mappings from <literal>java.util.Calendar</literal> to SQL types <literal>TIMESTAMP</literal> and <literal>DATE</literal> (or equivalent)."
msgstr "从 <literal>java.util.Calendar</literal> 到 SQL 类型 <literal>TIMESTAMP</literal> 和 <literal>DATE</literal>（或等价类型）的映射。"

#. Tag: term
#, no-c-format
msgid "<literal>big_decimal, big_integer</literal>"
msgstr "<literal>big_decimal, big_integer</literal>"

#. Tag: para
#, no-c-format
msgid "Type mappings from <literal>java.math.BigDecimal</literal> and <literal>java.math.BigInteger</literal> to <literal>NUMERIC</literal> (or Oracle <literal>NUMBER</literal>)."
msgstr "从 <literal>java.math.BigDecimal</literal> 和 <literal>java.math.BigInteger</literal> 到 <literal>NUMERIC</literal>（或者 Oracle 的 <literal>NUMBER</literal>类型）的映射。"

#. Tag: term
#, no-c-format
msgid "<literal>locale, timezone, currency</literal>"
msgstr "<literal>locale, timezone, currency</literal>"

#. Tag: para
#, no-c-format
msgid "Type mappings from <literal>java.util.Locale</literal>, <literal>java.util.TimeZone</literal> and <literal>java.util.Currency</literal> to <literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>). Instances of <literal>Locale</literal> and <literal>Currency</literal> are mapped to their ISO codes. Instances of <literal>TimeZone</literal> are mapped to their <literal>ID</literal>."
msgstr "从 <literal>java.util.Locale</literal>，<literal>java.util.TimeZone</literal>  和 <literal>java.util.Currency</literal> 到 <literal>VARCHAR</literal>（或者 Oracle 的 <literal>VARCHAR2</literal> 类型）的映射。<literal>Locale</literal> 和 <literal>Currency</literal> 的实例被映射为它们的 ISO 代码。<literal>TimeZone</literal> 的实例被影射为它的 <literal>ID</literal>。"

#. Tag: term
#, no-c-format
msgid "<literal>class</literal>"
msgstr "<literal>class</literal>"

#. Tag: para
#, no-c-format
msgid "A type mapping from <literal>java.lang.Class</literal> to <literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>). A <literal>Class</literal> is mapped to its fully qualified name."
msgstr "从 <literal>java.lang.Class</literal> 到 <literal>VARCHAR</literal>（或者 Oracle 的 <literal>VARCHAR2</literal> 类型）的映射。<literal>Class</literal> 被映射为它的全限定名。"

#. Tag: term
#, no-c-format
msgid "<literal>binary</literal>"
msgstr "<literal>binary</literal>"

#. Tag: para
#, no-c-format
msgid "Maps byte arrays to an appropriate SQL binary type."
msgstr "把字节数组（byte arrays）映射为对应的 SQL 二进制类型。"

#. Tag: term
#, no-c-format
msgid "<literal>text</literal>"
msgstr "<literal>text</literal>"

#. Tag: para
#, no-c-format
msgid "Maps long Java strings to a SQL <literal>CLOB</literal> or <literal>TEXT</literal> type."
msgstr "把长 Java 字符串映射为 SQL 的 <literal>CLOB</literal> 或者 <literal>TEXT</literal> 类型。"

#. Tag: term
#, no-c-format
msgid "<literal>serializable</literal>"
msgstr "<literal>serializable</literal>"

#. Tag: para
#, no-c-format
msgid "Maps serializable Java types to an appropriate SQL binary type. You can also indicate the Hibernate type <literal>serializable</literal> with the name of a serializable Java class or interface that does not default to a basic type."
msgstr "把可序列化的 Java 类型映射到对应的 SQL 二进制类型。你也可以为一个并非默认为基本类型的可序列化 Java 类或者接口指定 Hibernate 类型 <literal>serializable</literal>。 "

#. Tag: term
#, no-c-format
msgid "<literal>clob, blob</literal>"
msgstr "<literal>clob, blob</literal>"

#. Tag: para
#, no-c-format
msgid "Type mappings for the JDBC classes <literal>java.sql.Clob</literal> and <literal>java.sql.Blob</literal>. These types can be inconvenient for some applications, since the blob or clob object cannot be reused outside of a transaction. Driver support is patchy and inconsistent."
msgstr "JDBC 类 <literal>java.sql.Clob</literal> 和 <literal>java.sql.Blob</literal>的映射。某些程序可能不适合使用这个类型，因为 blob 和 clob 对象可能在一个事务之外是无法重用的。（而且, 驱动程序对这种类型的支持充满着补丁和前后矛盾。） "

#. Tag: term
#, no-c-format
msgid "<literal>imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, imm_serializable, imm_binary</literal>"
msgstr "<literal>imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, imm_serializable, imm_binary</literal>"

#. Tag: para
#, no-c-format
msgid "Type mappings for what are considered mutable Java types. This is where Hibernate makes certain optimizations appropriate only for immutable Java types, and the application treats the object as immutable. For example, you should not call <literal>Date.setTime()</literal> for an instance mapped as <literal>imm_timestamp</literal>. To change the value of the property, and have that change made persistent, the application must assign a new, nonidentical, object to the property."
msgstr "一般来说，映射类型被假定为是可变的 Java 类型，只有对不可变 Java 类型，Hibernate 会采取特定的优化措施，应用程序会把这些对象作为不可变对象处理。比如，你不应该对作为 <literal>imm_timestamp</literal> 映射的 Date 执行 <literal>Date.setTime()</literal>。要改变属性的值，并且保存这一改变，应用程序必须对这一属性重新设置一个新的（不一样的）对象。 "

#. Tag: para
#, no-c-format
msgid "Unique identifiers of entities and collections can be of any basic type except <literal>binary</literal>, <literal>blob</literal> and <literal>clob</literal>. Composite identifiers are also allowed. See below for more information."
msgstr "实体及其集合的唯一标识可以是除了 <literal>binary</literal>、 <literal>blob</literal> 和 <literal>clob</literal> 之外的任何基础类型。（联合标识也是允许的，后面会说到。）"

#. Tag: para
#, no-c-format
msgid "The basic value types have corresponding <literal>Type</literal> constants defined on <literal>org.hibernate.Hibernate</literal>. For example, <literal>Hibernate.STRING</literal> represents the <literal>string</literal> type."
msgstr "在 <literal>org.hibernate.Hibernate</literal> 中，定义了基础类型对应的 <literal>Type</literal> 常量。比如，<literal>Hibernate.STRING</literal> 代表 <literal>string</literal> 类型。"

#. Tag: title
#, no-c-format
msgid "Custom value types"
msgstr "自定义值类型"

#. Tag: para
#, no-c-format
msgid "It is relatively easy for developers to create their own value types. For example, you might want to persist properties of type <literal>java.lang.BigInteger</literal> to <literal>VARCHAR</literal> columns. Hibernate does not provide a built-in type for this. Custom types are not limited to mapping a property, or collection element, to a single table column. So, for example, you might have a Java property <literal>getName()</literal>/<literal>setName()</literal> of type <literal>java.lang.String</literal> that is persisted to the columns <literal>FIRST_NAME</literal>, <literal>INITIAL</literal>, <literal>SURNAME</literal>."
msgstr "开发者创建属于他们自己的值类型也是很容易的。比如说，你可能希望持久化 <literal>java.lang.BigInteger</literal> 类型的属性，持久化成为 <literal>VARCHAR</literal> 字段。Hibernate没有内置这样一种类型。自定义类型能够映射一个属性(或集合元素)到不止一个数据库表字段。比如说，你可能有这样的 Java 属性：<literal>getName()</literal>/<literal>setName()</literal>，这是 <literal>java.lang.String</literal> 类型的，对应的持久化到三个字段：<literal>FIRST_NAME</literal>，<literal>INITIAL</literal>，<literal>SURNAME</literal>。 "

#. Tag: para
#, no-c-format
msgid "To implement a custom type, implement either <literal>org.hibernate.UserType</literal> or <literal>org.hibernate.CompositeUserType</literal> and declare properties using the fully qualified classname of the type. View <literal>org.hibernate.test.DoubleStringType</literal> to see the kind of things that are possible."
msgstr "要实现一个自定义类型，可以实现 <literal>org.hibernate.UserType</literal> 或 <literal>org.hibernate.CompositeUserType</literal> 中的任一个，并且使用类型的 Java 全限定类名来定义属性。请查看 <literal>org.hibernate.test.DoubleStringType</literal> 这个例子，看看它是怎么做的。 "

#. Tag: para
#, no-c-format
msgid "Notice the use of <literal>&lt;column&gt;</literal> tags to map a property to multiple columns."
msgstr "注意使用 <literal>&lt;column&gt;</literal> 标签来把一个属性映射到多个字段的做法。"

#. Tag: para
#, no-c-format
msgid "The <literal>CompositeUserType</literal>, <literal>EnhancedUserType</literal>, <literal>UserCollectionType</literal>, and <literal>UserVersionType</literal> interfaces provide support for more specialized uses."
msgstr "<literal>CompositeUserType</literal>，<literal>EnhancedUserType</literal>，<literal>UserCollectionType</literal> 和 <literal>UserVersionType</literal> 接口为更特殊的使用方式提供支持。"

#. Tag: para
#, no-c-format
msgid "You can even supply parameters to a <literal>UserType</literal> in the mapping file. To do this, your <literal>UserType</literal> must implement the <literal>org.hibernate.usertype.ParameterizedType</literal> interface. To supply parameters to your custom type, you can use the <literal>&lt;type&gt;</literal> element in your mapping files."
msgstr "你甚至可以在一个映射文件中提供参数给一个 <literal>UserType</literal>。 为了这样做，你的 <literal>UserType</literal> 必须实现 <literal>org.hibernate.usertype.ParameterizedType</literal> 接口。为了给自定义类型提供参数，你可以在映射文件中使用 <literal>&lt;type&gt;</literal> 元素。 "

#. Tag: para
#, no-c-format
msgid "The <literal>UserType</literal> can now retrieve the value for the parameter named <literal>default</literal> from the <literal>Properties</literal> object passed to it."
msgstr "现在，<literal>UserType</literal> 可以从传入的 <literal>Properties</literal> 对象中得到 <literal>default</literal> 参数的值。"

#. Tag: para
#, no-c-format
msgid "If you regularly use a certain <literal>UserType</literal>, it is useful to define a shorter name for it. You can do this using the <literal>&lt;typedef&gt;</literal> element. Typedefs assign a name to a custom type, and can also contain a list of default parameter values if the type is parameterized."
msgstr "如果你非常频繁地使用某一 <literal>UserType</literal>，可以为他定义一个简称。这可以通过使用 <literal>&lt;typedef&gt;</literal> 元素来实现。Typedefs 为一自定义类型赋予一个名称，并且如果此类型是参数化的，还可以包含一系列默认的参数值。 "

#. Tag: para
#, no-c-format
msgid "It is also possible to override the parameters supplied in a typedef on a case-by-case basis by using type parameters on the property mapping."
msgstr "也可以根据具体案例通过属性映射中的类型参数覆盖在 typedef 中提供的参数。"

#. Tag: para
#, no-c-format
msgid "Even though Hibernate's rich range of built-in types and support for components means you will rarely need to use a custom type, it is considered good practice to use custom types for non-entity classes that occur frequently in your application. For example, a <literal>MonetaryAmount</literal> class is a good candidate for a <literal>CompositeUserType</literal>, even though it could be mapped as a component. One reason for this is abstraction. With a custom type, your mapping documents would be protected against changes to the way monetary values are represented."
msgstr "尽管 Hibernate 内建的丰富的类型和对组件的支持意味着你可能很少 <emphasis>需要</emphasis>使用自定义类型。不过，为那些在你的应用中经常出现的(非实体)类使用自定义类型也是一个好方法。例如，一个 <literal>MonetaryAmount</literal> 类使用 <literal>CompositeUserType</literal> 来映射是不错的选择，虽然他可以很容易地被映射成组件。这样做的动机之一是抽象。使用自定义类型，以后假若你改变表示金额的方法时，它可以保证映射文件不需要修改。 "

#. Tag: title
#, no-c-format
msgid "Mapping a class more than once"
msgstr "多次映射同一个类"

#. Tag: para
#, no-c-format
msgid "It is possible to provide more than one mapping for a particular persistent class. In this case, you must specify an <emphasis>entity name</emphasis> to disambiguate between instances of the two mapped entities. By default, the entity name is the same as the class name. Hibernate lets you specify the entity name when working with persistent objects, when writing queries, or when mapping associations to the named entity."
msgstr "对特定的持久化类，映射多次是允许的。这种情形下，你必须指定 <emphasis>entity name</emphasis> 来区别不同映射实体的对象实例。（默认情况下，实体名字和类名是相同的。） Hibernate 在操作持久化对象、编写查询条件，或者把关联映射到指定实体时，允许你指定这个 entity name（实体名字）。 "

#. Tag: para
#, no-c-format
msgid "Associations are now specified using <literal>entity-name</literal> instead of <literal>class</literal>."
msgstr "注意这里关联是如何用 <literal>entity-name</literal> 来代替 <literal>class</literal> 的。 "

#. Tag: title
#, no-c-format
msgid "SQL quoted identifiers"
msgstr "SQL 中引号包围的标识符"

#. Tag: para
#, no-c-format
msgid "You can force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document. Hibernate will use the correct quotation style for the SQL <literal>Dialect</literal>. This is usually double quotes, but the SQL Server uses brackets and MySQL uses backticks."
msgstr "你可通过在映射文档中使用反向引号（`）把表名或者字段名包围起来，以强制 Hibernate 在生成的 SQL 中把标识符用引号包围起来。Hibernate 会使用相应的 SQL<literal>Dialect</literal>（方言）来使用正确的引号风格(通常是双引号，但是在 SQL Server 中是括号，MySQL 中是反向引号)。 "

#. Tag: title
#, no-c-format
msgid "Metadata alternatives"
msgstr "其他元数据（Metadata）"

#. Tag: para
#, no-c-format
msgid "XML does not suit all users so there are some alternative ways to define O/R mapping metadata in Hibernate."
msgstr "XML 并不适用于所有人, 因此有其他定义 Hibernate O/R 映射元数据（metadata）的方法。 "

#. Tag: title
#, no-c-format
msgid "Using XDoclet markup"
msgstr "使用 XDoclet 标记"

#. Tag: para
#, no-c-format
msgid "Many Hibernate users prefer to embed mapping information directly in sourcecode using XDoclet <literal>@hibernate.tags</literal>. We do not cover this approach in this reference guide since it is considered part of XDoclet. However, we include the following example of the <literal>Cat</literal> class with XDoclet mappings:"
msgstr "很多 Hibernate 使用者更喜欢使用 XDoclet<literal>@hibernate.tags</literal> 将映射信息直接嵌入到源代码中。我们不会在本文档中涉及这个方法，因为严格说来，这属于 XDoclet 的一部分。然而，我们包含了如下使用 XDoclet 映射的 <literal>Cat</literal> 类的例子。 "

#. Tag: para
#, no-c-format
msgid "See the Hibernate website for more examples of XDoclet and Hibernate."
msgstr "参考 Hibernate 网站更多的 Xdoclet 和 Hibernate 的例子。"

#. Tag: title
#, no-c-format
msgid "Using JDK 5.0 Annotations"
msgstr "使用 JDK 5.0 的注解（Annotation）"

#. Tag: para
#, no-c-format
msgid "JDK 5.0 introduced XDoclet-style annotations at the language level that are type-safe and checked at compile time. This mechanism is more powerful than XDoclet annotations and better supported by tools and IDEs. IntelliJ IDEA, for example, supports auto-completion and syntax highlighting of JDK 5.0 annotations. The new revision of the EJB specification (JSR-220) uses JDK 5.0 annotations as the primary metadata mechanism for entity beans. Hibernate3 implements the <literal>EntityManager</literal> of JSR-220 (the persistence API). Support for mapping metadata is available via the <emphasis>Hibernate Annotations</emphasis> package as a separate download. Both EJB3 (JSR-220) and Hibernate3 metadata is supported."
msgstr "JDK 5.0 在语言级别引入了 XDoclet 风格的标注，并且是类型安全的，在编译期进行检查。这一机制比 XDoclet 的注解更为强大，有更好的工具和 IDE 支持。例如，IntelliJ IDEA，支持 JDK 5.0 注解的自动完成和语法高亮 。EJB 规范的新修订版 (JSR-220) 使用 JDK 5.0 的注解作为entity beans的主要元数据（metadata）机制。Hibernate 3 实现了JSR-220(the persistence API) 的 <literal>EntityManager</literal>，支持通过 <emphasis>Hibernate Annotations</emphasis> 包定义映射元数据。这个包作为单独的部分下载，支持 EJB3(JSR-220) 和 Hibernate3 的元数据。 "

#. Tag: para
#, no-c-format
msgid "This is an example of a POJO class annotated as an EJB entity bean:"
msgstr "这是一个被注解为 EJB entity bean 的 POJO 类的例子"

#. Tag: para
#, no-c-format
msgid "Support for JDK 5.0 Annotations (and JSR-220) is currently under development. Please refer to the Hibernate Annotations module for more details."
msgstr "注意：对 JDK 5.0 注解（和 JSR-220)支持的工作仍然在进行中,并未完成。更多细节请参阅 Hibernate Annotations 模块。 "

#. Tag: title
#, no-c-format
msgid "Generated properties"
msgstr "数据库生成属性（Generated Properties） "

#. Tag: para
#, no-c-format
msgid "Generated properties are properties that have their values generated by the database. Typically, Hibernate applications needed to <literal>refresh</literal> objects that contain any properties for which the database was generating values. Marking properties as generated, however, lets the application delegate this responsibility to Hibernate. When Hibernate issues an SQL INSERT or UPDATE for an entity that has defined generated properties, it immediately issues a select afterwards to retrieve the generated values."
msgstr "Generated properties 指的是其值由数据库生成的属性。一般来说，如果对象有任何属性由数据库生成值，Hibernate 应用程序需要进行<literal>刷新（refresh）</literal>。但如果把属性标明为 generated，就可以转由 Hibernate 来负责这个动作。实际上。对定义了 generated properties 的实体,每当 Hibernate 执行一条 SQL INSERT 或者 UPDATE 语句，会立刻执行一条 select 来获得生成的值。 "

#. Tag: para
#, no-c-format
msgid "Properties marked as generated must additionally be non-insertable and non-updateable. Only <link linkend=\"mapping-declaration-version\">versions</link>, <link linkend=\"mapping-declaration-timestamp\">timestamps</link>, and <link linkend=\"mapping-declaration-property\">simple properties</link>, can be marked as generated."
msgstr "被标明为 generated 的属性还必须是 non-insertable 和 non-updateable 的。只有 <link linkend=\"mapping-declaration-version\">versions</link>、<link linkend=\"mapping-declaration-timestamp\">timestamps</link> 和 <link linkend=\"mapping-declaration-property\">simple properties</link> 可以被标明为 generated。 "

#. Tag: para
#, no-c-format
msgid "<literal>never</literal> (the default): the given property value is not generated within the database."
msgstr "<literal>never</literal>（默认）标明此属性值不是从数据库中生成。 "

#. Tag: para
#, no-c-format
msgid "<literal>insert</literal>: the given property value is generated on insert, but is not regenerated on subsequent updates. Properties like created-date fall into this category. Even though <link linkend=\"mapping-declaration-version\">version</link> and <link linkend=\"mapping-declaration-timestamp\">timestamp</link> properties can be marked as generated, this option is not available."
msgstr "<literal>insert</literal> — 标明此属性值在 insert 的时候生成，但是不会在随后的 update 时重新生成。比如说创建日期就归属于这类。注意虽然 <link linkend=\"mapping-declaration-version\">version</link> 和 <link linkend=\"mapping-declaration-timestamp\">timestamp</link> 属性可以被标注为 generated，但是不适用这个选项。"

#. Tag: para
#, no-c-format
msgid "<literal>always</literal>: the property value is generated both on insert and on update."
msgstr "<literal>always</literal> — 标明此属性值在 insert 和 update 时都会被生成。 "

#. Tag: title
#, no-c-format
msgid "Column read and write expressions"
msgstr "字段的读写表达式"

#. Tag: para
#, no-c-format
msgid "Hibernate allows you to customize the SQL it uses to read and write the values of columns mapped to <link linkend=\"mapping-declaration-property\">simple properties</link>. For example, if your database provides a set of data encryption functions, you can invoke them for individual columns like this: <programlisting role=\"XML\">&lt;property name=\"creditCardNumber\"&gt; &lt;column name=\"credit_card_num\" read=\"decrypt(credit_card_num)\" write=\"encrypt(?)\"/&gt; &lt;/property&gt;</programlisting>"
msgstr "Hibernate 允许你自定义 SQL 以读写映射<link linkend=\"mapping-declaration-property\">简单属性</link>的字段值。例如，如果你的数据库提供了一套数据加密方法，你可以在单个字段上调用它们：<programlisting role=\"XML\">&lt;property name=\"creditCardNumber\"&gt; &lt;column name=\"credit_card_num\" read=\"decrypt(credit_card_num)\" write=\"encrypt(?)\"/&gt; &lt;/property&gt;</programlisting>"

#. Tag: para
#, no-c-format
msgid "Hibernate applies the custom expressions automatically whenever the property is referenced in a query. This functionality is similar to a derived-property <literal>formula</literal> with two differences:"
msgstr "每当属性在查询里被引用时，Hibernate 都自动应用自定义的表达式。这种功能和 derived-property <literal>formula</literal> 相似，但有两个不同的地方："

#. Tag: para
#, no-c-format
msgid "The property is backed by one or more columns that are exported as part of automatic schema generation."
msgstr "属性由一个或多个属性组成，它作为自动模式生成的一部分导出。"

#. Tag: para
#, no-c-format
msgid "The property is read-write, not read-only."
msgstr "属性是可读写的，非只读的。"

#. Tag: para
#, no-c-format
msgid "The <literal>write</literal> expression, if specified, must contain exactly one '?' placeholder for the value."
msgstr "如果指定了 <literal>write</literal> 表达式，它必须只包含一个“?”占位符。"

#. Tag: title
#, no-c-format
msgid "Auxiliary database objects"
msgstr "辅助数据库对象（Auxiliary Database Objects） "

#. Tag: para
#, no-c-format
msgid "Auxiliary database objects allow for the CREATE and DROP of arbitrary database objects. In conjunction with Hibernate's schema evolution tools, they have the ability to fully define a user schema within the Hibernate mapping files. Although designed specifically for creating and dropping things like triggers or stored procedures, any SQL command that can be run via a <literal>java.sql.Statement.execute()</literal> method is valid (for example, ALTERs, INSERTS, etc.). There are essentially two modes for defining auxiliary database objects:"
msgstr "允许 CREATE 和 DROP 任意数据库对象，与 Hibernate 的 schema 交互工具组合起来，可以提供在 Hibernate 映射文件中完全定义用户 schema 的能力。虽然这是为创建和销毁 trigger（触发器）或stored procedure（存储过程）等特别设计的，实际上任何可以在 <literal>java.sql.Statement.execute()</literal> 方法中执行的 SQL 命令都可以在此使用（比如ALTER, INSERT，等等）。本质上有两种模式来定义辅助数据库对象... "

#. Tag: para
#, no-c-format
msgid "The first mode is to explicitly list the CREATE and DROP commands in the mapping file:"
msgstr "第一种模式是在映射文件中显式声明 CREATE 和 DROP 命令： "

#. Tag: para
#, no-c-format
msgid "The second mode is to supply a custom class that constructs the CREATE and DROP commands. This custom class must implement the <literal>org.hibernate.mapping.AuxiliaryDatabaseObject</literal> interface."
msgstr "第二种模式是提供一个类，这个类知道如何组织 CREATE 和 DROP 命令。这个特别类必须实现 <literal>org.hibernate.mapping.AuxiliaryDatabaseObject</literal> 接口。 "

#. Tag: para
#, no-c-format
msgid "Additionally, these database objects can be optionally scoped so that they only apply when certain dialects are used."
msgstr "还有，这些数据库对象可以特别指定为仅在特定的方言中才使用。 "

#~ msgid ""
#~ "<![CDATA[<?xml version=\"1.0\"?>\n"
#~ "<!DOCTYPE hibernate-mapping PUBLIC\n"
#~ "      \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
#~ "          \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"
#~ "\">\n"
#~ "\n"
#~ "<hibernate-mapping package=\"eg\">\n"
#~ "\n"
#~ "        <class name=\"Cat\"\n"
#~ "            table=\"cats\"\n"
#~ "            discriminator-value=\"C\">\n"
#~ "\n"
#~ "                <id name=\"id\">\n"
#~ "                        <generator class=\"native\"/>\n"
#~ "                </id>\n"
#~ "\n"
#~ "                <discriminator column=\"subclass\"\n"
#~ "                     type=\"character\"/>\n"
#~ "\n"
#~ "                <property name=\"weight\"/>\n"
#~ "\n"
#~ "                <property name=\"birthdate\"\n"
#~ "                    type=\"date\"\n"
#~ "                    not-null=\"true\"\n"
#~ "                    update=\"false\"/>\n"
#~ "\n"
#~ "                <property name=\"color\"\n"
#~ "                    type=\"eg.types.ColorUserType\"\n"
#~ "                    not-null=\"true\"\n"
#~ "                    update=\"false\"/>\n"
#~ "\n"
#~ "                <property name=\"sex\"\n"
#~ "                    not-null=\"true\"\n"
#~ "                    update=\"false\"/>\n"
#~ "\n"
#~ "                <property name=\"litterId\"\n"
#~ "                    column=\"litterId\"\n"
#~ "                    update=\"false\"/>\n"
#~ "\n"
#~ "                <many-to-one name=\"mother\"\n"
#~ "                    column=\"mother_id\"\n"
#~ "                    update=\"false\"/>\n"
#~ "\n"
#~ "                <set name=\"kittens\"\n"
#~ "                    inverse=\"true\"\n"
#~ "                    order-by=\"litter_id\">\n"
#~ "                        <key column=\"mother_id\"/>\n"
#~ "                        <one-to-many class=\"Cat\"/>\n"
#~ "                </set>\n"
#~ "\n"
#~ "                <subclass name=\"DomesticCat\"\n"
#~ "                    discriminator-value=\"D\">\n"
#~ "\n"
#~ "                        <property name=\"name\"\n"
#~ "                            type=\"string\"/>\n"
#~ "\n"
#~ "                </subclass>\n"
#~ "\n"
#~ "        </class>\n"
#~ "\n"
#~ "        <class name=\"Dog\">\n"
#~ "                <!-- mapping for Dog could go here -->\n"
#~ "        </class>\n"
#~ "\n"
#~ "</hibernate-mapping>]]>"
#~ msgstr ""
#~ "<![CDATA[<?xml version=\"1.0\"?>\n"
#~ "<!DOCTYPE hibernate-mapping PUBLIC\n"
#~ "      \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
#~ "          \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"
#~ "\">\n"
#~ "\n"
#~ "<hibernate-mapping package=\"eg\">\n"
#~ "\n"
#~ "        <class name=\"Cat\"\n"
#~ "            table=\"cats\"\n"
#~ "            discriminator-value=\"C\">\n"
#~ "\n"
#~ "                <id name=\"id\">\n"
#~ "                        <generator class=\"native\"/>\n"
#~ "                </id>\n"
#~ "\n"
#~ "                <discriminator column=\"subclass\"\n"
#~ "                     type=\"character\"/>\n"
#~ "\n"
#~ "                <property name=\"weight\"/>\n"
#~ "\n"
#~ "                <property name=\"birthdate\"\n"
#~ "                    type=\"date\"\n"
#~ "                    not-null=\"true\"\n"
#~ "                    update=\"false\"/>\n"
#~ "\n"
#~ "                <property name=\"color\"\n"
#~ "                    type=\"eg.types.ColorUserType\"\n"
#~ "                    not-null=\"true\"\n"
#~ "                    update=\"false\"/>\n"
#~ "\n"
#~ "                <property name=\"sex\"\n"
#~ "                    not-null=\"true\"\n"
#~ "                    update=\"false\"/>\n"
#~ "\n"
#~ "                <property name=\"litterId\"\n"
#~ "                    column=\"litterId\"\n"
#~ "                    update=\"false\"/>\n"
#~ "\n"
#~ "                <many-to-one name=\"mother\"\n"
#~ "                    column=\"mother_id\"\n"
#~ "                    update=\"false\"/>\n"
#~ "\n"
#~ "                <set name=\"kittens\"\n"
#~ "                    inverse=\"true\"\n"
#~ "                    order-by=\"litter_id\">\n"
#~ "                        <key column=\"mother_id\"/>\n"
#~ "                        <one-to-many class=\"Cat\"/>\n"
#~ "                </set>\n"
#~ "\n"
#~ "                <subclass name=\"DomesticCat\"\n"
#~ "                    discriminator-value=\"D\">\n"
#~ "\n"
#~ "                        <property name=\"name\"\n"
#~ "                            type=\"string\"/>\n"
#~ "\n"
#~ "                </subclass>\n"
#~ "\n"
#~ "        </class>\n"
#~ "\n"
#~ "        <class name=\"Dog\">\n"
#~ "                <!-- mapping for Dog could go here -->\n"
#~ "        </class>\n"
#~ "\n"
#~ "</hibernate-mapping>]]>"

#~ msgid ""
#~ "<![CDATA[<?xml version=\"1.0\"?>\n"
#~ "<!DOCTYPE hibernate-mapping PUBLIC\n"
#~ "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
#~ "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\" [\n"
#~ "    <!ENTITY types SYSTEM \"classpath://your/domain/types.xml\">\n"
#~ "]>\n"
#~ "\n"
#~ "<hibernate-mapping package=\"your.domain\">\n"
#~ "    <class name=\"MyEntity\">\n"
#~ "        <id name=\"id\" type=\"my-custom-id-type\">\n"
#~ "            ...\n"
#~ "        </id>\n"
#~ "    <class>\n"
#~ "    &types;\n"
#~ "</hibernate-mapping>]]>"
#~ msgstr ""
#~ "<![CDATA[<?xml version=\"1.0\"?>\n"
#~ "<!DOCTYPE hibernate-mapping PUBLIC\n"
#~ "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
#~ "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\" [\n"
#~ "    <!ENTITY types SYSTEM \"classpath://your/domain/types.xml\">\n"
#~ "]>\n"
#~ "\n"
#~ "<hibernate-mapping package=\"your.domain\">\n"
#~ "    <class name=\"MyEntity\">\n"
#~ "        <id name=\"id\" type=\"my-custom-id-type\">\n"
#~ "            ...\n"
#~ "        </id>\n"
#~ "    <class>\n"
#~ "    &types;\n"
#~ "</hibernate-mapping>]]>"

#~ msgid ""
#~ "<![CDATA[<hibernate-mapping\n"
#~ "         schema=\"schemaName\"\n"
#~ "         catalog=\"catalogName\"\n"
#~ "         default-cascade=\"cascade_style\"\n"
#~ "         default-access=\"field|property|ClassName\"\n"
#~ "         default-lazy=\"true|false\"\n"
#~ "         auto-import=\"true|false\"\n"
#~ "         package=\"package.name\"\n"
#~ " />]]>"
#~ msgstr ""
#~ "<![CDATA[<hibernate-mapping\n"
#~ "         schema=\"schemaName\"\n"
#~ "         catalog=\"catalogName\"\n"
#~ "         default-cascade=\"cascade_style\"\n"
#~ "         default-access=\"field|property|ClassName\"\n"
#~ "         default-lazy=\"true|false\"\n"
#~ "         auto-import=\"true|false\"\n"
#~ "         package=\"package.name\"\n"
#~ " />]]>"

#~ msgid ""
#~ "<![CDATA[<class\n"
#~ "        name=\"ClassName\"\n"
#~ "        table=\"tableName\"\n"
#~ "        discriminator-value=\"discriminator_value\"\n"
#~ "        mutable=\"true|false\"\n"
#~ "        schema=\"owner\"\n"
#~ "        catalog=\"catalog\"\n"
#~ "        proxy=\"ProxyInterface\"\n"
#~ "        dynamic-update=\"true|false\"\n"
#~ "        dynamic-insert=\"true|false\"\n"
#~ "        select-before-update=\"true|false\"\n"
#~ "        polymorphism=\"implicit|explicit\"\n"
#~ "        where=\"arbitrary sql where condition\"\n"
#~ "        persister=\"PersisterClass\"\n"
#~ "        batch-size=\"N\"\n"
#~ "        optimistic-lock=\"none|version|dirty|all\"\n"
#~ "        lazy=\"true|false\"\n"
#~ "        entity-name=\"EntityName\"\n"
#~ "        check=\"arbitrary sql check condition\"\n"
#~ "        rowid=\"rowid\"\n"
#~ "        subselect=\"SQL expression\"\n"
#~ "        abstract=\"true|false\"\n"
#~ "        node=\"element-name\"\n"
#~ "/>]]>"
#~ msgstr ""
#~ "<![CDATA[<class\n"
#~ "        name=\"ClassName\"\n"
#~ "        table=\"tableName\"\n"
#~ "        discriminator-value=\"discriminator_value\"\n"
#~ "        mutable=\"true|false\"\n"
#~ "        schema=\"owner\"\n"
#~ "        catalog=\"catalog\"\n"
#~ "        proxy=\"ProxyInterface\"\n"
#~ "        dynamic-update=\"true|false\"\n"
#~ "        dynamic-insert=\"true|false\"\n"
#~ "        select-before-update=\"true|false\"\n"
#~ "        polymorphism=\"implicit|explicit\"\n"
#~ "        where=\"arbitrary sql where condition\"\n"
#~ "        persister=\"PersisterClass\"\n"
#~ "        batch-size=\"N\"\n"
#~ "        optimistic-lock=\"none|version|dirty|all\"\n"
#~ "        lazy=\"true|false\"\n"
#~ "        entity-name=\"EntityName\"\n"
#~ "        check=\"arbitrary sql check condition\"\n"
#~ "        rowid=\"rowid\"\n"
#~ "        subselect=\"SQL expression\"\n"
#~ "        abstract=\"true|false\"\n"
#~ "        node=\"element-name\"\n"
#~ "/>]]>"

#~ msgid ""
#~ "<![CDATA[<class name=\"Summary\">\n"
#~ "    <subselect>\n"
#~ "        select item.name, max(bid.amount), count(*)\n"
#~ "        from item\n"
#~ "        join bid on bid.item_id = item.id\n"
#~ "        group by item.name\n"
#~ "    </subselect>\n"
#~ "    <synchronize table=\"item\"/>\n"
#~ "    <synchronize table=\"bid\"/>\n"
#~ "    <id name=\"name\"/>\n"
#~ "    ...\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "<![CDATA[<class name=\"Summary\">\n"
#~ "    <subselect>\n"
#~ "        select item.name, max(bid.amount), count(*)\n"
#~ "        from item\n"
#~ "        join bid on bid.item_id = item.id\n"
#~ "        group by item.name\n"
#~ "    </subselect>\n"
#~ "    <synchronize table=\"item\"/>\n"
#~ "    <synchronize table=\"bid\"/>\n"
#~ "    <id name=\"name\"/>\n"
#~ "    ...\n"
#~ "</class>]]>"

#~ msgid ""
#~ "<![CDATA[<id\n"
#~ "        name=\"propertyName\"\n"
#~ "        type=\"typename\"\n"
#~ "        column=\"column_name\"\n"
#~ "        unsaved-value=\"null|any|none|undefined|id_value\"\n"
#~ "        access=\"field|property|ClassName\">\n"
#~ "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
#~ "\n"
#~ "        <generator class=\"generatorClass\"/>\n"
#~ "</id>]]>"
#~ msgstr ""
#~ "<![CDATA[<id\n"
#~ "        name=\"propertyName\"\n"
#~ "        type=\"typename\"\n"
#~ "        column=\"column_name\"\n"
#~ "        unsaved-value=\"null|any|none|undefined|id_value\"\n"
#~ "        access=\"field|property|ClassName\">\n"
#~ "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
#~ "\n"
#~ "        <generator class=\"generatorClass\"/>\n"
#~ "</id>]]>"

#~ msgid ""
#~ "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
#~ "        <generator class=\"org.hibernate.id.TableHiLoGenerator\">\n"
#~ "                <param name=\"table\">uid_table</param>\n"
#~ "                <param name=\"column\">next_hi_value_column</param>\n"
#~ "        </generator>\n"
#~ "</id>]]>"
#~ msgstr ""
#~ "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
#~ "        <generator class=\"org.hibernate.id.TableHiLoGenerator\">\n"
#~ "                <param name=\"table\">uid_table</param>\n"
#~ "                <param name=\"column\">next_hi_value_column</param>\n"
#~ "        </generator>\n"
#~ "</id>]]>"

#~ msgid "increment"
#~ msgstr "increment"

#~ msgid "identity"
#~ msgstr "identity"

#~ msgid "sequence"
#~ msgstr "sequence"

#~ msgid "hilo"
#~ msgstr "hilo"

#~ msgid "seqhilo"
#~ msgstr "seqhilo"

#~ msgid "guid"
#~ msgstr "guid"

#~ msgid "native"
#~ msgstr "native"

#~ msgid "assigned"
#~ msgstr "assigned"

#~ msgid "select"
#~ msgstr "select"

#~ msgid "foreign"
#~ msgstr "foreign"

#~ msgid ""
#~ "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
#~ "        <generator class=\"hilo\">\n"
#~ "                <param name=\"table\">hi_value</param>\n"
#~ "                <param name=\"column\">next_value</param>\n"
#~ "                <param name=\"max_lo\">100</param>\n"
#~ "        </generator>\n"
#~ "</id>]]>"
#~ msgstr ""
#~ "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
#~ "        <generator class=\"hilo\">\n"
#~ "                <param name=\"table\">hi_value</param>\n"
#~ "                <param name=\"column\">next_value</param>\n"
#~ "                <param name=\"max_lo\">100</param>\n"
#~ "        </generator>\n"
#~ "</id>]]>"

#~ msgid ""
#~ "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
#~ "        <generator class=\"seqhilo\">\n"
#~ "                <param name=\"sequence\">hi_value</param>\n"
#~ "                <param name=\"max_lo\">100</param>\n"
#~ "        </generator>\n"
#~ "</id>]]>"
#~ msgstr ""
#~ "<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
#~ "        <generator class=\"seqhilo\">\n"
#~ "                <param name=\"sequence\">hi_value</param>\n"
#~ "                <param name=\"max_lo\">100</param>\n"
#~ "        </generator>\n"
#~ "</id>]]>"

#~ msgid ""
#~ "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
#~ "        <generator class=\"sequence\">\n"
#~ "                <param name=\"sequence\">person_id_sequence</param>\n"
#~ "        </generator>\n"
#~ "</id>]]>"
#~ msgstr ""
#~ "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
#~ "        <generator class=\"sequence\">\n"
#~ "                <param name=\"sequence\">person_id_sequence</param>\n"
#~ "        </generator>\n"
#~ "</id>]]>"

#~ msgid ""
#~ "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\" unsaved-value="
#~ "\"0\">\n"
#~ "        <generator class=\"identity\"/>\n"
#~ "</id>]]>"
#~ msgstr ""
#~ "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\" unsaved-value="
#~ "\"0\">\n"
#~ "        <generator class=\"identity\"/>\n"
#~ "</id>]]>"

#~ msgid ""
#~ "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
#~ "        <generator class=\"select\">\n"
#~ "                <param name=\"key\">socialSecurityNumber</param>\n"
#~ "        </generator>\n"
#~ "</id>]]>"
#~ msgstr ""
#~ "<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
#~ "        <generator class=\"select\">\n"
#~ "                <param name=\"key\">socialSecurityNumber</param>\n"
#~ "        </generator>\n"
#~ "</id>]]>"

#~ msgid ""
#~ "<![CDATA[<composite-id\n"
#~ "        name=\"propertyName\"\n"
#~ "        class=\"ClassName\"\n"
#~ "        mapped=\"true|false\"\n"
#~ "        access=\"field|property|ClassName\">\n"
#~ "        node=\"element-name|.\"\n"
#~ "\n"
#~ "        <key-property name=\"propertyName\" type=\"typename\" column="
#~ "\"column_name\"/>\n"
#~ "        <key-many-to-one name=\"propertyName class=\"ClassName\" column="
#~ "\"column_name\"/>\n"
#~ "        ......\n"
#~ "</composite-id>]]>"
#~ msgstr ""
#~ "<![CDATA[<composite-id\n"
#~ "        name=\"propertyName\"\n"
#~ "        class=\"ClassName\"\n"
#~ "        mapped=\"true|false\"\n"
#~ "        access=\"field|property|ClassName\">\n"
#~ "        node=\"element-name|.\"\n"
#~ "\n"
#~ "        <key-property name=\"propertyName\" type=\"typename\" column="
#~ "\"column_name\"/>\n"
#~ "        <key-many-to-one name=\"propertyName class=\"ClassName\" column="
#~ "\"column_name\"/>\n"
#~ "        ......\n"
#~ "</composite-id>]]>"

#~ msgid ""
#~ "<![CDATA[<composite-id>\n"
#~ "        <key-property name=\"medicareNumber\"/>\n"
#~ "        <key-property name=\"dependent\"/>\n"
#~ "</composite-id>]]>"
#~ msgstr ""
#~ "<![CDATA[<composite-id>\n"
#~ "        <key-property name=\"medicareNumber\"/>\n"
#~ "        <key-property name=\"dependent\"/>\n"
#~ "</composite-id>]]>"

#~ msgid ""
#~ "<![CDATA[<composite-id class=\"MedicareId\" mapped=\"true\">\n"
#~ "        <key-property name=\"medicareNumber\"/>\n"
#~ "        <key-property name=\"dependent\"/>\n"
#~ "</composite-id>]]>"
#~ msgstr ""
#~ "<![CDATA[<composite-id class=\"MedicareId\" mapped=\"true\">\n"
#~ "        <key-property name=\"medicareNumber\"/>\n"
#~ "        <key-property name=\"dependent\"/>\n"
#~ "</composite-id>]]>"

#~ msgid ""
#~ "<![CDATA[<discriminator\n"
#~ "        column=\"discriminator_column\"\n"
#~ "        type=\"discriminator_type\"\n"
#~ "        force=\"true|false\"\n"
#~ "        insert=\"true|false\"\n"
#~ "        formula=\"arbitrary sql expression\"\n"
#~ "/>]]>"
#~ msgstr ""
#~ "<![CDATA[<discriminator\n"
#~ "        column=\"discriminator_column\"\n"
#~ "        type=\"discriminator_type\"\n"
#~ "        force=\"true|false\"\n"
#~ "        insert=\"true|false\"\n"
#~ "        formula=\"arbitrary sql expression\"\n"
#~ "/>]]>"

#~ msgid ""
#~ "<![CDATA[<discriminator\n"
#~ "    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
#~ "\"\n"
#~ "    type=\"integer\"/>]]>"
#~ msgstr ""
#~ "<![CDATA[<discriminator\n"
#~ "    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
#~ "\"\n"
#~ "    type=\"integer\"/>]]>"

#~ msgid ""
#~ "<![CDATA[<version\n"
#~ "        column=\"version_column\"\n"
#~ "        name=\"propertyName\"\n"
#~ "        type=\"typename\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        unsaved-value=\"null|negative|undefined\"\n"
#~ "        generated=\"never|always\"\n"
#~ "        insert=\"true|false\"\n"
#~ "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
#~ "/>]]>"
#~ msgstr ""
#~ "<![CDATA[<version\n"
#~ "        column=\"version_column\"\n"
#~ "        name=\"propertyName\"\n"
#~ "        type=\"typename\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        unsaved-value=\"null|negative|undefined\"\n"
#~ "        generated=\"never|always\"\n"
#~ "        insert=\"true|false\"\n"
#~ "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
#~ "/>]]>"

#~ msgid ""
#~ "<![CDATA[<timestamp\n"
#~ "        column=\"timestamp_column\"\n"
#~ "        name=\"propertyName\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        unsaved-value=\"null|undefined\"\n"
#~ "        source=\"vm|db\"\n"
#~ "        generated=\"never|always\"\n"
#~ "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
#~ "/>]]>"
#~ msgstr ""
#~ "<![CDATA[<timestamp\n"
#~ "        column=\"timestamp_column\"\n"
#~ "        name=\"propertyName\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        unsaved-value=\"null|undefined\"\n"
#~ "        source=\"vm|db\"\n"
#~ "        generated=\"never|always\"\n"
#~ "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
#~ "/>]]>"

#~ msgid ""
#~ "<![CDATA[<property\n"
#~ "        name=\"propertyName\"\n"
#~ "        column=\"column_name\"\n"
#~ "        type=\"typename\"\n"
#~ "        update=\"true|false\"\n"
#~ "        insert=\"true|false\"\n"
#~ "        formula=\"arbitrary SQL expression\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        lazy=\"true|false\"\n"
#~ "        unique=\"true|false\"\n"
#~ "        not-null=\"true|false\"\n"
#~ "        optimistic-lock=\"true|false\"\n"
#~ "        generated=\"never|insert|always\"\n"
#~ "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
#~ "        index=\"index_name\"\n"
#~ "        unique_key=\"unique_key_id\"\n"
#~ "        length=\"L\"\n"
#~ "        precision=\"P\"\n"
#~ "        scale=\"S\"\n"
#~ "/>]]>"
#~ msgstr ""
#~ "<![CDATA[<property\n"
#~ "        name=\"propertyName\"\n"
#~ "        column=\"column_name\"\n"
#~ "        type=\"typename\"\n"
#~ "        update=\"true|false\"\n"
#~ "        insert=\"true|false\"\n"
#~ "        formula=\"arbitrary SQL expression\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        lazy=\"true|false\"\n"
#~ "        unique=\"true|false\"\n"
#~ "        not-null=\"true|false\"\n"
#~ "        optimistic-lock=\"true|false\"\n"
#~ "        generated=\"never|insert|always\"\n"
#~ "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
#~ "        index=\"index_name\"\n"
#~ "        unique_key=\"unique_key_id\"\n"
#~ "        length=\"L\"\n"
#~ "        precision=\"P\"\n"
#~ "        scale=\"S\"\n"
#~ "/>]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[\n"
#~ "<property name=\"totalPrice\"\n"
#~ "    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, "
#~ "Product p\n"
#~ "                WHERE li.productId = p.productId\n"
#~ "                AND li.customerId = customerId\n"
#~ "                AND li.orderNumber = orderNumber )\"/>]]>"
#~ msgstr ""
#~ "&lt;property name=\"totalPrice\"\n"
#~ "    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, "
#~ "Product p\n"
#~ "                WHERE li.productId = p.productId\n"
#~ "                AND li.customerId = customerId\n"
#~ "                AND li.orderNumber = orderNumber )\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<many-to-one\n"
#~ "        name=\"propertyName\"\n"
#~ "        column=\"column_name\"\n"
#~ "        class=\"ClassName\"\n"
#~ "        cascade=\"cascade_style\"\n"
#~ "        fetch=\"join|select\"\n"
#~ "        update=\"true|false\"\n"
#~ "        insert=\"true|false\"\n"
#~ "        property-ref=\"propertyNameFromAssociatedClass\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        unique=\"true|false\"\n"
#~ "        not-null=\"true|false\"\n"
#~ "        optimistic-lock=\"true|false\"\n"
#~ "        lazy=\"proxy|no-proxy|false\"\n"
#~ "        not-found=\"ignore|exception\"\n"
#~ "        entity-name=\"EntityName\"\n"
#~ "        formula=\"arbitrary SQL expression\"\n"
#~ "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
#~ "        embed-xml=\"true|false\"\n"
#~ "        index=\"index_name\"\n"
#~ "        unique_key=\"unique_key_id\"\n"
#~ "        foreign-key=\"foreign_key_name\"\n"
#~ "/>]]>"
#~ msgstr ""
#~ "&lt;many-to-one\n"
#~ "        name=\"propertyName\"\n"
#~ "        column=\"column_name\"\n"
#~ "        class=\"ClassName\"\n"
#~ "        cascade=\"cascade_style\"\n"
#~ "        fetch=\"join|select\"\n"
#~ "        update=\"true|false\"\n"
#~ "        insert=\"true|false\"\n"
#~ "        property-ref=\"propertyNameFromAssociatedClass\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        unique=\"true|false\"\n"
#~ "        not-null=\"true|false\"\n"
#~ "        optimistic-lock=\"true|false\"\n"
#~ "        lazy=\"proxy|no-proxy|false\"\n"
#~ "        not-found=\"ignore|exception\"\n"
#~ "        entity-name=\"EntityName\"\n"
#~ "        formula=\"arbitrary SQL expression\"\n"
#~ "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
#~ "        embed-xml=\"true|false\"\n"
#~ "        index=\"index_name\"\n"
#~ "        unique_key=\"unique_key_id\"\n"
#~ "        foreign-key=\"foreign_key_name\"\n"
#~ "/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<many-to-one name=\"product\" class=\"Product\" column="
#~ "\"PRODUCT_ID\"/>]]>"
#~ msgstr ""
#~ "&lt;many-to-one name=\"product\" class=\"Product\" column=\"PRODUCT_ID\"/"
#~ "&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<property name=\"serialNumber\" unique=\"true\" type=\"string\" "
#~ "column=\"SERIAL_NUMBER\"/>]]>"
#~ msgstr ""
#~ "&lt;property name=\"serialNumber\" unique=\"true\" type=\"string\" column="
#~ "\"SERIAL_NUMBER\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<many-to-one name=\"product\" property-ref=\"serialNumber\" "
#~ "column=\"PRODUCT_SERIAL_NUMBER\"/>]]>"
#~ msgstr ""
#~ "&lt;many-to-one name=\"product\" property-ref=\"serialNumber\" column="
#~ "\"PRODUCT_SERIAL_NUMBER\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<many-to-one name=\"owner\" property-ref=\"identity.ssn\" column="
#~ "\"OWNER_SSN\"/>]]>"
#~ msgstr ""
#~ "&lt;many-to-one name=\"owner\" property-ref=\"identity.ssn\" column="
#~ "\"OWNER_SSN\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<one-to-one\n"
#~ "        name=\"propertyName\"\n"
#~ "        class=\"ClassName\"\n"
#~ "        cascade=\"cascade_style\"\n"
#~ "        constrained=\"true|false\"\n"
#~ "        fetch=\"join|select\"\n"
#~ "        property-ref=\"propertyNameFromAssociatedClass\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        formula=\"any SQL expression\"\n"
#~ "        lazy=\"proxy|no-proxy|false\"\n"
#~ "        entity-name=\"EntityName\"\n"
#~ "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
#~ "        embed-xml=\"true|false\"\n"
#~ "        foreign-key=\"foreign_key_name\"\n"
#~ "/>]]>"
#~ msgstr ""
#~ "&lt;one-to-one\n"
#~ "        name=\"propertyName\"\n"
#~ "        class=\"ClassName\"\n"
#~ "        cascade=\"cascade_style\"\n"
#~ "        constrained=\"true|false\"\n"
#~ "        fetch=\"join|select\"\n"
#~ "        property-ref=\"propertyNameFromAssociatedClass\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        formula=\"any SQL expression\"\n"
#~ "        lazy=\"proxy|no-proxy|false\"\n"
#~ "        entity-name=\"EntityName\"\n"
#~ "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
#~ "        embed-xml=\"true|false\"\n"
#~ "        foreign-key=\"foreign_key_name\"\n"
#~ "/&gt;"

#, fuzzy
#~ msgid "<![CDATA[<one-to-one name=\"person\" class=\"Person\"/>]]>"
#~ msgstr "&lt;one-to-one name=\"person\" class=\"Person\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<one-to-one name=\"employee\" class=\"Employee\" constrained="
#~ "\"true\"/>]]>"
#~ msgstr ""
#~ "&lt;one-to-one name=\"employee\" class=\"Employee\" constrained=\"true\"/"
#~ "&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"person\" table=\"PERSON\">\n"
#~ "    <id name=\"id\" column=\"PERSON_ID\">\n"
#~ "        <generator class=\"foreign\">\n"
#~ "            <param name=\"property\">employee</param>\n"
#~ "        </generator>\n"
#~ "    </id>\n"
#~ "    ...\n"
#~ "    <one-to-one name=\"employee\"\n"
#~ "        class=\"Employee\"\n"
#~ "        constrained=\"true\"/>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"person\" table=\"PERSON\"&gt;\n"
#~ "    &lt;id name=\"id\" column=\"PERSON_ID\"&gt;\n"
#~ "        &lt;generator class=\"foreign\"&gt;\n"
#~ "            &lt;param name=\"property\"&gt;employee&lt;/param&gt;\n"
#~ "        &lt;/generator&gt;\n"
#~ "    &lt;/id&gt;\n"
#~ "    ...\n"
#~ "    &lt;one-to-one name=\"employee\"\n"
#~ "        class=\"Employee\"\n"
#~ "        constrained=\"true\"/&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<many-to-one name=\"person\" class=\"Person\" column=\"PERSON_ID"
#~ "\" unique=\"true\"/>]]>"
#~ msgstr ""
#~ "&lt;many-to-one name=\"person\" class=\"Person\" column=\"PERSON_ID\" "
#~ "unique=\"true\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<one-to-one name=\"employee\" class=\"Employee\" property-ref="
#~ "\"person\"/>]]>"
#~ msgstr ""
#~ "&lt;one-to-one name\"employee\" class=\"Employee\" property-ref=\"person"
#~ "\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<natural-id mutable=\"true|false\"/>\n"
#~ "        <property ... />\n"
#~ "        <many-to-one ... />\n"
#~ "        ......\n"
#~ "</natural-id>]]>"
#~ msgstr ""
#~ "&lt;natural-id mutable=\"true|false\"/&gt;\n"
#~ "        &lt;property ... /&gt;\n"
#~ "        &lt;many-to-one ... /&gt;\n"
#~ "        ......\n"
#~ "&lt;/natural-id&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<component\n"
#~ "        name=\"propertyName\"\n"
#~ "        class=\"className\"\n"
#~ "        insert=\"true|false\"\n"
#~ "        update=\"true|false\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        lazy=\"true|false\"\n"
#~ "        optimistic-lock=\"true|false\"\n"
#~ "        unique=\"true|false\"\n"
#~ "        node=\"element-name|.\"\n"
#~ ">\n"
#~ "\n"
#~ "        <property ...../>\n"
#~ "        <many-to-one .... />\n"
#~ "        ........\n"
#~ "</component>]]>"
#~ msgstr ""
#~ "&lt;component \n"
#~ "        name=\"propertyName\" \n"
#~ "        class=\"className\"\n"
#~ "        insert=\"true|false\"\n"
#~ "        update=\"true|false\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        lazy=\"true|false\"\n"
#~ "        optimistic-lock=\"true|false\"\n"
#~ "        unique=\"true|false\"\n"
#~ "        node=\"element-name|.\"\n"
#~ "&gt;\n"
#~ "        \n"
#~ "        &lt;property ...../&gt;\n"
#~ "        &lt;many-to-one .... /&gt;\n"
#~ "        ........\n"
#~ "&lt;/component&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<properties\n"
#~ "        name=\"logicalName\"\n"
#~ "        insert=\"true|false\"\n"
#~ "        update=\"true|false\"\n"
#~ "        optimistic-lock=\"true|false\"\n"
#~ "        unique=\"true|false\"\n"
#~ ">\n"
#~ "\n"
#~ "        <property ...../>\n"
#~ "        <many-to-one .... />\n"
#~ "        ........\n"
#~ "</properties>]]>"
#~ msgstr ""
#~ "&lt;properties \n"
#~ "        name=\"logicalName\" \n"
#~ "        insert=\"true|false\"\n"
#~ "        update=\"true|false\"\n"
#~ "        optimistic-lock=\"true|false\"\n"
#~ "        unique=\"true|false\"\n"
#~ "&gt;\n"
#~ "        \n"
#~ "        &lt;property ...../&gt;\n"
#~ "        &lt;many-to-one .... /&gt;\n"
#~ "        ........\n"
#~ "&lt;/properties&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Person\">\n"
#~ "    <id name=\"personNumber\"/>\n"
#~ "\n"
#~ "    ...\n"
#~ "    <properties name=\"name\"\n"
#~ "            unique=\"true\" update=\"false\">\n"
#~ "        <property name=\"firstName\"/>\n"
#~ "        <property name=\"initial\"/>\n"
#~ "        <property name=\"lastName\"/>\n"
#~ "    </properties>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"Person\"&gt;\n"
#~ "    &lt;id name=\"personNumber\"/&gt;\n"
#~ "    ...\n"
#~ "    &lt;properties name=\"name\" \n"
#~ "            unique=\"true\" update=\"false\"&gt;\n"
#~ "        &lt;property name=\"firstName\"/&gt;\n"
#~ "        &lt;property name=\"initial\"/&gt;\n"
#~ "        &lt;property name=\"lastName\"/&gt;\n"
#~ "    &lt;/properties&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<many-to-one name=\"person\"\n"
#~ "         class=\"Person\" property-ref=\"name\">\n"
#~ "    <column name=\"firstName\"/>\n"
#~ "    <column name=\"initial\"/>\n"
#~ "    <column name=\"lastName\"/>\n"
#~ "</many-to-one>]]>"
#~ msgstr ""
#~ "&lt;many-to-one name=\"person\" \n"
#~ "         class=\"Person\" property-ref=\"name\"&gt;\n"
#~ "    &lt;column name=\"firstName\"/&gt;\n"
#~ "    &lt;column name=\"initial\"/&gt;\n"
#~ "    &lt;column name=\"lastName\"/&gt;\n"
#~ "&lt;/many-to-one&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<subclass\n"
#~ "        name=\"ClassName\"\n"
#~ "        discriminator-value=\"discriminator_value\"\n"
#~ "        proxy=\"ProxyInterface\"\n"
#~ "        lazy=\"true|false\"\n"
#~ "        dynamic-update=\"true|false\"\n"
#~ "        dynamic-insert=\"true|false\"\n"
#~ "        entity-name=\"EntityName\"\n"
#~ "        node=\"element-name\"\n"
#~ "        extends=\"SuperclassName\">\n"
#~ "\n"
#~ "        <property .... />\n"
#~ "        .....\n"
#~ "</subclass>]]>"
#~ msgstr ""
#~ "&lt;subclass\n"
#~ "        name=\"ClassName\"\n"
#~ "        discriminator-value=\"discriminator_value\"\n"
#~ "        proxy=\"ProxyInterface\"\n"
#~ "        lazy=\"true|false\"\n"
#~ "        dynamic-update=\"true|false\"\n"
#~ "        dynamic-insert=\"true|false\"\n"
#~ "        entity-name=\"EntityName\"\n"
#~ "        node=\"element-name\"\n"
#~ "        extends=\"SuperclassName\"&gt;\n"
#~ "\n"
#~ "        &lt;property .... /&gt;\n"
#~ "        .....\n"
#~ "&lt;/subclass&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<joined-subclass\n"
#~ "        name=\"ClassName\"\n"
#~ "        table=\"tablename\"\n"
#~ "        proxy=\"ProxyInterface\"\n"
#~ "        lazy=\"true|false\"\n"
#~ "        dynamic-update=\"true|false\"\n"
#~ "        dynamic-insert=\"true|false\"\n"
#~ "        schema=\"schema\"\n"
#~ "        catalog=\"catalog\"\n"
#~ "        extends=\"SuperclassName\"\n"
#~ "        persister=\"ClassName\"\n"
#~ "        subselect=\"SQL expression\"\n"
#~ "        entity-name=\"EntityName\"\n"
#~ "        node=\"element-name\">\n"
#~ "\n"
#~ "        <key .... >\n"
#~ "\n"
#~ "        <property .... />\n"
#~ "        .....\n"
#~ "</joined-subclass>]]>"
#~ msgstr ""
#~ "&lt;joined-subclass\n"
#~ "        name=\"ClassName\"\n"
#~ "        table=\"tablename\"\n"
#~ "        proxy=\"ProxyInterface\"\n"
#~ "        lazy=\"true|false\"\n"
#~ "        dynamic-update=\"true|false\"\n"
#~ "        dynamic-insert=\"true|false\"\n"
#~ "        schema=\"schema\"\n"
#~ "        catalog=\"catalog\"\n"
#~ "        extends=\"SuperclassName\"\n"
#~ "        persister=\"ClassName\"\n"
#~ "        subselect=\"SQL expression\"\n"
#~ "        entity-name=\"EntityName\"\n"
#~ "        node=\"element-name\"&gt;\n"
#~ "\n"
#~ "        &lt;key .... &gt;\n"
#~ "\n"
#~ "        &lt;property .... /&gt;\n"
#~ "        .....\n"
#~ "&lt;/joined-subclass&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<?xml version=\"1.0\"?>\n"
#~ "<!DOCTYPE hibernate-mapping PUBLIC\n"
#~ "        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
#~ "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
#~ "\n"
#~ "<hibernate-mapping package=\"eg\">\n"
#~ "\n"
#~ "        <class name=\"Cat\" table=\"CATS\">\n"
#~ "                <id name=\"id\" column=\"uid\" type=\"long\">\n"
#~ "                        <generator class=\"hilo\"/>\n"
#~ "                </id>\n"
#~ "                <property name=\"birthdate\" type=\"date\"/>\n"
#~ "                <property name=\"color\" not-null=\"true\"/>\n"
#~ "                <property name=\"sex\" not-null=\"true\"/>\n"
#~ "                <property name=\"weight\"/>\n"
#~ "                <many-to-one name=\"mate\"/>\n"
#~ "                <set name=\"kittens\">\n"
#~ "                        <key column=\"MOTHER\"/>\n"
#~ "                        <one-to-many class=\"Cat\"/>\n"
#~ "                </set>\n"
#~ "                <joined-subclass name=\"DomesticCat\" table="
#~ "\"DOMESTIC_CATS\">\n"
#~ "                    <key column=\"CAT\"/>\n"
#~ "                    <property name=\"name\" type=\"string\"/>\n"
#~ "                </joined-subclass>\n"
#~ "        </class>\n"
#~ "\n"
#~ "        <class name=\"eg.Dog\">\n"
#~ "                <!-- mapping for Dog could go here -->\n"
#~ "        </class>\n"
#~ "\n"
#~ "</hibernate-mapping>]]>"
#~ msgstr ""
#~ "&lt;?xml version=\"1.0\"?&gt;\n"
#~ "&lt;!DOCTYPE hibernate-mapping PUBLIC\n"
#~ "        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
#~ "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"
#~ "\"&gt;\n"
#~ "\n"
#~ "&lt;hibernate-mapping package=\"eg\"&gt;\n"
#~ "\n"
#~ "        &lt;class name=\"Cat\" table=\"CATS\"&gt;\n"
#~ "                &lt;id name=\"id\" column=\"uid\" type=\"long\"&gt;\n"
#~ "                        &lt;generator class=\"hilo\"/&gt;\n"
#~ "                &lt;/id&gt;\n"
#~ "                &lt;property name=\"birthdate\" type=\"date\"/&gt;\n"
#~ "                &lt;property name=\"color\" not-null=\"true\"/&gt;\n"
#~ "                &lt;property name=\"sex\" not-null=\"true\"/&gt;\n"
#~ "                &lt;property name=\"weight\"/&gt;\n"
#~ "                &lt;many-to-one name=\"mate\"/&gt;\n"
#~ "                &lt;set name=\"kittens\"&gt;\n"
#~ "                        &lt;key column=\"MOTHER\"/&gt;\n"
#~ "                        &lt;one-to-many class=\"Cat\"/&gt;\n"
#~ "                &lt;/set&gt;\n"
#~ "                &lt;joined-subclass name=\"DomesticCat\" table="
#~ "\"DOMESTIC_CATS\"&gt;\n"
#~ "                    &lt;key column=\"CAT\"/&gt;\n"
#~ "                    &lt;property name=\"name\" type=\"string\"/&gt;\n"
#~ "                &lt;/joined-subclass&gt;\n"
#~ "        &lt;/class&gt;\n"
#~ "\n"
#~ "        &lt;class name=\"eg.Dog\"&gt;\n"
#~ "                &lt;!-- mapping for Dog could go here --&gt;\n"
#~ "        &lt;/class&gt;\n"
#~ "\n"
#~ "&lt;/hibernate-mapping&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<union-subclass\n"
#~ "        name=\"ClassName\"\n"
#~ "        table=\"tablename\"\n"
#~ "        proxy=\"ProxyInterface\"\n"
#~ "        lazy=\"true|false\"\n"
#~ "        dynamic-update=\"true|false\"\n"
#~ "        dynamic-insert=\"true|false\"\n"
#~ "        schema=\"schema\"\n"
#~ "        catalog=\"catalog\"\n"
#~ "        extends=\"SuperclassName\"\n"
#~ "        abstract=\"true|false\"\n"
#~ "        persister=\"ClassName\"\n"
#~ "        subselect=\"SQL expression\"\n"
#~ "        entity-name=\"EntityName\"\n"
#~ "        node=\"element-name\">\n"
#~ "\n"
#~ "        <property .... />\n"
#~ "        .....\n"
#~ "</union-subclass>]]>"
#~ msgstr ""
#~ "&lt;union-subclass\n"
#~ "        name=\"ClassName\"\n"
#~ "        table=\"tablename\"\n"
#~ "        proxy=\"ProxyInterface\"\n"
#~ "        lazy=\"true|false\"\n"
#~ "        dynamic-update=\"true|false\"\n"
#~ "        dynamic-insert=\"true|false\"\n"
#~ "        schema=\"schema\"\n"
#~ "        catalog=\"catalog\"\n"
#~ "        extends=\"SuperclassName\"\n"
#~ "        abstract=\"true|false\"\n"
#~ "        persister=\"ClassName\"\n"
#~ "        subselect=\"SQL expression\"\n"
#~ "        entity-name=\"EntityName\"\n"
#~ "        node=\"element-name\"&gt;\n"
#~ "\n"
#~ "        &lt;property .... /&gt;\n"
#~ "        .....\n"
#~ "&lt;/union-subclass&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<join\n"
#~ "        table=\"tablename\"\n"
#~ "        schema=\"owner\"\n"
#~ "        catalog=\"catalog\"\n"
#~ "        fetch=\"join|select\"\n"
#~ "        inverse=\"true|false\"\n"
#~ "        optional=\"true|false\">\n"
#~ "\n"
#~ "        <key ... />\n"
#~ "\n"
#~ "        <property ... />\n"
#~ "        ...\n"
#~ "</join>]]>"
#~ msgstr ""
#~ "&lt;join\n"
#~ "        table=\"tablename\"\n"
#~ "        schema=\"owner\"\n"
#~ "        catalog=\"catalog\"\n"
#~ "        fetch=\"join|select\"\n"
#~ "        inverse=\"true|false\"\n"
#~ "        optional=\"true|false\"&gt;\n"
#~ "        \n"
#~ "        &lt;key ... /&gt;\n"
#~ "        \n"
#~ "        &lt;property ... /&gt;\n"
#~ "        ...\n"
#~ "&lt;/join&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Person\"\n"
#~ "    table=\"PERSON\">\n"
#~ "\n"
#~ "    <id name=\"id\" column=\"PERSON_ID\">...</id>\n"
#~ "\n"
#~ "    <join table=\"ADDRESS\">\n"
#~ "        <key column=\"ADDRESS_ID\"/>\n"
#~ "        <property name=\"address\"/>\n"
#~ "        <property name=\"zip\"/>\n"
#~ "        <property name=\"country\"/>\n"
#~ "    </join>\n"
#~ "    ...]]>"
#~ msgstr ""
#~ "&lt;class name=\"Person\"\n"
#~ "    table=\"PERSON\"&gt;\n"
#~ "\n"
#~ "    &lt;id name=\"id\" column=\"PERSON_ID\"&gt;...&lt;/id&gt;\n"
#~ "\n"
#~ "    &lt;join table=\"ADDRESS\"&gt;\n"
#~ "        &lt;key column=\"ADDRESS_ID\"/&gt;\n"
#~ "        &lt;property name=\"address\"/&gt;\n"
#~ "        &lt;property name=\"zip\"/&gt;\n"
#~ "        &lt;property name=\"country\"/&gt;\n"
#~ "    &lt;/join&gt;\n"
#~ "    ..."

#, fuzzy
#~ msgid "<title>Key</title>"
#~ msgstr "<title>键（key）</title>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<key\n"
#~ "        column=\"columnname\"\n"
#~ "        on-delete=\"noaction|cascade\"\n"
#~ "        property-ref=\"propertyName\"\n"
#~ "        not-null=\"true|false\"\n"
#~ "        update=\"true|false\"\n"
#~ "        unique=\"true|false\"\n"
#~ "/>]]>"
#~ msgstr ""
#~ "&lt;key\n"
#~ "        column=\"columnname\"\n"
#~ "        on-delete=\"noaction|cascade\"\n"
#~ "        property-ref=\"propertyName\"\n"
#~ "        not-null=\"true|false\"\n"
#~ "        update=\"true|false\"\n"
#~ "        unique=\"true|false\"\n"
#~ "/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<column\n"
#~ "        name=\"column_name\"\n"
#~ "        length=\"N\"\n"
#~ "        precision=\"N\"\n"
#~ "        scale=\"N\"\n"
#~ "        not-null=\"true|false\"\n"
#~ "        unique=\"true|false\"\n"
#~ "        unique-key=\"multicolumn_unique_key_name\"\n"
#~ "        index=\"index_name\"\n"
#~ "        sql-type=\"sql_type_name\"\n"
#~ "        check=\"SQL expression\"\n"
#~ "        default=\"SQL expression\"/>]]>"
#~ msgstr ""
#~ "&lt;column\n"
#~ "        name=\"column_name\"\n"
#~ "        length=\"N\"\n"
#~ "        precision=\"N\"\n"
#~ "        scale=\"N\"\n"
#~ "        not-null=\"true|false\"\n"
#~ "        unique=\"true|false\"\n"
#~ "        unique-key=\"multicolumn_unique_key_name\"\n"
#~ "        index=\"index_name\"\n"
#~ "        sql-type=\"sql_type_name\"\n"
#~ "        check=\"SQL expression\"\n"
#~ "        default=\"SQL expression\"/&gt;"

#, fuzzy
#~ msgid "<![CDATA[<formula>SQL expression</formula>]]>"
#~ msgstr "&lt;formula&gt;SQL expression&lt;/formula&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<many-to-one name=\"homeAddress\" class=\"Address\"\n"
#~ "        insert=\"false\" update=\"false\">\n"
#~ "    <column name=\"person_id\" not-null=\"true\" length=\"10\"/>\n"
#~ "    <formula>'MAILING'</formula>\n"
#~ "</many-to-one>]]>"
#~ msgstr ""
#~ "&lt;many-to-one name=\"homeAddress\" class=\"Address\"\n"
#~ "        insert=\"false\" update=\"false\"&gt;\n"
#~ "    &lt;column name=\"person_id\" not-null=\"true\" length=\"10\"/&gt;\n"
#~ "    &lt;formula&gt;'MAILING'&lt;/formula&gt;\n"
#~ "&lt;/many-to-one&gt;"

#, fuzzy
#~ msgid "<![CDATA[<import class=\"java.lang.Object\" rename=\"Universe\"/>]]>"
#~ msgstr "&lt;import class=\"java.lang.Object\" rename=\"Universe\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<import\n"
#~ "        class=\"ClassName\"\n"
#~ "        rename=\"ShortName\"\n"
#~ "/>]]>"
#~ msgstr ""
#~ "&lt;import\n"
#~ "        class=\"ClassName\"\n"
#~ "        rename=\"ShortName\"\n"
#~ "/&gt;"

#, fuzzy
#~ msgid "<title>Any</title>"
#~ msgstr "<title>any</title>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<any name=\"being\" id-type=\"long\" meta-type=\"string\">\n"
#~ "    <meta-value value=\"TBL_ANIMAL\" class=\"Animal\"/>\n"
#~ "    <meta-value value=\"TBL_HUMAN\" class=\"Human\"/>\n"
#~ "    <meta-value value=\"TBL_ALIEN\" class=\"Alien\"/>\n"
#~ "    <column name=\"table_name\"/>\n"
#~ "    <column name=\"id\"/>\n"
#~ "</any>]]>"
#~ msgstr ""
#~ "&lt;any name=\"being\" id-type=\"long\" meta-type=\"string\"&gt;\n"
#~ "    &lt;meta-value value=\"TBL_ANIMAL\" class=\"Animal\"/&gt;\n"
#~ "    &lt;meta-value value=\"TBL_HUMAN\" class=\"Human\"/&gt;\n"
#~ "    &lt;meta-value value=\"TBL_ALIEN\" class=\"Alien\"/&gt;\n"
#~ "    &lt;column name=\"table_name\"/&gt;\n"
#~ "    &lt;column name=\"id\"/&gt;\n"
#~ "&lt;/any&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<any\n"
#~ "        name=\"propertyName\"\n"
#~ "        id-type=\"idtypename\"\n"
#~ "        meta-type=\"metatypename\"\n"
#~ "        cascade=\"cascade_style\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        optimistic-lock=\"true|false\"\n"
#~ ">\n"
#~ "        <meta-value ... />\n"
#~ "        <meta-value ... />\n"
#~ "        .....\n"
#~ "        <column .... />\n"
#~ "        <column .... />\n"
#~ "        .....\n"
#~ "</any>]]>"
#~ msgstr ""
#~ "&lt;any\n"
#~ "        name=\"propertyName\"\n"
#~ "        id-type=\"idtypename\"\n"
#~ "        meta-type=\"metatypename\"\n"
#~ "        cascade=\"cascade_style\"\n"
#~ "        access=\"field|property|ClassName\"\n"
#~ "        optimistic-lock=\"true|false\"\n"
#~ "&gt;\n"
#~ "        &lt;meta-value ... /&gt;\n"
#~ "        &lt;meta-value ... /&gt;\n"
#~ "        .....\n"
#~ "        &lt;column .... /&gt;\n"
#~ "        &lt;column .... /&gt;\n"
#~ "        .....\n"
#~ "&lt;/any&gt;"

#~ msgid "string"
#~ msgstr "string"

#, fuzzy
#~ msgid "class"
#~ msgstr "子类（subclass）"

#~ msgid "binary"
#~ msgstr "binary"

#~ msgid "text"
#~ msgstr "text"

#~ msgid "serializable"
#~ msgstr "serializable"

#~ msgid "clob, blob"
#~ msgstr "clob, blob"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<property name=\"twoStrings\" type=\"org.hibernate.test."
#~ "DoubleStringType\">\n"
#~ "    <column name=\"first_string\"/>\n"
#~ "    <column name=\"second_string\"/>\n"
#~ "</property>]]>"
#~ msgstr ""
#~ "&lt;property name=\"twoStrings\" type=\"org.hibernate.test."
#~ "DoubleStringType\"&gt;\n"
#~ "    &lt;column name=\"first_string\"/&gt;\n"
#~ "    &lt;column name=\"second_string\"/&gt;\n"
#~ "&lt;/property&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<property name=\"priority\">\n"
#~ "    <type name=\"com.mycompany.usertypes.DefaultValueIntegerType\">\n"
#~ "        <param name=\"default\">0</param>\n"
#~ "    </type>\n"
#~ "</property>]]>"
#~ msgstr ""
#~ "&lt;property name=\"priority\"&gt;\n"
#~ "    &lt;type name=\"com.mycompany.usertypes.DefaultValueIntegerType"
#~ "\"&gt;\n"
#~ "        &lt;param name=\"default\"&gt;0&lt;/param&gt;\n"
#~ "    &lt;/type&gt;\n"
#~ "&lt;/property&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<typedef class=\"com.mycompany.usertypes.DefaultValueIntegerType"
#~ "\" name=\"default_zero\">\n"
#~ "    <param name=\"default\">0</param>\n"
#~ "</typedef>]]>"
#~ msgstr ""
#~ "&lt;typedef class=\"com.mycompany.usertypes.DefaultValueIntegerType\" "
#~ "name=\"default_zero\"&gt;\n"
#~ "    &lt;param name=\"default\"&gt;0&lt;/param&gt;\n"
#~ "&lt;/typedef&gt;"

#, fuzzy
#~ msgid "<![CDATA[<property name=\"priority\" type=\"default_zero\"/>]]>"
#~ msgstr "&lt;property name=\"priority\" type=\"default_zero\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Contract\" table=\"Contracts\"\n"
#~ "        entity-name=\"CurrentContract\">\n"
#~ "    ...\n"
#~ "    <set name=\"history\" inverse=\"true\"\n"
#~ "            order-by=\"effectiveEndDate desc\">\n"
#~ "        <key column=\"currentContractId\"/>\n"
#~ "        <one-to-many entity-name=\"HistoricalContract\"/>\n"
#~ "    </set>\n"
#~ "</class>\n"
#~ "\n"
#~ "<class name=\"Contract\" table=\"ContractHistory\"\n"
#~ "        entity-name=\"HistoricalContract\">\n"
#~ "    ...\n"
#~ "    <many-to-one name=\"currentContract\"\n"
#~ "            column=\"currentContractId\"\n"
#~ "            entity-name=\"CurrentContract\"/>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"Contract\" table=\"Contracts\" \n"
#~ "        entity-name=\"CurrentContract\"&gt;\n"
#~ "    ...\n"
#~ "    &lt;set name=\"history\" inverse=\"true\" \n"
#~ "            order-by=\"effectiveEndDate desc\"&gt;\n"
#~ "        &lt;key column=\"currentContractId\"/&gt;\n"
#~ "        &lt;one-to-many entity-name=\"HistoricalContract\"/&gt;\n"
#~ "    &lt;/set&gt;\n"
#~ "&lt;/class&gt;\n"
#~ "\n"
#~ "&lt;class name=\"Contract\" table=\"ContractHistory\" \n"
#~ "        entity-name=\"HistoricalContract\"&gt;\n"
#~ "    ...\n"
#~ "    &lt;many-to-one name=\"currentContract\" \n"
#~ "            column=\"currentContractId\" \n"
#~ "            entity-name=\"CurrentContract\"/&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"LineItem\" table=\"`Line Item`\">\n"
#~ "    <id name=\"id\" column=\"`Item Id`\"/><generator class=\"assigned\"/"
#~ "></id>\n"
#~ "    <property name=\"itemNumber\" column=\"`Item #`\"/>\n"
#~ "    ...\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"LineItem\" table=\"`Line Item`\"&gt;\n"
#~ "    &lt;id name=\"id\" column=\"`Item Id`\"/&gt;&lt;generator class="
#~ "\"assigned\"/&gt;&lt;/id&gt;\n"
#~ "    &lt;property name=\"itemNumber\" column=\"`Item #`\"/&gt;\n"
#~ "    ...\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[package eg;\n"
#~ "import java.util.Set;\n"
#~ "import java.util.Date;\n"
#~ "\n"
#~ "/**\n"
#~ " * @hibernate.class\n"
#~ " *  table=\"CATS\"\n"
#~ " */\n"
#~ "public class Cat {\n"
#~ "    private Long id; // identifier\n"
#~ "    private Date birthdate;\n"
#~ "    private Cat mother;\n"
#~ "    private Set kittens\n"
#~ "    private Color color;\n"
#~ "    private char sex;\n"
#~ "    private float weight;\n"
#~ "\n"
#~ "    /*\n"
#~ "     * @hibernate.id\n"
#~ "     *  generator-class=\"native\"\n"
#~ "     *  column=\"CAT_ID\"\n"
#~ "     */\n"
#~ "    public Long getId() {\n"
#~ "        return id;\n"
#~ "    }\n"
#~ "    private void setId(Long id) {\n"
#~ "        this.id=id;\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.many-to-one\n"
#~ "     *  column=\"PARENT_ID\"\n"
#~ "     */\n"
#~ "    public Cat getMother() {\n"
#~ "        return mother;\n"
#~ "    }\n"
#~ "    void setMother(Cat mother) {\n"
#~ "        this.mother = mother;\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"BIRTH_DATE\"\n"
#~ "     */\n"
#~ "    public Date getBirthdate() {\n"
#~ "        return birthdate;\n"
#~ "    }\n"
#~ "    void setBirthdate(Date date) {\n"
#~ "        birthdate = date;\n"
#~ "    }\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"WEIGHT\"\n"
#~ "     */\n"
#~ "    public float getWeight() {\n"
#~ "        return weight;\n"
#~ "    }\n"
#~ "    void setWeight(float weight) {\n"
#~ "        this.weight = weight;\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"COLOR\"\n"
#~ "     *  not-null=\"true\"\n"
#~ "     */\n"
#~ "    public Color getColor() {\n"
#~ "        return color;\n"
#~ "    }\n"
#~ "    void setColor(Color color) {\n"
#~ "        this.color = color;\n"
#~ "    }\n"
#~ "    /**\n"
#~ "     * @hibernate.set\n"
#~ "     *  inverse=\"true\"\n"
#~ "     *  order-by=\"BIRTH_DATE\"\n"
#~ "     * @hibernate.collection-key\n"
#~ "     *  column=\"PARENT_ID\"\n"
#~ "     * @hibernate.collection-one-to-many\n"
#~ "     */\n"
#~ "    public Set getKittens() {\n"
#~ "        return kittens;\n"
#~ "    }\n"
#~ "    void setKittens(Set kittens) {\n"
#~ "        this.kittens = kittens;\n"
#~ "    }\n"
#~ "    // addKitten not needed by Hibernate\n"
#~ "    public void addKitten(Cat kitten) {\n"
#~ "        kittens.add(kitten);\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"SEX\"\n"
#~ "     *  not-null=\"true\"\n"
#~ "     *  update=\"false\"\n"
#~ "     */\n"
#~ "    public char getSex() {\n"
#~ "        return sex;\n"
#~ "    }\n"
#~ "    void setSex(char sex) {\n"
#~ "        this.sex=sex;\n"
#~ "    }\n"
#~ "}]]>"
#~ msgstr ""
#~ "package eg;\n"
#~ "import java.util.Set;\n"
#~ "import java.util.Date;\n"
#~ "\n"
#~ "/**\n"
#~ " * @hibernate.class\n"
#~ " *  table=\"CATS\"\n"
#~ " */\n"
#~ "public class Cat {\n"
#~ "    private Long id; // identifier\n"
#~ "    private Date birthdate;\n"
#~ "    private Cat mother;\n"
#~ "    private Set kittens\n"
#~ "    private Color color;\n"
#~ "    private char sex;\n"
#~ "    private float weight;\n"
#~ "\n"
#~ "    /*\n"
#~ "     * @hibernate.id\n"
#~ "     *  generator-class=\"native\"\n"
#~ "     *  column=\"CAT_ID\"\n"
#~ "     */\n"
#~ "    public Long getId() {\n"
#~ "        return id;\n"
#~ "    }\n"
#~ "    private void setId(Long id) {\n"
#~ "        this.id=id;\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.many-to-one\n"
#~ "     *  column=\"PARENT_ID\"\n"
#~ "     */\n"
#~ "    public Cat getMother() {\n"
#~ "        return mother;\n"
#~ "    }\n"
#~ "    void setMother(Cat mother) {\n"
#~ "        this.mother = mother;\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"BIRTH_DATE\"\n"
#~ "     */\n"
#~ "    public Date getBirthdate() {\n"
#~ "        return birthdate;\n"
#~ "    }\n"
#~ "    void setBirthdate(Date date) {\n"
#~ "        birthdate = date;\n"
#~ "    }\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"WEIGHT\"\n"
#~ "     */\n"
#~ "    public float getWeight() {\n"
#~ "        return weight;\n"
#~ "    }\n"
#~ "    void setWeight(float weight) {\n"
#~ "        this.weight = weight;\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"COLOR\"\n"
#~ "     *  not-null=\"true\"\n"
#~ "     */\n"
#~ "    public Color getColor() {\n"
#~ "        return color;\n"
#~ "    }\n"
#~ "    void setColor(Color color) {\n"
#~ "        this.color = color;\n"
#~ "    }\n"
#~ "    /**\n"
#~ "     * @hibernate.set\n"
#~ "     *  inverse=\"true\"\n"
#~ "     *  order-by=\"BIRTH_DATE\"\n"
#~ "     * @hibernate.collection-key\n"
#~ "     *  column=\"PARENT_ID\"\n"
#~ "     * @hibernate.collection-one-to-many\n"
#~ "     */\n"
#~ "    public Set getKittens() {\n"
#~ "        return kittens;\n"
#~ "    }\n"
#~ "    void setKittens(Set kittens) {\n"
#~ "        this.kittens = kittens;\n"
#~ "    }\n"
#~ "    // addKitten not needed by Hibernate\n"
#~ "    public void addKitten(Cat kitten) {\n"
#~ "        kittens.add(kitten);\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"SEX\"\n"
#~ "     *  not-null=\"true\"\n"
#~ "     *  update=\"false\"\n"
#~ "     */\n"
#~ "    public char getSex() {\n"
#~ "        return sex;\n"
#~ "    }\n"
#~ "    void setSex(char sex) {\n"
#~ "        this.sex=sex;\n"
#~ "    }\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[@Entity(access = AccessType.FIELD)\n"
#~ "public class Customer implements Serializable {\n"
#~ "\n"
#~ "    @Id;\n"
#~ "    Long id;\n"
#~ "\n"
#~ "    String firstName;\n"
#~ "    String lastName;\n"
#~ "    Date birthday;\n"
#~ "\n"
#~ "    @Transient\n"
#~ "    Integer age;\n"
#~ "\n"
#~ "    @Embedded\n"
#~ "    private Address homeAddress;\n"
#~ "\n"
#~ "    @OneToMany(cascade=CascadeType.ALL)\n"
#~ "    @JoinColumn(name=\"CUSTOMER_ID\")\n"
#~ "    Set<Order> orders;\n"
#~ "\n"
#~ "    // Getter/setter and business methods\n"
#~ "}]]>"
#~ msgstr ""
#~ "@Entity(access = AccessType.FIELD)\n"
#~ "public class Customer implements Serializable {\n"
#~ "\n"
#~ "    @Id;\n"
#~ "    Long id;\n"
#~ "\n"
#~ "    String firstName;\n"
#~ "    String lastName;\n"
#~ "    Date birthday;\n"
#~ "\n"
#~ "    @Transient\n"
#~ "    Integer age;\n"
#~ "\n"
#~ "    @Embedded\n"
#~ "    private Address homeAddress;\n"
#~ "\n"
#~ "    @OneToMany(cascade=CascadeType.ALL)\n"
#~ "    @JoinColumn(name=\"CUSTOMER_ID\")\n"
#~ "    Set&lt;Order&gt; orders;\n"
#~ "\n"
#~ "    // Getter/setter and business methods\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<hibernate-mapping>\n"
#~ "    ...\n"
#~ "    <database-object>\n"
#~ "        <create>CREATE TRIGGER my_trigger ...</create>\n"
#~ "        <drop>DROP TRIGGER my_trigger</drop>\n"
#~ "    </database-object>\n"
#~ "</hibernate-mapping>]]>"
#~ msgstr ""
#~ "&lt;hibernate-mapping&gt;\n"
#~ "    ...\n"
#~ "    &lt;database-object&gt;\n"
#~ "        &lt;create&gt;CREATE TRIGGER my_trigger ...&lt;/create&gt;\n"
#~ "        &lt;drop&gt;DROP TRIGGER my_trigger&lt;/drop&gt;\n"
#~ "    &lt;/database-object&gt;\n"
#~ "&lt;/hibernate-mapping&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<hibernate-mapping>\n"
#~ "    ...\n"
#~ "    <database-object>\n"
#~ "        <definition class=\"MyTriggerDefinition\"/>\n"
#~ "    </database-object>\n"
#~ "</hibernate-mapping>]]>"
#~ msgstr ""
#~ "&lt;hibernate-mapping&gt;\n"
#~ "    ...\n"
#~ "    &lt;database-object&gt;\n"
#~ "        &lt;definition class=\"MyTriggerDefinition\"/&gt;\n"
#~ "    &lt;/database-object&gt;\n"
#~ "&lt;/hibernate-mapping&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<hibernate-mapping>\n"
#~ "    ...\n"
#~ "    <database-object>\n"
#~ "        <definition class=\"MyTriggerDefinition\"/>\n"
#~ "        <dialect-scope name=\"org.hibernate.dialect.Oracle9iDialect\"/>\n"
#~ "        <dialect-scope name=\"org.hibernate.dialect.Oracle10gDialect\"/>\n"
#~ "    </database-object>\n"
#~ "</hibernate-mapping>]]>"
#~ msgstr ""
#~ "&lt;hibernate-mapping&gt;\n"
#~ "    ...\n"
#~ "    &lt;database-object&gt;\n"
#~ "        &lt;definition class=\"MyTriggerDefinition\"/&gt;\n"
#~ "        &lt;dialect-scope name=\"org.hibernate.dialect.Oracle9Dialect\"/"
#~ "&gt;\n"
#~ "        &lt;dialect-scope name=\"org.hibernate.dialect.OracleDialect\"/"
#~ "&gt;\n"
#~ "    &lt;/database-object&gt;\n"
#~ "&lt;/hibernate-mapping&gt;"
