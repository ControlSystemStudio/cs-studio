# translation of performance.po to French
# Myriam Malga <mmalga@redhat.com>, 2007.
# Xi HUANG <xhuang@redhat.com>, 2007.
# Corina Roe <croe@redhat.com>, 2009, 2010.
# translation of Collection_Mapping.po to
msgid ""
msgstr ""
"Project-Id-Version: performance\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:15\n"
"PO-Revision-Date: 2010-01-05 09:38+1000\n"
"Last-Translator: Corina Roe <croe@redhat.com>\n"
"Language-Team: French <i18@redhat.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Improving performance"
msgstr "Améliorer les performances"

#. Tag: title
#, no-c-format
msgid "Fetching strategies"
msgstr "Stratégies de chargement"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate uses a <emphasis>fetching strategy</emphasis> to retrieve "
"associated objects if the application needs to navigate the association. "
"Fetch strategies can be declared in the O/R mapping metadata, or over-ridden "
"by a particular HQL or <literal>Criteria</literal> query."
msgstr ""
"Une <emphasis>stratégie de chargement</emphasis> est une stratégie que "
"Hibernate va utiliser pour récupérer des objets associés si l'application a "
"besoin de naviguer à travers une association. Les stratégies de chargement "
"peuvent être déclarées dans les méta-données de l'outil de mappage objet "
"relationnel, ou surchargées par une requête de type HQL ou "
"<literal>Criteria</literal> particulière."

#. Tag: para
#, no-c-format
msgid "Hibernate3 defines the following fetching strategies:"
msgstr "Hibernate3 définit les stratégies de chargement suivantes :"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Join fetching</emphasis>: Hibernate retrieves the associated "
"instance or collection in the same <literal>SELECT</literal>, using an "
"<literal>OUTER JOIN</literal>."
msgstr ""
"<emphasis>Chargement par jointure</emphasis> - Hibernate récupère l'instance "
"associée ou la collection dans un même <literal>SELECT</literal>, en "
"utilisant un <literal>OUTER JOIN</literal>. "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Select fetching</emphasis>: a second <literal>SELECT</literal> is "
"used to retrieve the associated entity or collection. Unless you explicitly "
"disable lazy fetching by specifying <literal>lazy=\"false\"</literal>, this "
"second select will only be executed when you access the association."
msgstr ""
"<emphasis>Chargement par select</emphasis> - Un second <literal>SELECT</"
"literal> est utilisé pour récupérer l'instance associée à l'entité ou à la "
"collection. À moins que vous ne désactiviez explicitement le chargement "
"différé en spécifiant <literal>lazy=\"false\"</literal>, ce second select ne "
"sera exécuté que lorsque vous accéderez réellement à l'association."

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Subselect fetching</emphasis>: a second <literal>SELECT</literal> "
"is used to retrieve the associated collections for all entities retrieved in "
"a previous query or fetch. Unless you explicitly disable lazy fetching by "
"specifying <literal>lazy=\"false\"</literal>, this second select will only "
"be executed when you access the association."
msgstr ""
"<emphasis>Chargement par sous-select</emphasis> - Un second <literal>SELECT</"
"literal> est utilisé pour récupérer les associations pour toutes les entités "
"récupérées dans une requête ou un chargement préalable. A moins que vous ne "
"désactiviez explicitement le chargement différé en spécifiant <literal>lazy="
"\"false\"</literal>, ce second select ne sera exécuté que lorsque vous "
"accéderez réellement à l'association. "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Batch fetching</emphasis>: an optimization strategy for select "
"fetching. Hibernate retrieves a batch of entity instances or collections in "
"a single <literal>SELECT</literal> by specifying a list of primary or "
"foreign keys."
msgstr ""
"<emphasis>Chargement par lot</emphasis> - Il s'agit d'une stratégie "
"d'optimisation pour le chargement par select - Hibernate récupère un lot "
"d'instances ou de collections en un seul <literal>SELECT</literal> en "
"spécifiant une liste de clés primaires ou de clés étrangères. "

#. Tag: para
#, no-c-format
msgid "Hibernate also distinguishes between:"
msgstr "Hibernate fait également la distinction entre :"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Immediate fetching</emphasis>: an association, collection or "
"attribute is fetched immediately when the owner is loaded."
msgstr ""
"<emphasis>Chargement immédiat</emphasis> - Une association, une collection "
"ou un attribut est chargé immédiatement lorsque l'objet auquel appartient "
"cet élément est chargé. "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Lazy collection fetching</emphasis>: a collection is fetched when "
"the application invokes an operation upon that collection. This is the "
"default for collections."
msgstr ""
"<emphasis>Chargement différé d'une collection</emphasis> - Une collection "
"est chargée lorsque l'application invoque une méthode sur cette collection "
"(il s'agit du mode de chargement par défaut pour les collections). "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>\"Extra-lazy\" collection fetching</emphasis>: individual elements "
"of the collection are accessed from the database as needed. Hibernate tries "
"not to fetch the whole collection into memory unless absolutely needed. It "
"is suitable for large collections."
msgstr ""
"<emphasis>Chargement \"super différé\" d'une collection</emphasis> - On "
"accède aux éléments de la collection depuis la base de données lorsque c'est "
"nécessaire. Hibernate essaie de ne pas charger toute la collection en "
"mémoire sauf si cela est absolument nécessaire (bien adapté aux très grandes "
"collections). "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Proxy fetching</emphasis>: a single-valued association is fetched "
"when a method other than the identifier getter is invoked upon the "
"associated object."
msgstr ""
"<emphasis>Chargement par proxy</emphasis> - Une association vers un seul "
"objet est chargée lorsqu'une méthode autre que le getter sur l'identifiant "
"est appelée sur l'objet associé."

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>\"No-proxy\" fetching</emphasis>: a single-valued association is "
"fetched when the instance variable is accessed. Compared to proxy fetching, "
"this approach is less lazy; the association is fetched even when only the "
"identifier is accessed. It is also more transparent, since no proxy is "
"visible to the application. This approach requires buildtime bytecode "
"instrumentation and is rarely necessary."
msgstr ""
"<emphasis>Chargement \"sans proxy\"</emphasis> - une association vers un "
"seul objet est chargée lorsque l'on accède à la variable d'instance. Par "
"rapport au chargement par proxy, cette approche est moins différée "
"(l'association est quand même chargée même si on n'accède qu'à "
"l'identifiant) mais plus transparente car il n'y a pas de proxy visible dans "
"l'application. Cette approche requiert une instrumentation du bytecode à la "
"compilation et est rarement nécessaire. "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Lazy attribute fetching</emphasis>: an attribute or single valued "
"association is fetched when the instance variable is accessed. This approach "
"requires buildtime bytecode instrumentation and is rarely necessary."
msgstr ""
"<emphasis>Chargement différé des attributs</emphasis> - Un attribut ou un "
"objet associé seul est chargé lorsque l'on accède à la variable d'instance. "
"Cette approche requiert une instrumentation du bytecode à la compilation et "
"est rarement nécessaire. "

#. Tag: para
#, no-c-format
msgid ""
"We have two orthogonal notions here: <emphasis>when</emphasis> is the "
"association fetched and <emphasis>how</emphasis> is it fetched. It is "
"important that you do not confuse them. We use <literal>fetch</literal> to "
"tune performance. We can use <literal>lazy</literal> to define a contract "
"for what data is always available in any detached instance of a particular "
"class."
msgstr ""
"Nous avons ici deux notions orthogonales : <emphasis>quand</emphasis> "
"l'association est chargée et <emphasis>comment</emphasis> (quelle requête "
"SQL est utilisée). Il ne faut pas les confondre. Le mode de chargement "
"<literal>fetch</literal> est utilisé pour améliorer les performances. On "
"peut utiliser le mode <literal>lazy</literal> pour définir un contrat sur "
"quelles données sont toujours accessibles sur toute instance détachée d'une "
"classe particulière. "

#. Tag: title
#, no-c-format
msgid "Working with lazy associations"
msgstr "Travailler avec des associations chargées en différé"

#. Tag: para
#, no-c-format
msgid ""
"By default, Hibernate3 uses lazy select fetching for collections and lazy "
"proxy fetching for single-valued associations. These defaults make sense for "
"most associations in the majority of applications."
msgstr ""
"Par défaut, Hibernate3 utilise le chargement différé par select pour les "
"collections et le chargement différé par proxy pour les associations vers un "
"seul objet. Ces valeurs par défaut sont valables pour la plupart des "
"associations dans la plupart des applications. "

#. Tag: para
#, no-c-format
msgid ""
"If you set <literal>hibernate.default_batch_fetch_size</literal>, Hibernate "
"will use the batch fetch optimization for lazy fetching. This optimization "
"can also be enabled at a more granular level."
msgstr ""
"Si vous définissez <literal>hibernate.default_batch_fetch_size</literal>, "
"Hibernate va utiliser l'optimisation du chargement par lot pour le "
"chargement différé (cette optimisation peut aussi être activée à un niveau "
"de granularité plus fin). "

#. Tag: para
#, no-c-format
msgid ""
"Please be aware that access to a lazy association outside of the context of "
"an open Hibernate session will result in an exception. For example:"
msgstr ""
"L'accès à une association définie comme \"différé\", hors du contexte d'une "
"session Hibernate ouverte, entraîne une exception. Par exemple : "

#. Tag: para
#, no-c-format
msgid ""
"Since the permissions collection was not initialized when the "
"<literal>Session</literal> was closed, the collection will not be able to "
"load its state. <emphasis>Hibernate does not support lazy initialization for "
"detached objects</emphasis>. This can be fixed by moving the code that reads "
"from the collection to just before the transaction is committed."
msgstr ""
"Étant donné que la collection des permissions n'a pas été initialisée avant "
"de fermer la <literal>Session</literal>, la collection n'est pas capable de "
"charger son état. <emphasis>Hibernate ne supporte pas le chargement différé "
"pour des objets détachés</emphasis>. La solution à ce problème est de "
"déplacer le code qui lit à partir de la collection avant le \"commit\" de la "
"transaction. "

#. Tag: para
#, no-c-format
msgid ""
"Alternatively, you can use a non-lazy collection or association, by "
"specifying <literal>lazy=\"false\"</literal> for the association mapping. "
"However, it is intended that lazy initialization be used for almost all "
"collections and associations. If you define too many non-lazy associations "
"in your object model, Hibernate will fetch the entire database into memory "
"in every transaction."
msgstr ""
"Une autre alternative est d'utiliser une collection ou une association non "
"\"différée\" en spécifiant <literal>lazy=\"false\"</literal> dans le mappage "
"de l'association. Cependant il est prévu que le chargement différé soit "
"utilisé pour quasiment toutes les collections ou associations. Si vous "
"définissez trop d'associations non \"différées\" dans votre modèle objet, "
"Hibernate va finir par devoir charger toute la base de données en mémoire à "
"chaque transaction."

#. Tag: para
#, no-c-format
msgid ""
"On the other hand, you can use join fetching, which is non-lazy by nature, "
"instead of select fetching in a particular transaction. We will now explain "
"how to customize the fetching strategy. In Hibernate3, the mechanisms for "
"choosing a fetch strategy are identical for single-valued associations and "
"collections."
msgstr ""
"Par ailleurs, on veut souvent choisir un chargement par jointure (qui est "
"par défaut non différé) à la place du chargement par select dans une "
"transaction particulière. Nous allons maintenant voir comment adapter les "
"stratégies de chargement. Dans Hibernate3 les mécanismes pour choisir une "
"stratégie de chargement sont identiques que l'on ait une association vers un "
"objet simple ou vers une collection. "

#. Tag: title
#, no-c-format
msgid "Tuning fetch strategies"
msgstr "Personnalisation des stratégies de chargement"

#. Tag: para
#, no-c-format
msgid ""
"Select fetching (the default) is extremely vulnerable to N+1 selects "
"problems, so we might want to enable join fetching in the mapping document:"
msgstr ""
"Le chargement par select (mode par défaut) est très vulnérable au problème "
"du N+1 selects, ainsi vous souhaiterez peut-être activer le chargement par "
"jointure dans les fichiers de mappage :"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>fetch</literal> strategy defined in the mapping document "
"affects:"
msgstr ""
"La stratégie de chargement définie à l'aide du mot <literal>fetch</literal> "
"dans les fichiers de mappage affecte :"

#. Tag: para
#, no-c-format
msgid "retrieval via <literal>get()</literal> or <literal>load()</literal>"
msgstr ""
"La récupération via <literal>get()</literal> ou <literal>load()</literal>"

#. Tag: para
#, no-c-format
msgid "retrieval that happens implicitly when an association is navigated"
msgstr ""
"La récupération implicite lorsque l'on navigue à travers une association"

#. Tag: para
#, no-c-format
msgid "<literal>Criteria</literal> queries"
msgstr "Les requêtes par <literal>Criteria</literal>"

#. Tag: para
#, no-c-format
msgid "HQL queries if <literal>subselect</literal> fetching is used"
msgstr ""
"Les requêtes HQL si l'on utilise le chargement par <literal>subselect</"
"literal>"

#. Tag: para
#, no-c-format
msgid ""
"Irrespective of the fetching strategy you use, the defined non-lazy graph is "
"guaranteed to be loaded into memory. This might, however, result in several "
"immediate selects being used to execute a particular HQL query."
msgstr ""
"Quelle que soit la stratégie de chargement que vous utilisez, la partie du "
"graphe d'objets, non-différée, sera chargée en mémoire. Cela peut mener à "
"l'exécution de plusieurs selects successifs pour une seule requête HQL. "

#. Tag: para
#, no-c-format
msgid ""
"Usually, the mapping document is not used to customize fetching. Instead, we "
"keep the default behavior, and override it for a particular transaction, "
"using <literal>left join fetch</literal> in HQL. This tells Hibernate to "
"fetch the association eagerly in the first select, using an outer join. In "
"the <literal>Criteria</literal> query API, you would use "
"<literal>setFetchMode(FetchMode.JOIN)</literal>."
msgstr ""
"On n'utilise pas souvent les documents de mappage pour adapter le "
"chargement. En revanche, on conserve le comportement par défaut et on le "
"surcharge pour une transaction particulière en utilisant <literal>left join "
"fetch</literal> dans les requêtes HQL. Cela indique à Hibernate de charger "
"l'association de manière agressive lors du premier select en utilisant une "
"jointure externe. Dans la requête API <literal>Criteria</literal> vous "
"utiliserez la méthode <literal>setFetchMode(FetchMode.JOIN)</literal>."

#. Tag: para
#, no-c-format
msgid ""
"If you want to change the fetching strategy used by <literal>get()</literal> "
"or <literal>load()</literal>, you can use a <literal>Criteria</literal> "
"query. For example:"
msgstr ""
"S'il vous arrive de vouloir changer la stratégie de chargement utilisée par "
"utilisée par <literal>get()</literal> ou <literal>load()</literal>, vous "
"pouvez juste utiliser une requête de type <literal>Criteria</literal> comme "
"par exemple : "

#. Tag: para
#, no-c-format
msgid ""
"This is Hibernate's equivalent of what some ORM solutions call a \"fetch plan"
"\"."
msgstr ""
"Il s'agit de l'équivalent pour Hibernate de ce que d'autres outils de "
"mappage appellent un \"fetch plan\" ou \"plan de chargement\"."

#. Tag: para
#, no-c-format
msgid ""
"A completely different approach to problems with N+1 selects is to use the "
"second-level cache."
msgstr ""
"Une autre manière complètement différente d'éviter le problème des N+1 "
"selects est d'utiliser le cache de second niveau. "

#. Tag: title
#, no-c-format
msgid "Single-ended association proxies"
msgstr "Proxies pour des associations vers un seul objet "

#. Tag: para
#, no-c-format
msgid ""
"Lazy fetching for collections is implemented using Hibernate's own "
"implementation of persistent collections. However, a different mechanism is "
"needed for lazy behavior in single-ended associations. The target entity of "
"the association must be proxied. Hibernate implements lazy initializing "
"proxies for persistent objects using runtime bytecode enhancement which is "
"accessed via the CGLIB library."
msgstr ""
"Le chargement différé des collections est implémenté par Hibernate qui "
"utilise ses propres implémentations pour des collections persistantes. Si "
"l'on veut un chargement différé pour des associations vers un seul objet, il "
"faut utiliser un autre mécanisme. L'entité qui est pointée par l'association "
"doit être masquée derrière un proxy. Hibernate implémente l'initialisation "
"différée des proxies sur des objets persistants via une mise à jour à chaud "
"du bytecode (à l'aide de l'excellente librairie CGLIB)."

#. Tag: para
#, no-c-format
msgid ""
"At startup, Hibernate3 generates proxies by default for all persistent "
"classes and uses them to enable lazy fetching of <literal>many-to-one</"
"literal> and <literal>one-to-one</literal> associations."
msgstr ""
"Par défaut, Hibernate génère des proxies (au démarrage) pour toutes les "
"classes persistantes et les utilise pour activer le chargement différé des "
"associations <literal>many-to-one</literal> et <literal>one-to-one</literal>."

#. Tag: para
#, no-c-format
msgid ""
"The mapping file may declare an interface to use as the proxy interface for "
"that class, with the <literal>proxy</literal> attribute. By default, "
"Hibernate uses a subclass of the class. <emphasis>The proxied class must "
"implement a default constructor with at least package visibility. This "
"constructor is recommended for all persistent classes</emphasis>."
msgstr ""
"Le fichier de mappage peut déclarer une interface à utiliser comme interface "
"de proxy pour cette classe à l'aide de l'attribut <literal>proxy</literal>. "
"Par défaut Hibernate utilise une sous-classe de la classe persistante. "
"<emphasis>Il faut que les classes pour lesquelles on ajoute un proxy "
"implémentent un constructeur par défaut avec au minimum une visibilité de "
"paquetage. Ce constructeur est recommandé pour toutes les classes "
"persistantes !</emphasis>."

#. Tag: para
#, no-c-format
msgid ""
"There are potential problems to note when extending this approach to "
"polymorphic classes.For example:"
msgstr ""
"Il y a quelques précautions à prendre lorsque l'on étend cette approche à "
"des classes polymorphiques, par exemple : "

#. Tag: para
#, no-c-format
msgid ""
"Firstly, instances of <literal>Cat</literal> will never be castable to "
"<literal>DomesticCat</literal>, even if the underlying instance is an "
"instance of <literal>DomesticCat</literal>:"
msgstr ""
"Tout d'abord, les instances de <literal>Cat</literal> ne pourront jamais "
"être \"castées\" en <literal>DomesticCat</literal>, même si l'instance sous-"
"jacente est une instance de <literal>DomesticCat</literal> :"

#. Tag: para
#, no-c-format
msgid "Secondly, it is possible to break proxy <literal>==</literal>:"
msgstr ""
"Deuxièmement, il est possible de casser la notion de <literal>==</literal> "
"des proxies. "

#. Tag: para
#, no-c-format
msgid ""
"However, the situation is not quite as bad as it looks. Even though we now "
"have two references to different proxy objects, the underlying instance will "
"still be the same object:"
msgstr ""
"Cette situation n'est pas si mauvaise qu'il n'y parait. Même si nous avons "
"deux références à deux objets proxies différents, l'instance sous-jacente "
"sera quand même le même objet :"

#. Tag: para
#, no-c-format
msgid ""
"Third, you cannot use a CGLIB proxy for a <literal>final</literal> class or "
"a class with any <literal>final</literal> methods."
msgstr ""
"Troisièmement, vous ne pourrez pas utiliser un proxy CGLIB pour une classe "
"<literal>final</literal> ou pour une classe contenant la moindre méthode "
"<literal>final</literal>. "

#. Tag: para
#, no-c-format
msgid ""
"Finally, if your persistent object acquires any resources upon instantiation "
"(e.g. in initializers or default constructor), then those resources will "
"also be acquired by the proxy. The proxy class is an actual subclass of the "
"persistent class."
msgstr ""
"Enfin, si votre objet persistant obtient une quelconque ressource à "
"l'instanciation (par exemple dans les initialiseurs ou dans le constructeur "
"par défaut), alors ces ressources seront aussi obtenues par le proxy. La "
"classe proxy est en réalité une sous-classe de la classe persistante. "

#. Tag: para
#, no-c-format
msgid ""
"These problems are all due to fundamental limitations in Java's single "
"inheritance model. To avoid these problems your persistent classes must each "
"implement an interface that declares its business methods. You should "
"specify these interfaces in the mapping file where <literal>CatImpl</"
"literal> implements the interface <literal>Cat</literal> and "
"<literal>DomesticCatImpl</literal> implements the interface "
"<literal>DomesticCat</literal>. For example:"
msgstr ""
"Ces problèmes sont tous dus aux limitations fondamentales du modèle "
"d'héritage unique de Java. Si vous souhaitez éviter ces problèmes, vos "
"classes persistantes doivent chacune implémenter une interface qui déclare "
"ses méthodes métier. Vous devriez alors spécifier ces interfaces dans le "
"fichier de mappage : <literal>CatImpl</literal> implémente l'interface "
"<literal>Cat</literal> et <literal>DomesticCatImpl</literal> implémente "
"l'interface <literal>DomesticCat</literal>. Par exemple :"

#. Tag: para
#, no-c-format
msgid ""
"Then proxies for instances of <literal>Cat</literal> and "
"<literal>DomesticCat</literal> can be returned by <literal>load()</literal> "
"or <literal>iterate()</literal>."
msgstr ""
"Tout d'abord, les instances de <literal>Cat</literal> et de "
"<literal>DomesticCat</literal> peuvent être retournées par <literal>load()</"
"literal> ou par <literal>iterate()</literal>."

#. Tag: title
#, no-c-format
msgid "Note"
msgstr "Remarque"

#. Tag: para
#, no-c-format
msgid "<literal>list()</literal> does not usually return proxies."
msgstr "<literal>list()</literal> ne retourne pas les proxies normalement."

#. Tag: para
#, no-c-format
msgid ""
"Relationships are also lazily initialized. This means you must declare any "
"properties to be of type <literal>Cat</literal>, not <literal>CatImpl</"
"literal>."
msgstr ""
"Les relations sont aussi initialisées en différé. Ceci signifie que vous "
"devez déclarer chaque propriété comme étant de type <literal>Cat</literal>, "
"et non <literal>CatImpl</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Certain operations do <emphasis>not</emphasis> require proxy initialization:"
msgstr ""
"Certaines opérations ne nécessitent <emphasis>pas</emphasis> "
"l'initialisation du proxy :"

#. Tag: para
#, no-c-format
msgid ""
"<literal>equals()</literal>: if the persistent class does not override "
"<literal>equals()</literal>"
msgstr ""
"<literal>equals()</literal>, si la classe persistante ne surcharge pas "
"<literal>equals()</literal> "

#. Tag: para
#, no-c-format
msgid ""
"<literal>hashCode()</literal>: if the persistent class does not override "
"<literal>hashCode()</literal>"
msgstr ""
"<literal>hashCode()</literal>, si la classe persistante ne surcharge pas "
"<literal>hashCode()</literal> "

#. Tag: para
#, no-c-format
msgid "The identifier getter method"
msgstr "La méthode getter de l'identifiant "

#. Tag: para
#, no-c-format
msgid ""
"Hibernate will detect persistent classes that override <literal>equals()</"
"literal> or <literal>hashCode()</literal>."
msgstr ""
"Hibernate détectera les classes qui surchargent <literal>equals()</literal> "
"ou <literal>hashCode()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"By choosing <literal>lazy=\"no-proxy\"</literal> instead of the default "
"<literal>lazy=\"proxy\"</literal>, you can avoid problems associated with "
"typecasting. However, buildtime bytecode instrumentation is required, and "
"all operations will result in immediate proxy initialization."
msgstr ""
"Eh choisissant <literal>lazy=\"no-proxy\"</literal> au lieu de <literal>lazy="
"\"proxy\"</literal> qui est la valeur par défaut, il est possible d'éviter "
"les problèmes liés au transtypage. Il faudra alors une instrumentation du "
"bytecode à la compilation et toutes les opérations résulteront immédiatement "
"en une initialisation du proxy. "

#. Tag: title
#, no-c-format
msgid "Initializing collections and proxies"
msgstr "Initialisation des collections et des proxies"

#. Tag: para
#, no-c-format
msgid ""
"A <literal>LazyInitializationException</literal> will be thrown by Hibernate "
"if an uninitialized collection or proxy is accessed outside of the scope of "
"the <literal>Session</literal>, i.e., when the entity owning the collection "
"or having the reference to the proxy is in the detached state."
msgstr ""
"Une exception de type <literal>LazyInitializationException</literal> sera "
"renvoyée par Hibernate si une collection ou un proxy non initialisé est "
"accédé en dehors de la portée de la <literal>Session</literal>, par ex. "
"lorsque l'entité à laquelle appartient la collection ou qui a une référence "
"vers le proxy, est dans l'état \"détaché\". "

#. Tag: para
#, no-c-format
msgid ""
"Sometimes a proxy or collection needs to be initialized before closing the "
"<literal>Session</literal>. You can force initialization by calling "
"<literal>cat.getSex()</literal> or <literal>cat.getKittens().size()</"
"literal>, for example. However, this can be confusing to readers of the code "
"and it is not convenient for generic code."
msgstr ""
"Parfois, nous devons nous assurer qu'un proxy ou une collection est "
"initialisé avant de fermer la <literal>Session</literal>. Bien sûr, nous "
"pouvons toujours forcer l'initialisation en appelant par exemple "
"<literal>cat.getSex()</literal> ou <literal>cat.getKittens().size()</"
"literal>. Mais ceci n'est pas très lisible pour les personnes parcourant le "
"code et n'est pas approprié pour le code générique. "

#. Tag: para
#, no-c-format
msgid ""
"The static methods <literal>Hibernate.initialize()</literal> and "
"<literal>Hibernate.isInitialized()</literal>, provide the application with a "
"convenient way of working with lazily initialized collections or proxies. "
"<literal>Hibernate.initialize(cat)</literal> will force the initialization "
"of a proxy, <literal>cat</literal>, as long as its <literal>Session</"
"literal> is still open. <literal>Hibernate.initialize( cat.getKittens() )</"
"literal> has a similar effect for the collection of kittens."
msgstr ""
"Les méthodes statiques <literal>Hibernate.initialize()</literal> et "
"<literal>Hibernate.isInitialized()</literal> fournissent à l'application un "
"moyen de travailler avec des proxies ou des collections initialisés. "
"<literal>Hibernate.initialize(cat)</literal> forcera l'initialisation d'un "
"proxy de <literal>cat</literal>, si tant est que sa <literal>Session</"
"literal> est ouverte. <literal>Hibernate.initialize( cat.getKittens() )</"
"literal> a le même effet sur la collection kittens. "

#. Tag: para
#, no-c-format
msgid ""
"Another option is to keep the <literal>Session</literal> open until all "
"required collections and proxies have been loaded. In some application "
"architectures, particularly where the code that accesses data using "
"Hibernate, and the code that uses it are in different application layers or "
"different physical processes, it can be a problem to ensure that the "
"<literal>Session</literal> is open when a collection is initialized. There "
"are two basic ways to deal with this issue:"
msgstr ""
"Une autre option est de conserver la <literal>Session</literal> ouverte "
"jusqu'à ce que toutes les collections et tous les proxies nécessaires aient "
"été chargés. Dans certaines architectures applicatives, particulièrement "
"celles ou le code d'accès aux données via Hiberante et le code qui utilise "
"ces données sont dans des couches applicatives différentes ou des processus "
"physiques différents, il sera alors difficile de garantir que la "
"<literal>Session</literal> est ouverte lorsqu'une collection est "
"initialisée. Il y a deux moyens de maîtriser ce problème : "

#. Tag: para
#, no-c-format
msgid ""
"In a web-based application, a servlet filter can be used to close the "
"<literal>Session</literal> only at the end of a user request, once the "
"rendering of the view is complete (the <emphasis>Open Session in View</"
"emphasis> pattern). Of course, this places heavy demands on the correctness "
"of the exception handling of your application infrastructure. It is vitally "
"important that the <literal>Session</literal> is closed and the transaction "
"ended before returning to the user, even when an exception occurs during "
"rendering of the view. See the Hibernate Wiki for examples of this \"Open "
"Session in View\" pattern."
msgstr ""
"Dans une application web, un filtre de servlet peut être utilisé pour fermer "
"la <literal>Session</literal> uniquement lorsque la requête a été "
"entièrement traitée, lorsque le rendu de la vue est fini (il s'agit du "
"modèle <emphasis>Vue de la session ouverte</emphasis>). Bien sûr, cela "
"demande plus d'attention à la bonne gestion des exceptions de l'application. "
"Il est d'une importance vitale que la <literal>Session</literal> soit fermée "
"et la transaction terminée avant que l'on rende la main à l'utilisateur même "
"si une exception survient durant le traitement de la vue. Voir le wiki "
"Hibernate pour des exemples sur le modèle \"Open Session in View\". "

#. Tag: para
#, no-c-format
msgid ""
"In an application with a separate business tier, the business logic must "
"\"prepare\" all collections that the web tier needs before returning. This "
"means that the business tier should load all the data and return all the "
"data already initialized to the presentation/web tier that is required for a "
"particular use case. Usually, the application calls <literal>Hibernate."
"initialize()</literal> for each collection that will be needed in the web "
"tier (this call must occur before the session is closed) or retrieves the "
"collection eagerly using a Hibernate query with a <literal>FETCH</literal> "
"clause or a <literal>FetchMode.JOIN</literal> in <literal>Criteria</"
"literal>. This is usually easier if you adopt the <emphasis>Command</"
"emphasis> pattern instead of a <emphasis>Session Facade</emphasis>."
msgstr ""
"Dans une application avec une couche métier multiniveaux séparée, la couche "
"contenant la logique métier doit \"préparer\" toutes les collections qui "
"seront nécessaires à la couche web multiniveaux avant de retourner les "
"données. Cela signifie que la couche métier doit charger toutes les données "
"et retourner toutes les données déjà initialisées à la couche de "
"présentation/web pour un cas d'utilisation donné. En général l'application "
"appelle la méthode <literal>Hibernate.initialize()</literal> pour chaque "
"collection nécessaire dans la couche web (cet appel doit être fait avant la "
"fermeture de la session) ou bien récupère les collections de manière "
"agressive à l'aide d'une requête HQL avec une clause <literal>FETCH</"
"literal> ou à l'aide du mode <literal>FetchMode.JOIN</literal> pour une "
"requête de type <literal>Criteria</literal>. Cela est en général plus facile "
"si vous utilisez le modèle <emphasis>Command</emphasis> plutôt que "
"<emphasis>Session Facade</emphasis>. "

#. Tag: para
#, no-c-format
msgid ""
"You can also attach a previously loaded object to a new <literal>Session</"
"literal> with <literal>merge()</literal> or <literal>lock()</literal> before "
"accessing uninitialized collections or other proxies. Hibernate does not, "
"and certainly <emphasis>should</emphasis> not, do this automatically since "
"it would introduce impromptu transaction semantics."
msgstr ""
"Vous pouvez également attacher à une <literal>Session</literal> un objet "
"chargé au préalable à l'aide des méthodes <literal>merge()</literal> ou "
"<literal>lock()</literal> avant d'accéder aux collections (ou aux proxies) "
"non initialisés. Non, Hibernate ne fait pas, et ne doit pas faire cela "
"automatiquement car cela pourrait introduire une sémantique transactionnelle "
"ad hoc. "

#. Tag: para
#, no-c-format
msgid ""
"Sometimes you do not want to initialize a large collection, but still need "
"some information about it, like its size, for example, or a subset of the "
"data."
msgstr ""
"Parfois, vous ne voulez pas initialiser une grande collection mais vous avez "
"quand même besoin d'informations sur elle (comme sa taille) ou un sous-"
"ensemble de ses données."

#. Tag: para
#, no-c-format
msgid ""
"You can use a collection filter to get the size of a collection without "
"initializing it:"
msgstr ""
"Vous pouvez utiliser un filtre de collection pour récupérer sa taille sans "
"l'initialiser :"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>createFilter()</literal> method is also used to efficiently "
"retrieve subsets of a collection without needing to initialize the whole "
"collection:"
msgstr ""
"La méthode <literal>createFilter()</literal> est également utilisée pour "
"récupérer efficacement des sous-ensembles d'une collection sans avoir besoin "
"de l'initialiser dans son ensemble :"

#. Tag: title
#, no-c-format
msgid "Using batch fetching"
msgstr "Utiliser le chargement par lot"

#. Tag: para
#, no-c-format
msgid ""
"Using batch fetching, Hibernate can load several uninitialized proxies if "
"one proxy is accessed. Batch fetching is an optimization of the lazy select "
"fetching strategy. There are two ways you can configure batch fetching: on "
"the class level and the collection level."
msgstr ""
"Pour améliorer les performances, Hibernate peut utiliser le chargement par "
"lot ce qui veut dire que Hibernate peut charger plusieurs proxies (ou "
"collections) non initialisés en une seule requête lorsque l'on accède à l'un "
"de ces proxies. Le chargement par lot est une optimisation intimement liée à "
"la stratégie de chargement en différé par select. Il y a deux moyens "
"d'activer le chargement par lot : au niveau de la classe et au niveau de la "
"collection."

#. Tag: para
#, no-c-format
msgid ""
"Batch fetching for classes/entities is easier to understand. Consider the "
"following example: at runtime you have 25 <literal>Cat</literal> instances "
"loaded in a <literal>Session</literal>, and each <literal>Cat</literal> has "
"a reference to its <literal>owner</literal>, a <literal>Person</literal>. "
"The <literal>Person</literal> class is mapped with a proxy, <literal>lazy="
"\"true\"</literal>. If you now iterate through all cats and call "
"<literal>getOwner()</literal> on each, Hibernate will, by default, execute "
"25 <literal>SELECT</literal> statements to retrieve the proxied owners. You "
"can tune this behavior by specifying a <literal>batch-size</literal> in the "
"mapping of <literal>Person</literal>:"
msgstr ""
"Le chargement par lot pour les classes/entités est plus simple à comprendre. "
"Imaginez que vous ayez la situation suivante à l'exécution : vous avez 25 "
"instances de <literal>Cat</literal> chargées dans une <literal>Session</"
"literal>, chaque <literal>Cat</literal> a une référence à son "
"<literal>owner</literal>, une <literal>Person</literal>. La classe "
"<literal>Person</literal> est mappée avec un proxy, <literal>lazy=\"true\"</"
"literal>. Si vous itérez sur tous les cats et appelez <literal>getOwner()</"
"literal> sur chacun d'eux, Hibernate exécutera par défaut 25 "
"<literal>SELECT</literal>, pour charger les owners (initialiser le proxy). "
"Vous pouvez paramétrer ce comportement en spécifiant une <literal>batch-"
"size</literal> (taille du lot) dans le mappage de <literal>Person</"
"literal> : "

#. Tag: para
#, no-c-format
msgid ""
"Hibernate will now execute only three queries: the pattern is 10, 10, 5."
msgstr ""
"Hibernate exécutera désormais trois requêtes, en chargeant respectivement "
"10, 10, et 5 entités. "

#. Tag: para
#, no-c-format
msgid ""
"You can also enable batch fetching of collections. For example, if each "
"<literal>Person</literal> has a lazy collection of <literal>Cat</literal>s, "
"and 10 persons are currently loaded in the <literal>Session</literal>, "
"iterating through all persons will generate 10 <literal>SELECT</literal>s, "
"one for every call to <literal>getCats()</literal>. If you enable batch "
"fetching for the <literal>cats</literal> collection in the mapping of "
"<literal>Person</literal>, Hibernate can pre-fetch collections:"
msgstr ""
"Vous pouvez aussi activer le chargement par lot pour les collections. Par "
"exemple, si chaque <literal>Person</literal> a une collection chargée en "
"différé des <literal>Cat</literal>s, et que 10 personnes sont actuellement "
"chargées dans la <literal>Session</literal>, itérer sur toutes les persons "
"générera 10 <literal>SELECT</literal> s, un pour chaque appel de "
"<literal>getCats()</literal>. Si vous activez le chargement par lot pour la "
"collection <literal>cats</literal> dans le mappage de <literal>Person</"
"literal>, Hibernate pourra précharger les collections :"

#. Tag: para
#, no-c-format
msgid ""
"With a <literal>batch-size</literal> of 3, Hibernate will load 3, 3, 3, 1 "
"collections in four <literal>SELECT</literal>s. Again, the value of the "
"attribute depends on the expected number of uninitialized collections in a "
"particular <literal>Session</literal>."
msgstr ""
"Avec une taille de lot <literal>batch-size</literal> de 8, Hibernate "
"chargera respectivement des collections 3, 3, 3, et 1 en quatre "
"<literal>SELECT</literal> s. Encore une fois, la valeur de l'attribut dépend "
"du nombre de collections non initialisées dans une <literal>Session</"
"literal> particulière. "

#. Tag: para
#, no-c-format
msgid ""
"Batch fetching of collections is particularly useful if you have a nested "
"tree of items, i.e. the typical bill-of-materials pattern. However, a "
"<emphasis>nested set</emphasis> or a <emphasis>materialized path</emphasis> "
"might be a better option for read-mostly trees."
msgstr ""
"Le chargement par lot de collections est particulièrement utile si vous avez "
"une arborescence imbriquée d'éléments, c'est-à-dire le le schéma facture de "
"matériels typique. (Bien qu'un <emphasis>sous ensemble</emphasis> ou un "
"<emphasis>chemin matérialisé</emphasis> soit probablement une meilleure "
"option pour des arbres principalement en lecture.) "

#. Tag: title
#, no-c-format
msgid "Using subselect fetching"
msgstr "Utilisation du chargement par sous select"

#. Tag: para
#, no-c-format
msgid ""
"If one lazy collection or single-valued proxy has to be fetched, Hibernate "
"will load all of them, re-running the original query in a subselect. This "
"works in the same way as batch-fetching but without the piecemeal loading."
msgstr ""
"Si une collection en différé ou un proxy vers un objet doit être chargée, "
"Hibernate va tous les charger en ré-exécutant la requête originale dans un "
"sous select. Cela fonctionne de la même manière que le chargement par lot "
"sans la possibilité de fragmenter le chargement."

#. Tag: title
#, fuzzy, no-c-format
msgid "Fetch profiles"
msgstr "Stratégies de chargement"

#. Tag: para
#, no-c-format
msgid ""
"Another way to affect the fetching strategy for loading associated objects "
"is through something called a fetch profile, which is a named configuration "
"associated with the <interfacename>org.hibernate.SessionFactory</"
"interfacename> but enabled, by name, on the <interfacename>org.hibernate."
"Session</interfacename>. Once enabled on a <interfacename>org.hibernate."
"Session</interfacename>, the fetch profile wull be in affect for that "
"<interfacename>org.hibernate.Session</interfacename> until it is explicitly "
"disabled."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"So what does that mean? Well lets explain that by way of an example. Say we "
"have the following mappings:"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Now normally when you get a reference to a particular customer, that "
"customer's set of orders will be lazy meaning we will not yet have loaded "
"those orders from the database. Normally this is a good thing. Now lets say "
"that you have a certain use case where it is more efficient to load the "
"customer and their orders together. One way certainly is to use \"dynamic "
"fetching\" strategies via an HQL or criteria queries. But another option is "
"to use a fetch profile to achieve that. Just add the following to your "
"mapping:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "or even:"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Now the following code will actually load both the customer <emphasis>and "
"their orders</emphasis>:"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Currently only join style fetch profiles are supported, but they plan is to "
"support additional styles. See <ulink url=\"http://opensource.atlassian.com/"
"projects/hibernate/browse/HHH-3414\">HHH-3414</ulink> for details."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Using lazy property fetching"
msgstr "Utiliser le chargement en différé des propriétés"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate3 supports the lazy fetching of individual properties. This "
"optimization technique is also known as <emphasis>fetch groups</emphasis>. "
"Please note that this is mostly a marketing feature; optimizing row reads is "
"much more important than optimization of column reads. However, only loading "
"some properties of a class could be useful in extreme cases. For example, "
"when legacy tables have hundreds of columns and the data model cannot be "
"improved."
msgstr ""
"Hibernate3 supporte le chargement en différé de propriétés individuelles. La "
"technique d'optimisation est également connue sous le nom de <emphasis>fetch "
"groups</emphasis> (groupes de chargement). Il faut noter qu'il s'agit "
"principalement d'une fonctionnalité marketing car en pratique l'optimisation "
"de la lecture d'un enregistrement est beaucoup plus importante que "
"l'optimisation de la lecture d'une colonne. Cependant, la restriction du "
"chargement à certaines colonnes peut être pratique dans des cas extrêmes, "
"lorsque des tables \"legacy\" possèdent des centaines de colonnes et que le "
"modèle de données ne peut pas être amélioré."

#. Tag: para
#, no-c-format
msgid ""
"To enable lazy property loading, set the <literal>lazy</literal> attribute "
"on your particular property mappings:"
msgstr ""
"Pour activer le chargement en différé d'une propriété, il faut mettre "
"l'attribut <literal>lazy</literal> sur une propriété particulière du "
"mappage :"

#. Tag: para
#, no-c-format
msgid ""
"Lazy property loading requires buildtime bytecode instrumentation. If your "
"persistent classes are not enhanced, Hibernate will ignore lazy property "
"settings and return to immediate fetching."
msgstr ""
"Le chargement en différé des propriétés requiert une instrumentation du "
"bytecode lors de la compilation ! Si les classes persistantes ne sont pas "
"instrumentées, Hibernate ignorera de manière silencieuse le mode en différé "
"et retombera dans le mode de chargement immédiat. "

#. Tag: para
#, no-c-format
msgid "For bytecode instrumentation, use the following Ant task:"
msgstr ""
"Pour l'instrumentation du bytecode vous pouvez utiliser la tâche Ant "
"suivante :"

#. Tag: para
#, no-c-format
msgid ""
"A different way of avoiding unnecessary column reads, at least for read-only "
"transactions, is to use the projection features of HQL or Criteria queries. "
"This avoids the need for buildtime bytecode processing and is certainly a "
"preferred solution."
msgstr ""
"Une autre façon (meilleure ?) pour éviter de lire plus de colonnes que "
"nécessaire au moins pour des transactions en lecture seule est d'utiliser "
"les fonctionnalités de projection des requêtes HQL ou Criteria. Cela évite "
"de devoir instrumenter le bytecode à la compilation et est certainement une "
"solution préférable. "

#. Tag: para
#, no-c-format
msgid ""
"You can force the usual eager fetching of properties using <literal>fetch "
"all properties</literal> in HQL."
msgstr ""
"Vous pouvez forcer le mode de chargement agressif des propriétés en "
"utilisant <literal>fetch all properties</literal> dans les requêtes HQL. "

#. Tag: title
#, no-c-format
msgid "The Second Level Cache"
msgstr "Le cache de second niveau"

#. Tag: para
#, no-c-format
msgid ""
"A Hibernate <literal>Session</literal> is a transaction-level cache of "
"persistent data. It is possible to configure a cluster or JVM-level "
"(<literal>SessionFactory</literal>-level) cache on a class-by-class and "
"collection-by-collection basis. You can even plug in a clustered cache. Be "
"aware that caches are not aware of changes made to the persistent store by "
"another application. They can, however, be configured to regularly expire "
"cached data."
msgstr ""
"Une <literal>Session</literal> Hibernate est un cache de niveau "
"transactionnel de données persistantes. Il est possible de configurer un "
"cache de cluster ou de JVM (de niveau <literal>SessionFactory</literal>) "
"défini classe par classe et collection par collection. Vous pouvez même "
"utiliser votre choix de cache en implémentant le fournisseur associé. Faites "
"attention, les caches ne sont jamais avertis des modifications faites dans "
"la base de données par d'autres applications (ils peuvent cependant être "
"configurés pour régulièrement expirer les données en cache). "

#. Tag: para
#, no-c-format
msgid ""
"You have the option to tell Hibernate which caching implementation to use by "
"specifying the name of a class that implements <literal>org.hibernate.cache."
"CacheProvider</literal> using the property <literal>hibernate.cache."
"provider_class</literal>. Hibernate is bundled with a number of built-in "
"integrations with the open-source cache providers that are listed below. You "
"can also implement your own and plug it in as outlined above. Note that "
"versions prior to 3.2 use EhCache as the default cache provider."
msgstr ""
"Vous pouvez choisir une autre implémentation en spécifiant le nom de la "
"classe qui implémente <literal>org.hibernate.cache.CacheProvider</literal> "
"en utilisant la propriété <literal>hibernate.cache.provider_class</literal>. "
"Hibernate est accompagné de plusieurs intégrations imbriquées avec des "
"fournisseurs de cache open-source (listés ci-dessous) ; par ailleurs vous "
"pouvez implémenter votre propre fournisseur et le brancher comme indiqué ci-"
"dessus. Notez que les versions antérieures à 3.2, utilisaient par défaut le "
"EhCache comme le fournisseur de cache par défaut, ce qui n'est plus le cas. "

#. Tag: title
#, no-c-format
msgid "Cache Providers"
msgstr "Fournisseurs de cache"

#. Tag: entry
#, no-c-format
msgid "Cache"
msgstr "Cache"

#. Tag: entry
#, no-c-format
msgid "Provider class"
msgstr "Classe pourvoyeuse"

#. Tag: entry
#, no-c-format
msgid "Type"
msgstr "Type"

#. Tag: entry
#, no-c-format
msgid "Cluster Safe"
msgstr "Cluster sécurisé"

#. Tag: entry
#, no-c-format
msgid "Query Cache Supported"
msgstr "Cache de requêtes supporté"

#. Tag: entry
#, no-c-format
msgid "Hashtable (not intended for production use)"
msgstr "Table de hachage (ne pas utiliser en production)"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache.HashtableCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.HashtableCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "memory"
msgstr "mémoire"

#. Tag: entry
#, no-c-format
msgid "yes"
msgstr "oui"

#. Tag: entry
#, no-c-format
msgid "EHCache"
msgstr "EHCache"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache.EhCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.EhCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "memory, disk"
msgstr "mémoire, disque"

#. Tag: entry
#, no-c-format
msgid "OSCache"
msgstr "OSCache"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache.OSCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.OSCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "SwarmCache"
msgstr "SwarmCache"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache.SwarmCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.SwarmCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "clustered (ip multicast)"
msgstr "en cluster (multicast ip)"

#. Tag: entry
#, no-c-format
msgid "yes (clustered invalidation)"
msgstr "oui (invalidation de cluster)"

#. Tag: entry
#, no-c-format
msgid "JBoss Cache 1.x"
msgstr "JBoss Cache 1.x"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache.TreeCacheProvider</literal>"
msgstr "    org.hibernate.cache.TreeCacheProvider"

#. Tag: entry
#, no-c-format
msgid "clustered (ip multicast), transactional"
msgstr "en cluster (multicast ip), transactionnel"

#. Tag: entry
#, no-c-format
msgid "yes (replication)"
msgstr "oui (réplication)"

#. Tag: entry
#, no-c-format
msgid "yes (clock sync req.)"
msgstr "oui (horloge sync. nécessaire)"

#. Tag: entry
#, no-c-format
msgid "JBoss Cache 2"
msgstr "JBoss Cache 2"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache.jbc.JBossCacheRegionFactory</literal>"
msgstr "<literal>org.hibernate.cache.jbc2.JBossCacheRegionFactory</literal>"

#. Tag: entry
#, no-c-format
msgid "yes (replication or invalidation)"
msgstr "oui (replication ou invalidation)"

#. Tag: title
#, no-c-format
msgid "Cache mappings"
msgstr "Mappages de Cache"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>&lt;cache&gt;</literal> element of a class or collection "
"mapping has the following form:"
msgstr ""
"L'élément <literal>&lt;cache&gt;</literal> d'une classe ou d'une collection "
"a la forme suivante :"

#. Tag: para
#, no-c-format
msgid ""
"<literal>usage</literal> (required) specifies the caching strategy: "
"<literal>transactional</literal>, <literal>read-write</literal>, "
"<literal>nonstrict-read-write</literal> or <literal>read-only</literal>"
msgstr ""
"<literal>usage</literal> (requis) spécifie la stratégie de cache : "
"<literal>transactionel</literal>, <literal>lecture-écriture</literal>, "
"<literal>lecture-écriture non stricte</literal> ou <literal>lecture seule</"
"literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>region</literal> (optional: defaults to the class or collection "
"role name): specifies the name of the second level cache region"
msgstr ""
"<literal>region</literal> (optionnel, par défaut il s'agit du nom de la "
"classe ou du nom de rôle de la collection) : spécifie le nom de la région du "
"cache de second niveau"

#. Tag: para
#, no-c-format
msgid ""
"<literal>include</literal> (optional: defaults to <literal>all</literal>) "
"<literal>non-lazy</literal>: specifies that properties of the entity mapped "
"with <literal>lazy=\"true\"</literal> cannot be cached when attribute-level "
"lazy fetching is enabled"
msgstr ""
"<literal>include</literal> (optionnel, par défaut <literal>all</literal>) "
"<literal>non-lazy</literal> : spécifie que les propriétés des entités "
"mappées avec <literal>lazy=\"true\"</literal> ne doivent pas être mises en "
"cache lorsque le chargement en différé des attributs est activé."

#. Tag: para
#, no-c-format
msgid ""
"Alternatively, you can specify <literal>&lt;class-cache&gt;</literal> and "
"<literal>&lt;collection-cache&gt;</literal> elements in <literal>hibernate."
"cfg.xml</literal>."
msgstr ""
"Alternativement (voir préférentiellement), vous pouvez spécifier les "
"éléments <literal>&lt;class-cache&gt;</literal> et <literal>&lt;collection-"
"cache&gt;</literal> dans <literal>hibernate.cfg.xml</literal>. "

#. Tag: para
#, no-c-format
msgid ""
"The <literal>usage</literal> attribute specifies a <emphasis>cache "
"concurrency strategy</emphasis>."
msgstr ""
"L'attribut <literal>usage</literal> spécifie une <emphasis>stratégie de "
"concurrence d'accès au cache</emphasis>."

#. Tag: title
#, no-c-format
msgid "Strategy: read only"
msgstr "Stratégie : lecture seule"

#. Tag: para
#, no-c-format
msgid ""
"If your application needs to read, but not modify, instances of a persistent "
"class, a <literal>read-only</literal> cache can be used. This is the "
"simplest and optimal performing strategy. It is even safe for use in a "
"cluster."
msgstr ""
"Si votre application a besoin de lire mais ne modifie jamais les instances "
"d'une classe, un cache <literal>read-only</literal> peut être utilisé. C'est "
"la stratégie la plus simple et la plus performante. Elle est même "
"parfaitement sûre dans un cluster. "

#. Tag: title
#, no-c-format
msgid "Strategy: read/write"
msgstr "Stratégie : lecture/écriture"

#. Tag: para
#, no-c-format
msgid ""
"If the application needs to update data, a <literal>read-write</literal> "
"cache might be appropriate. This cache strategy should never be used if "
"serializable transaction isolation level is required. If the cache is used "
"in a JTA environment, you must specify the property <literal>hibernate."
"transaction.manager_lookup_class</literal> and naming a strategy for "
"obtaining the JTA <literal>TransactionManager</literal>. In other "
"environments, you should ensure that the transaction is completed when "
"<literal>Session.close()</literal> or <literal>Session.disconnect()</"
"literal> is called. If you want to use this strategy in a cluster, you "
"should ensure that the underlying cache implementation supports locking. The "
"built-in cache providers <emphasis>do not</emphasis> support locking."
msgstr ""
"Si l'application a besoin de mettre à jour des données, un cache "
"<literal>read-write</literal> peut être approprié. Cette stratégie ne "
"devrait jamais être utilisée si votre application nécessite un niveau "
"d'isolation transactionnelle sérialisable. Si le cache est utilisé dans un "
"environnement JTA, vous devez spécifier la propriété <literal>hibernate."
"transaction.manager_lookup_class</literal>, fournissant une stratégie pour "
"obtenir le JTA <literal>TransactionManager</literal>. Dans d'autres "
"environnements, vous devriez vous assurer que la transation est terminée à "
"l'appel de <literal>Session.close()</literal> ou <literal>Session.disconnect"
"()</literal>. Si vous souhaitez utiliser cette stratégie dans un cluster, "
"vous devriez vous assurer que l'implémentation de cache utilisée supporte le "
"verrouillage, ce que ne font <emphasis>pas</emphasis> les pourvoyeurs caches "
"fournis. "

#. Tag: title
#, no-c-format
msgid "Strategy: nonstrict read/write"
msgstr "Stratégie : lecture/écriture non stricte"

#. Tag: para
#, no-c-format
msgid ""
"If the application only occasionally needs to update data (i.e. if it is "
"extremely unlikely that two transactions would try to update the same item "
"simultaneously), and strict transaction isolation is not required, a "
"<literal>nonstrict-read-write</literal> cache might be appropriate. If the "
"cache is used in a JTA environment, you must specify <literal>hibernate."
"transaction.manager_lookup_class</literal>. In other environments, you "
"should ensure that the transaction is completed when <literal>Session.close()"
"</literal> or <literal>Session.disconnect()</literal> is called."
msgstr ""
"Si l'application a besoin de mettre à jour les données de manière "
"occasionnelle (il est très peu probable que deux transactions essaient de "
"mettre à jour le même élément simultanément) et si une isolation "
"transactionnelle stricte n'est pas nécessaire, un cache <literal>nonstrict-"
"read-write</literal> peut être approprié. Si le cache est utilisé dans un "
"environnement JTA, vous devez spécifier <literal>hibernate.transaction."
"manager_lookup_class</literal>. Dans d'autres environnements, vous devriez "
"vous assurer que la transation est terminée à l'appel de <literal>Session."
"close()</literal> ou <literal>Session.disconnect()</literal>."

#. Tag: title
#, no-c-format
msgid "Strategy: transactional"
msgstr "Stratégie : transactionelle"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>transactional</literal> cache strategy provides support for "
"fully transactional cache providers such as JBoss TreeCache. Such a cache "
"can only be used in a JTA environment and you must specify "
"<literal>hibernate.transaction.manager_lookup_class</literal>."
msgstr ""
"La stratégie de cache <literal>transactional</literal> supporte un cache "
"complètement transactionnel comme, par exemple, JBoss TreeCache. Un tel "
"cache ne peut être utilisé que dans un environnement JTA et vous devez "
"spécifier <literal>hibernate.transaction.manager_lookup_class</literal>. "

#. Tag: title
#, no-c-format
msgid "Cache-provider/concurrency-strategy compatibility"
msgstr "Support de stratégie de concurrence du fournisseur-cache"

#. Tag: para
#, no-c-format
msgid ""
"None of the cache providers support all of the cache concurrency strategies."
msgstr ""
"Aucun des caches livrés ne supporte toutes les stratégies de concurrence. Le "
"tableau suivant montre quels caches sont compatibles avec quelles stratégies "
"de concurrence. "

#. Tag: para
#, no-c-format
msgid ""
"The following table shows which providers are compatible with which "
"concurrency strategies."
msgstr ""
"Aucun des caches livrés ne supporte toutes les stratégies de concurrence. Le "
"tableau suivant montre quels caches sont compatibles avec quelles stratégies "
"de concurrence. "

#. Tag: title
#, no-c-format
msgid "Cache Concurrency Strategy Support"
msgstr "Support de stratégie de concurrence du cache"

#. Tag: entry
#, no-c-format
msgid "read-only"
msgstr "read-only (lecture seule)"

#. Tag: entry
#, no-c-format
msgid "nonstrict-read-write"
msgstr "nonstrict-read-write (lecture-écriture non stricte)"

#. Tag: entry
#, no-c-format
msgid "read-write"
msgstr "read-write (lecture-écriture)"

#. Tag: entry
#, no-c-format
msgid "transactional"
msgstr "transactional (transactionnel)"

#. Tag: title
#, no-c-format
msgid "Managing the caches"
msgstr "Gérer les caches"

#. Tag: para
#, no-c-format
msgid ""
"Whenever you pass an object to <literal>save()</literal>, <literal>update()</"
"literal> or <literal>saveOrUpdate()</literal>, and whenever you retrieve an "
"object using <literal>load()</literal>, <literal>get()</literal>, "
"<literal>list()</literal>, <literal>iterate()</literal> or <literal>scroll()"
"</literal>, that object is added to the internal cache of the "
"<literal>Session</literal>."
msgstr ""
"A chaque fois que vous passez un objet à la méthode <literal>save()</"
"literal>, <literal>update()</literal> ou <literal>saveOrUpdate()</literal> "
"et à chaque fois que vous récupérez un objet avec <literal>load()</literal>, "
"<literal>get()</literal>, <literal>list()</literal>, <literal>iterate()</"
"literal> ou <literal>scroll()</literal>, cet objet est ajouté au cache "
"interne de la <literal>Session</literal>. "

#. Tag: para
#, no-c-format
msgid ""
"When <literal>flush()</literal> is subsequently called, the state of that "
"object will be synchronized with the database. If you do not want this "
"synchronization to occur, or if you are processing a huge number of objects "
"and need to manage memory efficiently, the <literal>evict()</literal> method "
"can be used to remove the object and its collections from the first-level "
"cache."
msgstr ""
"Lorsqu'il y a un appel à la méthode <literal>flush()</literal>, l'état de "
"cet objet va être synchronisé avec la base de données. Si vous ne voulez pas "
"que cette synchronisation ait lieu ou si vous traitez un grand nombre "
"d'objets et que vous avez besoin de gérer la mémoire de manière efficace, "
"vous pouvez utiliser la méthode <literal>evict()</literal> pour supprimer "
"l'objet et ses collections dépendantes du cache de premier niveau de la "
"session. "

#. Tag: para
#, no-c-format
msgid ""
"The <literal>Session</literal> also provides a <literal>contains()</literal> "
"method to determine if an instance belongs to the session cache."
msgstr ""
"La <literal>Session</literal> fournit également une méthode <literal>contains"
"()</literal> pour déterminer si une instance appartient au cache de la "
"session. "

#. Tag: para
#, no-c-format
msgid ""
"To evict all objects from the session cache, call <literal>Session.clear()</"
"literal>"
msgstr ""
"Pour retirer tous les objets du cache session, appelez <literal>Session.clear"
"()</literal> "

#. Tag: para
#, no-c-format
msgid ""
"For the second-level cache, there are methods defined on "
"<literal>SessionFactory</literal> for evicting the cached state of an "
"instance, entire class, collection instance or entire collection role."
msgstr ""
"Pour le cache de second niveau, il existe des méthodes définies dans "
"<literal>SessionFactory</literal> pour retirer du cache d'une instance, de "
"la classe entière, d'une instance de collection ou du rôle entier d'une "
"collection."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>CacheMode</literal> controls how a particular session interacts "
"with the second-level cache:"
msgstr ""
"Le <literal>CacheMode</literal> contrôle la manière dont une session "
"particulière interagit avec le cache de second niveau :"

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.NORMAL</literal>: will read items from and write items to "
"the second-level cache"
msgstr ""
"<literal>CacheMode.NORMAL</literal> - lit et écrit les articles dans le "
"cache de second niveau "

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.GET</literal>: will read items from the second-level "
"cache. Do not write to the second-level cache except when updating data"
msgstr ""
"<literal>CacheMode.GET</literal> - lit les articles du cache de second "
"niveau mais ne les écrit pas sauf dans le cas d'une mise à jour des données "

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.PUT</literal>: will write items to the second-level "
"cache. Do not read from the second-level cache"
msgstr ""
"<literal>CacheMode.PUT</literal> - écrit les articles dans le cache de "
"second niveau mais ne les lit pas dans le cache de second niveau "

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.REFRESH</literal>: will write items to the second-level "
"cache. Do not read from the second-level cache. Bypass the effect of "
"<literal>hibernate.cache.use_minimal_puts</literal> forcing a refresh of the "
"second-level cache for all items read from the database"
msgstr ""
"<literal>CacheMode.REFRESH</literal> - écrit les articles dans le cache de "
"second niveau mais ne les lit pas dans le cache de second niveau, outrepasse "
"l'effet de <literal>hibernate.cache.use_minimal_puts</literal>, en forçant "
"un rafraîchissement du cache de second niveau pour chaque article lu dans la "
"base de données. "

#. Tag: para
#, no-c-format
msgid ""
"To browse the contents of a second-level or query cache region, use the "
"<literal>Statistics</literal> API:"
msgstr ""
"Pour parcourir le contenu du cache de second niveau ou la région du cache "
"dédiée aux requêtes, vous pouvez utiliser l'API <literal>Statistics</"
"literal> :"

#. Tag: para
#, no-c-format
msgid ""
"You will need to enable statistics and, optionally, force Hibernate to keep "
"the cache entries in a more readable format:"
msgstr ""
"Vous devez pour cela activer les statistiques et optionnellement forcer "
"Hibernate à conserver les entrées dans le cache sous un format plus "
"compréhensible pour l'utilisateur : "

#. Tag: title
#, no-c-format
msgid "The Query Cache"
msgstr "Le cache de requêtes"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Query result sets can also be cached. This is only useful for queries that "
"are run frequently with the same parameters."
msgstr ""
"Les résultats d'une requête peuvent aussi être placés en cache. Ceci n'est "
"utile que pour les requêtes qui sont exécutées avec les mêmes paramètres. "
"Pour utiliser le cache de requêtes, vous devez d'abord l'activer : "

#. Tag: title
#, no-c-format
msgid "Enabling query caching"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Caching of query results introduces some overhead in terms of your "
"applications normal transactional processing. For example, if you cache "
"results of a query against Person Hibernate will need to keep track of when "
"those results should be invalidated because changes have been committed "
"against Person. That, coupled with the fact that most applications simply "
"gain no benefit from caching query results, leads Hibernate to disable "
"caching of query results by default. To use query caching, you will first "
"need to enable the query cache:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "This setting creates two new cache regions:"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"<classname>org.hibernate.cache.StandardQueryCache</classname>, holding the "
"cached query results"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"<classname>org.hibernate.cache.UpdateTimestampsCache</classname>, holding "
"timestamps of the most recent updates to queryable tables. These are used to "
"validate the results as they are served from the query cache."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"If you configure your underlying cache implementation to use expiry or "
"timeouts is is very important that the cache timeout of the underlying cache "
"region for the UpdateTimestampsCache be set to a higher value than the "
"timeouts of any of the query caches. In fact, we recommend that the the "
"UpdateTimestampsCache region not be configured for expiry at all. Note, in "
"particular, that an LRU cache expiry policy is never appropriate."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"As mentioned above, most queries do not benefit from caching or their "
"results. So by default, individual queries are not cached even after "
"enabling query caching. To enable results caching for a particular query, "
"call <literal>org.hibernate.Query.setCacheable(true)</literal>. This call "
"allows the query to look for existing cache results or add its results to "
"the cache when it is executed."
msgstr ""
"La plupart des requêtes ne tirent pas avantage du cache, donc par défaut les "
"requêtes ne sont pas mises en cache. Pour activer le cache, appelez "
"<literal>Query.setCacheable(true)</literal>. Cet appel permet de vérifier si "
"les résultats sont en cache ou non, voire d'ajouter ces résultats quand la "
"requête est exécutée. "

#. Tag: para
#, no-c-format
msgid ""
"The query cache does not cache the state of the actual entities in the "
"cache; it caches only identifier values and results of value type. For this "
"reaso, the query cache should always be used in conjunction with the second-"
"level cache for those entities expected to be cached as part of a query "
"result cache (just as with collection caching)."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Query cache regions"
msgstr "Cache de requêtes supporté"

#. Tag: para
#, no-c-format
msgid ""
"If you require fine-grained control over query cache expiration policies, "
"you can specify a named cache region for a particular query by calling "
"<literal>Query.setCacheRegion()</literal>."
msgstr ""
"Si vous avez besoin de contrôler finement les délais d'expiration du cache, "
"vous pouvez spécifier une région de cache nommée pour une requête "
"particulière en appelant <literal>Query.setCacheRegion()</literal>. "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you want to force the query cache to refresh one of its regions "
"(disregard any cached results it finds there) you can use <literal>org."
"hibernate.Query.setCacheMode(CacheMode.REFRESH)</literal>. In conjunction "
"with the region you have defined for the given query, Hibernate will "
"selectively force the results cached in that particular region to be "
"refreshed. This is particularly useful in cases where underlying data may "
"have been updated via a separate process and is a far more efficient "
"alternative to bulk eviction of the region via <literal>org.hibernate."
"SessionFactory.evictQueries()</literal>."
msgstr ""
"Si une requête doit forcer le rafraîchissement de sa région de cache, vous "
"devez appeler <literal>Query.setCacheMode(CacheMode.REFRESH)</literal>. "
"C'est particulièrement utile lorsque les données peuvent avoir été mises à "
"jour par un processus séparé (c'est-à-dire qu'elles n'ont pas été modifiées "
"par Hibernate). Cela permet à l'application de rafraîchir de manière "
"sélective les résultats d'une requête particulière. Il s'agit d'une "
"alternative plus efficace à l'éviction d'une région du cache à l'aide de la "
"méthode <literal>SessionFactory.evictQueries()</literal>."

#. Tag: title
#, no-c-format
msgid "Understanding Collection performance"
msgstr "Comprendre les performances des collections"

#. Tag: para
#, no-c-format
msgid ""
"In the previous sections we have covered collections and their applications. "
"In this section we explore some more issues in relation to collections at "
"runtime."
msgstr ""
"Dans les sections précédentes, nous avons couvert les collections et leurs "
"applications. Dans cette section, nous allons explorer de nouveaux problèmes "
"en rapport aux collections en cours d'exécution."

#. Tag: title
#, no-c-format
msgid "Taxonomy"
msgstr "Taxinomie"

#. Tag: para
#, no-c-format
msgid "Hibernate defines three basic kinds of collections:"
msgstr "Hibernate définit trois types de collections de base :"

#. Tag: para
#, no-c-format
msgid "collections of values"
msgstr "les collections de valeurs"

#. Tag: para
#, no-c-format
msgid "one-to-many associations"
msgstr "Association un-à-plusieurs "

#. Tag: para
#, no-c-format
msgid "many-to-many associations"
msgstr "les associations plusieurs-à-plusieurs "

#. Tag: para
#, no-c-format
msgid ""
"This classification distinguishes the various table and foreign key "
"relationships but does not tell us quite everything we need to know about "
"the relational model. To fully understand the relational structure and "
"performance characteristics, we must also consider the structure of the "
"primary key that is used by Hibernate to update or delete collection rows. "
"This suggests the following classification:"
msgstr ""
"Cette classification distingue les différentes relations entre les tables et "
"les clés étrangères mais ne n'en dit pas suffisamment sur le modèle "
"relationnel. Pour comprendre parfaitement la structure relationnelle et les "
"caractéristiques des performances, nous devons considérer la structure de la "
"clé primaire qui est utilisée par Hibernate pour mettre à jour ou supprimer "
"les lignes des collections. Cela nous amène aux classifications suivantes :"

#. Tag: para
#, no-c-format
msgid "indexed collections"
msgstr "collections indexées"

#. Tag: para
#, no-c-format
msgid "sets"
msgstr "ensembles (sets)"

#. Tag: para
#, no-c-format
msgid "bags"
msgstr "sacs (bags)"

#. Tag: para
#, no-c-format
msgid ""
"All indexed collections (maps, lists, and arrays) have a primary key "
"consisting of the <literal>&lt;key&gt;</literal> and <literal>&lt;index&gt;</"
"literal> columns. In this case, collection updates are extremely efficient. "
"The primary key can be efficiently indexed and a particular row can be "
"efficiently located when Hibernate tries to update or delete it."
msgstr ""
"Toutes les collections indexées (maps, lists, arrays) ont une clé primaire "
"constituée des colonnes clés (<literal>&lt;key&gt;</literal>) et "
"<literal>&lt;index&gt;</literal>. Avec ce type de clé primaire, la mise à "
"jour de collection est en général très performante - la clé primaire peut "
"être indexées efficacement et une ligne particulière peut être localisée "
"efficacement lorsque Hibernate essaie de la mettre à jour ou de la "
"supprimer. "

#. Tag: para
#, no-c-format
msgid ""
"Sets have a primary key consisting of <literal>&lt;key&gt;</literal> and "
"element columns. This can be less efficient for some types of collection "
"element, particularly composite elements or large text or binary fields, as "
"the database may not be able to index a complex primary key as efficiently. "
"However, for one-to-many or many-to-many associations, particularly in the "
"case of synthetic identifiers, it is likely to be just as efficient. If you "
"want <literal>SchemaExport</literal> to actually create the primary key of a "
"<literal>&lt;set&gt;</literal>, you must declare all columns as <literal>not-"
"null=\"true\"</literal>."
msgstr ""
"Les ensembles ont une clé primaire composée de <literal>&lt;key&gt;</"
"literal> et des colonnes représentant l'élément. Elle est donc moins "
"efficace pour certains types d'éléments de collection, en particulier les "
"éléments composites, les textes volumineux ou les champs binaires ; la base "
"de données peut ne pas être capable d'indexer aussi efficacement une clé "
"primaire aussi complexe. Cependant, pour les associations un-à-plusieurs ou "
"plusieurs-à-plusieurs, en particulier lorsqu'on utilise des entités ayant "
"des identifiants techniques, il est probable que cela soit aussi efficace "
"(note : si vous voulez que <literal>SchemaExport</literal> crée "
"effectivement la clé primaire d'un <literal>&lt;set&gt;</literal> pour vous, "
"vous devez déclarer toutes les colonnes avec <literal>not-null=\"true\"</"
"literal>). "

#. Tag: para
#, no-c-format
msgid ""
"<literal>&lt;idbag&gt;</literal> mappings define a surrogate key, so they "
"are efficient to update. In fact, they are the best case."
msgstr ""
"Le mappage à l'aide de <literal>&lt;idbag&gt;</literal> définit une clé de "
"substitution ce qui leur permet d'être très efficaces lors de la mise à "
"jour. En fait il s'agit du meilleur cas de mise à jour d'une collection."

#. Tag: para
#, no-c-format
msgid ""
"Bags are the worst case since they permit duplicate element values and, as "
"they have no index column, no primary key can be defined. Hibernate has no "
"way of distinguishing between duplicate rows. Hibernate resolves this "
"problem by completely removing in a single <literal>DELETE</literal> and "
"recreating the collection whenever it changes. This can be inefficient."
msgstr ""
"Le pire cas intervient pour les sacs. Dans la mesure où un sac permet la "
"duplication des valeurs d'éléments et n'a pas de colonne d'index, aucune clé "
"primaire ne peut être définie. Hibernate n'a aucun moyen de distinguer entre "
"les  lignes dupliquées. Hibernate résout ce problème en supprimant "
"complètement (via un simple <literal>DELETE</literal>), puis en recréant la "
"collection chaque fois qu'elle change. Ce qui peut être très inefficace. "

#. Tag: para
#, no-c-format
msgid ""
"For a one-to-many association, the \"primary key\" may not be the physical "
"primary key of the database table. Even in this case, the above "
"classification is still useful. It reflects how Hibernate \"locates\" "
"individual rows of the collection."
msgstr ""
"Notez que pour une relation un-à-plusieurs, la \"clé primaire\" peut ne pas "
"être la clé primaire de la table en base de données - mais même dans ce cas, "
"la classification ci-dessus reste utile (Elle explique comment Hibernate "
"localise les lignes individuelles de la collection). "

#. Tag: title
#, no-c-format
msgid ""
"Lists, maps, idbags and sets are the most efficient collections to update"
msgstr ""
"Les lists, les maps, les idbags et les ensembles sont les collections les "
"plus efficaces pour la mise à jour "

#. Tag: para
#, no-c-format
msgid ""
"From the discussion above, it should be clear that indexed collections and "
"sets allow the most efficient operation in terms of adding, removing and "
"updating elements."
msgstr ""
"La discussion précédente montre clairement que les collections indexées et "
"(la plupart du temps) les ensembles, permettent de réaliser le plus "
"efficacement les opérations d'ajout, de suppression ou mise à jour "
"d'éléments. "

#. Tag: para
#, no-c-format
msgid ""
"There is, arguably, one more advantage that indexed collections have over "
"sets for many-to-many associations or collections of values. Because of the "
"structure of a <literal>Set</literal>, Hibernate does not <literal>UPDATE</"
"literal> a row when an element is \"changed\". Changes to a <literal>Set</"
"literal> always work via <literal>INSERT</literal> and <literal>DELETE</"
"literal> of individual rows. Once again, this consideration does not apply "
"to one-to-many associations."
msgstr ""
"Les collections indexées ont un avantage sur les ensembles, dans le cadre "
"des associations plusieurs-à-plusieurs ou de collections de valeurs. À cause "
"de la structure inhérente d'un <literal>Set</literal>, Hibernate n'effectue "
"jamais de ligne <literal>UPDATE</literal> quand un élément est modifié. Les "
"modifications apportées à un <literal>Set</literal> se font via un "
"<literal>INSERT</literal> et <literal>DELETE</literal> (de chaque ligne). "
"Une fois de plus, ce cas ne s'applique pas aux associations un-à-plusieurs. "

#. Tag: para
#, no-c-format
msgid ""
"After observing that arrays cannot be lazy, you can conclude that lists, "
"maps and idbags are the most performant (non-inverse) collection types, with "
"sets not far behind. You can expect sets to be the most common kind of "
"collection in Hibernate applications. This is because the \"set\" semantics "
"are most natural in the relational model."
msgstr ""
"Après s'être rappelé que les tableaux ne peuvent pas être chargés en "
"différé, nous pouvons conclure que les lists, les maps et les idbags sont "
"les types de collections (non inversées) les plus performants, avec les "
"ensembles pas loin derrière. Les ensembles sont le type de collection le "
"plus courant dans les applications Hibernate. Cela vient du fait que la "
"sémantique des ensembles est la plus naturelle dans le modèle relationnel. "

#. Tag: para
#, no-c-format
msgid ""
"However, in well-designed Hibernate domain models, most collections are in "
"fact one-to-many associations with <literal>inverse=\"true\"</literal>. For "
"these associations, the update is handled by the many-to-one end of the "
"association, and so considerations of collection update performance simply "
"do not apply."
msgstr ""
"Cependant, dans des modèles objet bien conçus avec Hibernate, on constate "
"que la plupart des collections sont en fait des associations un-à-plusieurs "
"avec <literal>inverse=\"true\"</literal>. Pour ces associations, les mises à "
"jour sont gérées au niveau de l'association \"plusieurs-à-un\" et les "
"considérations de performance de mise à jour des collections ne s'appliquent "
"tout simplement pas dans ces cas-là. "

#. Tag: title
#, no-c-format
msgid "Bags and lists are the most efficient inverse collections"
msgstr ""
"Les sacs et les listes sont les plus efficaces pour les collections inverses"

#. Tag: para
#, no-c-format
msgid ""
"There is a particular case, however, in which bags, and also lists, are much "
"more performant than sets. For a collection with <literal>inverse=\"true\"</"
"literal>, the standard bidirectional one-to-many relationship idiom, for "
"example, we can add elements to a bag or list without needing to initialize "
"(fetch) the bag elements. This is because, unlike a <literal>set</literal>, "
"<literal>Collection.add()</literal> or <literal>Collection.addAll()</"
"literal> must always return true for a bag or <literal>List</literal>. This "
"can make the following common code much faster:"
msgstr ""
"Avant que vous n'oubliez les sacs pour toujours, il y a un cas précis où les "
"sacs (et les listes) sont bien plus performants que les ensembles. Pour une "
"collection marquée comme <literal>inverse=\"true\"</literal> (le choix le "
"plus courant pour un relation un-à-plusieurs bidirectionnelle), nous pouvons "
"ajouter des éléments à un sac ou une liste sans avoir besoin de "
"l'initialiser (charger) les éléments du sac! Ceci parce que "
"<literal>Collection.add()</literal> ou <literal>Collection.addAll()</"
"literal> doit toujours retourner vrai pour un sac ou une <literal>List</"
"literal> (contrairement au <literal>Set</literal>). Cela peut rendre le code "
"suivant beaucoup plus rapide :"

#. Tag: title
#, no-c-format
msgid "One shot delete"
msgstr "Suppression en un coup"

#. Tag: para
#, no-c-format
msgid ""
"Deleting collection elements one by one can sometimes be extremely "
"inefficient. Hibernate knows not to do that in the case of an newly-empty "
"collection (if you called <literal>list.clear()</literal>, for example). In "
"this case, Hibernate will issue a single <literal>DELETE</literal>."
msgstr ""
"Parfois, effacer les éléments d'une collection un par un peut être "
"extrêmement inefficace. Hibernate n'est pas totalement stupide, il sait "
"qu'il ne faut pas le faire dans le cas d'une collection complètement vidée "
"(lorsque vous appelez <literal>list.clear()</literal>, par exemple). Dans ce "
"cas, Hibernate fera un simple <literal>DELETE</literal> et le travail est "
"fait ! "

#. Tag: para
#, no-c-format
msgid ""
"Suppose you added a single element to a collection of size twenty and then "
"remove two elements. Hibernate will issue one <literal>INSERT</literal> "
"statement and two <literal>DELETE</literal> statements, unless the "
"collection is a bag. This is certainly desirable."
msgstr ""
"Supposons que nous ajoutions un élément unique dans une collection de taille "
"vingt et que nous enlevions ensuite deux éléments. Hibernate effectuera un "
"<literal>INSERT</literal> puis deux <literal>DELETE</literal> (à moins que "
"la collection ne soit un sac). Cela est préférable. "

#. Tag: para
#, no-c-format
msgid ""
"However, suppose that we remove eighteen elements, leaving two and then add "
"thee new elements. There are two possible ways to proceed"
msgstr ""
"Cependant, supposons que nous enlevions dix-huit éléments, laissant ainsi "
"deux éléments, puis que nous ajoutions trois nouveaux éléments. Il y a deux "
"moyens de procéder."

#. Tag: para
#, no-c-format
msgid "delete eighteen rows one by one and then insert three rows"
msgstr "effacer dix-huit lignes une à une puis en insérer trois"

#. Tag: para
#, no-c-format
msgid ""
"remove the whole collection in one SQL <literal>DELETE</literal> and insert "
"all five current elements one by one"
msgstr ""
"effacer la totalité de la collection (en un SQL <literal>DELETE</literal>) "
"puis insérer les cinq éléments restant (un à un) "

#. Tag: para
#, no-c-format
msgid ""
"Hibernate cannot know that the second option is probably quicker. It would "
"probably be undesirable for Hibernate to be that intuitive as such behavior "
"might confuse database triggers, etc."
msgstr ""
"Hibernate n'est pas assez intelligent pour savoir que, dans ce cas, la "
"seconde option est plus rapide (Il vaut mieux que Hibernate ne soit pas trop "
"intelligent ; un tel comportement pourrait rendre l'utilisation de triggers "
"de bases de données plutôt aléatoire, etc...). "

#. Tag: para
#, no-c-format
msgid ""
"Fortunately, you can force this behavior (i.e. the second strategy) at any "
"time by discarding (i.e. dereferencing) the original collection and "
"returning a newly instantiated collection with all the current elements."
msgstr ""
"Heureusement, vous pouvez forcer ce comportement (c'est-à-dire la deuxième "
"stratégie) à tout moment en libérant (c'est-à-dire en déréférençant) la "
"collection initiale et en retournant une collection nouvellement instanciée "
"avec tous les éléments restants. "

#. Tag: para
#, no-c-format
msgid ""
"One-shot-delete does not apply to collections mapped <literal>inverse=\"true"
"\"</literal>."
msgstr ""
"Bien sûr, la suppression en un coup ne s'applique pas pour les collections "
"qui sont mappées avec <literal>inverse=\"true\"</literal>. "

#. Tag: title
#, no-c-format
msgid "Monitoring performance"
msgstr "Moniteur de performance"

#. Tag: para
#, no-c-format
msgid ""
"Optimization is not much use without monitoring and access to performance "
"numbers. Hibernate provides a full range of figures about its internal "
"operations. Statistics in Hibernate are available per "
"<literal>SessionFactory</literal>."
msgstr ""
"L'optimisation n'est pas d'un grand intérêt sans le suivi et l'accès aux "
"données de performance. Hibernate fournit toute une panoplie de rapport sur "
"ses opérations internes. Les statistiques dans Hibernate sont fournies par "
"<literal>SessionFactory</literal>."

#. Tag: title
#, no-c-format
msgid "Monitoring a SessionFactory"
msgstr "Suivi d'une SessionFactory"

#. Tag: para
#, no-c-format
msgid ""
"You can access <literal>SessionFactory</literal> metrics in two ways. Your "
"first option is to call <literal>sessionFactory.getStatistics()</literal> "
"and read or display the <literal>Statistics</literal> yourself."
msgstr ""
"Vous pouvez accéder aux métriques d'une <literal>SessionFactory</literal> de "
"deux manières. La première option est d'appeler <literal>sessionFactory."
"getStatistics()</literal> et de lire ou d'afficher les <literal>Statistics</"
"literal> vous-même."

#. Tag: para
#, no-c-format
msgid ""
"Hibernate can also use JMX to publish metrics if you enable the "
"<literal>StatisticsService</literal> MBean. You can enable a single MBean "
"for all your <literal>SessionFactory</literal> or one per factory. See the "
"following code for minimalistic configuration examples:"
msgstr ""
"Hibernate peut également utiliser JMX pour publier les métriques si vous "
"activez le MBean <literal>StatisticsService</literal>. Vous pouvez activer "
"un seul MBean pour toutes vos <literal>SessionFactory</literal> ou un par "
"fabrique. Voici un code qui montre un exemple de configuration minimaliste : "

#. Tag: para
#, no-c-format
msgid ""
"You can activate and deactivate the monitoring for a "
"<literal>SessionFactory</literal>:"
msgstr ""
"Vous pouvez (dés)activer le suivi pour une <literal>SessionFactory</"
"literal> :"

#. Tag: para
#, no-c-format
msgid ""
"at configuration time, set <literal>hibernate.generate_statistics</literal> "
"to <literal>false</literal>"
msgstr ""
"au moment de la configuration en mettant <literal>hibernate."
"generate_statistics</literal> à <literal>false</literal>"

#. Tag: para
#, no-c-format
msgid ""
"at runtime: <literal>sf.getStatistics().setStatisticsEnabled(true)</literal> "
"or <literal>hibernateStatsBean.setStatisticsEnabled(true)</literal>"
msgstr ""
"à chaud avec <literal>sf.getStatistics().setStatisticsEnabled(true)</"
"literal> ou <literal>hibernateStatsBean.setStatisticsEnabled(true)</literal>"

#. Tag: para
#, no-c-format
msgid ""
"Statistics can be reset programmatically using the <literal>clear()</"
"literal> method. A summary can be sent to a logger (info level) using the "
"<literal>logSummary()</literal> method."
msgstr ""
"Les statistiques peuvent être remises à zéro de manière programmatique à "
"l'aide de la méthode <literal>clear()</literal> Un résumé peut être envoyé à "
"un logger (niveau info) à l'aide de la méthode <literal>logSummary()</"
"literal>."

#. Tag: title
#, no-c-format
msgid "Metrics"
msgstr "Métriques"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate provides a number of metrics, from basic information to more "
"specialized information that is only relevant in certain scenarios. All "
"available counters are described in the <literal>Statistics</literal> "
"interface API, in three categories:"
msgstr ""
"Hibernate fournit plusieurs métriques, qui vont des informations très "
"basiques aux informations très spécialisées qui ne sont appropriées que dans "
"certains scénarios. Tous les compteurs accessibles sont décrits dans l'API "
"de l'interface <literal>Statistics</literal> dans trois catégories : "

#. Tag: para
#, no-c-format
msgid ""
"Metrics related to the general <literal>Session</literal> usage, such as "
"number of open sessions, retrieved JDBC connections, etc."
msgstr ""
"Les métriques relatives à l'usage général de la <literal>Session</literal> "
"comme le nombre de sessions ouvertes, le nombre de connexions JDBC "
"récupérées, etc..."

#. Tag: para
#, no-c-format
msgid ""
"Metrics related to the entities, collections, queries, and caches as a whole "
"(aka global metrics)."
msgstr ""
"Les métriques relatives aux entités, collections, requêtes et caches dans "
"leur ensemble (métriques globales aka)."

#. Tag: para
#, no-c-format
msgid ""
"Detailed metrics related to a particular entity, collection, query or cache "
"region."
msgstr ""
"Les métriques détaillées relatives à une entité, une collection, une requête "
"ou une région de cache particulière."

#. Tag: para
#, no-c-format
msgid ""
"For example, you can check the cache hit, miss, and put ratio of entities, "
"collections and queries, and the average time a query needs. Be aware that "
"the number of milliseconds is subject to approximation in Java. Hibernate is "
"tied to the JVM precision and on some platforms this might only be accurate "
"to 10 seconds."
msgstr ""
"Par exemple, vous pouvez vérifier les hit, miss du cache ainsi que le taux "
"d'éléments manquants et de mise à jour des entités, collections et requêtes "
"et le temps moyen que met une requête. Il faut faire attention au fait que "
"le nombre de millisecondes est sujet à approximation en Java. Hibernate est "
"lié à la précision de la machine virtuelle, sur certaines plateformes, cela "
"n'offre qu'une précision de l'ordre de 10 secondes. "

#. Tag: para
#, no-c-format
msgid ""
"Simple getters are used to access the global metrics (i.e. not tied to a "
"particular entity, collection, cache region, etc.). You can access the "
"metrics of a particular entity, collection or cache region through its name, "
"and through its HQL or SQL representation for queries. Please refer to the "
"<literal>Statistics</literal>, <literal>EntityStatistics</literal>, "
"<literal>CollectionStatistics</literal>, "
"<literal>SecondLevelCacheStatistics</literal>, and <literal>QueryStatistics</"
"literal> API Javadoc for more information. The following code is a simple "
"example:"
msgstr ""
"Des accesseurs simples sont utilisés pour accéder aux métriques globales "
"(c'est-à-dire, celles qui ne sont pas liées à une entité, collection ou "
"région de cache particulière). Vous pouvez accéder aux métriques d'une "
"entité, collection, région de cache particulière à l'aide de son nom et à "
"l'aide de sa représentation HQL ou SQL pour une requête. Référez vous à la "
"javadoc des APIS <literal>Statistics</literal>, <literal>EntityStatistics</"
"literal>, <literal>CollectionStatistics</literal>, "
"<literal>SecondLevelCacheStatistics</literal>, et <literal>QueryStatistics</"
"literal> pour plus d'informations. Le code ci-dessous montre un exemple "
"simple : "

#. Tag: para
#, no-c-format
msgid ""
"You can work on all entities, collections, queries and region caches, by "
"retrieving the list of names of entities, collections, queries and region "
"caches using the following methods: <literal>getQueries()</literal>, "
"<literal>getEntityNames()</literal>, <literal>getCollectionRoleNames()</"
"literal>, and <literal>getSecondLevelCacheRegionNames()</literal>."
msgstr ""
"Pour travailler sur toutes les entités, collections, requêtes et régions de "
"cache, vous pouvez récupérer la liste des noms des entités, collections, "
"requêtes et régions de cache avec les méthodes suivantes : "
"<literal>getQueries()</literal>, <literal>getEntityNames()</literal>, "
"<literal>getCollectionRoleNames()</literal>, et "
"<literal>getSecondLevelCacheRegionNames()</literal>. "

#~ msgid ""
#~ "This setting creates two new cache regions: one holding cached query "
#~ "result sets (<literal>org.hibernate.cache.StandardQueryCache</literal>), "
#~ "the other holding timestamps of the most recent updates to queryable "
#~ "tables (<literal>org.hibernate.cache.UpdateTimestampsCache</literal>). "
#~ "Note that the query cache does not cache the state of the actual entities "
#~ "in the result set; it caches only identifier values and results of value "
#~ "type. The query cache should always be used in conjunction with the "
#~ "second-level cache."
#~ msgstr ""
#~ "Ce paramètre amène la création de deux nouvelles régions dans le cache, "
#~ "une qui va conserver le résultat des requêtes mises en cache "
#~ "(<literal>org.hibernate.cache.StandardQueryCache</literal>) et l'autre "
#~ "qui va conserver l'horodatage des mises à jour les plus récentes "
#~ "effectuées sur les tables requêtables (<literal>org.hibernate.cache."
#~ "UpdateTimestampsCache</literal>). Il faut noter que le cache de requête "
#~ "ne conserve pas l'état des entités dans les résultats, il met en cache "
#~ "uniquement les valeurs de l'identifiant et les résultats de types de "
#~ "valeurs. Par conséquent, le cache de requête doit toujours être utilisé "
#~ "avec le cache de second niveau. "
