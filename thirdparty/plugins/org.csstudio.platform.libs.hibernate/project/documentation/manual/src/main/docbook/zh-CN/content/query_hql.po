# translation of Collection_Mapping.po to
# Xi Huang <xhuang@redhat.com>, 2006.
# Xi HUANG <xhuang@redhat.com>, 2007.
msgid ""
msgstr ""
"Project-Id-Version: Collection_Mapping\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:15\n"
"PO-Revision-Date: 2010-03-16 10:03+1000\n"
"Last-Translator: Xi HUANG <xhuang@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "HQL: The Hibernate Query Language"
msgstr "HQL: Hibernate 查询语言"

#. Tag: para
#, no-c-format
msgid "Hibernate uses a powerful query language (HQL) that is similar in appearance to SQL. Compared with SQL, however, HQL is fully object-oriented and understands notions like inheritance, polymorphism and association."
msgstr "Hibernate 配备了一种非常强大的查询语言，这种语言看上去很像 SQL。但是不要被语法结构上的相似所迷惑，HQL 是非常有意识的被设计为完全面向对象的查询，它可以理解如继承、多态和关联之类的概念。 "

#. Tag: title
#, no-c-format
msgid "Case Sensitivity"
msgstr "大小写敏感性问题"

#. Tag: para
#, no-c-format
msgid "With the exception of names of Java classes and properties, queries are case-insensitive. So <literal>SeLeCT</literal> is the same as <literal>sELEct</literal> is the same as <literal>SELECT</literal>, but <literal>org.hibernate.eg.FOO</literal> is not <literal>org.hibernate.eg.Foo</literal>, and <literal>foo.barSet</literal> is not <literal>foo.BARSET</literal>."
msgstr "除了 Java 类与属性的名称外，查询语句对大小写并不敏感。 所以 <literal>SeLeCT</literal> 与 <literal>sELEct</literal> 以及 <literal>SELECT</literal> 是相同的，但是 <literal>org.hibernate.eg.FOO</literal> 并不等价于 <literal>org.hibernate.eg.Foo</literal> 并且 <literal>foo.barSet</literal> 也不等价于 <literal>foo.BARSET</literal>。 "

#. Tag: para
#, no-c-format
msgid "This manual uses lowercase HQL keywords. Some users find queries with uppercase keywords more readable, but this convention is unsuitable for queries embedded in Java code."
msgstr "本手册中的 HQL 关键字将使用小写字母。很多用户发现使用完全大写的关键字会使查询语句的可读性更强，但我们发现，当把查询语句嵌入到 Java 语句中的时候使用大写关键字比较难看。"

#. Tag: title
#, no-c-format
msgid "The from clause"
msgstr "from 子句"

#. Tag: para
#, no-c-format
msgid "The simplest possible Hibernate query is of the form:"
msgstr "Hibernate 中最简单的查询语句的形式如下："

#. Tag: para
#, no-c-format
msgid "This returns all instances of the class <literal>eg.Cat</literal>. You do not usually need to qualify the class name, since <literal>auto-import</literal> is the default. For example:"
msgstr "该子句简单的返回 <literal>eg.Cat</literal> 类的所有实例。通常我们不需要使用类的全限定名，因为  <literal>auto-import</literal>（自动引入）是缺省的情况。所以我们几乎只使用如下的简单写法： "

#. Tag: para
#, no-c-format
msgid "In order to refer to the <literal>Cat</literal> in other parts of the query, you will need to assign an <emphasis>alias</emphasis>. For example:"
msgstr "为了在这个查询的其他部分里引用 <literal>Cat</literal>，你将需要分配一个<emphasis>别名</emphasis>。例如："

#. Tag: para
#, no-c-format
msgid "This query assigns the alias <literal>cat</literal> to <literal>Cat</literal> instances, so you can use that alias later in the query. The <literal>as</literal> keyword is optional. You could also write:"
msgstr "这个语句把别名 <literal>cat</literal> 指定给类<literal>Cat</literal> 的实例，这样我们就可以在随后的查询中使用此别名了。关键字 <literal>as</literal> 是可选的，我们也可以这样写： "

#. Tag: para
#, no-c-format
msgid "Multiple classes can appear, resulting in a cartesian product or \"cross\" join."
msgstr "子句中可以同时出现多个类，其查询结果是产生一个笛卡儿积或产生跨表的连接。 "

#. Tag: para
#, no-c-format
msgid "It is good practice to name query aliases using an initial lowercase as this is consistent with Java naming standards for local variables (e.g. <literal>domesticCat</literal>)."
msgstr "查询语句中别名的开头部分小写被认为是实践中的好习惯，这样做与 Java 变量的命名标准保持了一致（比如，<literal>domesticCat</literal>）。 "

#. Tag: title
#, no-c-format
msgid "Associations and joins"
msgstr "关联（Association）与连接（Join）"

#. Tag: para
#, no-c-format
msgid "You can also assign aliases to associated entities or to elements of a collection of values using a <literal>join</literal>. For example:"
msgstr "我们也可以为相关联的实体甚至是对一个集合中的全部元素指定一个别名，这时要使用关键字 <literal>join</literal>。 "

#. Tag: para
#, no-c-format
msgid "The supported join types are borrowed from ANSI SQL:"
msgstr "受支持的连接类型是从 ANSI SQL 中借鉴来的："

#. Tag: para
#, no-c-format
msgid "<literal>inner join</literal>"
msgstr "<literal>inner join</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>left outer join</literal>"
msgstr "<literal>left outer join</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>right outer join</literal>"
msgstr "<literal>right outer join</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>full join</literal> (not usually useful)"
msgstr "<literal>full join</literal>（全连接，并不常用）"

#. Tag: para
#, no-c-format
msgid "The <literal>inner join</literal>, <literal>left outer join</literal> and <literal>right outer join</literal> constructs may be abbreviated."
msgstr "语句 <literal>inner join</literal>，<literal>left outer join</literal> 以及 <literal>right outer join</literal> 可以简写。"

#. Tag: para
#, no-c-format
msgid "You may supply extra join conditions using the HQL <literal>with</literal> keyword."
msgstr "通过 HQL 的 <literal>with</literal> 关键字，你可以提供额外的 join 条件。"

#. Tag: para
#, no-c-format
msgid "A \"fetch\" join allows associations or collections of values to be initialized along with their parent objects using a single select. This is particularly useful in the case of a collection. It effectively overrides the outer join and lazy declarations of the mapping file for associations and collections. See <xref linkend=\"performance-fetching\" /> for more information."
msgstr "还有，一个 \"fetch\" 连接允许仅仅使用一个选择语句就将相关联的对象或一组值的集合随着他们的父对象的初始化而被初始化，这种方法在使用到集合的情况下尤其有用，对于关联和集合来说，它有效的代替了映射文件中的外联接与延迟声明（lazy declarations）。查看 <xref linkend=\"performance-fetching\" /> 以获得等多的信息。 "

#. Tag: para
#, no-c-format
msgid "A fetch join does not usually need to assign an alias, because the associated objects should not be used in the <literal>where</literal> clause (or any other clause). The associated objects are also not returned directly in the query results. Instead, they may be accessed via the parent object. The only reason you might need an alias is if you are recursively join fetching a further collection:"
msgstr "一个 fetch 连接通常不需要被指定别名，因为相关联的对象不应当被用在 <literal>where</literal> 子句（或其它任何子句）中。同时，相关联的对象并不在查询的结果中直接返回，但可以通过他们的父对象来访问到他们。 "

#. Tag: para
#, no-c-format
msgid "The <literal>fetch</literal> construct cannot be used in queries called using <literal>iterate()</literal> (though <literal>scroll()</literal> can be used). <literal>Fetch</literal> should be used together with <literal>setMaxResults()</literal> or <literal>setFirstResult()</literal>, as these operations are based on the result rows which usually contain duplicates for eager collection fetching, hence, the number of rows is not what you would expect. <literal>Fetch</literal> should also not be used together with impromptu <literal>with</literal> condition. It is possible to create a cartesian product by join fetching more than one collection in a query, so take care in this case. Join fetching multiple collection roles can produce unexpected results for bag mappings, so user discretion is advised when formulating queries in this case. Finally, note that <literal>full join fetch</literal> and <literal>right join fetch</literal> are not meaningful."
msgstr "假若使用 <literal>iterate()</literal> 来调用查询，请注意 <literal>fetch</literal> 构造是不能使用的（<literal>scroll()</literal> 可以使用）。<literal>fetch</literal> 也不应该与 <literal>setMaxResults()</literal> 或 <literal>setFirstResult()</literal> 共用，这是因为这些操作是基于结果集的，而在预先抓取集合类时可能包含重复的数据，也就是说无法预先知道精确的行数。<literal>fetch</literal> 还不能与独立的 <literal>with</literal> 条件一起使用。通过在一次查询中 fetch 多个集合，可以制造出笛卡尔积，因此请多加注意。对 bag 映射来说，同时 join fetch 多个集合角色可能在某些情况下给出并非预期的结果，也请小心。最后注意，使用 <literal>full join fetch</literal> 与 <literal>right join fetch</literal> 是没有意义的。 "

#. Tag: para
#, no-c-format
msgid "If you are using property-level lazy fetching (with bytecode instrumentation), it is possible to force Hibernate to fetch the lazy properties in the first query immediately using <literal>fetch all properties</literal>."
msgstr "如果你使用属性级别的延迟获取（lazy fetching）（这是通过重新编写字节码实现的），可以使用  <literal>fetch all properties</literal> 来强制 Hibernate 立即取得那些原本需要延迟加载的属性（在第一个查询中）。 "

#. Tag: title
#, no-c-format
msgid "Forms of join syntax"
msgstr "join 语法的形式"

#. Tag: para
#, no-c-format
msgid "HQL supports two forms of association joining: <literal>implicit</literal> and <literal>explicit</literal>."
msgstr "HQL 支持两种关联 join 的形式：<literal>implicit（隐式）</literal> 与 <literal>explicit（显式）</literal>。"

#. Tag: para
#, no-c-format
msgid "The queries shown in the previous section all use the <literal>explicit</literal> form, that is, where the join keyword is explicitly used in the from clause. This is the recommended form."
msgstr "上一节中给出的查询都是使用 <literal>explicit（显式）</literal>形式的，其中 form 子句中明确给出了 join 关键字。这是建议使用的方式。 "

#. Tag: para
#, no-c-format
msgid "The <literal>implicit</literal> form does not use the join keyword. Instead, the associations are \"dereferenced\" using dot-notation. <literal>implicit</literal> joins can appear in any of the HQL clauses. <literal>implicit</literal> join result in inner joins in the resulting SQL statement."
msgstr "<literal>implicit（隐式）</literal>形式不使用 join 关键字。关联使用\"点号\"来进行“引用”。<literal>implicit</literal> join 可以在任何 HQL 子句中出现。<literal>implicit</literal> join 在最终的 SQL 语句中以 inner join 的方式出现。"

#. Tag: title
#, no-c-format
msgid "Referring to identifier property"
msgstr "引用 identifier 属性 "

#. Tag: para
#, no-c-format
msgid "There are 2 ways to refer to an entity's identifier property:"
msgstr "通常有两种方法来引用实体的 identifier 属性： "

#. Tag: para
#, no-c-format
msgid "The special property (lowercase) <literal>id</literal> may be used to reference the identifier property of an entity <emphasis>provided that the entity does not define a non-identifier property named id</emphasis>."
msgstr "特殊属性（lowercase）<literal>id</literal> 可以用来引用实体的 identifier 属性 <emphasis>假设这个实体没有定义用 non-identifier 属性命名的 id</emphasis>。 "

#. Tag: para
#, no-c-format
msgid "If the entity defines a named identifier property, you can use that property name."
msgstr "如果这个实体定义了 identifier 属性，你可以使用属性名。 "

#. Tag: para
#, no-c-format
msgid "References to composite identifier properties follow the same naming rules. If the entity has a non-identifier property named id, the composite identifier property can only be referenced by its defined named. Otherwise, the special <literal>id</literal> property can be used to reference the identifier property."
msgstr "对组合 identifier 属性的引用遵循相同的命名规则。如果实体有一个 non-identifier 属性命名的 id，这个组合 identifier 属性只能用自己定义的名字来引用；否则，特殊 <literal>id</literal> 属性可以用来引用 identifier 属性。 "

#. Tag: para
#, no-c-format
msgid "Please note that, starting in version 3.2.2, this has changed significantly. In previous versions, <literal>id</literal> <emphasis>always</emphasis> referred to the identifier property regardless of its actual name. A ramification of that decision was that non-identifier properties named <literal>id</literal> could never be referenced in Hibernate queries."
msgstr "注意：从 3.2.2 版本开始，这已经改变了很多。在前面的版本里，不管实际的名字，<literal>id</literal> <emphasis>总是</emphasis>指向 identifier 属性；而用 non-identifier 属性命名的 <literal>id</literal> 就从来不在 Hibernate 查询里引用。  "

#. Tag: title
#, no-c-format
msgid "The select clause"
msgstr "select 子句"

#. Tag: para
#, no-c-format
msgid "The <literal>select</literal> clause picks which objects and properties to return in the query result set. Consider the following:"
msgstr "<literal>select</literal> 子句选择将哪些对象与属性返回到查询结果集中。考虑如下情况："

#. Tag: para
#, no-c-format
msgid "The query will select <literal>mate</literal>s of other <literal>Cat</literal>s. You can express this query more compactly as:"
msgstr "该语句将选择其它 <literal>Cat</literal> 的 <literal>mate</literal>（其他猫的配偶）。实际上，你可以更简洁的用以下的查询语句表达相同的含义： "

#. Tag: para
#, no-c-format
msgid "Queries can return properties of any value type including properties of component type:"
msgstr "查询语句可以返回值为任何类型的属性，包括返回类型为某种组件（Component）的属性： "

#. Tag: para
#, no-c-format
msgid "Queries can return multiple objects and/or properties as an array of type <literal>Object[]</literal>:"
msgstr "查询语句可以返回多个对象和（或）属性，存放在 <literal>Object[]</literal> 队列中， "

#. Tag: para
#, no-c-format
msgid "Or as a <literal>List</literal>:"
msgstr "或存放在一个 <literal>List</literal> 对象中："

#. Tag: para
#, no-c-format
msgid "Or - assuming that the class <literal>Family</literal> has an appropriate constructor - as an actual typesafe Java object:"
msgstr "假设类 <literal>Family</literal> 有一个合适的构造函数 - 作为实际的类型安全的 Java 对象："

#. Tag: para
#, no-c-format
msgid "You can assign aliases to selected expressions using <literal>as</literal>:"
msgstr "你可以使用关键字 <literal>as</literal> 给“被选择了的表达式”指派别名： "

#. Tag: para
#, no-c-format
msgid "This is most useful when used together with <literal>select new map</literal>:"
msgstr "这种做法在与子句 <literal>select new map</literal> 一起使用时最有用："

#. Tag: para
#, no-c-format
msgid "This query returns a <literal>Map</literal> from aliases to selected values."
msgstr "该查询返回了一个 <literal>Map</literal> 的对象，内容是别名与被选择的值组成的名-值映射。"

#. Tag: title
#, no-c-format
msgid "Aggregate functions"
msgstr "聚集函数"

#. Tag: para
#, no-c-format
msgid "HQL queries can even return the results of aggregate functions on properties:"
msgstr "HQL 查询甚至可以返回作用于属性之上的聚集函数的计算结果： "

#. Tag: para
#, no-c-format
msgid "The supported aggregate functions are:"
msgstr "受支持的聚集函数如下： "

#. Tag: para
#, no-c-format
msgid "<literal>avg(...), sum(...), min(...), max(...)</literal>"
msgstr "<literal>avg(...), sum(...), min(...), max(...)</literal> "

#. Tag: para
#, no-c-format
msgid "<literal>count(*)</literal>"
msgstr "<literal>count(*)</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>count(...), count(distinct ...), count(all...)</literal>"
msgstr "<literal>count(...), count(distinct ...), count(all...)</literal>"

#. Tag: para
#, no-c-format
msgid "You can use arithmetic operators, concatenation, and recognized SQL functions in the select clause:"
msgstr "你可以在选择子句中使用数学操作符、连接以及经过验证的 SQL 函数： "

#. Tag: para
#, no-c-format
msgid "The <literal>distinct</literal> and <literal>all</literal> keywords can be used and have the same semantics as in SQL."
msgstr "关键字 <literal>distinct</literal> 与 <literal>all</literal> 也可以使用，它们具有与 SQL 相同的语义。 "

#. Tag: title
#, no-c-format
msgid "Polymorphic queries"
msgstr "多态查询"

#. Tag: para
#, no-c-format
msgid "A query like:"
msgstr "一个如下的查询语句："

#. Tag: para
#, no-c-format
msgid "returns instances not only of <literal>Cat</literal>, but also of subclasses like <literal>DomesticCat</literal>. Hibernate queries can name <emphasis>any</emphasis> Java class or interface in the <literal>from</literal> clause. The query will return instances of all persistent classes that extend that class or implement the interface. The following query would return all persistent objects:"
msgstr "不仅返回 <literal>Cat</literal> 类的实例，也同时返回子类 <literal>DomesticCat</literal> 的实例。Hibernate 可以在 <literal>from</literal> 子句中指定<emphasis>任何</emphasis> Java 类或接口。查询会返回继承了该类的所有持久化子类的实例或返回声明了该接口的所有持久化类的实例。下面的查询语句返回所有的被持久化的对象： "

#. Tag: para
#, no-c-format
msgid "The interface <literal>Named</literal> might be implemented by various persistent classes:"
msgstr "接口 <literal>Named</literal> 可能被各种各样的持久化类声明："

#. Tag: para
#, no-c-format
msgid "These last two queries will require more than one SQL <literal>SELECT</literal>. This means that the <literal>order by</literal> clause does not correctly order the whole result set. It also means you cannot call these queries using <literal>Query.scroll()</literal>."
msgstr "注意，最后的两个查询将需要超过一个的 SQL <literal>SELECT</literal>。这表明 <literal>order by</literal> 子句没有对整个结果集进行正确的排序。（这也说明你不能对这样的查询使用 <literal>Query.scroll()</literal> 方法。）"

#. Tag: title
#, no-c-format
msgid "The where clause"
msgstr "where 子句"

#. Tag: para
#, no-c-format
msgid "The <literal>where</literal> clause allows you to refine the list of instances returned. If no alias exists, you can refer to properties by name:"
msgstr "<literal>where</literal> 子句允许你将返回的实例列表的范围缩小。如果没有指定别名，你可以使用属性名来直接引用属性： "

#. Tag: para
#, no-c-format
msgid "If there is an alias, use a qualified property name:"
msgstr "如果指派了别名，需要使用完整的属性名："

#. Tag: para
#, no-c-format
msgid "This returns instances of <literal>Cat</literal> named 'Fritz'."
msgstr "返回名为（属性 name 等于）'Fritz' 的 <literal>Cat</literal> 类的实例。 "

#. Tag: para
#, no-c-format
msgid "The following query:"
msgstr "下面的查询："

#. Tag: para
#, no-c-format
msgid "returns all instances of <literal>Foo</literal> with an instance of <literal>bar</literal> with a <literal>date</literal> property equal to the <literal>startDate</literal> property of the <literal>Foo</literal>. Compound path expressions make the <literal>where</literal> clause extremely powerful. Consider the following:"
msgstr "将返回所有满足下面条件的 <literal>Foo</literal> 类的实例： 存在如下的 <literal>bar</literal> 的一个实例，其 <literal>date</literal> 属性等于 <literal>Foo</literal> 的 <literal>startDate</literal> 属性。复合路径表达式使得 <literal>where</literal> 子句非常的强大，考虑如下情况： "

#. Tag: para
#, no-c-format
msgid "This query translates to an SQL query with a table (inner) join. For example:"
msgstr "该查询将被翻译成为一个含有表连接（内连接）的 SQL 查询。如果你打算写像这样的查询语句："

#. Tag: para
#, no-c-format
msgid "would result in a query that would require four table joins in SQL."
msgstr "在 SQL 中，你为达此目的将需要进行一个四表连接的查询。 "

#. Tag: para
#, no-c-format
msgid "The <literal>=</literal> operator can be used to compare not only properties, but also instances:"
msgstr "<literal>=</literal> 运算符不仅可以被用来比较属性的值，也可以用来比较实例： "

#. Tag: para
#, no-c-format
msgid "The special property (lowercase) <literal>id</literal> can be used to reference the unique identifier of an object. See <xref linkend=\"queryhql-identifier-property\" /> for more information."
msgstr "特殊属性（小写）<literal>id</literal> 可以用来表示一个对象的唯一的标识符。详情请参考 <xref linkend=\"queryhql-identifier-property\" />。 "

#. Tag: para
#, no-c-format
msgid "The second query is efficient and does not require a table join."
msgstr "第二个查询是有效的。此时不需要进行表连接。"

#. Tag: para
#, no-c-format
msgid "Properties of composite identifiers can also be used. Consider the following example where <literal>Person</literal> has composite identifiers consisting of <literal>country</literal> and <literal>medicareNumber</literal>:"
msgstr "同样也可以使用复合标识符。比如 <literal>Person</literal> 类有一个复合标识符，它由 <literal>country</literal> 属性与 <literal>medicareNumber</literal> 属性组成："

#. Tag: para
#, no-c-format
msgid "Once again, the second query does not require a table join."
msgstr "第二个查询也不需要进行表连接。 "

#. Tag: para
#, no-c-format
msgid "See <xref linkend=\"queryhql-identifier-property\" /> for more information regarding referencing identifier properties)"
msgstr "关于引用标识符属性的更多信息，请参考 <xref linkend=\"queryhql-identifier-property\" />。 "

#. Tag: para
#, no-c-format
msgid "The special property <literal>class</literal> accesses the discriminator value of an instance in the case of polymorphic persistence. A Java class name embedded in the where clause will be translated to its discriminator value."
msgstr "同样的，特殊属性 <literal>class</literal> 在进行多态持久化的情况下被用来存取一个实例的鉴别值（discriminator value）。一个嵌入到 where 子句中的 Java 类的名字将被转换为该类的鉴别值。 "

#. Tag: para
#, no-c-format
msgid "You can also use components or composite user types, or properties of said component types. See <xref linkend=\"queryhql-components\" /> for more information."
msgstr "你也可以使用组件或者复合用户类型，以及组件类型的属性。详情请参考 <xref linkend=\"queryhql-components\" />。 "

#. Tag: para
#, no-c-format
msgid "An \"any\" type has the special properties <literal>id</literal> and <literal>class</literal> that allows you to express a join in the following way (where <literal>AuditLog.item</literal> is a property mapped with <literal>&lt;any&gt;</literal>):"
msgstr "一个“任意”类型有两个特殊的属性 <literal>id</literal> 和 <literal>class</literal>，来允许我们按照下面的方式表达一个连接（<literal>AuditLog.item</literal> 是一个属性，该属性被映射为 <literal>&lt;any&gt;</literal>）。 "

#. Tag: para
#, no-c-format
msgid "The <literal>log.item.class</literal> and <literal>payment.class</literal> would refer to the values of completely different database columns in the above query."
msgstr "注意，在上面的查询与句中，<literal>log.item.class</literal> 和 <literal>payment.class</literal> 将涉及到完全不同的数据库中的列。"

#. Tag: title
#, no-c-format
msgid "Expressions"
msgstr "表达式"

#. Tag: para
#, no-c-format
msgid "Expressions used in the <literal>where</literal> clause include the following:"
msgstr "在 <literal>where</literal> 子句中允许使用的表达式包括 大多数你可以在 SQL 使用的表达式种类： "

#. Tag: para
#, no-c-format
msgid "mathematical operators: <literal>+, -, *, /</literal>"
msgstr "数学运算符 <literal>+，-，*，/</literal> "

#. Tag: para
#, no-c-format
msgid "binary comparison operators: <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</literal>"
msgstr "二进制比较运算符 <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</literal> "

#. Tag: para
#, no-c-format
msgid "logical operations <literal>and, or, not</literal>"
msgstr "逻辑运算符 <literal>and，or，not</literal>"

#. Tag: para
#, no-c-format
msgid "Parentheses <literal>( )</literal> that indicates grouping"
msgstr "括号 <literal>( )</literal>，表示分组 "

#. Tag: para
#, no-c-format
msgid "<literal>in</literal>, <literal>not in</literal>, <literal>between</literal>, <literal>is null</literal>, <literal>is not null</literal>, <literal>is empty</literal>, <literal>is not empty</literal>, <literal>member of</literal> and <literal>not member of</literal>"
msgstr "<literal>in</literal>, <literal>not in</literal>, <literal>between</literal>, <literal>is null</literal>, <literal>is not null</literal>, <literal>is empty</literal>, <literal>is not empty</literal>, <literal>member of</literal> and <literal>not member of</literal>"

#. Tag: para
#, no-c-format
msgid "\"Simple\" case, <literal>case ... when ... then ... else ... end</literal>, and \"searched\" case, <literal>case when ... then ... else ... end</literal>"
msgstr "\"Simple\" case, <literal>case ... when ... then ... else ... end</literal>, and \"searched\" case, <literal>case when ... then ... else ... end</literal>"

#. Tag: para
#, no-c-format
msgid "string concatenation <literal>...||...</literal> or <literal>concat(...,...)</literal>"
msgstr "字符串连接符 <literal>...||...</literal> or <literal>concat(...,...)</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>current_date()</literal>, <literal>current_time()</literal>, and <literal>current_timestamp()</literal>"
msgstr "<literal>current_date()</literal>, <literal>current_time()</literal>, and <literal>current_timestamp()</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, and <literal>year(...)</literal>"
msgstr "<literal>second(...)</literal>、<literal>minute(...)</literal>、<literal>hour(...)</literal>、<literal>day(...)</literal>、<literal>month(...)</literal> 和 <literal>year(...)</literal>"

#. Tag: para
#, no-c-format
msgid "Any function or operator defined by EJB-QL 3.0: <literal>substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</literal>"
msgstr "EJB-QL 3.0 定义的任何功能或操作符：<literal>substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>coalesce()</literal> and <literal>nullif()</literal>"
msgstr "<literal>coalesce()</literal> 和 <literal>nullif()</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>str()</literal> for converting numeric or temporal values to a readable string"
msgstr "<literal>str()</literal> 把数字或者时间值转换为可读的字符串"

#. Tag: para
#, no-c-format
msgid "<literal>cast(... as ...)</literal>, where the second argument is the name of a Hibernate type, and <literal>extract(... from ...)</literal> if ANSI <literal>cast()</literal> and <literal>extract()</literal> is supported by the underlying database"
msgstr "<literal>cast(... as ...)</literal>，其第二个参数是某 Hibernate 类型的名字，以及 <literal>extract(... from ...)</literal>，只要 ANSI <literal>cast()</literal> 和  <literal>extract()</literal> 被底层数据库支持"

#. Tag: para
#, no-c-format
msgid "the HQL <literal>index()</literal> function, that applies to aliases of a joined indexed collection"
msgstr "HQL <literal>index()</literal> 函数，作用于 join 的有序集合的别名。"

#. Tag: para
#, no-c-format
msgid "HQL functions that take collection-valued path expressions: <literal>size(), minelement(), maxelement(), minindex(), maxindex()</literal>, along with the special <literal>elements()</literal> and <literal>indices</literal> functions that can be quantified using <literal>some, all, exists, any, in</literal>."
msgstr "HQL 函数，把集合作为参数：<literal>size(), minelement(), maxelement(), minindex(), maxindex()</literal>，还有特别的 <literal>elements()</literal> 和 <literal>indices</literal> 函数，可以与数量词加以限定：<literal>some, all, exists, any, in</literal>。 "

#. Tag: para
#, no-c-format
msgid "Any database-supported SQL scalar function like <literal>sign()</literal>, <literal>trunc()</literal>, <literal>rtrim()</literal>, and <literal>sin()</literal>"
msgstr "任何数据库支持的 SQL 标量函数，比如 <literal>sign()</literal>, <literal>trunc()</literal>, <literal>rtrim()</literal>, <literal>sin()</literal> "

#. Tag: para
#, no-c-format
msgid "JDBC-style positional parameters <literal>?</literal>"
msgstr "JDBC 风格的参数传入 <literal>?</literal>"

#. Tag: para
#, no-c-format
msgid "named parameters <literal>:name</literal>, <literal>:start_date</literal>, and <literal>:x1</literal>"
msgstr "命名参数 <literal>:name</literal>，<literal>:start_date</literal>，<literal>:x1</literal> "

#. Tag: para
#, no-c-format
msgid "SQL literals <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"
msgstr "SQL 直接常量 <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"

#. Tag: para
#, no-c-format
msgid "Java <literal>public static final</literal> constants <literal>eg.Color.TABBY</literal>"
msgstr "Java <literal>public static final</literal> 类型的常量 <literal>eg.Color.TABBY</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>in</literal> and <literal>between</literal> can be used as follows:"
msgstr "关键字 <literal>in</literal> 与 <literal>between</literal> 可按如下方法使用： "

#. Tag: para
#, no-c-format
msgid "The negated forms can be written as follows:"
msgstr "而且否定的格式也可以如下书写： "

#. Tag: para
#, no-c-format
msgid "Similarly, <literal>is null</literal> and <literal>is not null</literal> can be used to test for null values."
msgstr "同样，子句 <literal>is null</literal> 与 <literal>is not null</literal> 可以被用来测试空值（null）。 "

#. Tag: para
#, no-c-format
msgid "Booleans can be easily used in expressions by declaring HQL query substitutions in Hibernate configuration:"
msgstr "在 Hibernate 配置文件中声明 HQL“查询替代（query substitutions）”之后，布尔表达式（Booleans）可以在其他表达式中轻松的使用： "

#. Tag: para
#, no-c-format
msgid "This will replace the keywords <literal>true</literal> and <literal>false</literal> with the literals <literal>1</literal> and <literal>0</literal> in the translated SQL from this HQL:"
msgstr "系统将该 HQL 转换为 SQL 语句时，该设置表明将用字符 <literal>1</literal> 和  <literal>0</literal> 来取代关键字 <literal>true</literal> 和 <literal>false</literal>："

#. Tag: para
#, no-c-format
msgid "You can test the size of a collection with the special property <literal>size</literal> or the special <literal>size()</literal> function."
msgstr "你可以用特殊属性 <literal>size</literal>，或是特殊函数 <literal>size()</literal> 测试一个集合的大小。 "

#. Tag: para
#, no-c-format
msgid "For indexed collections, you can refer to the minimum and maximum indices using <literal>minindex</literal> and <literal>maxindex</literal> functions. Similarly, you can refer to the minimum and maximum elements of a collection of basic type using the <literal>minelement</literal> and <literal>maxelement</literal> functions. For example:"
msgstr "对于索引了（有序）的集合，你可以使用 <literal>minindex</literal> 与  <literal>maxindex</literal> 函数来引用到最小与最大的索引序数。同理，你可以使用 <literal>minelement</literal> 与 <literal>maxelement</literal> 函数来引用到一个基本数据类型的集合中最小与最大的元素。例如："

#. Tag: para
#, no-c-format
msgid "The SQL functions <literal>any, some, all, exists, in</literal> are supported when passed the element or index set of a collection (<literal>elements</literal> and <literal>indices</literal> functions) or the result of a subquery (see below):"
msgstr "在传递一个集合的索引集或者是元素集（<literal>elements</literal> 与 <literal>indices</literal> 函数）或者传递一个子查询的结果的时候，可以使用 SQL 函数 <literal>any, some，all, exists, in</literal>："

#. Tag: para
#, no-c-format
msgid "Note that these constructs - <literal>size</literal>, <literal>elements</literal>, <literal>indices</literal>, <literal>minindex</literal>, <literal>maxindex</literal>, <literal>minelement</literal>, <literal>maxelement</literal> - can only be used in the where clause in Hibernate3."
msgstr "注意，在 Hibernate3 中，这些结构变量 —  <literal>size</literal>，<literal>elements</literal>，<literal>indices</literal>，<literal>minindex</literal>，<literal>maxindex</literal>，<literal>minelement</literal>，<literal>maxelement</literal> — 只能在 where 子句中使用。 "

#. Tag: para
#, no-c-format
msgid "Elements of indexed collections (arrays, lists, and maps) can be referred to by index in a where clause only:"
msgstr "一个被索引过的（有序的）集合的元素（arrays，lists，maps）可以在其他索引中被引用（只能在 where 子句中）： "

#. Tag: para
#, no-c-format
msgid "The expression inside <literal>[]</literal> can even be an arithmetic expression:"
msgstr "在 <literal>[]</literal> 中的表达式甚至可以是一个算数表达式："

#. Tag: para
#, no-c-format
msgid "HQL also provides the built-in <literal>index()</literal> function for elements of a one-to-many association or collection of values."
msgstr "对于一个一对多的关联（one-to-many association）或是值的集合中的元素，HQL 也提供内建的 <literal>index()</literal> 函数。"

#. Tag: para
#, no-c-format
msgid "Scalar SQL functions supported by the underlying database can be used:"
msgstr "如果底层数据库支持标量的 SQL 函数，它们也可以被使用："

#. Tag: para
#, no-c-format
msgid "Consider how much longer and less readable the following query would be in SQL:"
msgstr "如果你还不能对所有的这些深信不疑，想想下面的查询。如果使用 SQL，语句长度会增长多少，可读性会下降多少： "

#. Tag: para
#, no-c-format
msgid "<emphasis>Hint:</emphasis> something like"
msgstr "<emphasis>提示：</emphasis> 会像如下的语句"

#. Tag: title
#, no-c-format
msgid "The order by clause"
msgstr "order by 子句"

#. Tag: para
#, no-c-format
msgid "The list returned by a query can be ordered by any property of a returned class or components:"
msgstr "查询返回的列表（list）可以按照一个返回的类或组件（components）中的任何属性（property）进行排序： "

#. Tag: para
#, no-c-format
msgid "The optional <literal>asc</literal> or <literal>desc</literal> indicate ascending or descending order respectively."
msgstr "可选的 <literal>asc</literal> 或 <literal>desc</literal> 关键字指明了按照升序或降序进行排序。"

#. Tag: title
#, no-c-format
msgid "The group by clause"
msgstr "group by 子句"

#. Tag: para
#, no-c-format
msgid "A query that returns aggregate values can be grouped by any property of a returned class or components:"
msgstr "一个返回聚集值（aggregate values）的查询可以按照一个返回的类或组件（components）中的任何属性（property）进行分组： "

#. Tag: para
#, no-c-format
msgid "A <literal>having</literal> clause is also allowed."
msgstr "<literal>having</literal> 子句在这里也允许使用。"

#. Tag: para
#, no-c-format
msgid "SQL functions and aggregate functions are allowed in the <literal>having</literal> and <literal>order by</literal> clauses if they are supported by the underlying database (i.e., not in MySQL)."
msgstr "如果底层的数据库支持的话（例如不能在 MySQL 中使用），SQL 的一般函数与聚集函数也可以出现在 <literal>having</literal> 与 <literal>order by</literal> 子句中。 "

#. Tag: para
#, no-c-format
msgid "Neither the <literal>group by</literal> clause nor the <literal>order by</literal> clause can contain arithmetic expressions. Hibernate also does not currently expand a grouped entity, so you cannot write <literal>group by cat</literal> if all properties of <literal>cat</literal> are non-aggregated. You have to list all non-aggregated properties explicitly."
msgstr "注意 <literal>group by</literal> 子句与 <literal>order by</literal> 子句中都不能包含算术表达式（arithmetic expressions）。也要注意 Hibernate 目前不会扩展 group 的实体，因此你不能写 <literal>group by cat</literal>，除非 <literal>cat</literal> 的所有属性都不是聚集的（non-aggregated）。你必须明确的列出所有的非聚集属性。 "

#. Tag: title
#, no-c-format
msgid "Subqueries"
msgstr "子查询"

#. Tag: para
#, no-c-format
msgid "For databases that support subselects, Hibernate supports subqueries within queries. A subquery must be surrounded by parentheses (often by an SQL aggregate function call). Even correlated subqueries (subqueries that refer to an alias in the outer query) are allowed."
msgstr "对于支持子查询的数据库，Hibernate 支持在查询中使用子查询。一个子查询必须被圆括号包围起来（经常是 SQL 聚集函数的圆括号）。甚至相互关联的子查询（引用到外部查询中的别名的子查询）也是允许的。"

#. Tag: para
#, no-c-format
msgid "Note that HQL subqueries can occur only in the select or where clauses."
msgstr "注意，HQL 自查询只可以在 select 或者 where 子句中出现。 "

#. Tag: para
#, no-c-format
msgid "Note that subqueries can also utilize <literal>row value constructor</literal> syntax. See <xref linkend=\"queryhql-tuple\" /> for more information."
msgstr "注意子查询也可以利用 <literal>row value constructor</literal> 语法。请参考 <xref linkend=\"queryhql-tuple\" /> 来获得详情。"

#. Tag: title
#, no-c-format
msgid "HQL examples"
msgstr "HQL 示例 "

#. Tag: para
#, no-c-format
msgid "Hibernate queries can be quite powerful and complex. In fact, the power of the query language is one of Hibernate's main strengths. The following example queries are similar to queries that have been used on recent projects. Please note that most queries you will write will be much simpler than the following examples."
msgstr "Hibernate 查询可以非常的强大与复杂。实际上，Hibernate 的一个主要卖点就是查询语句的威力。这里有一些例子，它们与我在最近的一个项目中使用的查询非常相似。注意你能用到的大多数查询比这些要简单的多。"

#. Tag: para
#, no-c-format
msgid "The following query returns the order id, number of items, the given minimum total value and the total value of the order for all unpaid orders for a particular customer. The results are ordered by total value. In determining the prices, it uses the current catalog. The resulting SQL query, against the <literal>ORDER</literal>, <literal>ORDER_LINE</literal>, <literal>PRODUCT</literal>, <literal>CATALOG</literal> and <literal>PRICE</literal> tables has four inner joins and an (uncorrelated) subselect."
msgstr "下面的查询对于某个特定的客户的所有未支付的账单，在给定给最小总价值的情况下，返回订单的 id，条目的数量和总价值，返回值按照总价值的结果进行排序。为了决定价格，查询使用了当前目录。作为转换结果的 SQL 查询，使用了<literal>ORDER</literal>，<literal>ORDER_LINE</literal>，<literal>PRODUCT</literal>，<literal>CATALOG</literal> 和 <literal>PRICE</literal> 库表。"

#. Tag: para
#, no-c-format
msgid "What a monster! Actually, in real life, I'm not very keen on subqueries, so my query was really more like this:"
msgstr "这简直是一个怪物！实际上，在现实生活中，我并不热衷于子查询，所以我的查询语句看起来更像这个："

#. Tag: para
#, no-c-format
msgid "The next query counts the number of payments in each status, excluding all payments in the <literal>AWAITING_APPROVAL</literal> status where the most recent status change was made by the current user. It translates to an SQL query with two inner joins and a correlated subselect against the <literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal> and <literal>PAYMENT_STATUS_CHANGE</literal> tables."
msgstr "下面一个查询计算每一种状态下的支付的数目，除去所有处于 <literal>AWAITING_APPROVAL</literal> 状态的支付，因为在该状态下 当前的用户作出了状态的最新改变。该查询被转换成含有两个内连接以及一个相关联的子选择的 SQL 查询，该查询使用了表 <literal>PAYMENT</literal>，<literal>PAYMENT_STATUS</literal> 以及  <literal>PAYMENT_STATUS_CHANGE</literal>。"

#. Tag: para
#, no-c-format
msgid "If the <literal>statusChanges</literal> collection was mapped as a list, instead of a set, the query would have been much simpler to write."
msgstr "如果我把 <literal>statusChanges</literal> 实例集映射为一个列表（list）而不是一个集合（set），书写查询语句将更加简单。 "

#. Tag: para
#, no-c-format
msgid "The next query uses the MS SQL Server <literal>isNull()</literal> function to return all the accounts and unpaid payments for the organization to which the current user belongs. It translates to an SQL query with three inner joins, an outer join and a subselect against the <literal>ACCOUNT</literal>, <literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal>, <literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> and <literal>ORG_USER</literal> tables."
msgstr "下面一个查询使用了 MS SQL Server 的 <literal>isNull()</literal> 函数用以返回当前用户所属组织的组织帐号及组织未支付的账。它被转换成一个对表 <literal>ACCOUNT</literal>，<literal>PAYMENT</literal>，<literal>PAYMENT_STATUS</literal>，<literal>ACCOUNT_TYPE</literal>，<literal>ORGANIZATION</literal>  以及 <literal>ORG_USER</literal> 进行的三个内连接，一个外连接和一个子选择的 SQL 查询。"

#. Tag: para
#, no-c-format
msgid "For some databases, we would need to do away with the (correlated) subselect."
msgstr "对于一些数据库，我们需要弃用（相关的）子选择。"

#. Tag: title
#, no-c-format
msgid "Bulk update and delete"
msgstr "批量的 UPDATE 和 DELETE"

#. Tag: para
#, no-c-format
msgid "HQL now supports <literal>update</literal>, <literal>delete</literal> and <literal>insert ... select ...</literal> statements. See <xref linkend=\"batch-direct\" /> for more information."
msgstr "HQL 现在支持 <literal>update</literal>，<literal>delete</literal> 和 <literal>insert ... select ...</literal>语句。查阅 <xref linkend=\"batch-direct\" /> 以获得更多信息。 "

#. Tag: title
#, no-c-format
msgid "Tips &amp; Tricks"
msgstr "小技巧 &amp; 小窍门"

#. Tag: para
#, no-c-format
msgid "You can count the number of query results without returning them:"
msgstr "你可以统计查询结果的数目而不必实际的返回他们： "

#. Tag: para
#, no-c-format
msgid "To order a result by the size of a collection, use the following query:"
msgstr "若想根据一个集合的大小来进行排序，可以使用如下的语句："

#. Tag: para
#, no-c-format
msgid "If your database supports subselects, you can place a condition upon selection size in the where clause of your query:"
msgstr "如果你的数据库支持子选择，你可以在你的查询的 where 子句中为选择的大小（selection size）指定一个条件："

#. Tag: para
#, no-c-format
msgid "If your database does not support subselects, use the following query:"
msgstr "如果你的数据库不支持子选择语句，使用下面的查询： "

#. Tag: para
#, no-c-format
msgid "As this solution cannot return a <literal>User</literal> with zero messages because of the inner join, the following form is also useful:"
msgstr "因为内连接（inner join）的原因，这个解决方案不能返回含有零个信息的 <literal>User</literal> 类的实例，所以这种情况下使用下面的格式将是有帮助的： "

#. Tag: para
#, no-c-format
msgid "Properties of a JavaBean can be bound to named query parameters:"
msgstr "JavaBean 的属性可以被绑定到一个命名查询（named query）的参数上："

#. Tag: para
#, no-c-format
msgid "Collections are pageable by using the <literal>Query</literal> interface with a filter:"
msgstr "通过将接口 <literal>Query</literal> 与一个过滤器（filter）一起使用，集合（Collections）是可以分页的："

#. Tag: para
#, no-c-format
msgid "Collection elements can be ordered or grouped using a query filter:"
msgstr "通过使用查询过滤器（query filter）可以将集合（Collection）的元素分组或排序： "

#. Tag: para
#, no-c-format
msgid "You can find the size of a collection without initializing it:"
msgstr "不用通过初始化，你就可以知道一个集合（Collection）的大小："

#. Tag: title
#, no-c-format
msgid "Components"
msgstr "组件"

#. Tag: para
#, no-c-format
msgid "Components can be used similarly to the simple value types that are used in HQL queries. They can appear in the <literal>select</literal> clause as follows:"
msgstr "在 HQL 查询里，组件可以和简单值类型一样使用。它们可以出现在 <literal>select</literal> 子句里： "

#. Tag: para
#, no-c-format
msgid "where the Person's name property is a component. Components can also be used in the <literal>where</literal> clause:"
msgstr "在这里，Person 的 name 属性是一个组件。组件也可以用在 <literal>where</literal> 子句里："

#. Tag: para
#, no-c-format
msgid "Components can also be used in the <literal>order by</literal> clause:"
msgstr "组件也可以用在 <literal>order by</literal> 子句里："

#. Tag: para
#, no-c-format
msgid "Another common use of components is in <link linkend=\"queryhql-tuple\">row value constructors</link>."
msgstr "组件的另外一个常见用法是在 <xref linkend=\"queryhql-tuple\" /> 行值（row value）构造函数里。 "

#. Tag: title
#, no-c-format
msgid "Row value constructor syntax"
msgstr "Row value 构造函数语法"

#. Tag: para
#, no-c-format
msgid "HQL supports the use of ANSI SQL <literal>row value constructor</literal> syntax, sometimes referred to AS <literal>tuple</literal> syntax, even though the underlying database may not support that notion. Here, we are generally referring to multi-valued comparisons, typically associated with components. Consider an entity Person which defines a name component:"
msgstr "HQL 支持 ANSI SQL <literal>row value constructor</literal> 语法（有时也叫作 <literal>tuple</literal> 语法），即使底层数据库可能不支持这个概念。在这里我们通常指的是多值（multi-valued）的比较，典型地是和组件相关联。来看看一个定义了 name 组件的实体 Person："

#. Tag: para
#, no-c-format
msgid "That is valid syntax although it is a little verbose. You can make this more concise by using <literal>row value constructor</literal> syntax:"
msgstr "那是有效的语法，虽然有点冗长。我们可以使它更加简洁一点，并使用 <literal>row value constructor</literal> 语法： "

#. Tag: para
#, no-c-format
msgid "It can also be useful to specify this in the <literal>select</literal> clause:"
msgstr "在 <literal>select</literal> 子句里指定这个也是很有用的："

#. Tag: para
#, no-c-format
msgid "Using <literal>row value constructor</literal> syntax can also be beneficial when using subqueries that need to compare against multiple values:"
msgstr "当使用需要比较多个值的子查询时，采用 <literal>row value constructor</literal> 语法也很有用处： "

#. Tag: para
#, no-c-format
msgid "One thing to consider when deciding if you want to use this syntax, is that the query will be dependent upon the ordering of the component sub-properties in the metadata."
msgstr "决定是否使用这个语法的一件因素就是：这个查询将依赖于元数据里的组件子属性（sub-properties）的顺序。 "

#, fuzzy
#~ msgid "<![CDATA[from eg.Cat]]>"
#~ msgstr "from eg.Cat"

#, fuzzy
#~ msgid "<![CDATA[from Cat]]>"
#~ msgstr "from eg.Cat"

#, fuzzy
#~ msgid "<![CDATA[from Cat as cat]]>"
#~ msgstr "from Cat as cat"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat]]>"
#~ msgstr "from Cat cat"

#, fuzzy
#~ msgid "<![CDATA[from Formula, Parameter]]>"
#~ msgstr "from Formula, Parameter"

#, fuzzy
#~ msgid "<![CDATA[from Formula as form, Parameter as param]]>"
#~ msgstr "from Formula as form, Parameter as param"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "    inner join cat.mate as mate\n"
#~ "    left outer join cat.kittens as kitten]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "    inner join cat.mate as mate\n"
#~ "    left outer join cat.kittens as kitten"

#, fuzzy
#~ msgid "<![CDATA[from Cat as cat left join cat.mate.kittens as kittens]]>"
#~ msgstr "from Cat as cat left join cat.mate.kittens as kittens"

#, fuzzy
#~ msgid "<![CDATA[from Formula form full join form.parameter param]]>"
#~ msgstr "from Formula form full join form.parameter param"
#~ msgid "inner join"
#~ msgstr "<literal>inner join</literal>（内连接）"
#~ msgid "left outer join"
#~ msgstr "<literal>left outer join</literal>（左外连接）"

#, fuzzy
#~ msgid "right outer join"
#~ msgstr "<literal>left outer join</literal>（左外连接）"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "    join cat.mate as mate\n"
#~ "    left join cat.kittens as kitten]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "    join cat.mate as mate\n"
#~ "    left join cat.kittens as kitten"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "    left join cat.kittens as kitten\n"
#~ "        with kitten.bodyWeight > 10.0]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "    left join cat.kittens as kitten\n"
#~ "        with kitten.bodyWeight &gt; 10.0"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "    inner join fetch cat.mate\n"
#~ "    left join fetch cat.kittens]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "    inner join fetch cat.mate\n"
#~ "    left join fetch cat.kittens"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "    inner join fetch cat.mate\n"
#~ "    left join fetch cat.kittens child\n"
#~ "    left join fetch child.kittens]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "    inner join fetch cat.mate\n"
#~ "    left join fetch cat.kittens child\n"
#~ "    left join fetch child.kittens"

#, fuzzy
#~ msgid "<![CDATA[from Document fetch all properties order by name]]>"
#~ msgstr "from Document fetch all properties order by name"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Document doc fetch all properties where lower(doc.name) "
#~ "like '%cats%']]>"
#~ msgstr ""
#~ "from Document doc fetch all properties where lower(doc.name) like '&#37;"
#~ "cats&#37;'"

#, fuzzy
#~ msgid "<![CDATA[from Cat as cat where cat.mate.name like '%s%']]>"
#~ msgstr "from Cat as cat where cat.mate.name like '&#37;s&#37;'"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select mate\n"
#~ "from Cat as cat\n"
#~ "    inner join cat.mate as mate]]>"
#~ msgstr ""
#~ "select mate\n"
#~ "from Cat as cat\n"
#~ "    inner join cat.mate as mate"

#, fuzzy
#~ msgid "<![CDATA[select cat.mate from Cat cat]]>"
#~ msgstr "select cat.mate from Cat cat"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat.name from DomesticCat cat\n"
#~ "where cat.name like 'fri%']]>"
#~ msgstr ""
#~ "select cat.name from DomesticCat cat\n"
#~ "where cat.name like 'fri&#37;'"

#, fuzzy
#~ msgid "<![CDATA[select cust.name.firstName from Customer as cust]]>"
#~ msgstr "select cust.name.firstName from Customer as cust"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select mother, offspr, mate.name\n"
#~ "from DomesticCat as mother\n"
#~ "    inner join mother.mate as mate\n"
#~ "    left outer join mother.kittens as offspr]]>"
#~ msgstr ""
#~ "select mother, offspr, mate.name\n"
#~ "from DomesticCat as mother\n"
#~ "    inner join mother.mate as mate\n"
#~ "    left outer join mother.kittens as offspr"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select new list(mother, offspr, mate.name)\n"
#~ "from DomesticCat as mother\n"
#~ "    inner join mother.mate as mate\n"
#~ "    left outer join mother.kittens as offspr]]>"
#~ msgstr ""
#~ "select new list(mother, offspr, mate.name)\n"
#~ "from DomesticCat as mother\n"
#~ "    inner join mother.mate as mate\n"
#~ "    left outer join mother.kittens as offspr"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select new Family(mother, mate, offspr)\n"
#~ "from DomesticCat as mother\n"
#~ "    join mother.mate as mate\n"
#~ "    left join mother.kittens as offspr]]>"
#~ msgstr ""
#~ "select new Family(mother, mate, offspr)\n"
#~ "from DomesticCat as mother\n"
#~ "    join mother.mate as mate\n"
#~ "    left join mother.kittens as offspr"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select max(bodyWeight) as max, min(bodyWeight) as min, count(*) "
#~ "as n\n"
#~ "from Cat cat]]>"
#~ msgstr ""
#~ "select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n\n"
#~ "from Cat cat"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select new map( max(bodyWeight) as max, min(bodyWeight) as min, "
#~ "count(*) as n )\n"
#~ "from Cat cat]]>"
#~ msgstr ""
#~ "select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) "
#~ "as n )\n"
#~ "from Cat cat"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select avg(cat.weight), sum(cat.weight), max(cat.weight), count"
#~ "(cat)\n"
#~ "from Cat cat]]>"
#~ msgstr ""
#~ "select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)\n"
#~ "from Cat cat"
#~ msgid "count(*)"
#~ msgstr "count(*)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat.weight + sum(kitten.weight)\n"
#~ "from Cat cat\n"
#~ "    join cat.kittens kitten\n"
#~ "group by cat.id, cat.weight]]>"
#~ msgstr ""
#~ "select cat.weight + sum(kitten.weight)\n"
#~ "from Cat cat\n"
#~ "    join cat.kittens kitten\n"
#~ "group by cat.id, cat.weight"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select firstName||' '||initial||' '||upper(lastName) from "
#~ "Person]]>"
#~ msgstr "select firstName||' '||initial||' '||upper(lastName) from Person"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select distinct cat.name from Cat cat\n"
#~ "\n"
#~ "select count(distinct cat.name), count(cat) from Cat cat]]>"
#~ msgstr ""
#~ "select distinct cat.name from Cat cat\n"
#~ "\n"
#~ "select count(distinct cat.name), count(cat) from Cat cat"

#, fuzzy
#~ msgid "<![CDATA[from java.lang.Object o]]>"
#~ msgstr "from java.lang.Object o"

#, fuzzy
#~ msgid "<![CDATA[from Named n, Named m where n.name = m.name]]>"
#~ msgstr "from Named n, Named m where n.name = m.name"

#, fuzzy
#~ msgid "<![CDATA[from Cat where name='Fritz']]>"
#~ msgstr "from Cat where name='Fritz'"

#, fuzzy
#~ msgid "<![CDATA[from Cat as cat where cat.name='Fritz']]>"
#~ msgstr "from Cat as cat where cat.name='Fritz'"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select foo\n"
#~ "from Foo foo, Bar bar\n"
#~ "where foo.startDate = bar.date]]>"
#~ msgstr ""
#~ "select foo\n"
#~ "from Foo foo, Bar bar\n"
#~ "where foo.startDate = bar.date"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat where cat.mate.name is not null]]>"
#~ msgstr "from Cat cat where cat.mate.name is not null"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Foo foo\n"
#~ "where foo.bar.baz.customer.address.city is not null]]>"
#~ msgstr ""
#~ "from Foo foo\n"
#~ "where foo.bar.baz.customer.address.city is not null"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat, Cat rival where cat.mate = rival.mate]]>"
#~ msgstr "from Cat cat, Cat rival where cat.mate = rival.mate"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat, mate\n"
#~ "from Cat cat, Cat mate\n"
#~ "where cat.mate = mate]]>"
#~ msgstr ""
#~ "select cat, mate\n"
#~ "from Cat cat, Cat mate\n"
#~ "where cat.mate = mate"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat where cat.id = 123\n"
#~ "\n"
#~ "from Cat as cat where cat.mate.id = 69]]>"
#~ msgstr ""
#~ "from Cat as cat where cat.id = 123\n"
#~ "\n"
#~ "from Cat as cat where cat.mate.id = 69"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from bank.Person person\n"
#~ "where person.id.country = 'AU'\n"
#~ "    and person.id.medicareNumber = 123456]]>"
#~ msgstr ""
#~ "from bank.Person person\n"
#~ "where person.id.country = 'AU'\n"
#~ "    and person.id.medicareNumber = 123456"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from bank.Account account\n"
#~ "where account.owner.id.country = 'AU'\n"
#~ "    and account.owner.id.medicareNumber = 123456]]>"
#~ msgstr ""
#~ "from bank.Account account\n"
#~ "where account.owner.id.country = 'AU'\n"
#~ "    and account.owner.id.medicareNumber = 123456"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat where cat.class = DomesticCat]]>"
#~ msgstr "from Cat cat where cat.class = DomesticCat"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from AuditLog log, Payment payment\n"
#~ "where log.item.class = 'Payment' and log.item.id = payment.id]]>"
#~ msgstr ""
#~ "from AuditLog log, Payment payment\n"
#~ "where log.item.class = 'Payment' and log.item.id = payment.id"

#, fuzzy
#~ msgid "<![CDATA[from DomesticCat cat where cat.name between 'A' and 'B']]>"
#~ msgstr "from DomesticCat cat where cat.name between 'A' and 'B'"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )]]>"
#~ msgstr "from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from DomesticCat cat where cat.name not between 'A' and 'B']]>"
#~ msgstr "from DomesticCat cat where cat.name not between 'A' and 'B'"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', "
#~ "'Baz' )]]>"
#~ msgstr "from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<property name=\"hibernate.query.substitutions\">true 1, false "
#~ "0</property>]]>"
#~ msgstr ""
#~ "&lt;property name=\"hibernate.query.substitutions\"&gt;true 1, false "
#~ "0&lt;/property&gt;"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat where cat.alive = true]]>"
#~ msgstr "from Cat cat where cat.alive = true"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat where cat.kittens.size > 0]]>"
#~ msgstr "from Cat cat where cat.kittens.size &gt; 0"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat where size(cat.kittens) > 0]]>"
#~ msgstr "from Cat cat where size(cat.kittens) &gt; 0"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Calendar cal where maxelement(cal.holidays) > current_date]]"
#~ ">"
#~ msgstr "from Calendar cal where maxelement(cal.holidays) &gt; current_date"

#, fuzzy
#~ msgid "<![CDATA[from Order order where maxindex(order.items) > 100]]>"
#~ msgstr "from Order order where maxindex(order.items) &gt; 100"

#, fuzzy
#~ msgid "<![CDATA[from Order order where minelement(order.items) > 10000]]>"
#~ msgstr "from Order order where minelement(order.items) &gt; 10000"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select mother from Cat as mother, Cat as kit\n"
#~ "where kit in elements(foo.kittens)]]>"
#~ msgstr ""
#~ "select mother from Cat as mother, Cat as kit\n"
#~ "where kit in elements(foo.kittens)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select p from NameList list, Person p\n"
#~ "where p.name = some elements(list.names)]]>"
#~ msgstr ""
#~ "select p from NameList list, Person p\n"
#~ "where p.name = some elements(list.names)"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat where exists elements(cat.kittens)]]>"
#~ msgstr "from Cat cat where exists elements(cat.kittens)"

#, fuzzy
#~ msgid "<![CDATA[from Player p where 3 > all elements(p.scores)]]>"
#~ msgstr "from Player p where 3 &gt; all elements(p.scores)"

#, fuzzy
#~ msgid "<![CDATA[from Show show where 'fizard' in indices(show.acts)]]>"
#~ msgstr "from Show show where 'fizard' in indices(show.acts)"

#, fuzzy
#~ msgid "<![CDATA[from Order order where order.items[0].id = 1234]]>"
#~ msgstr "from Order order where order.items[0].id = 1234"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select person from Person person, Calendar calendar\n"
#~ "where calendar.holidays['national day'] = person.birthDay\n"
#~ "    and person.nationality.calendar = calendar]]>"
#~ msgstr ""
#~ "select person from Person person, Calendar calendar\n"
#~ "where calendar.holidays['national day'] = person.birthDay\n"
#~ "    and person.nationality.calendar = calendar"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select item from Item item, Order order\n"
#~ "where order.items[ order.deliveredItemIndices[0] ] = item and order.id = "
#~ "11]]>"
#~ msgstr ""
#~ "select item from Item item, Order order\n"
#~ "where order.items[ order.deliveredItemIndices[0] ] = item and order.id = "
#~ "11"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select item from Item item, Order order\n"
#~ "where order.items[ maxindex(order.items) ] = item and order.id = 11]]>"
#~ msgstr ""
#~ "select item from Item item, Order order\n"
#~ "where order.items[ maxindex(order.items) ] = item and order.id = 11"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select item from Item item, Order order\n"
#~ "where order.items[ size(order.items) - 1 ] = item]]>"
#~ msgstr ""
#~ "select item from Item item, Order order\n"
#~ "where order.items[ size(order.items) - 1 ] = item"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select item, index(item) from Order order\n"
#~ "    join order.items item\n"
#~ "where index(item) < 5]]>"
#~ msgstr ""
#~ "select item, index(item) from Order order\n"
#~ "    join order.items item\n"
#~ "where index(item) &lt; 5"

#, fuzzy
#~ msgid "<![CDATA[from DomesticCat cat where upper(cat.name) like 'FRI%']]>"
#~ msgstr "from DomesticCat cat where upper(cat.name) like 'FRI&#37;'"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cust\n"
#~ "from Product prod,\n"
#~ "    Store store\n"
#~ "    inner join store.customers cust\n"
#~ "where prod.name = 'widget'\n"
#~ "    and store.location.name in ( 'Melbourne', 'Sydney' )\n"
#~ "    and prod = all elements(cust.currentOrder.lineItems)]]>"
#~ msgstr ""
#~ "select cust\n"
#~ "from Product prod,\n"
#~ "    Store store\n"
#~ "    inner join store.customers cust\n"
#~ "where prod.name = 'widget'\n"
#~ "    and store.location.name in ( 'Melbourne', 'Sydney' )\n"
#~ "    and prod = all elements(cust.currentOrder.lineItems)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[SELECT cust.name, cust.address, cust.phone, cust.id, cust."
#~ "current_order\n"
#~ "FROM customers cust,\n"
#~ "    stores store,\n"
#~ "    locations loc,\n"
#~ "    store_customers sc,\n"
#~ "    product prod\n"
#~ "WHERE prod.name = 'widget'\n"
#~ "    AND store.loc_id = loc.id\n"
#~ "    AND loc.name IN ( 'Melbourne', 'Sydney' )\n"
#~ "    AND sc.store_id = store.id\n"
#~ "    AND sc.cust_id = cust.id\n"
#~ "    AND prod.id = ALL(\n"
#~ "        SELECT item.prod_id\n"
#~ "        FROM line_items item, orders o\n"
#~ "        WHERE item.order_id = o.id\n"
#~ "            AND cust.current_order = o.id\n"
#~ "    )]]>"
#~ msgstr ""
#~ "SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order\n"
#~ "FROM customers cust,\n"
#~ "    stores store,\n"
#~ "    locations loc,\n"
#~ "    store_customers sc,\n"
#~ "    product prod\n"
#~ "WHERE prod.name = 'widget'\n"
#~ "    AND store.loc_id = loc.id\n"
#~ "    AND loc.name IN ( 'Melbourne', 'Sydney' )\n"
#~ "    AND sc.store_id = store.id\n"
#~ "    AND sc.cust_id = cust.id\n"
#~ "    AND prod.id = ALL(\n"
#~ "        SELECT item.prod_id\n"
#~ "        FROM line_items item, orders o\n"
#~ "        WHERE item.order_id = o.id\n"
#~ "            AND cust.current_order = o.id\n"
#~ "    )"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from DomesticCat cat\n"
#~ "order by cat.name asc, cat.weight desc, cat.birthdate]]>"
#~ msgstr ""
#~ "from DomesticCat cat\n"
#~ "order by cat.name asc, cat.weight desc, cat.birthdate"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat.color, sum(cat.weight), count(cat)\n"
#~ "from Cat cat\n"
#~ "group by cat.color]]>"
#~ msgstr ""
#~ "select cat.color, sum(cat.weight), count(cat)\n"
#~ "from Cat cat\n"
#~ "group by cat.color"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select foo.id, avg(name), max(name)\n"
#~ "from Foo foo join foo.names name\n"
#~ "group by foo.id]]>"
#~ msgstr ""
#~ "select foo.id, avg(name), max(name)\n"
#~ "from Foo foo join foo.names name\n"
#~ "group by foo.id"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat.color, sum(cat.weight), count(cat)\n"
#~ "from Cat cat\n"
#~ "group by cat.color\n"
#~ "having cat.color in (eg.Color.TABBY, eg.Color.BLACK)]]>"
#~ msgstr ""
#~ "select cat.color, sum(cat.weight), count(cat)\n"
#~ "from Cat cat\n"
#~ "group by cat.color\n"
#~ "having cat.color in (eg.Color.TABBY, eg.Color.BLACK)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat\n"
#~ "from Cat cat\n"
#~ "    join cat.kittens kitten\n"
#~ "group by cat.id, cat.name, cat.other, cat.properties\n"
#~ "having avg(kitten.weight) > 100\n"
#~ "order by count(kitten) asc, sum(kitten.weight) desc]]>"
#~ msgstr ""
#~ "select cat\n"
#~ "from Cat cat\n"
#~ "    join cat.kittens kitten\n"
#~ "group by cat.id, cat.name, cat.other, cat.properties\n"
#~ "having avg(kitten.weight) &gt; 100\n"
#~ "order by count(kitten) asc, sum(kitten.weight) desc"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as fatcat\n"
#~ "where fatcat.weight > (\n"
#~ "    select avg(cat.weight) from DomesticCat cat\n"
#~ ")]]>"
#~ msgstr ""
#~ "from Cat as fatcat\n"
#~ "where fatcat.weight &gt; (\n"
#~ "    select avg(cat.weight) from DomesticCat cat\n"
#~ ")"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from DomesticCat as cat\n"
#~ "where cat.name = some (\n"
#~ "    select name.nickName from Name as name\n"
#~ ")]]>"
#~ msgstr ""
#~ "from DomesticCat as cat\n"
#~ "where cat.name = some (\n"
#~ "    select name.nickName from Name as name\n"
#~ ")"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "where not exists (\n"
#~ "    from Cat as mate where mate.mate = cat\n"
#~ ")]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "where not exists (\n"
#~ "    from Cat as mate where mate.mate = cat\n"
#~ ")"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from DomesticCat as cat\n"
#~ "where cat.name not in (\n"
#~ "    select name.nickName from Name as name\n"
#~ ")]]>"
#~ msgstr ""
#~ "from DomesticCat as cat\n"
#~ "where cat.name not in (\n"
#~ "    select name.nickName from Name as name\n"
#~ ")"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat.id, (select max(kit.weight) from cat.kitten kit)\n"
#~ "from Cat as cat]]>"
#~ msgstr ""
#~ "select cat.id, (select max(kit.weight) from cat.kitten kit)\n"
#~ "from Cat as cat"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select order.id, sum(price.amount), count(item)\n"
#~ "from Order as order\n"
#~ "    join order.lineItems as item\n"
#~ "    join item.product as product,\n"
#~ "    Catalog as catalog\n"
#~ "    join catalog.prices as price\n"
#~ "where order.paid = false\n"
#~ "    and order.customer = :customer\n"
#~ "    and price.product = product\n"
#~ "    and catalog.effectiveDate < sysdate\n"
#~ "    and catalog.effectiveDate >= all (\n"
#~ "        select cat.effectiveDate\n"
#~ "        from Catalog as cat\n"
#~ "        where cat.effectiveDate < sysdate\n"
#~ "    )\n"
#~ "group by order\n"
#~ "having sum(price.amount) > :minAmount\n"
#~ "order by sum(price.amount) desc]]>"
#~ msgstr ""
#~ "select order.id, sum(price.amount), count(item)\n"
#~ "from Order as order\n"
#~ "    join order.lineItems as item\n"
#~ "    join item.product as product,\n"
#~ "    Catalog as catalog\n"
#~ "    join catalog.prices as price\n"
#~ "where order.paid = false\n"
#~ "    and order.customer = :customer\n"
#~ "    and price.product = product\n"
#~ "    and catalog.effectiveDate &lt; sysdate\n"
#~ "    and catalog.effectiveDate &gt;= all (\n"
#~ "        select cat.effectiveDate\n"
#~ "        from Catalog as cat\n"
#~ "        where cat.effectiveDate &lt; sysdate\n"
#~ "    )\n"
#~ "group by order\n"
#~ "having sum(price.amount) &gt; :minAmount\n"
#~ "order by sum(price.amount) desc"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select order.id, sum(price.amount), count(item)\n"
#~ "from Order as order\n"
#~ "    join order.lineItems as item\n"
#~ "    join item.product as product,\n"
#~ "    Catalog as catalog\n"
#~ "    join catalog.prices as price\n"
#~ "where order.paid = false\n"
#~ "    and order.customer = :customer\n"
#~ "    and price.product = product\n"
#~ "    and catalog = :currentCatalog\n"
#~ "group by order\n"
#~ "having sum(price.amount) > :minAmount\n"
#~ "order by sum(price.amount) desc]]>"
#~ msgstr ""
#~ "select order.id, sum(price.amount), count(item)\n"
#~ "from Order as order\n"
#~ "    join order.lineItems as item\n"
#~ "    join item.product as product,\n"
#~ "    Catalog as catalog\n"
#~ "    join catalog.prices as price\n"
#~ "where order.paid = false\n"
#~ "    and order.customer = :customer\n"
#~ "    and price.product = product\n"
#~ "    and catalog = :currentCatalog\n"
#~ "group by order\n"
#~ "having sum(price.amount) &gt; :minAmount\n"
#~ "order by sum(price.amount) desc"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select count(payment), status.name\n"
#~ "from Payment as payment\n"
#~ "    join payment.currentStatus as status\n"
#~ "    join payment.statusChanges as statusChange\n"
#~ "where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"
#~ "    or (\n"
#~ "        statusChange.timeStamp = (\n"
#~ "            select max(change.timeStamp)\n"
#~ "            from PaymentStatusChange change\n"
#~ "            where change.payment = payment\n"
#~ "        )\n"
#~ "        and statusChange.user <> :currentUser\n"
#~ "    )\n"
#~ "group by status.name, status.sortOrder\n"
#~ "order by status.sortOrder]]>"
#~ msgstr ""
#~ "select count(payment), status.name\n"
#~ "from Payment as payment\n"
#~ "    join payment.currentStatus as status\n"
#~ "    join payment.statusChanges as statusChange\n"
#~ "where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL\n"
#~ "    or (\n"
#~ "        statusChange.timeStamp = (\n"
#~ "            select max(change.timeStamp)\n"
#~ "            from PaymentStatusChange change\n"
#~ "            where change.payment = payment\n"
#~ "        )\n"
#~ "        and statusChange.user &lt;&gt; :currentUser\n"
#~ "    )\n"
#~ "group by status.name, status.sortOrder\n"
#~ "order by status.sortOrder"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select count(payment), status.name\n"
#~ "from Payment as payment\n"
#~ "    join payment.currentStatus as status\n"
#~ "where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"
#~ "    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user <> :"
#~ "currentUser\n"
#~ "group by status.name, status.sortOrder\n"
#~ "order by status.sortOrder]]>"
#~ msgstr ""
#~ "select count(payment), status.name\n"
#~ "from Payment as payment\n"
#~ "    join payment.currentStatus as status\n"
#~ "where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL\n"
#~ "    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;"
#~ "&gt; :currentUser\n"
#~ "group by status.name, status.sortOrder\n"
#~ "order by status.sortOrder"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select account, payment\n"
#~ "from Account as account\n"
#~ "    left outer join account.payments as payment\n"
#~ "where :currentUser in elements(account.holder.users)\n"
#~ "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, "
#~ "PaymentStatus.UNPAID)\n"
#~ "order by account.type.sortOrder, account.accountNumber, payment.dueDate]]>"
#~ msgstr ""
#~ "select account, payment\n"
#~ "from Account as account\n"
#~ "    left outer join account.payments as payment\n"
#~ "where :currentUser in elements(account.holder.users)\n"
#~ "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, "
#~ "PaymentStatus.UNPAID)\n"
#~ "order by account.type.sortOrder, account.accountNumber, payment.dueDate"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select account, payment\n"
#~ "from Account as account\n"
#~ "    join account.holder.users as user\n"
#~ "    left outer join account.payments as payment\n"
#~ "where :currentUser = user\n"
#~ "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, "
#~ "PaymentStatus.UNPAID)\n"
#~ "order by account.type.sortOrder, account.accountNumber, payment.dueDate]]>"
#~ msgstr ""
#~ "select account, payment\n"
#~ "from Account as account\n"
#~ "    join account.holder.users as user\n"
#~ "    left outer join account.payments as payment\n"
#~ "where :currentUser = user\n"
#~ "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, "
#~ "PaymentStatus.UNPAID)\n"
#~ "order by account.type.sortOrder, account.accountNumber, payment.dueDate"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[( (Integer) session.createQuery(\"select count(*) from ....\")."
#~ "iterate().next() ).intValue()]]>"
#~ msgstr ""
#~ "( (Integer) session.iterate(\"select count(*) from ....\").next() )."
#~ "intValue()"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select usr.id, usr.name\n"
#~ "from User as usr\n"
#~ "    left join usr.messages as msg\n"
#~ "group by usr.id, usr.name\n"
#~ "order by count(msg)]]>"
#~ msgstr ""
#~ "select usr.id, usr.name\n"
#~ "from User as usr\n"
#~ "    left join usr.messages as msg\n"
#~ "group by usr.id, usr.name\n"
#~ "order by count(msg)"

#, fuzzy
#~ msgid "<![CDATA[from User usr where size(usr.messages) >= 1]]>"
#~ msgstr "from User usr where size(usr.messages) &gt;= 1"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select usr.id, usr.name\n"
#~ "from User usr.name\n"
#~ "    join usr.messages msg\n"
#~ "group by usr.id, usr.name\n"
#~ "having count(msg) >= 1]]>"
#~ msgstr ""
#~ "select usr.id, usr.name\n"
#~ "from User usr.name\n"
#~ "    join usr.messages msg\n"
#~ "group by usr.id, usr.name\n"
#~ "having count(msg) &gt;= 1"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select usr.id, usr.name\n"
#~ "from User as usr\n"
#~ "    left join usr.messages as msg\n"
#~ "group by usr.id, usr.name\n"
#~ "having count(msg) = 0]]>"
#~ msgstr ""
#~ "select usr.id, usr.name\n"
#~ "from User as usr\n"
#~ "    left join usr.messages as msg\n"
#~ "group by usr.id, usr.name\n"
#~ "having count(msg) = 0"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Query q = s.createQuery(\"from foo Foo as foo where foo.name=:"
#~ "name and foo.size=:size\");\n"
#~ "q.setProperties(fooBean); // fooBean has getName() and getSize()\n"
#~ "List foos = q.list();]]>"
#~ msgstr ""
#~ "Query q = s.createQuery(\"from foo Foo as foo where foo.name=:name and "
#~ "foo.size=:size\");\n"
#~ "q.setProperties(fooBean); // fooBean has getName() and getSize()\n"
#~ "List foos = q.list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Query q = s.createFilter( collection, \"\" ); // the trivial "
#~ "filter\n"
#~ "q.setMaxResults(PAGE_SIZE);\n"
#~ "q.setFirstResult(PAGE_SIZE * pageNumber);\n"
#~ "List page = q.list();]]>"
#~ msgstr ""
#~ "Query q = s.createFilter( collection, \"\" ); // the trivial filter\n"
#~ "q.setMaxResults(PAGE_SIZE);\n"
#~ "q.setFirstResult(PAGE_SIZE * pageNumber);\n"
#~ "List page = q.list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Collection orderedCollection = s.filter( collection, \"order by "
#~ "this.amount\" );\n"
#~ "Collection counts = s.filter( collection, \"select this.type, count(this) "
#~ "group by this.type\" );]]>"
#~ msgstr ""
#~ "Collection orderedCollection = s.filter( collection, \"order by this."
#~ "amount\" );\n"
#~ "Collection counts = s.filter( collection, \"select this.type, count(this) "
#~ "group by this.type\" );"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[( (Integer) session.createQuery(\"select count(*) from ....\")."
#~ "iterate().next() ).intValue();]]>"
#~ msgstr ""
#~ "( (Integer) session.iterate(\"select count(*) from ....\").next() )."
#~ "intValue();"

#, fuzzy
#~ msgid "<![CDATA[select p.name from Person p]]>"
#~ msgstr "select p.name from from Person p"

#, fuzzy
#~ msgid "<![CDATA[select p.name.first from Person p]]>"
#~ msgstr "select p.name.first from from Person p"

#, fuzzy
#~ msgid "<![CDATA[from Person p where p.name = :name]]>"
#~ msgstr "from from Person p where p.name = :name"

#, fuzzy
#~ msgid "<![CDATA[from Person p where p.name.first = :firstName]]>"
#~ msgstr "from from Person p where p.name.first = :firstName"

#, fuzzy
#~ msgid "<![CDATA[from Person p order by p.name]]>"
#~ msgstr "from from Person p order by p.name"

#, fuzzy
#~ msgid "<![CDATA[from Person p order by p.name.first]]>"
#~ msgstr "from from Person p order by p.name.first"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Person p where p.name.first='John' and p.name."
#~ "last='Jingleheimer-Schmidt']]>"
#~ msgstr ""
#~ "from Person p where p.name.first='John' and p.name.last='Jingleheimer-"
#~ "Schmidt'"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Person p where p.name=('John', 'Jingleheimer-Schmidt')]]>"
#~ msgstr "from Person p where p.name=('John', 'Jingleheimer-Schmidt')"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "where not ( cat.name, cat.color ) in (\n"
#~ "    select cat.name, cat.color from DomesticCat cat\n"
#~ ")]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "where not ( cat.name, cat.color ) in (\n"
#~ "    select cat.name, cat.color from DomesticCat cat\n"
#~ ")"

