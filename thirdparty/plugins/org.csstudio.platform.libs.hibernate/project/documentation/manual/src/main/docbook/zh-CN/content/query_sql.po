# translation of Collection_Mapping.po to
# Xi Huang <xhuang@redhat.com>, 2006.
# Xi HUANG <xhuang@redhat.com>, 2007.
msgid ""
msgstr ""
"Project-Id-Version: Collection_Mapping\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-03-12T00:03:47\n"
"PO-Revision-Date: 2010-03-16 10:16+1000\n"
"Last-Translator: Xi HUANG <xhuang@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Native SQL"
msgstr "Native SQL 查询"

#. Tag: para
#, no-c-format
msgid "You can also express queries in the native SQL dialect of your database. This is useful if you want to utilize database-specific features such as query hints or the <literal>CONNECT</literal> keyword in Oracle. It also provides a clean migration path from a direct SQL/JDBC based application to Hibernate."
msgstr "你也可以使用你的数据库的 Native SQL 语言来查询数据。这对你在要使用数据库的某些特性的时候（比如说在查询提示或者 Oracle 中的 <literal>CONNECT</literal> 关键字），这是非常有用的。这就能够扫清你把原来直接使用 SQL/JDBC 的程序迁移到基于 Hibernate 应用的道路上的障碍。 "

#. Tag: para
#, no-c-format
msgid "Hibernate3 allows you to specify handwritten SQL, including stored procedures, for all create, update, delete, and load operations."
msgstr "Hibernate3 允许你使用手写的 sql 来完成所有的 create、update、delete 和 load 操作（包括存储过程） "

#. Tag: title
#, no-c-format
msgid "Using a <literal>SQLQuery</literal>"
msgstr "使用 <literal>SQLQuery</literal>"

#. Tag: para
#, no-c-format
msgid "Execution of native SQL queries is controlled via the <literal>SQLQuery</literal> interface, which is obtained by calling <literal>Session.createSQLQuery()</literal>. The following sections describe how to use this API for querying."
msgstr "对原生 SQL 查询执行的控制是通过 <literal>SQLQuery</literal> 接口进行的，通过执行<literal>Session.createSQLQuery()</literal>获取这个接口。下面来描述如何使用这个 API 进行查询。 "

#. Tag: title
#, no-c-format
msgid "Scalar queries"
msgstr "标量查询（Scalar queries）"

#. Tag: para
#, no-c-format
msgid "The most basic SQL query is to get a list of scalars (values)."
msgstr "最基本的 SQL 查询就是获得一个标量（数值）的列表。"

#. Tag: para
#, no-c-format
msgid "These will return a List of Object arrays (Object[]) with scalar values for each column in the CATS table. Hibernate will use ResultSetMetadata to deduce the actual order and types of the returned scalar values."
msgstr "它们都将返回一个 Object 数组（Object[]）组成的 List，数组每个元素都是 CATS 表的一个字段值。Hibernate 会使用 ResultSetMetadata 来判定返回的标量值的实际顺序和类型。 "

#. Tag: para
#, no-c-format
msgid "To avoid the overhead of using <literal>ResultSetMetadata</literal>, or simply to be more explicit in what is returned, one can use <literal>addScalar()</literal>:"
msgstr "如果要避免过多的使用 <literal>ResultSetMetadata</literal>，或者只是为了更加明确的指名返回值，可以使用 <literal>addScalar()</literal>： "

#. Tag: para
#, no-c-format
msgid "This query specified:"
msgstr "这个查询指定："

#. Tag: para
#, no-c-format
msgid "the SQL query string"
msgstr "SQL 查询字符串"

#. Tag: para
#, no-c-format
msgid "the columns and types to return"
msgstr "要返回的字段和类型"

#. Tag: para
#, no-c-format
msgid "This will return Object arrays, but now it will not use <literal>ResultSetMetadata</literal> but will instead explicitly get the ID, NAME and BIRTHDATE column as respectively a Long, String and a Short from the underlying resultset. This also means that only these three columns will be returned, even though the query is using <literal>*</literal> and could return more than the three listed columns."
msgstr "它仍然会返回 Object 数组,但是此时不再使用 <literal>ResultSetMetdata</literal>，而是明确的将 ID，NAME 和 BIRTHDATE 按照 Long，String 和 Short 类型从 resultset 中取出。同时，也指明了就算 query 是使用 <literal>*</literal> 来查询的，可能获得超过列出的这三个字段，也仅仅会返回这三个字段。 "

#. Tag: para
#, no-c-format
msgid "It is possible to leave out the type information for all or some of the scalars."
msgstr "对全部或者部分的标量值不设置类型信息也是可以的。"

#. Tag: para
#, no-c-format
msgid "This is essentially the same query as before, but now <literal>ResultSetMetaData</literal> is used to determine the type of NAME and BIRTHDATE, where as the type of ID is explicitly specified."
msgstr "基本上这和前面一个查询相同,只是此时使用 <literal>ResultSetMetaData</literal> 来决定 NAME 和 BIRTHDATE 的类型，而 ID 的类型是明确指出的。 "

#. Tag: para
#, no-c-format
msgid "How the java.sql.Types returned from ResultSetMetaData is mapped to Hibernate types is controlled by the Dialect. If a specific type is not mapped, or does not result in the expected type, it is possible to customize it via calls to <literal>registerHibernateType</literal> in the Dialect."
msgstr "关于从 ResultSetMetaData 返回的 java.sql.Types 是如何映射到 Hibernate 类型，是由方言（Dialect）控制的。假若某个指定的类型没有被映射，或者不是你所预期的类型，你可以通过 Dialet 的 <literal>registerHibernateType</literal> 调用自行定义。 "

#. Tag: title
#, no-c-format
msgid "Entity queries"
msgstr "实体查询（Entity queries）"

#. Tag: para
#, no-c-format
msgid "The above queries were all about returning scalar values, basically returning the \"raw\" values from the resultset. The following shows how to get entity objects from a native sql query via <literal>addEntity()</literal>."
msgstr "上面的查询都是返回标量值的，也就是从 resultset 中返回的“裸”数据。下面展示如何通过 <literal>addEntity()</literal> 让原生查询返回实体对象。"

#. Tag: para
#, no-c-format
msgid "the entity returned by the query"
msgstr "要返回的实体"

#. Tag: para
#, no-c-format
msgid "Assuming that Cat is mapped as a class with the columns ID, NAME and BIRTHDATE the above queries will both return a List where each element is a Cat entity."
msgstr "假设 Cat 被映射为拥有 ID，NAME 和 BIRTHDATE 三个字段的类，以上的两个查询都返回一个 List，每个元素都是一个 Cat 实体。"

#. Tag: para
#, no-c-format
msgid "If the entity is mapped with a <literal>many-to-one</literal> to another entity it is required to also return this when performing the native query, otherwise a database specific \"column not found\" error will occur. The additional columns will automatically be returned when using the * notation, but we prefer to be explicit as in the following example for a <literal>many-to-one</literal> to a <literal>Dog</literal>:"
msgstr "假若实体在映射时有一个 <literal>many-to-one</literal> 的关联指向另外一个实体，在查询时必须也返回那个实体，否则会导致发生一个 \"column not found\" 的数据库错误。这些附加的字段可以使用 * 标注来自动返回，但我们希望还是明确指明，看下面这个具有指向 <literal>Dog</literal> 的 <literal>many-to-one</literal> 的例子："

#. Tag: para
#, no-c-format
msgid "This will allow cat.getDog() to function properly."
msgstr "这样 cat.getDog() 就能正常运作。"

#. Tag: title
#, no-c-format
msgid "Handling associations and collections"
msgstr "处理关联和集合类（Handling associations and collections）"

#. Tag: para
#, no-c-format
msgid "It is possible to eagerly join in the <literal>Dog</literal> to avoid the possible extra roundtrip for initializing the proxy. This is done via the <literal>addJoin()</literal> method, which allows you to join in an association or collection."
msgstr "通过提前抓取将 <literal>Dog</literal> 连接获得，而避免初始化 proxy 带来的额外开销也是可能的。这是通过 <literal>addJoin()</literal> 方法进行的，这个方法可以让你将关联或集合连接进来。"

#. Tag: para
#, no-c-format
msgid "In this example, the returned <literal>Cat</literal>'s will have their <literal>dog</literal> property fully initialized without any extra roundtrip to the database. Notice that you added an alias name (\"cat\") to be able to specify the target property path of the join. It is possible to do the same eager joining for collections, e.g. if the <literal>Cat</literal> had a one-to-many to <literal>Dog</literal> instead."
msgstr "上面这个例子中，返回的 <literal>Cat</literal> 对象，其 <literal>dog</literal> 属性被完全初始化了，不再需要数据库的额外操作。注意，我们加了一个别名（\"cat\"），以便指明 join 的目标属性路径。通过同样的提前连接也可以作用于集合类，例如，假若 <literal>Cat</literal> 有一个指向 <literal>Dog</literal> 的一对多关联。 "

#. Tag: para
#, no-c-format
msgid "At this stage you are reaching the limits of what is possible with native queries, without starting to enhance the sql queries to make them usable in Hibernate. Problems can arise when returning multiple entities of the same type or when the default alias/column names are not enough."
msgstr "到此为止，我们碰到了天花板：若不对 SQL 查询进行增强，这些已经是在 Hibernate 中使用原生 SQL 查询所能做到的最大可能了。下面的问题即将出现：返回多个同样类型的实体怎么办？或者默认的别名／字段不够又怎么办？ "

#. Tag: title
#, no-c-format
msgid "Returning multiple entities"
msgstr "返回多个实体（Returning multiple entities）"

#. Tag: para
#, no-c-format
msgid "Until now, the result set column names are assumed to be the same as the column names specified in the mapping document. This can be problematic for SQL queries that join multiple tables, since the same column names can appear in more than one table."
msgstr "到目前为止,结果集字段名被假定为和映射文件中指定的的字段名是一致的。假若 SQL 查询连接了多个表，同一个字段名可能在多个表中出现多次，这就会造成问题。 "

#. Tag: para
#, no-c-format
msgid "Column alias injection is needed in the following query (which most likely will fail):"
msgstr "下面的查询中需要使用字段别名注射（这个例子本身会失败）："

#. Tag: para
#, no-c-format
msgid "The query was intended to return two Cat instances per row: a cat and its mother. The query will, however, fail because there is a conflict of names; the instances are mapped to the same column names. Also, on some databases the returned column aliases will most likely be on the form \"c.ID\", \"c.NAME\", etc. which are not equal to the columns specified in the mappings (\"ID\" and \"NAME\")."
msgstr "这个查询的本意是希望每行返回两个 Cat 实例，一个是 cat,另一个是它的妈妈。但是因为它们的字段名被映射为相同的，而且在某些数据库中，返回的字段别名是“c.ID”，\"c.NAME\" 这样的形式，而它们和在映射文件中的名字（\"ID\" 和 \"NAME\"）不匹配，这就会造成失败。 "

#. Tag: para
#, no-c-format
msgid "The following form is not vulnerable to column name duplication:"
msgstr "下面的形式可以解决字段名重复："

#. Tag: para
#, no-c-format
msgid "the SQL query string, with placeholders for Hibernate to inject column aliases"
msgstr "SQL 查询语句，其中包含占位附来让 Hibernate 注射字段别名"

#. Tag: para
#, no-c-format
msgid "the entities returned by the query"
msgstr "查询返回的实体"

#. Tag: para
#, no-c-format
msgid "The {cat.*} and {mother.*} notation used above is a shorthand for \"all properties\". Alternatively, you can list the columns explicitly, but even in this case Hibernate injects the SQL column aliases for each property. The placeholder for a column alias is just the property name qualified by the table alias. In the following example, you retrieve Cats and their mothers from a different table (cat_log) to the one declared in the mapping metadata. You can even use the property aliases in the where clause."
msgstr "上面使用的 {cat.*} 和 {mother.*} 标记是作为“所有属性”的简写形式出现的。当然你也可以明确地罗列出字段名，但在这个例子里面我们让 Hibernate 来为每个属性注射 SQL 字段别名。字段别名的占位符是属性名加上表别名的前缀。在下面的例子中，我们从另外一个表（cat_log）中通过映射元数据中的指定获取 Cat 和它的妈妈。注意，要是我们愿意，我们甚至可以在 where 子句中使用属性别名。 "

#. Tag: title
#, no-c-format
msgid "Alias and property references"
msgstr "别名和属性引用（Alias and property references）"

#. Tag: para
#, no-c-format
msgid "In most cases the above alias injection is needed. For queries relating to more complex mappings, like composite properties, inheritance discriminators, collections etc., you can use specific aliases that allow Hibernate to inject the proper aliases."
msgstr "大多数情况下，都需要上面的属性注射，但在使用更加复杂的映射，比如复合属性、通过标识符构造继承树，以及集合类等等情况下，也有一些特别的别名，来允许 Hibernate 注入合适的别名。 "

#. Tag: para
#, no-c-format
msgid "The following table shows the different ways you can use the alias injection. Please note that the alias names in the result are simply examples; each alias will have a unique and probably different name when used."
msgstr "下表列出了使用别名注射参数的不同可能性。注意：下面结果中的别名只是示例，实用时每个别名需要唯一并且不同的名字。 "

#. Tag: title
#, no-c-format
msgid "Alias injection names"
msgstr "别名注射（alias injection names）"

#. Tag: entry
#, no-c-format
msgid "Description"
msgstr "描述"

#. Tag: entry
#, no-c-format
msgid "Syntax"
msgstr "语法"

#. Tag: entry
#, no-c-format
msgid "Example"
msgstr "示例"

#. Tag: entry
#, no-c-format
msgid "A simple property"
msgstr "简单属性"

#. Tag: entry
#, no-c-format
msgid "<literal>{[aliasname].[propertyname]</literal>"
msgstr "<literal>{[aliasname].[propertyname]</literal> "

#. Tag: entry
#, no-c-format
msgid "<literal>A_NAME as {item.name}</literal>"
msgstr "<literal>A_NAME as {item.name}</literal>"

#. Tag: entry
#, no-c-format
msgid "A composite property"
msgstr "复合属性"

#. Tag: entry
#, no-c-format
msgid "<literal>{[aliasname].[componentname].[propertyname]}</literal>"
msgstr "<literal>{[aliasname].[componentname].[propertyname]}</literal> "

#. Tag: entry
#, no-c-format
msgid "<literal>CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}</literal>"
msgstr "<literal>CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}</literal> "

#. Tag: entry
#, no-c-format
msgid "Discriminator of an entity"
msgstr "实体辨别器（Discriminator of an entity）"

#. Tag: entry
#, no-c-format
msgid "<literal>{[aliasname].class}</literal>"
msgstr "<literal>{[aliasname].class}</literal>"

#. Tag: entry
#, no-c-format
msgid "<literal>DISC as {item.class}</literal>"
msgstr "<literal>DISC as {item.class}</literal>"

#. Tag: entry
#, no-c-format
msgid "All properties of an entity"
msgstr "实体的所有属性"

#. Tag: entry
#, no-c-format
msgid "<literal>{[aliasname].*}</literal>"
msgstr "<literal>{[aliasname].*}</literal>"

#. Tag: entry
#, no-c-format
msgid "<literal>{item.*}</literal>"
msgstr "<literal>{item.*}</literal>"

#. Tag: entry
#, no-c-format
msgid "A collection key"
msgstr "集合键（collection key）"

#. Tag: entry
#, no-c-format
msgid "<literal>{[aliasname].key}</literal>"
msgstr "<literal>{[aliasname].key}</literal>"

#. Tag: entry
#, no-c-format
msgid "<literal>ORGID as {coll.key}</literal>"
msgstr "<literal>ORGID as {coll.key}</literal>"

#. Tag: entry
#, no-c-format
msgid "The id of an collection"
msgstr "集合 id"

#. Tag: entry
#, no-c-format
msgid "<literal>{[aliasname].id}</literal>"
msgstr "<literal>{[aliasname].id}</literal>"

#. Tag: entry
#, no-c-format
msgid "<literal>EMPID as {coll.id}</literal>"
msgstr "<literal>EMPID as {coll.id}</literal>"

#. Tag: entry
#, no-c-format
msgid "The element of an collection"
msgstr "集合元素"

#. Tag: entry
#, no-c-format
msgid "<literal>{[aliasname].element}</literal>"
msgstr "<literal>{[aliasname].element}</literal>"

#. Tag: entry
#, no-c-format
msgid "<literal>XID as {coll.element}</literal>"
msgstr "<literal>XID as {coll.element}</literal>"

#. Tag: entry
#, no-c-format
msgid "property of the element in the collection"
msgstr "集合元素的属性 "

#. Tag: entry
#, no-c-format
msgid "<literal>{[aliasname].element.[propertyname]}</literal>"
msgstr "<literal>{[aliasname].element.[propertyname]}</literal> "

#. Tag: entry
#, no-c-format
msgid "<literal>NAME as {coll.element.name}</literal>"
msgstr "<literal>NAME as {coll.element.name}</literal>"

#. Tag: entry
#, no-c-format
msgid "All properties of the element in the collection"
msgstr "集合元素的所有属性"

#. Tag: entry
#, no-c-format
msgid "<literal>{[aliasname].element.*}</literal>"
msgstr "<literal>{[aliasname].element.*}</literal>"

#. Tag: entry
#, no-c-format
msgid "<literal>{coll.element.*}</literal>"
msgstr "<literal>{coll.element.*}</literal>"

#. Tag: entry
#, no-c-format
msgid "All properties of the collection"
msgstr "集合的所有属性 "

#. Tag: entry
#, no-c-format
msgid "<literal>{coll.*}</literal>"
msgstr "<literal>{coll.*}</literal>"

#. Tag: title
#, no-c-format
msgid "Returning non-managed entities"
msgstr "返回非受管实体（Returning non-managed entities）"

#. Tag: para
#, no-c-format
msgid "It is possible to apply a ResultTransformer to native SQL queries, allowing it to return non-managed entities."
msgstr "可以对原生 sql 查询使用 ResultTransformer。这会返回不受 Hibernate 管理的实体。 "

#. Tag: para
#, no-c-format
msgid "a result transformer"
msgstr "结果转换器（result transformer）"

#. Tag: para
#, no-c-format
msgid "The above query will return a list of <literal>CatDTO</literal> which has been instantiated and injected the values of NAME and BIRTHNAME into its corresponding properties or fields."
msgstr "上面的查询将会返回 <literal>CatDTO</literal> 的列表,它将被实例化并且将 NAME 和 BIRTHDAY 的值注射入对应的属性或者字段。"

#. Tag: title
#, no-c-format
msgid "Handling inheritance"
msgstr "处理继承（Handling inheritance）"

#. Tag: para
#, no-c-format
msgid "Native SQL queries which query for entities that are mapped as part of an inheritance must include all properties for the baseclass and all its subclasses."
msgstr "原生 SQL 查询假若其查询结果实体是继承树中的一部分，它必须包含基类和所有子类的所有属性。 "

#. Tag: title
#, no-c-format
msgid "Parameters"
msgstr "参数（Parameters）"

#. Tag: para
#, no-c-format
msgid "Native SQL queries support positional as well as named parameters:"
msgstr "原生查询支持位置参数和命名参数： "

#. Tag: title
#, no-c-format
msgid "Named SQL queries"
msgstr "命名 SQL 查询"

#. Tag: para
#, no-c-format
msgid "Named SQL queries can be defined in the mapping document and called in exactly the same way as a named HQL query. In this case, you do <emphasis>not</emphasis> need to call <literal>addEntity()</literal>."
msgstr "可以在映射文档中定义查询的名字,然后就可以象调用一个命名的 HQL 查询一样直接调用命名 SQL 查询.在这种情况下，我们<emphasis>不</emphasis> 需要调用 <literal>addEntity()</literal> 方法。 "

#. Tag: para
#, no-c-format
msgid "The <literal>&lt;return-join&gt;</literal> element is use to join associations and the <literal>&lt;load-collection&gt;</literal> element is used to define queries which initialize collections,"
msgstr "<literal>&lt;return-join&gt;</literal> 和 <literal>&lt;load-collection&gt;</literal> 元素是用来连接关联以及将查询定义为预先初始化各个集合的。 "

#. Tag: para
#, no-c-format
msgid "A named SQL query may return a scalar value. You must declare the column alias and Hibernate type using the <literal>&lt;return-scalar&gt;</literal> element:"
msgstr "一个命名查询可能会返回一个标量值。你必须使用 <literal>&lt;return-scalar&gt;</literal> 元素来指定字段的别名和 Hibernate 类型："

#. Tag: para
#, no-c-format
msgid "You can externalize the resultset mapping information in a <literal>&lt;resultset&gt;</literal> element which will allow you to either reuse them across several named queries or through the <literal>setResultSetMapping()</literal> API."
msgstr "你可以把结果集映射的信息放在外部的 <literal>&lt;resultset&gt;</literal> 元素中，这样就可以在多个命名查询间，或者通过 <literal>setResultSetMapping()</literal> API 来访问。 "

#. Tag: para
#, no-c-format
msgid "You can, alternatively, use the resultset mapping information in your hbm files directly in java code."
msgstr "另外，你可以在 java 代码中直接使用 hbm 文件中的结果集定义信息。 "

#. Tag: title
#, no-c-format
msgid "Using return-property to explicitly specify column/alias names"
msgstr "使用 return-property 来明确地指定字段／别名"

#. Tag: para
#, no-c-format
msgid "You can explicitly tell Hibernate what column aliases to use with <literal>&lt;return-property&gt;</literal>, instead of using the <literal>{}</literal>-syntax to let Hibernate inject its own aliases.For example:"
msgstr "使用 <literal>&lt;return-property&gt;</literal> 你可以明确的告诉 Hibernate 使用哪些字段别名，这取代了使用 <literal>{}</literal>-语法 来让 Hibernate 注入它自己的别名。例如："

#. Tag: para
#, no-c-format
msgid "<literal>&lt;return-property&gt;</literal> also works with multiple columns. This solves a limitation with the <literal>{}</literal>-syntax which cannot allow fine grained control of multi-column properties."
msgstr "<literal>&lt;return-property&gt;</literal> 也可用于多个字段，它解决了使用 <literal>{}</literal>-语法不能细粒度控制多个字段的限制。 "

#. Tag: para
#, no-c-format
msgid "In this example <literal>&lt;return-property&gt;</literal> was used in combination with the <literal>{}</literal>-syntax for injection. This allows users to choose how they want to refer column and properties."
msgstr "注意在这个例子中，我们使用了 <literal>&lt;return-property&gt;</literal> 结合 <literal>{}</literal> 的注入语法。允许用户来选择如何引用字段以及属性。 "

#. Tag: para
#, no-c-format
msgid "If your mapping has a discriminator you must use <literal>&lt;return-discriminator&gt;</literal> to specify the discriminator column."
msgstr "如果你映射一个识别器（discriminator），你必须使用 <literal>&lt;return-discriminator&gt;</literal> 来指定识别器字段。"

#. Tag: title
#, no-c-format
msgid "Using stored procedures for querying"
msgstr "使用存储过程来查询"

#. Tag: para
#, no-c-format
msgid "Hibernate3 provides support for queries via stored procedures and functions. Most of the following documentation is equivalent for both. The stored procedure/function must return a resultset as the first out-parameter to be able to work with Hibernate. An example of such a stored function in Oracle 9 and higher is as follows:"
msgstr "Hibernate 3 引入了对存储过程查询（stored procedure）和函数（function）的支持。以下的说明中，这二者一般都适用。存储过程／函数必须返回一个结果集，作为 Hibernate 能够使用的第一个外部参数。下面是一个 Oracle9 和更高版本的存储过程例子。 "

#. Tag: para
#, no-c-format
msgid "To use this query in Hibernate you need to map it via a named query."
msgstr "在 Hibernate 里要要使用这个查询，你需要通过命名查询来映射它。"

#. Tag: para
#, no-c-format
msgid "Stored procedures currently only return scalars and entities. <literal>&lt;return-join&gt;</literal> and <literal>&lt;load-collection&gt;</literal> are not supported."
msgstr "注意存储过程当前仅仅返回标量和实体现在。不支持 <literal>&lt;return-join&gt;</literal> 和 <literal>&lt;load-collection&gt;</literal>。 "

#. Tag: title
#, no-c-format
msgid "Rules/limitations for using stored procedures"
msgstr "使用存储过程的规则和限制"

#. Tag: para
#, no-c-format
msgid "You cannot use stored procedures with Hibernate unless you follow some procedure/function rules. If they do not follow those rules they are not usable with Hibernate. If you still want to use these procedures you have to execute them via <literal>session.connection()</literal>. The rules are different for each database, since database vendors have different stored procedure semantics/syntax."
msgstr "为了在 Hibernate 中使用存储过程，你必须遵循一些规则。不遵循这些规则的存储过程将不可用。如果你仍然想使用他们，你必须通过 <literal>session.connection()</literal> 来执行他们。这些规则针对于不同的数据库。因为数据库提供商有各种不同的存储过程语法和语义。 "

#. Tag: para
#, no-c-format
msgid "Stored procedure queries cannot be paged with <literal>setFirstResult()/setMaxResults()</literal>."
msgstr "对存储过程进行的查询无法使用 <literal>setFirstResult()/setMaxResults()</literal> 进行分页。 "

#. Tag: para
#, no-c-format
msgid "The recommended call form is standard SQL92: <literal>{ ? = call functionName(&lt;parameters&gt;) }</literal> or <literal>{ ? = call procedureName(&lt;parameters&gt;}</literal>. Native call syntax is not supported."
msgstr "建议采用的调用方式是标准 SQL92: <literal>{ ? = call functionName(&lt;parameters&gt;) }</literal> 或者 <literal>{ ? = call procedureName(&lt;parameters&gt;) }</literal>。原生调用语法不被支持。 "

#. Tag: para
#, no-c-format
msgid "For Oracle the following rules apply:"
msgstr "对于 Oracle 有如下规则："

#. Tag: para
#, no-c-format
msgid "A function must return a result set. The first parameter of a procedure must be an <literal>OUT</literal> that returns a result set. This is done by using a <literal>SYS_REFCURSOR</literal> type in Oracle 9 or 10. In Oracle you need to define a <literal>REF CURSOR</literal> type. See Oracle literature for further information."
msgstr "函数必须返回一个结果集。存储过程的第一个参数必须是 <literal>OUT</literal>，它返回一个结果集。这是通过 Oracle 9 或 10 的 <literal>SYS_REFCURSOR</literal> 类型来完成的。在 Oracle 中你需要定义一个 <literal>REF CURSOR</literal> 类型，参见 Oracle 的手册。 "

#. Tag: para
#, no-c-format
msgid "For Sybase or MS SQL server the following rules apply:"
msgstr "对于 Sybase 或者 MS SQL server 有如下规则："

#. Tag: para
#, no-c-format
msgid "The procedure must return a result set. Note that since these servers can return multiple result sets and update counts, Hibernate will iterate the results and take the first result that is a result set as its return value. Everything else will be discarded."
msgstr "存储过程必须返回一个结果集。注意这些 servers 可能返回多个结果集以及更新的数目。Hibernate 将取出第一条结果集作为它的返回值，其他将被丢弃。 "

#. Tag: para
#, no-c-format
msgid "If you can enable <literal>SET NOCOUNT ON</literal> in your procedure it will probably be more efficient, but this is not a requirement."
msgstr "如果你能够在存储过程里设定 <literal>SET NOCOUNT ON</literal>，这可能会效率更高，但这不是必需的。"

#. Tag: title
#, no-c-format
msgid "Custom SQL for create, update and delete"
msgstr "定制 SQL 用来 create，update 和 delete"

#. Tag: para
#, no-c-format
msgid "Hibernate3 can use custom SQL for create, update, and delete operations. The SQL can be overridden at the statement level or inidividual column level. This section describes statement overrides. For columns, see <xref linkend=\"mapping-column-read-and-write\" />."
msgstr "Hibernate3 可以自定义 create、update 和 delete 操作。SQL 可以在语句或单个字段级别进行覆盖。本节描述了语句覆盖。对于字段覆盖，请参考 <xref linkend=\"mapping-column-read-and-write\" />。"

#. Tag: para
#, no-c-format
msgid "The class and collection persisters in Hibernate already contain a set of configuration time generated strings (insertsql, deletesql, updatesql etc.). The mapping tags <literal>&lt;sql-insert&gt;</literal>, <literal>&lt;sql-delete&gt;</literal>, and <literal>&lt;sql-update&gt;</literal> override these strings:"
msgstr "Hibernate3 能够使用定制的 SQL 语句来执行 create，update 和 delete 操作。在 Hibernate 中，持久化的类和集合已经包含了一套配置期产生的语句（insertsql，deletesql，updatesql 等等），这些映射标记 <literal>&lt;sql-insert&gt;</literal>，<literal>&lt;sql-delete&gt;</literal> 和 <literal>&lt;sql-update&gt;</literal> 重载了这些语句。 "

#. Tag: para
#, no-c-format
msgid "The SQL is directly executed in your database, so you can use any dialect you like. This will reduce the portability of your mapping if you use database specific SQL."
msgstr "这些 SQL 直接在你的数据库里执行，所以你可以自由的使用你喜欢的任意语法。但如果你使用数据库特定的语法，这当然会降低你映射的可移植性。 "

#. Tag: para
#, no-c-format
msgid "Stored procedures are supported if the <literal>callable</literal> attribute is set:"
msgstr "如果设定 <literal>callable</literal>，则能够支持存储过程了。"

#. Tag: para
#, no-c-format
msgid "The order of the positional parameters is vital, as they must be in the same sequence as Hibernate expects them."
msgstr "参数的位置顺序是非常重要的，他们必须和 Hibernate 所期待的顺序相同。 "

#. Tag: para
#, no-c-format
msgid "You can view the expected order by enabling debug logging for the <literal>org.hibernate.persister.entity</literal> level. With this level enabled, Hibernate will print out the static SQL that is used to create, update, delete etc. entities. To view the expected sequence, do not include your custom SQL in the mapping files, as this will override the Hibernate generated static SQL."
msgstr "你能够通过设定日志调试级别为 <literal>org.hiberante.persister.entity</literal> 来查看 Hibernate 所期待的顺序。在这个级别下，Hibernate 将会打印出create，update 和 delete 实体的静态 SQL。（如果想看到预计的顺序。记得不要将定制 SQL 包含在映射文件里，因为他们会重载 Hibernate 生成的静态 SQL。） "

#. Tag: para
#, no-c-format
msgid "The stored procedures are in most cases required to return the number of rows inserted, updated and deleted, as Hibernate has some runtime checks for the success of the statement. Hibernate always registers the first statement parameter as a numeric output parameter for the CUD operations:"
msgstr "在大多数情况下（最好这么做），存储过程需要返回插入／更新／删除的行数，因为 Hibernate 对语句的成功执行有些运行时的检查。Hibernate 常会把进行 CUD 操作的语句的第一个参数注册为一个数值型输出参数。 "

#. Tag: title
#, no-c-format
msgid "Custom SQL for loading"
msgstr "定制装载 SQL"

#. Tag: para
#, no-c-format
msgid "You can also declare your own SQL (or HQL) queries for entity loading. As with inserts, updates, and deletes, this can be done at the individual column level as described in <xref linkend=\"mapping-column-read-and-write\" /> or at the statement level. Here is an example of a statement level override:"
msgstr "你也可以为实体加载声明自己的 SQL（或 HQL）。如 <xref linkend=\"mapping-column-read-and-write\" /> 所描述的，inserts、updates 和 deletes 可以在字段级别或语句级别来完成。下面是一个语句覆盖的例子："

#. Tag: para
#, no-c-format
msgid "This is just a named query declaration, as discussed earlier. You can reference this named query in a class mapping:"
msgstr "这只是一个前面讨论过的命名查询声明，你可以在类映射里引用这个命名查询。 "

#. Tag: para
#, no-c-format
msgid "This even works with stored procedures."
msgstr "这也可以用于存储过程"

#. Tag: para
#, no-c-format
msgid "You can even define a query for collection loading:"
msgstr "你甚至可以定一个用于集合装载的查询： "

#. Tag: para
#, no-c-format
msgid "You can also define an entity loader that loads a collection by join fetching:"
msgstr "你甚至还可以定义一个实体装载器，它通过连接抓取装载一个集合： "

#~ msgid ""
#~ "You can also declare your own SQL (or HQL) queries for entity loading:"
#~ msgstr "你可能需要声明你自己的 SQL（或 HQL）来装载实体："

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").list();\n"
#~ "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").list();\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT * FROM CATS\").list();\n"
#~ "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
#~ " .addScalar(\"ID\", Hibernate.LONG)\n"
#~ " .addScalar(\"NAME\", Hibernate.STRING)\n"
#~ " .addScalar(\"BIRTHDATE\", Hibernate.DATE)\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
#~ " .addScalar(\"ID\", Hibernate.LONG)\n"
#~ " .addScalar(\"NAME\", Hibernate.STRING)\n"
#~ " .addScalar(\"BIRTHDATE\", Hibernate.DATE)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
#~ " .addScalar(\"ID\", Hibernate.LONG)\n"
#~ " .addScalar(\"NAME\")\n"
#~ " .addScalar(\"BIRTHDATE\")\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
#~ " .addScalar(\"ID\", Hibernate.LONG)\n"
#~ " .addScalar(\"NAME\")\n"
#~ " .addScalar(\"BIRTHDATE\")"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").addEntity(Cat."
#~ "class);\n"
#~ "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").addEntity"
#~ "(Cat.class);\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT * FROM CATS\").addEntity(Cat.class);\n"
#~ "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").addEntity"
#~ "(Cat.class);"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, DOG_ID FROM "
#~ "CATS\").addEntity(Cat.class);\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS\")."
#~ "addEntity(Cat.class);"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT c.ID, NAME, BIRTHDATE, DOG_ID, "
#~ "D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addJoin(\"cat.dog\");\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME "
#~ "FROM CATS c, DOGS d \n"
#~ "    WHERE c.DOG_ID = d.D_ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addJoin(\"cat.dog\");"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, "
#~ "CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addJoin(\"cat.dogs\");\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID "
#~ "FROM CATS c, DOGS d\n"
#~ "    WHERE c.ID = d.CAT_ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addJoin(\"cat.dogs\");"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT c.*, m.*  FROM CATS c, CATS m WHERE "
#~ "c.MOTHER_ID = c.ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addEntity(\"mother\", Cat.class)\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT c.*, m.*  FROM CATS c, CATS m WHERE c."
#~ "MOTHER_ID = c.ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addEntity(\"mother\", Cat.class)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT {cat.*}, {mother.*}  FROM CATS c, "
#~ "CATS m WHERE c.MOTHER_ID = c.ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addEntity(\"mother\", Cat.class)\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m "
#~ "WHERE c.MOTHER_ID = c.ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addEntity(\"mother\", Cat.class)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[String sql = \"SELECT ID as {c.id}, NAME as {c.name}, \" + \n"
#~ "         \"BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother."
#~ "*} \" +\n"
#~ "         \"FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID\";\n"
#~ "\n"
#~ "List loggedCats = sess.createSQLQuery(sql)\n"
#~ "        .addEntity(\"cat\", Cat.class)\n"
#~ "        .addEntity(\"mother\", Cat.class).list()\n"
#~ "]]>"
#~ msgstr ""
#~ "String sql = \"SELECT ID as {c.id}, NAME as {c.name}, \" + \n"
#~ "         \"BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother."
#~ "*} \" +\n"
#~ "         \"FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID\";\n"
#~ "\n"
#~ "List loggedCats = sess.createSQLQuery(sql)\n"
#~ "        .addEntity(\"cat\", Cat.class)\n"
#~ "        .addEntity(\"mother\", Cat.class).list()"

#, fuzzy
#~ msgid "A_NAME as {item.name}"
#~ msgstr "<literal>A_NAME as {item.name}</literal>"

#, fuzzy
#~ msgid "{[aliasname].class}"
#~ msgstr "<literal>{[aliasname].class}</literal>"

#, fuzzy
#~ msgid "DISC as {item.class}"
#~ msgstr "<literal>DISC as {item.class}</literal>"

#, fuzzy
#~ msgid "{[aliasname].*}"
#~ msgstr "<literal>{[aliasname].*}</literal>"
#~ msgid "{item.*}"
#~ msgstr "{item.*}"

#, fuzzy
#~ msgid "{[aliasname].key}"
#~ msgstr "<literal>{[aliasname].key}</literal>"

#, fuzzy
#~ msgid "ORGID as {coll.key}"
#~ msgstr "<literal>ORGID as {coll.key}</literal>"

#, fuzzy
#~ msgid "{[aliasname].id}"
#~ msgstr "<literal>{[aliasname].id}</literal>"

#, fuzzy
#~ msgid "EMPID as {coll.id}"
#~ msgstr "<literal>EMPID as {coll.id}</literal>"

#, fuzzy
#~ msgid "{[aliasname].element}"
#~ msgstr "<literal>{[aliasname].element}</literal>"

#, fuzzy
#~ msgid "XID as {coll.element}"
#~ msgstr "<literal>XID as {coll.element}</literal>"

#, fuzzy
#~ msgid "NAME as {coll.element.name}"
#~ msgstr "<literal>NAME as {coll.element.name}</literal>"

#, fuzzy
#~ msgid "{[aliasname].element.*}"
#~ msgstr "<literal>{[aliasname].element.*}</literal>"

#, fuzzy
#~ msgid "{coll.element.*}"
#~ msgstr "{coll.*}"
#~ msgid "{coll.*}"
#~ msgstr "{coll.*}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT NAME, BIRTHDATE FROM CATS\")\n"
#~ "        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT NAME, BIRTHDATE FROM CATS\")\n"
#~ "        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Query query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE "
#~ "NAME like ?\").addEntity(Cat.class);\n"
#~ "List pusList = query.setString(0, \"Pus%\").list();\n"
#~ "     \n"
#~ "query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like :name\")."
#~ "addEntity(Cat.class);\n"
#~ "List pusList = query.setString(\"name\", \"Pus%\").list();          ]]>"
#~ msgstr ""
#~ "Query query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like ?"
#~ "\").addEntity(Cat.class);\n"
#~ "List pusList = query.setString(0, \"Pus&#37;\").list();\n"
#~ "     \n"
#~ "query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like :name\")."
#~ "addEntity(Cat.class);\n"
#~ "List pusList = query.setString(\"name\", \"Pus&#37;\").list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"persons\">\n"
#~ "    <return alias=\"person\" class=\"eg.Person\"/>\n"
#~ "    SELECT person.NAME AS {person.name},\n"
#~ "           person.AGE AS {person.age},\n"
#~ "           person.SEX AS {person.sex}\n"
#~ "    FROM PERSON person\n"
#~ "    WHERE person.NAME LIKE :namePattern\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"persons\"&gt;\n"
#~ "    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
#~ "    SELECT person.NAME AS {person.name},\n"
#~ "           person.AGE AS {person.age},\n"
#~ "           person.SEX AS {person.sex}\n"
#~ "    FROM PERSON person\n"
#~ "    WHERE person.NAME LIKE :namePattern\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[List people = sess.getNamedQuery(\"persons\")\n"
#~ "    .setString(\"namePattern\", namePattern)\n"
#~ "    .setMaxResults(50)\n"
#~ "    .list();]]>"
#~ msgstr ""
#~ "List people = sess.getNamedQuery(\"persons\")\n"
#~ "    .setString(\"namePattern\", namePattern)\n"
#~ "    .setMaxResults(50)\n"
#~ "    .list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"personsWith\">\n"
#~ "    <return alias=\"person\" class=\"eg.Person\"/>\n"
#~ "    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
#~ "    SELECT person.NAME AS {person.name},\n"
#~ "           person.AGE AS {person.age},\n"
#~ "           person.SEX AS {person.sex},\n"
#~ "           address.STREET AS {address.street},\n"
#~ "           address.CITY AS {address.city},\n"
#~ "           address.STATE AS {address.state},\n"
#~ "           address.ZIP AS {address.zip}\n"
#~ "    FROM PERSON person\n"
#~ "    JOIN ADDRESS address\n"
#~ "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
#~ "    WHERE person.NAME LIKE :namePattern\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"personsWith\"&gt;\n"
#~ "    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
#~ "    &lt;return-join alias=\"address\" property=\"person.mailingAddress\"/"
#~ "&gt;\n"
#~ "    SELECT person.NAME AS {person.name},\n"
#~ "           person.AGE AS {person.age},\n"
#~ "           person.SEX AS {person.sex},\n"
#~ "           adddress.STREET AS {address.street},\n"
#~ "           adddress.CITY AS {address.city},\n"
#~ "           adddress.STATE AS {address.state},\n"
#~ "           adddress.ZIP AS {address.zip}\n"
#~ "    FROM PERSON person\n"
#~ "    JOIN ADDRESS adddress\n"
#~ "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
#~ "    WHERE person.NAME LIKE :namePattern\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"mySqlQuery\">\n"
#~ "    <return-scalar column=\"name\" type=\"string\"/>\n"
#~ "    <return-scalar column=\"age\" type=\"long\"/>\n"
#~ "    SELECT p.NAME AS name,\n"
#~ "           p.AGE AS age,\n"
#~ "    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"mySqlQuery\"&gt;\n"
#~ "    &lt;return-scalar column=\"name\" type=\"string\"/&gt;\n"
#~ "    &lt;return-scalar column=\"age\" type=\"long\"/&gt;\n"
#~ "    SELECT p.NAME AS name,\n"
#~ "           p.AGE AS age,\n"
#~ "    FROM PERSON p WHERE p.NAME LIKE 'Hiber&#37;'\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<resultset name=\"personAddress\">\n"
#~ "    <return alias=\"person\" class=\"eg.Person\"/>\n"
#~ "    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
#~ "</resultset>\n"
#~ "\n"
#~ "<sql-query name=\"personsWith\" resultset-ref=\"personAddress\">\n"
#~ "    SELECT person.NAME AS {person.name},\n"
#~ "           person.AGE AS {person.age},\n"
#~ "           person.SEX AS {person.sex},\n"
#~ "           address.STREET AS {address.street},\n"
#~ "           address.CITY AS {address.city},\n"
#~ "           address.STATE AS {address.state},\n"
#~ "           address.ZIP AS {address.zip}\n"
#~ "    FROM PERSON person\n"
#~ "    JOIN ADDRESS address\n"
#~ "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
#~ "    WHERE person.NAME LIKE :namePattern\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;resultset name=\"personAddress\"&gt;\n"
#~ "    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
#~ "    &lt;return-join alias=\"address\" property=\"person.mailingAddress\"/"
#~ "&gt;\n"
#~ "&lt;/resultset&gt;\n"
#~ "\n"
#~ "&lt;sql-query name=\"personsWith\" resultset-ref=\"personAddress\"&gt;\n"
#~ "    SELECT person.NAME AS {person.name},\n"
#~ "           person.AGE AS {person.age},\n"
#~ "           person.SEX AS {person.sex},\n"
#~ "           adddress.STREET AS {address.street},\n"
#~ "           adddress.CITY AS {address.city},\n"
#~ "           adddress.STATE AS {address.state},\n"
#~ "           adddress.ZIP AS {address.zip}\n"
#~ "    FROM PERSON person\n"
#~ "    JOIN ADDRESS adddress\n"
#~ "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
#~ "    WHERE person.NAME LIKE :namePattern\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[List cats = sess.createSQLQuery(\n"
#~ "        \"select {cat.*}, {kitten.*} from cats cat, cats kitten where "
#~ "kitten.mother = cat.id\"\n"
#~ "    )\n"
#~ "    .setResultSetMapping(\"catAndKitten\")\n"
#~ "    .list();]]>"
#~ msgstr ""
#~ "List cats = sess.createSQLQuery(\n"
#~ "        \"select {cat.*}, {kitten.*} from cats cat, cats kitten where "
#~ "kitten.mother = cat.id\"\n"
#~ "    )\n"
#~ "    .setResultSetMapping(\"catAndKitten\")\n"
#~ "    .list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"mySqlQuery\">\n"
#~ "    <return alias=\"person\" class=\"eg.Person\">\n"
#~ "        <return-property name=\"name\" column=\"myName\"/>\n"
#~ "        <return-property name=\"age\" column=\"myAge\"/>\n"
#~ "        <return-property name=\"sex\" column=\"mySex\"/>\n"
#~ "    </return>\n"
#~ "    SELECT person.NAME AS myName,\n"
#~ "           person.AGE AS myAge,\n"
#~ "           person.SEX AS mySex,\n"
#~ "    FROM PERSON person WHERE person.NAME LIKE :name\n"
#~ "</sql-query>\n"
#~ "]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"mySqlQuery\"&gt;\n"
#~ "    &lt;return alias=\"person\" class=\"eg.Person\"&gt;\n"
#~ "        &lt;return-property name=\"name\" column=\"myName\"/&gt;\n"
#~ "        &lt;return-property name=\"age\" column=\"myAge\"/&gt;\n"
#~ "        &lt;return-property name=\"sex\" column=\"mySex\"/&gt;\n"
#~ "    &lt;/return&gt;\n"
#~ "    SELECT person.NAME AS myName,\n"
#~ "           person.AGE AS myAge,\n"
#~ "           person.SEX AS mySex,\n"
#~ "    FROM PERSON person WHERE person.NAME LIKE :name\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"organizationCurrentEmployments\">\n"
#~ "    <return alias=\"emp\" class=\"Employment\">\n"
#~ "        <return-property name=\"salary\">\n"
#~ "            <return-column name=\"VALUE\"/>\n"
#~ "            <return-column name=\"CURRENCY\"/>\n"
#~ "        </return-property>\n"
#~ "        <return-property name=\"endDate\" column=\"myEndDate\"/>\n"
#~ "    </return>\n"
#~ "        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},\n"
#~ "        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},\n"
#~ "        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY\n"
#~ "        FROM EMPLOYMENT\n"
#~ "        WHERE EMPLOYER = :id AND ENDDATE IS NULL\n"
#~ "        ORDER BY STARTDATE ASC\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"organizationCurrentEmployments\"&gt;\n"
#~ "    &lt;return alias=\"emp\" class=\"Employment\"&gt;\n"
#~ "        &lt;return-property name=\"salary\"&gt;\n"
#~ "            &lt;return-column name=\"VALUE\"/&gt;\n"
#~ "            &lt;return-column name=\"CURRENCY\"/&gt;\n"
#~ "        &lt;/return-property&gt;\n"
#~ "        &lt;return-property name=\"endDate\" column=\"myEndDate\"/&gt;\n"
#~ "    &lt;/return&gt;\n"
#~ "        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},\n"
#~ "        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},\n"
#~ "        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY\n"
#~ "        FROM EMPLOYMENT\n"
#~ "        WHERE EMPLOYER = :id AND ENDDATE IS NULL\n"
#~ "        ORDER BY STARTDATE ASC\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[CREATE OR REPLACE FUNCTION selectAllEmployments\n"
#~ "    RETURN SYS_REFCURSOR\n"
#~ "AS\n"
#~ "    st_cursor SYS_REFCURSOR;\n"
#~ "BEGIN\n"
#~ "    OPEN st_cursor FOR\n"
#~ " SELECT EMPLOYEE, EMPLOYER,\n"
#~ " STARTDATE, ENDDATE,\n"
#~ " REGIONCODE, EID, VALUE, CURRENCY\n"
#~ " FROM EMPLOYMENT;\n"
#~ "      RETURN  st_cursor;\n"
#~ " END;]]>"
#~ msgstr ""
#~ "CREATE OR REPLACE FUNCTION selectAllEmployments\n"
#~ "    RETURN SYS_REFCURSOR\n"
#~ "AS\n"
#~ "    st_cursor SYS_REFCURSOR;\n"
#~ "BEGIN\n"
#~ "    OPEN st_cursor FOR\n"
#~ " SELECT EMPLOYEE, EMPLOYER,\n"
#~ " STARTDATE, ENDDATE,\n"
#~ " REGIONCODE, EID, VALUE, CURRENCY\n"
#~ " FROM EMPLOYMENT;\n"
#~ "      RETURN  st_cursor;\n"
#~ " END;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"selectAllEmployees_SP\" callable=\"true\">\n"
#~ "    <return alias=\"emp\" class=\"Employment\">\n"
#~ "        <return-property name=\"employee\" column=\"EMPLOYEE\"/>\n"
#~ "        <return-property name=\"employer\" column=\"EMPLOYER\"/>\n"
#~ "        <return-property name=\"startDate\" column=\"STARTDATE\"/>\n"
#~ "        <return-property name=\"endDate\" column=\"ENDDATE\"/>\n"
#~ "        <return-property name=\"regionCode\" column=\"REGIONCODE\"/>\n"
#~ "        <return-property name=\"id\" column=\"EID\"/>\n"
#~ "        <return-property name=\"salary\">\n"
#~ "            <return-column name=\"VALUE\"/>\n"
#~ "            <return-column name=\"CURRENCY\"/>\n"
#~ "        </return-property>\n"
#~ "    </return>\n"
#~ "    { ? = call selectAllEmployments() }\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"selectAllEmployees_SP\" callable=\"true\"&gt;\n"
#~ "    &lt;return alias=\"emp\" class=\"Employment\"&gt;\n"
#~ "        &lt;return-property name=\"employee\" column=\"EMPLOYEE\"/&gt;\n"
#~ "        &lt;return-property name=\"employer\" column=\"EMPLOYER\"/&gt;\n"
#~ "        &lt;return-property name=\"startDate\" column=\"STARTDATE\"/&gt;\n"
#~ "        &lt;return-property name=\"endDate\" column=\"ENDDATE\"/&gt;\n"
#~ "        &lt;return-property name=\"regionCode\" column=\"REGIONCODE\"/"
#~ "&gt;\n"
#~ "        &lt;return-property name=\"id\" column=\"EID\"/&gt;\n"
#~ "        &lt;return-property name=\"salary\"&gt;\n"
#~ "            &lt;return-column name=\"VALUE\"/&gt;\n"
#~ "            &lt;return-column name=\"CURRENCY\"/&gt;\n"
#~ "        &lt;/return-property&gt;\n"
#~ "    &lt;/return&gt;\n"
#~ "    { ? = call selectAllEmployments() }\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Person\">\n"
#~ "    <id name=\"id\">\n"
#~ "        <generator class=\"increment\"/>\n"
#~ "    </id>\n"
#~ "    <property name=\"name\" not-null=\"true\"/>\n"
#~ "    <sql-insert>INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )</sql-"
#~ "insert>\n"
#~ "    <sql-update>UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?</sql-update>\n"
#~ "    <sql-delete>DELETE FROM PERSON WHERE ID=?</sql-delete>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"Person\"&gt;\n"
#~ "    &lt;id name=\"id\"&gt;\n"
#~ "        &lt;generator class=\"increment\"/&gt;\n"
#~ "    &lt;/id&gt;\n"
#~ "    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
#~ "    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )"
#~ "&lt;/sql-insert&gt;\n"
#~ "    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-"
#~ "update&gt;\n"
#~ "    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Person\">\n"
#~ "    <id name=\"id\">\n"
#~ "        <generator class=\"increment\"/>\n"
#~ "    </id>\n"
#~ "    <property name=\"name\" not-null=\"true\"/>\n"
#~ "    <sql-insert callable=\"true\">{call createPerson (?, ?)}</sql-"
#~ "insert>\n"
#~ "    <sql-delete callable=\"true\">{? = call deletePerson (?)}</sql-"
#~ "delete>\n"
#~ "    <sql-update callable=\"true\">{? = call updatePerson (?, ?)}</sql-"
#~ "update>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"Person\"&gt;\n"
#~ "    &lt;id name=\"id\"&gt;\n"
#~ "        &lt;generator class=\"increment\"/&gt;\n"
#~ "    &lt;/id&gt;\n"
#~ "    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
#~ "    &lt;sql-insert callable=\"true\"&gt;{call createPerson (?, ?)}&lt;/"
#~ "sql-insert&gt;\n"
#~ "    &lt;sql-delete callable=\"true\"&gt;{? = call deletePerson (?)}&lt;/"
#~ "sql-delete&gt;\n"
#~ "    &lt;sql-update callable=\"true\"&gt;{? = call updatePerson (?, ?)}"
#~ "&lt;/sql-update&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN "
#~ "VARCHAR2)\n"
#~ "    RETURN NUMBER IS\n"
#~ "BEGIN\n"
#~ "\n"
#~ "    update PERSON\n"
#~ "    set\n"
#~ "        NAME = uname,\n"
#~ "    where\n"
#~ "        ID = uid;\n"
#~ "\n"
#~ "    return SQL%ROWCOUNT;\n"
#~ "\n"
#~ "END updatePerson;]]>"
#~ msgstr ""
#~ "CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN "
#~ "VARCHAR2)\n"
#~ "    RETURN NUMBER IS\n"
#~ "BEGIN\n"
#~ "\n"
#~ "    update PERSON\n"
#~ "    set\n"
#~ "        NAME = uname,\n"
#~ "    where\n"
#~ "        ID = uid;\n"
#~ "\n"
#~ "    return SQL&#37;ROWCOUNT;\n"
#~ "\n"
#~ "END updatePerson;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"person\">\n"
#~ "    <return alias=\"pers\" class=\"Person\" lock-mode=\"upgrade\"/>\n"
#~ "    SELECT NAME AS {pers.name}, ID AS {pers.id}\n"
#~ "    FROM PERSON\n"
#~ "    WHERE ID=?\n"
#~ "    FOR UPDATE\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"person\"&gt;\n"
#~ "    &lt;return alias=\"pers\" class=\"Person\" lock-mode=\"upgrade\"/"
#~ "&gt;\n"
#~ "    SELECT NAME AS {pers.name}, ID AS {pers.id}\n"
#~ "    FROM PERSON\n"
#~ "    WHERE ID=?\n"
#~ "    FOR UPDATE\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Person\">\n"
#~ "    <id name=\"id\">\n"
#~ "        <generator class=\"increment\"/>\n"
#~ "    </id>\n"
#~ "    <property name=\"name\" not-null=\"true\"/>\n"
#~ "    <loader query-ref=\"person\"/>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"Person\"&gt;\n"
#~ "    &lt;id name=\"id\"&gt;\n"
#~ "        &lt;generator class=\"increment\"/&gt;\n"
#~ "    &lt;/id&gt;\n"
#~ "    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
#~ "    &lt;loader query-ref=\"person\"/&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<set name=\"employments\" inverse=\"true\">\n"
#~ "    <key/>\n"
#~ "    <one-to-many class=\"Employment\"/>\n"
#~ "    <loader query-ref=\"employments\"/>\n"
#~ "</set>]]>"
#~ msgstr ""
#~ "&lt;set name=\"employments\" inverse=\"true\"&gt;\n"
#~ "    &lt;key/&gt;\n"
#~ "    &lt;one-to-many class=\"Employment\"/&gt;\n"
#~ "    &lt;loader query-ref=\"employments\"/&gt;\n"
#~ "&lt;/set&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"employments\">\n"
#~ "    <load-collection alias=\"emp\" role=\"Person.employments\"/>\n"
#~ "    SELECT {emp.*}\n"
#~ "    FROM EMPLOYMENT emp\n"
#~ "    WHERE EMPLOYER = :id\n"
#~ "    ORDER BY STARTDATE ASC, EMPLOYEE ASC\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"employments\"&gt;\n"
#~ "    &lt;load-collection alias=\"emp\" role=\"Person.employments\"/&gt;\n"
#~ "    SELECT {emp.*}\n"
#~ "    FROM EMPLOYMENT emp\n"
#~ "    WHERE EMPLOYER = :id\n"
#~ "    ORDER BY STARTDATE ASC, EMPLOYEE ASC\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"person\">\n"
#~ "    <return alias=\"pers\" class=\"Person\"/>\n"
#~ "    <return-join alias=\"emp\" property=\"pers.employments\"/>\n"
#~ "    SELECT NAME AS {pers.*}, {emp.*}\n"
#~ "    FROM PERSON pers\n"
#~ "    LEFT OUTER JOIN EMPLOYMENT emp\n"
#~ "        ON pers.ID = emp.PERSON_ID\n"
#~ "    WHERE ID=?\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"person\"&gt;\n"
#~ "    &lt;return alias=\"pers\" class=\"Person\"/&gt;\n"
#~ "    &lt;return-join alias=\"emp\" property=\"pers.employments\"/&gt;\n"
#~ "    SELECT NAME AS {pers.*}, {emp.*}\n"
#~ "    FROM PERSON pers\n"
#~ "    LEFT OUTER JOIN EMPLOYMENT emp\n"
#~ "        ON pers.ID = emp.PERSON_ID\n"
#~ "    WHERE ID=?\n"
#~ "&lt;/sql-query&gt;"

