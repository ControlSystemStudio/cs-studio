# translation of performance.po to
# Xi Huang <xhuang@redhat.com>, 2006.
# Xi HUANG <xhuang@redhat.com>, 2007, 2009.
# translation of Collection_Mapping.po to
msgid ""
msgstr ""
"Project-Id-Version: performance\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:15\n"
"PO-Revision-Date: 2010-03-15 15:27+1000\n"
"Last-Translator: Xi HUANG <xhuang@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Improving performance"
msgstr "提升性能"

#. Tag: title
#, no-c-format
msgid "Fetching strategies"
msgstr "抓取策略（Fetching strategies）"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate uses a <emphasis>fetching strategy</emphasis> to retrieve "
"associated objects if the application needs to navigate the association. "
"Fetch strategies can be declared in the O/R mapping metadata, or over-ridden "
"by a particular HQL or <literal>Criteria</literal> query."
msgstr ""
"当应用程序需要在（Hibernate实体对象图的）关联关系间进行导航的时候，Hibernate "
"使用 <emphasis>抓取策略（fetching strategy）</emphasis> 获取关联对象。抓取策"
"略可以在 O/R 映射的元数据中声明，也可以在特定的 HQL 或<literal>条件查询"
"（Criteria Query）</literal>中重载声明。"

#. Tag: para
#, no-c-format
msgid "Hibernate3 defines the following fetching strategies:"
msgstr "Hibernate3 定义了如下几种抓取策略："

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Join fetching</emphasis>: Hibernate retrieves the associated "
"instance or collection in the same <literal>SELECT</literal>, using an "
"<literal>OUTER JOIN</literal>."
msgstr ""
"<emphasis>连接抓取（Join fetching）</emphasis>：Hibernate 通过在 "
"<literal>SELECT</literal>  语句使用 <literal>OUTER JOIN</literal>（外连接）来"
"获得对象的关联实例或者关联集合。 "

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Select fetching</emphasis>: a second <literal>SELECT</literal> is "
"used to retrieve the associated entity or collection. Unless you explicitly "
"disable lazy fetching by specifying <literal>lazy=\"false\"</literal>, this "
"second select will only be executed when you access the association."
msgstr ""
"<emphasis>查询抓取（Select fetching）</emphasis>：另外发送一条 "
"<literal>SELECT</literal> 语句抓取当前对象的关联实体或集合。除非你显式的指定 "
"<literal>lazy=\"false\"</literal> 禁止 延迟抓取（lazy fetching），否则只有当"
"你真正访问关联关系的时候，才会执行第二条 select 语句。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Subselect fetching</emphasis>: a second <literal>SELECT</literal> "
"is used to retrieve the associated collections for all entities retrieved in "
"a previous query or fetch. Unless you explicitly disable lazy fetching by "
"specifying <literal>lazy=\"false\"</literal>, this second select will only "
"be executed when you access the association."
msgstr ""
"<emphasis>子查询抓取（Subselect fetching）</emphasis>：另外发送一条  "
"<literal>SELECT</literal> 语句抓取在前面查询到（或者抓取到）的所有实体对象的"
"关联集合。除非你显式的指定 <literal>lazy=\"false\"</literal> 禁止延迟抓取"
"（lazy fetching），否则只有当你真正访问关联关系的时候，才会执行第二条 select "
"语句。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Batch fetching</emphasis>: an optimization strategy for select "
"fetching. Hibernate retrieves a batch of entity instances or collections in "
"a single <literal>SELECT</literal> by specifying a list of primary or "
"foreign keys."
msgstr ""
"<emphasis>批量抓取（Batch fetching）</emphasis>：对查询抓取的优化方案，通过指"
"定一个主键或外键列表，Hibernate 使用单条 <literal>SELECT</literal> 语句获取一"
"批对象实例或集合。"

#. Tag: para
#, no-c-format
msgid "Hibernate also distinguishes between:"
msgstr "Hibernate 会区分下列各种情况："

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Immediate fetching</emphasis>: an association, collection or "
"attribute is fetched immediately when the owner is loaded."
msgstr ""
"<emphasis>Immediate fetching，立即抓取</emphasis>：当宿主被加载时，关联、集合"
"或属性被立即抓取。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Lazy collection fetching</emphasis>: a collection is fetched when "
"the application invokes an operation upon that collection. This is the "
"default for collections."
msgstr ""
"<emphasis>Lazy collection fetching，延迟集合抓取</emphasis>：直到应用程序对集"
"合进行了一次操作时，集合才被抓取（对集合而言这是默认行为）。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>\"Extra-lazy\" collection fetching</emphasis>: individual elements "
"of the collection are accessed from the database as needed. Hibernate tries "
"not to fetch the whole collection into memory unless absolutely needed. It "
"is suitable for large collections."
msgstr ""
"<emphasis>\"Extra-lazy\" collection fetching,\"Extra-lazy\" 集合抓取</"
"emphasis>：对集合类中的每个元素而言，都是直到需要时才去访问数据库。除非绝对必"
"要，Hibernate 不会试图去把整个集合都抓取到内存里来（适用于非常大的集合）。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Proxy fetching</emphasis>: a single-valued association is fetched "
"when a method other than the identifier getter is invoked upon the "
"associated object."
msgstr ""
"<emphasis>Proxy fetching，代理抓取</emphasis>：对返回单值的关联而言，当其某个"
"方法被调用，而非对其关键字进行 get 操作时才抓取。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>\"No-proxy\" fetching</emphasis>: a single-valued association is "
"fetched when the instance variable is accessed. Compared to proxy fetching, "
"this approach is less lazy; the association is fetched even when only the "
"identifier is accessed. It is also more transparent, since no proxy is "
"visible to the application. This approach requires buildtime bytecode "
"instrumentation and is rarely necessary."
msgstr ""
"<emphasis>\"No-proxy\" fetching，非代理抓取</emphasis>：对返回单值的关联而"
"言，当实例变量被访问的时候进行抓取。与上面的代理抓取相比，这种方法没有那么“延"
"迟”得厉害（就算只访问标识符，也会导致关联抓取）但是更加透明，因为对应用程序来"
"说，不再看到 proxy。这种方法需要在编译期间进行字节码增强操作，因此很少需要用"
"到。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Lazy attribute fetching</emphasis>: an attribute or single valued "
"association is fetched when the instance variable is accessed. This approach "
"requires buildtime bytecode instrumentation and is rarely necessary."
msgstr ""
"<emphasis>Lazy attribute fetching，属性延迟加载</emphasis>：对属性或返回单值"
"的关联而言，当其实例变量被访问的时候进行抓取。需要编译期字节码强化，因此这一"
"方法很少是必要的。"

#. Tag: para
#, no-c-format
msgid ""
"We have two orthogonal notions here: <emphasis>when</emphasis> is the "
"association fetched and <emphasis>how</emphasis> is it fetched. It is "
"important that you do not confuse them. We use <literal>fetch</literal> to "
"tune performance. We can use <literal>lazy</literal> to define a contract "
"for what data is always available in any detached instance of a particular "
"class."
msgstr ""
"这里有两个正交的概念：关联<emphasis>何时</emphasis>被抓取，以及被<emphasis>如"
"何</emphasis>抓取（会采用什么样的 SQL 语句）。注意不要混淆它们。我们使用"
"<literal>抓取</literal>来改善性能。我们使用<literal>延迟</literal>来定义一些"
"契约，对某特定类的某个脱管的实例，知道有哪些数据是可以使用的。"

#. Tag: title
#, no-c-format
msgid "Working with lazy associations"
msgstr "操作延迟加载的关联"

#. Tag: para
#, no-c-format
msgid ""
"By default, Hibernate3 uses lazy select fetching for collections and lazy "
"proxy fetching for single-valued associations. These defaults make sense for "
"most associations in the majority of applications."
msgstr ""
"默认情况下，Hibernate 3 对集合使用延迟 select 抓取，对返回单值的关联使用延迟"
"代理抓取。对几乎是所有的应用而言，其绝大多数的关联，这种策略都是有效的。"

#. Tag: para
#, no-c-format
msgid ""
"If you set <literal>hibernate.default_batch_fetch_size</literal>, Hibernate "
"will use the batch fetch optimization for lazy fetching. This optimization "
"can also be enabled at a more granular level."
msgstr ""
"假若你设置了 <literal>hibernate.default_batch_fetch_size</literal>，"
"Hibernate 会对延迟加载采取批量抓取优化措施（这种优化也可能会在更细化的级别打"
"开）。"

#. Tag: para
#, no-c-format
msgid ""
"Please be aware that access to a lazy association outside of the context of "
"an open Hibernate session will result in an exception. For example:"
msgstr ""
"然而，你必须了解延迟抓取带来的一个问题。在一个打开的 Hibernate session 上下文"
"之外调用延迟集合会导致一次意外。比如： "

#. Tag: para
#, no-c-format
msgid ""
"Since the permissions collection was not initialized when the "
"<literal>Session</literal> was closed, the collection will not be able to "
"load its state. <emphasis>Hibernate does not support lazy initialization for "
"detached objects</emphasis>. This can be fixed by moving the code that reads "
"from the collection to just before the transaction is committed."
msgstr ""
"在 <literal>Session</literal> 关闭后，permessions 集合将是未实例化的、不再可"
"用，因此无法正常载入其状态。 <emphasis>Hibernate 对脱管对象不支持延迟实例化</"
"emphasis>。这里的修改方法是将 permissions 读取数据的代码移到事务提交之前。"

#. Tag: para
#, no-c-format
msgid ""
"Alternatively, you can use a non-lazy collection or association, by "
"specifying <literal>lazy=\"false\"</literal> for the association mapping. "
"However, it is intended that lazy initialization be used for almost all "
"collections and associations. If you define too many non-lazy associations "
"in your object model, Hibernate will fetch the entire database into memory "
"in every transaction."
msgstr ""
"除此之外，通过对关联映射指定 <literal>lazy=\"false\"</literal>，我们也可以使"
"用非延迟的集合或关联。但是，对绝大部分集合来说，更推荐使用延迟方式抓取数据。"
"如果在你的对象模型中定义了太多的非延迟关联，Hibernate 最终几乎需要在每个事务"
"中载入整个数据库到内存中。"

#. Tag: para
#, no-c-format
msgid ""
"On the other hand, you can use join fetching, which is non-lazy by nature, "
"instead of select fetching in a particular transaction. We will now explain "
"how to customize the fetching strategy. In Hibernate3, the mechanisms for "
"choosing a fetch strategy are identical for single-valued associations and "
"collections."
msgstr ""
"但是，另一方面，在一些特殊的事务中，我们也经常需要使用到连接抓取（它本身上就"
"是非延迟的），以代替查询抓取。 下面我们将会很快明白如何具体的定制 Hibernate "
"中的抓取策略。在 Hibernate3 中，具体选择哪种抓取策略的机制是和选择 单值关联或"
"集合关联相一致的。 "

#. Tag: title
#, no-c-format
msgid "Tuning fetch strategies"
msgstr "调整抓取策略（Tuning fetch strategies）"

#. Tag: para
#, no-c-format
msgid ""
"Select fetching (the default) is extremely vulnerable to N+1 selects "
"problems, so we might want to enable join fetching in the mapping document:"
msgstr ""
"查询抓取（默认的）在 N+1 查询的情况下是极其脆弱的，因此我们可能会要求在映射文"
"档中定义使用连接抓取："

#. Tag: para
#, no-c-format
msgid ""
"The <literal>fetch</literal> strategy defined in the mapping document "
"affects:"
msgstr ""
"在映射文档中定义的<literal>抓取</literal>策略将会对以下列表条目产生影响："

#. Tag: para
#, no-c-format
msgid "retrieval via <literal>get()</literal> or <literal>load()</literal>"
msgstr ""
"通过 <literal>get()</literal> 或 <literal>load()</literal> 方法取得数据。"

#. Tag: para
#, no-c-format
msgid "retrieval that happens implicitly when an association is navigated"
msgstr "只有在关联之间进行导航时，才会隐式的取得数据。"

#. Tag: para
#, no-c-format
msgid "<literal>Criteria</literal> queries"
msgstr "条件查询"

#. Tag: para
#, no-c-format
msgid "HQL queries if <literal>subselect</literal> fetching is used"
msgstr "使用了 <literal>subselect</literal> 抓取的 HQL 查询"

#. Tag: para
#, no-c-format
msgid ""
"Irrespective of the fetching strategy you use, the defined non-lazy graph is "
"guaranteed to be loaded into memory. This might, however, result in several "
"immediate selects being used to execute a particular HQL query."
msgstr ""
"不管你使用哪种抓取策略，定义为非延迟的类图会被保证一定装载入内存。注意这可能"
"意味着在一条 HQL 查询后紧跟着一系列的查询。 "

#. Tag: para
#, no-c-format
msgid ""
"Usually, the mapping document is not used to customize fetching. Instead, we "
"keep the default behavior, and override it for a particular transaction, "
"using <literal>left join fetch</literal> in HQL. This tells Hibernate to "
"fetch the association eagerly in the first select, using an outer join. In "
"the <literal>Criteria</literal> query API, you would use "
"<literal>setFetchMode(FetchMode.JOIN)</literal>."
msgstr ""
"通常情况下，我们并不使用映射文档进行抓取策略的定制。更多的是，保持其默认值，"
"然后在特定的事务中， 使用 HQL 的<literal>左连接抓取（left join fetch）</"
"literal> 对其进行重载。这将通知 Hibernate在第一次查询中使用外部关联（outer "
"join），直接得到其关联数据。在<literal>条件查询</literal> API 中，应该调用 "
"<literal>setFetchMode（FetchMode.JOIN）</literal>语句。 "

#. Tag: para
#, no-c-format
msgid ""
"If you want to change the fetching strategy used by <literal>get()</literal> "
"or <literal>load()</literal>, you can use a <literal>Criteria</literal> "
"query. For example:"
msgstr ""
"也许你喜欢仅仅通过条件查询，就可以改变 <literal>get()</literal> 或 "
"<literal>load()</literal> 语句中的数据抓取策略。例如： "

#. Tag: para
#, no-c-format
msgid ""
"This is Hibernate's equivalent of what some ORM solutions call a \"fetch plan"
"\"."
msgstr ""
"这就是其他 ORM 解决方案的“抓取计划（fetch plan）”在 Hibernate 中的等价物。"

#. Tag: para
#, no-c-format
msgid ""
"A completely different approach to problems with N+1 selects is to use the "
"second-level cache."
msgstr "截然不同的一种避免 N+1 次查询的方法是，使用二级缓存。 "

#. Tag: title
#, no-c-format
msgid "Single-ended association proxies"
msgstr "单端关联代理（Single-ended association proxies）"

#. Tag: para
#, no-c-format
msgid ""
"Lazy fetching for collections is implemented using Hibernate's own "
"implementation of persistent collections. However, a different mechanism is "
"needed for lazy behavior in single-ended associations. The target entity of "
"the association must be proxied. Hibernate implements lazy initializing "
"proxies for persistent objects using runtime bytecode enhancement which is "
"accessed via the CGLIB library."
msgstr ""
"在 Hinerbate 中，对集合的延迟抓取的采用了自己的实现方法。但是，对于单端关联的"
"延迟抓取，则需要采用 其他不同的机制。单端关联的目标实体必须使用代理，"
"Hihernate 在运行期二进制级（通过优异的 CGLIB 库）， 为持久对象实现了延迟载入"
"代理。 "

#. Tag: para
#, no-c-format
msgid ""
"At startup, Hibernate3 generates proxies by default for all persistent "
"classes and uses them to enable lazy fetching of <literal>many-to-one</"
"literal> and <literal>one-to-one</literal> associations."
msgstr ""
"默认的，Hibernate3 将会为所有的持久对象产生代理（在启动阶段），然后使用他们实"
"现 <literal>多对一（many-to-one）</literal>关联和<literal>一对一（one-to-"
"one）</literal> 关联的延迟抓取。 "

#. Tag: para
#, no-c-format
msgid ""
"The mapping file may declare an interface to use as the proxy interface for "
"that class, with the <literal>proxy</literal> attribute. By default, "
"Hibernate uses a subclass of the class. <emphasis>The proxied class must "
"implement a default constructor with at least package visibility. This "
"constructor is recommended for all persistent classes</emphasis>."
msgstr ""
"在映射文件中，可以通过设置 <literal>proxy</literal> 属性为目标 class 声明一个"
"接口供代理接口使用。 默认的，Hibernate 将会使用该类的一个子类。<emphasis>注"
"意：被代理的类必须实现一个至少包可见的默认构造函数，我们建议所有的持久类都应"
"拥有这样的构造函数。</emphasis>"

#. Tag: para
#, no-c-format
msgid ""
"There are potential problems to note when extending this approach to "
"polymorphic classes.For example:"
msgstr "在如此方式定义一个多态类的时候，有许多值得注意的常见性的问题，例如： "

#. Tag: para
#, no-c-format
msgid ""
"Firstly, instances of <literal>Cat</literal> will never be castable to "
"<literal>DomesticCat</literal>, even if the underlying instance is an "
"instance of <literal>DomesticCat</literal>:"
msgstr ""
"首先，<literal>Cat</literal> 实例永远不可以被强制转换为 "
"<literal>DomesticCat</literal>，即使它本身就是 <literal>DomesticCat</"
"literal> 实例。"

#. Tag: para
#, no-c-format
msgid "Secondly, it is possible to break proxy <literal>==</literal>:"
msgstr "其次，代理的“<literal>==</literal>”可能不再成立。 "

#. Tag: para
#, no-c-format
msgid ""
"However, the situation is not quite as bad as it looks. Even though we now "
"have two references to different proxy objects, the underlying instance will "
"still be the same object:"
msgstr ""
"虽然如此，但实际情况并没有看上去那么糟糕。虽然我们现在有两个不同的引用，分别"
"指向这两个不同的代理对象，但实际上，其底层应该是同一个实例对象："

#. Tag: para
#, no-c-format
msgid ""
"Third, you cannot use a CGLIB proxy for a <literal>final</literal> class or "
"a class with any <literal>final</literal> methods."
msgstr ""
"第三，你不能对 <literal>final</literal> 类或具有 <literal>final</literal> 方"
"法的类使用 CGLIB 代理。"

#. Tag: para
#, no-c-format
msgid ""
"Finally, if your persistent object acquires any resources upon instantiation "
"(e.g. in initializers or default constructor), then those resources will "
"also be acquired by the proxy. The proxy class is an actual subclass of the "
"persistent class."
msgstr ""
"最后，如果你的持久化对象在实例化时需要某些资源（例如，在实例化方法、默认构造"
"方法中），那么代理对象也同样需要使用这些资源。实际上，代理类是持久化类的子"
"类。"

#. Tag: para
#, no-c-format
msgid ""
"These problems are all due to fundamental limitations in Java's single "
"inheritance model. To avoid these problems your persistent classes must each "
"implement an interface that declares its business methods. You should "
"specify these interfaces in the mapping file where <literal>CatImpl</"
"literal> implements the interface <literal>Cat</literal> and "
"<literal>DomesticCatImpl</literal> implements the interface "
"<literal>DomesticCat</literal>. For example:"
msgstr ""
"这些问题都源于 Java 的单根继承模型的天生限制。如果你希望避免这些问题，那么你"
"的每个持久化类必须实现一个接口， 在此接口中已经声明了其业务方法。然后，你需要"
"在映射文档中再指定这些接口，如 <literal>CatImpl</literal> 实现 <literal>Cat</"
"literal> 而 <literal>DomesticCatImpl</literal> 实现 <literal>DomesticCat</"
"literal> 接口。例如："

#. Tag: para
#, no-c-format
msgid ""
"Then proxies for instances of <literal>Cat</literal> and "
"<literal>DomesticCat</literal> can be returned by <literal>load()</literal> "
"or <literal>iterate()</literal>."
msgstr ""
"然后，<literal>load()</literal> 和 <literal>iterate()</literal> 永远也不会返"
"回 <literal>Cat</literal> 和 <literal>DomesticCat</literal> 实例的代理。"

#. Tag: title
#, no-c-format
msgid "Note"
msgstr "注意"

#. Tag: para
#, no-c-format
msgid "<literal>list()</literal> does not usually return proxies."
msgstr "<literal>list()</literal> 通常不返回代理。"

#. Tag: para
#, no-c-format
msgid ""
"Relationships are also lazily initialized. This means you must declare any "
"properties to be of type <literal>Cat</literal>, not <literal>CatImpl</"
"literal>."
msgstr ""
"这里，对象之间的关系也将被延迟载入。这就意味着，你应该将属性声明为 "
"<literal>Cat</literal>，而不是 <literal>CatImpl</literal>。"

#. Tag: para
#, no-c-format
msgid ""
"Certain operations do <emphasis>not</emphasis> require proxy initialization:"
msgstr "有些方法中是<emphasis>不</emphasis>需要代理初始化的："

#. Tag: para
#, no-c-format
msgid ""
"<literal>equals()</literal>: if the persistent class does not override "
"<literal>equals()</literal>"
msgstr ""
"<literal>equals()</literal> 方法，如果持久类没有重载 <literal>equals()</"
"literal> 方法。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>hashCode()</literal>: if the persistent class does not override "
"<literal>hashCode()</literal>"
msgstr ""
"<literal>hashCode()</literal>：如果持久类没有重载 <literal>hashCode()</"
"literal> 方法。"

#. Tag: para
#, no-c-format
msgid "The identifier getter method"
msgstr "标志符的 getter 方法。"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate will detect persistent classes that override <literal>equals()</"
"literal> or <literal>hashCode()</literal>."
msgstr ""
"Hibernate 将会识别出那些重载了 <literal>equals()</literal>、或 "
"<literal>hashCode()</literal> 方法的持久化类。"

#. Tag: para
#, no-c-format
msgid ""
"By choosing <literal>lazy=\"no-proxy\"</literal> instead of the default "
"<literal>lazy=\"proxy\"</literal>, you can avoid problems associated with "
"typecasting. However, buildtime bytecode instrumentation is required, and "
"all operations will result in immediate proxy initialization."
msgstr ""
"若选择 <literal>lazy=\"no-proxy\"</literal> 而非默认的 <literal>lazy=\"proxy"
"\"</literal>，我们可以避免类型转换带来的问题。然而，这样我们就需要编译期字节"
"码增强，并且所有的操作都会导致立刻进行代理初始化。 "

#. Tag: title
#, no-c-format
msgid "Initializing collections and proxies"
msgstr "实例化集合和代理（Initializing collections and proxies）"

#. Tag: para
#, no-c-format
msgid ""
"A <literal>LazyInitializationException</literal> will be thrown by Hibernate "
"if an uninitialized collection or proxy is accessed outside of the scope of "
"the <literal>Session</literal>, i.e., when the entity owning the collection "
"or having the reference to the proxy is in the detached state."
msgstr ""
"在 <literal>Session</literal> 范围之外访问未初始化的集合或代理，Hibernate 将"
"会抛出 <literal>LazyInitializationException</literal> 异常。也就是说，在分离"
"状态下，访问一个实体所拥有的集合，或者访问其指向代理的属性时，会引发此异常。 "

#. Tag: para
#, no-c-format
msgid ""
"Sometimes a proxy or collection needs to be initialized before closing the "
"<literal>Session</literal>. You can force initialization by calling "
"<literal>cat.getSex()</literal> or <literal>cat.getKittens().size()</"
"literal>, for example. However, this can be confusing to readers of the code "
"and it is not convenient for generic code."
msgstr ""
"有时候我们需要保证某个代理或者集合在 Session 关闭前就已经被初始化了。当然，我"
"们可以通过强行调用 <literal>cat.getSex()</literal> 或者 <literal>cat."
"getKittens().size()</literal> 之类的方法来确保这一点。 但是这样的程序会造成读"
"者的疑惑，也不符合通常的代码规范。 "

#. Tag: para
#, no-c-format
msgid ""
"The static methods <literal>Hibernate.initialize()</literal> and "
"<literal>Hibernate.isInitialized()</literal>, provide the application with a "
"convenient way of working with lazily initialized collections or proxies. "
"<literal>Hibernate.initialize(cat)</literal> will force the initialization "
"of a proxy, <literal>cat</literal>, as long as its <literal>Session</"
"literal> is still open. <literal>Hibernate.initialize( cat.getKittens() )</"
"literal> has a similar effect for the collection of kittens."
msgstr ""
"静态方法 <literal>Hibernate.initialized()</literal> 为你的应用程序提供了一个"
"便捷的途径来延迟加载集合或代理。 只要它的 Session 处于 open 状态，"
"<literal>Hibernate.initialize(cat)</literal> 将会为 cat 强制对代理实例化。同"
"样，<literal>Hibernate.initialize(cat.getKittens())</literal> 对 kittens 的集"
"合具有同样的功能。 "

#. Tag: para
#, no-c-format
msgid ""
"Another option is to keep the <literal>Session</literal> open until all "
"required collections and proxies have been loaded. In some application "
"architectures, particularly where the code that accesses data using "
"Hibernate, and the code that uses it are in different application layers or "
"different physical processes, it can be a problem to ensure that the "
"<literal>Session</literal> is open when a collection is initialized. There "
"are two basic ways to deal with this issue:"
msgstr ""
"还有另外一种选择，就是保持 <literal>Session</literal> 一直处于 open 状态，直"
"到所有需要的集合或代理都被载入。 在某些应用架构中，特别是对于那些使用 "
"Hibernate 进行数据访问的代码，以及那些在不同应用层和不同物理进程中使用 "
"Hibernate 的代码。 在集合实例化时，如何保证 <literal>Session</literal> 处于 "
"open 状态经常会是一个问题。有两种方法可以解决此问题： "

#. Tag: para
#, no-c-format
msgid ""
"In a web-based application, a servlet filter can be used to close the "
"<literal>Session</literal> only at the end of a user request, once the "
"rendering of the view is complete (the <emphasis>Open Session in View</"
"emphasis> pattern). Of course, this places heavy demands on the correctness "
"of the exception handling of your application infrastructure. It is vitally "
"important that the <literal>Session</literal> is closed and the transaction "
"ended before returning to the user, even when an exception occurs during "
"rendering of the view. See the Hibernate Wiki for examples of this \"Open "
"Session in View\" pattern."
msgstr ""
"在一个基于 Web 的应用中，可以利用 servlet 过滤器（filter），在用户请求"
"（request）结束、页面生成 结束时关闭 <literal>Session</literal>（这里使用了"
"<emphasis>在展示层保持打开 Session 模式（Open Session in View）</"
"emphasis>），当然，这将依赖于应用框架中异常需要被正确的处理。在返回界面给用户"
"之前，乃至在生成界面过程中发生异常的情况下，正确关闭 <literal>Session</"
"literal> 和结束事务将是非常重要的， 请参见 Hibernate wiki 上的 \"Open "
"Session in View\" 模式，你可以找到示例。 "

#. Tag: para
#, no-c-format
msgid ""
"In an application with a separate business tier, the business logic must "
"\"prepare\" all collections that the web tier needs before returning. This "
"means that the business tier should load all the data and return all the "
"data already initialized to the presentation/web tier that is required for a "
"particular use case. Usually, the application calls <literal>Hibernate."
"initialize()</literal> for each collection that will be needed in the web "
"tier (this call must occur before the session is closed) or retrieves the "
"collection eagerly using a Hibernate query with a <literal>FETCH</literal> "
"clause or a <literal>FetchMode.JOIN</literal> in <literal>Criteria</"
"literal>. This is usually easier if you adopt the <emphasis>Command</"
"emphasis> pattern instead of a <emphasis>Session Facade</emphasis>."
msgstr ""
"在一个拥有单独业务层的应用中，业务层必须在返回之前，为 web 层“准备”好其所需的"
"数据集合。这就意味着 业务层应该载入所有表现层/web 层所需的数据，并将这些已实"
"例化完毕的数据返回。通常，应用程序应该为 web 层所需的每个集合调用 "
"<literal>Hibernate.initialize()</literal>（这个调用必须发生咱 session 关闭之"
"前）；或者使用带有 <literal>FETCH</literal> 从句，或 <literal>FetchMode."
"JOIN</literal> 的 Hibernate 查询，事先取得所有的数据集合。如果你在应用中使用"
"了 <emphasis>Command</emphasis> 模式，代替 <emphasis>Session Facade</"
"emphasis>，那么这项任务将会变得简单的多。 "

#. Tag: para
#, no-c-format
msgid ""
"You can also attach a previously loaded object to a new <literal>Session</"
"literal> with <literal>merge()</literal> or <literal>lock()</literal> before "
"accessing uninitialized collections or other proxies. Hibernate does not, "
"and certainly <emphasis>should</emphasis> not, do this automatically since "
"it would introduce impromptu transaction semantics."
msgstr ""
"你也可以通过 <literal>merge()</literal> 或 <literal>lock()</literal> 方法，在"
"访问未实例化的集合（或代理）之前，为先前载入的对象绑定一个新的 "
"<literal>Session</literal>。显然，Hibernate 将不会，也不<emphasis>应该</"
"emphasis>自动完成这些任务，因为这将引入一个特殊的事务语义。 "

#. Tag: para
#, no-c-format
msgid ""
"Sometimes you do not want to initialize a large collection, but still need "
"some information about it, like its size, for example, or a subset of the "
"data."
msgstr ""
"有时候，你并不需要完全实例化整个大的集合，仅需要了解它的部分信息（例如其大"
"小）、或者集合的部分内容。 "

#. Tag: para
#, no-c-format
msgid ""
"You can use a collection filter to get the size of a collection without "
"initializing it:"
msgstr "你可以使用集合过滤器得到其集合的大小，而不必实例化整个集合："

#. Tag: para
#, no-c-format
msgid ""
"The <literal>createFilter()</literal> method is also used to efficiently "
"retrieve subsets of a collection without needing to initialize the whole "
"collection:"
msgstr ""
"这里的 <literal>createFilter()</literal> 方法也可以被用来有效的抓取集合的部分"
"内容，而无需实例化整个集合："

#. Tag: title
#, no-c-format
msgid "Using batch fetching"
msgstr "使用批量抓取（Using batch fetching）"

#. Tag: para
#, no-c-format
msgid ""
"Using batch fetching, Hibernate can load several uninitialized proxies if "
"one proxy is accessed. Batch fetching is an optimization of the lazy select "
"fetching strategy. There are two ways you can configure batch fetching: on "
"the class level and the collection level."
msgstr ""
"Hibernate 可以充分有效的使用批量抓取，也就是说，如果仅一个访问代理（或集"
"合），那么 Hibernate 将不载入其他未实例化的代理。批量抓取是延迟查询抓取的优化"
"方案，你可以在两种批量抓取方案之间进行选择：在类级别和集合级别。 "

#. Tag: para
#, no-c-format
msgid ""
"Batch fetching for classes/entities is easier to understand. Consider the "
"following example: at runtime you have 25 <literal>Cat</literal> instances "
"loaded in a <literal>Session</literal>, and each <literal>Cat</literal> has "
"a reference to its <literal>owner</literal>, a <literal>Person</literal>. "
"The <literal>Person</literal> class is mapped with a proxy, <literal>lazy="
"\"true\"</literal>. If you now iterate through all cats and call "
"<literal>getOwner()</literal> on each, Hibernate will, by default, execute "
"25 <literal>SELECT</literal> statements to retrieve the proxied owners. You "
"can tune this behavior by specifying a <literal>batch-size</literal> in the "
"mapping of <literal>Person</literal>:"
msgstr ""
"类/实体级别的批量抓取很容易理解。假设你在运行时将需要面对下面的问题：你在一"
"个 <literal>Session</literal> 中载入了 25 个 <literal>Cat</literal> 实例，每"
"个 <literal>Cat</literal> 实例都拥有一个引用成员 <literal>owner</literal>，其"
"指向 <literal>Person</literal>，而 <literal>Person</literal> 类是代理，同时 "
"<literal>lazy=\"true\"</literal>。如果你必须遍历整个 cats 集合，对每个元素调"
"用 <literal>getOwner()</literal> 方法，Hibernate 将会默认的执行 25 次 "
"<literal>SELECT</literal> 查询， 得到其 owner 的代理对象。这时，你可以通过在"
"映射文件的 <literal>Person</literal> 属性，显式声明 <literal>batch-size</"
"literal>，改变其行为： "

#. Tag: para
#, no-c-format
msgid ""
"Hibernate will now execute only three queries: the pattern is 10, 10, 5."
msgstr "随之，Hibernate 将只需要执行三次查询，分别为 10、10、 5。 "

#. Tag: para
#, no-c-format
msgid ""
"You can also enable batch fetching of collections. For example, if each "
"<literal>Person</literal> has a lazy collection of <literal>Cat</literal>s, "
"and 10 persons are currently loaded in the <literal>Session</literal>, "
"iterating through all persons will generate 10 <literal>SELECT</literal>s, "
"one for every call to <literal>getCats()</literal>. If you enable batch "
"fetching for the <literal>cats</literal> collection in the mapping of "
"<literal>Person</literal>, Hibernate can pre-fetch collections:"
msgstr ""
"你也可以在集合级别定义批量抓取。例如，如果每个 <literal>Person</literal> 都拥"
"有一个延迟载入的 <literal>Cats</literal> 集合， 现在，<literal>Sesssion</"
"literal> 中载入了 10 个 person 对象，遍历 person 集合将会引起 10 次 "
"<literal>SELECT</literal> 查询，每次查询都会调用 <literal>getCats()</"
"literal> 方法。如果你在 <literal>Person</literal> 的映射定义部分，允许对 "
"<literal>cats</literal> 批量抓取，那么，Hibernate 将可以预先抓取整个集合。请"
"看例子： "

#. Tag: para
#, no-c-format
msgid ""
"With a <literal>batch-size</literal> of 3, Hibernate will load 3, 3, 3, 1 "
"collections in four <literal>SELECT</literal>s. Again, the value of the "
"attribute depends on the expected number of uninitialized collections in a "
"particular <literal>Session</literal>."
msgstr ""
"如果整个的 <literal>batch-size</literal> 是 3，那么 Hibernate 将会分四次执行 "
"<literal>SELECT</literal> 查询， 按照 3、3、3、1 的大小分别载入数据。这里的每"
"次载入的数据量还具体依赖于当前 <literal>Session</literal> 中未实例化集合的个"
"数。 "

#. Tag: para
#, no-c-format
msgid ""
"Batch fetching of collections is particularly useful if you have a nested "
"tree of items, i.e. the typical bill-of-materials pattern. However, a "
"<emphasis>nested set</emphasis> or a <emphasis>materialized path</emphasis> "
"might be a better option for read-mostly trees."
msgstr ""
"如果你的模型中有嵌套的树状结构，例如典型的帐单－原料结构（bill-of-materials "
"pattern），集合的批量抓取是非常有用的。（尽管在更多情况下对树进行读取时，"
"<emphasis>嵌套集合（nested set）</emphasis>或<emphasis>原料路径"
"（materialized path）</emphasis>可能是更好的解决方法。）"

#. Tag: title
#, no-c-format
msgid "Using subselect fetching"
msgstr "使用子查询抓取（Using subselect fetching）"

#. Tag: para
#, no-c-format
msgid ""
"If one lazy collection or single-valued proxy has to be fetched, Hibernate "
"will load all of them, re-running the original query in a subselect. This "
"works in the same way as batch-fetching but without the piecemeal loading."
msgstr ""
"假若一个延迟集合或单值代理需要抓取，Hibernate 会使用一个 subselect 重新运行原"
"来的查询，一次性读入所有的实例。这和批量抓取的实现方法是一样的，不会有破碎的"
"加载。 "

#. Tag: title
#, no-c-format
msgid "Fetch profiles"
msgstr "Fetch profile（抓取策略）"

#. Tag: para
#, no-c-format
msgid ""
"Another way to affect the fetching strategy for loading associated objects "
"is through something called a fetch profile, which is a named configuration "
"associated with the <interfacename>org.hibernate.SessionFactory</"
"interfacename> but enabled, by name, on the <interfacename>org.hibernate."
"Session</interfacename>. Once enabled on a <interfacename>org.hibernate."
"Session</interfacename>, the fetch profile wull be in affect for that "
"<interfacename>org.hibernate.Session</interfacename> until it is explicitly "
"disabled."
msgstr ""
"影响抓取加载相关对象的策略的另外一个方法是通过抓取配置（fetch profile），它是"
"和 <interfacename>org.hibernate.SessionFactory</interfacename> 相关的配置但"
"对 <interfacename>org.hibernate.Session</interfacename> 启用。一旦在 "
"<interfacename>org.hibernate.Session</interfacename> 上启用，抓取配置将对这"
"个 <interfacename>org.hibernate.Session</interfacename> 生效直至它被显性地禁"
"用。"

#. Tag: para
#, no-c-format
msgid ""
"So what does that mean? Well lets explain that by way of an example. Say we "
"have the following mappings:"
msgstr "这是什么意思呢？让我们通过一个例子进行解释。假设我们有下列映射："

#. Tag: para
#, no-c-format
msgid ""
"Now normally when you get a reference to a particular customer, that "
"customer's set of orders will be lazy meaning we will not yet have loaded "
"those orders from the database. Normally this is a good thing. Now lets say "
"that you have a certain use case where it is more efficient to load the "
"customer and their orders together. One way certainly is to use \"dynamic "
"fetching\" strategies via an HQL or criteria queries. But another option is "
"to use a fetch profile to achieve that. Just add the following to your "
"mapping:"
msgstr ""
"现在，当你获得某个特定客户的引用时，这个客户的订单将处于 lazy 状态，表示我们"
"暂不会从数据库里加载这些订单。这样通常没有问题。假设在某种情况下，加载客户及"
"其订单会更高效。其中一个办法当然是使用通过 HQL 或 Criteria 查询“动态抓取”的策"
"略。另外一个方法就是使用抓取配置（Fetch Profile）。你可以在映射里加入下面的内"
"容："

#. Tag: para
#, no-c-format
msgid "or even:"
msgstr "甚至："

#. Tag: para
#, no-c-format
msgid ""
"Now the following code will actually load both the customer <emphasis>and "
"their orders</emphasis>:"
msgstr "下面的代码将实际上加载客户<emphasis>以及</emphasis>订单："

#. Tag: para
#, no-c-format
msgid ""
"Currently only join style fetch profiles are supported, but they plan is to "
"support additional styles. See <ulink url=\"http://opensource.atlassian.com/"
"projects/hibernate/browse/HHH-3414\">HHH-3414</ulink> for details."
msgstr ""
"目前只有 join 风格的抓取策略被支持，但其他风格也将被支持。更多细节请参考 "
"<ulink url=\"http://opensource.atlassian.com/projects/hibernate/browse/HHH-"
"3414\">HHH-3414</ulink>。"

#. Tag: title
#, no-c-format
msgid "Using lazy property fetching"
msgstr "使用延迟属性抓取（Using lazy property fetching）"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate3 supports the lazy fetching of individual properties. This "
"optimization technique is also known as <emphasis>fetch groups</emphasis>. "
"Please note that this is mostly a marketing feature; optimizing row reads is "
"much more important than optimization of column reads. However, only loading "
"some properties of a class could be useful in extreme cases. For example, "
"when legacy tables have hundreds of columns and the data model cannot be "
"improved."
msgstr ""
"Hibernate3 对单独的属性支持延迟抓取，这项优化技术也被称为<emphasis>组抓取"
"（fetch groups）</emphasis>。 请注意，该技术更多的属于市场特性。在实际应用"
"中，优化行读取比优化列读取更重要。但是，仅载入类的部分属性在某些特定情况下会"
"有用，例如在原有表中拥有几百列数据、数据模型无法改动的情况下。 "

#. Tag: para
#, no-c-format
msgid ""
"To enable lazy property loading, set the <literal>lazy</literal> attribute "
"on your particular property mappings:"
msgstr ""
"可以在映射文件中对特定的属性设置 <literal>lazy</literal>，定义该属性为延迟载"
"入。"

#. Tag: para
#, no-c-format
msgid ""
"Lazy property loading requires buildtime bytecode instrumentation. If your "
"persistent classes are not enhanced, Hibernate will ignore lazy property "
"settings and return to immediate fetching."
msgstr ""
"属性的延迟载入要求在其代码构建时加入二进制指示指令（bytecode "
"instrumentation），如果你的持久类代码中未含有这些指令， Hibernate 将会忽略这"
"些属性的延迟设置，仍然将其直接载入。 "

#. Tag: para
#, no-c-format
msgid "For bytecode instrumentation, use the following Ant task:"
msgstr "你可以在 Ant 的 Task 中，进行如下定义，对持久类代码加入“二进制指令。”"

#. Tag: para
#, no-c-format
msgid ""
"A different way of avoiding unnecessary column reads, at least for read-only "
"transactions, is to use the projection features of HQL or Criteria queries. "
"This avoids the need for buildtime bytecode processing and is certainly a "
"preferred solution."
msgstr ""
"还有一种可以优化的方法，它使用 HQL 或条件查询的投影（projection）特性，可以避"
"免读取非必要的列， 这一点至少对只读事务是非常有用的。它无需在代码构建时“二进"
"制指令”处理，因此是一个更加值得选择的解决方法。 "

#. Tag: para
#, no-c-format
msgid ""
"You can force the usual eager fetching of properties using <literal>fetch "
"all properties</literal> in HQL."
msgstr ""
"有时你需要在 HQL 中通过<literal>抓取所有属性</literal>，强行抓取所有内容。 "

#. Tag: title
#, no-c-format
msgid "The Second Level Cache"
msgstr "二级缓存（The Second Level Cache）"

#. Tag: para
#, no-c-format
msgid ""
"A Hibernate <literal>Session</literal> is a transaction-level cache of "
"persistent data. It is possible to configure a cluster or JVM-level "
"(<literal>SessionFactory</literal>-level) cache on a class-by-class and "
"collection-by-collection basis. You can even plug in a clustered cache. Be "
"aware that caches are not aware of changes made to the persistent store by "
"another application. They can, however, be configured to regularly expire "
"cached data."
msgstr ""
"Hibernate 的 <literal>Session</literal> 在事务级别进行持久化数据的缓存操作。 "
"当然，也有可能分别为每个类（或集合），配置集群、或 JVM 级别"
"（<literal>SessionFactory 级别</literal>）的缓存。你甚至可以为之插入一个集群"
"的缓存。注意，缓存永远不知道其他应用程序对持久化仓库（数据库）可能进行的修改 "
"（即使可以将缓存数据设定为定期失效）。 "

#. Tag: para
#, no-c-format
msgid ""
"You have the option to tell Hibernate which caching implementation to use by "
"specifying the name of a class that implements <literal>org.hibernate.cache."
"CacheProvider</literal> using the property <literal>hibernate.cache."
"provider_class</literal>. Hibernate is bundled with a number of built-in "
"integrations with the open-source cache providers that are listed below. You "
"can also implement your own and plug it in as outlined above. Note that "
"versions prior to 3.2 use EhCache as the default cache provider."
msgstr ""
"通过在 <literal>hibernate.cache.provider_class</literal> 属性中指定  "
"<literal>org.hibernate.cache.CacheProvider</literal> 的某个实现的类名,你可以"
"选择让 Hibernate 使用哪个缓存实现。Hibernate 打包一些开源缓存实现，提供对它们"
"的内置支持（见下表）。除此之外，你也可以实现你自己的实现，将它们插入到系统"
"中。注意，在 3.2 版本之前，默认使用 EhCache 作为缓存实现，但从 3.2 起就不再这"
"样了。 "

#. Tag: title
#, no-c-format
msgid "Cache Providers"
msgstr "缓存策略提供商（Cache Providers）"

#. Tag: entry
#, no-c-format
msgid "Cache"
msgstr "Cache"

#. Tag: entry
#, no-c-format
msgid "Provider class"
msgstr "Provider class"

#. Tag: entry
#, no-c-format
msgid "Type"
msgstr "Type"

#. Tag: entry
#, no-c-format
msgid "Cluster Safe"
msgstr "Cluster Safe"

#. Tag: entry
#, no-c-format
msgid "Query Cache Supported"
msgstr "Query Cache Supported"

#. Tag: entry
#, no-c-format
msgid "Hashtable (not intended for production use)"
msgstr "Hashtable （not intended for production use）"

#. Tag: entry
#, no-c-format
msgid "<literal>org.hibernate.cache.HashtableCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.HashtableCacheProvider</literal> "

#. Tag: entry
#, no-c-format
msgid "memory"
msgstr "memory"

#. Tag: entry
#, no-c-format
msgid "yes"
msgstr "yes"

#. Tag: entry
#, no-c-format
msgid "EHCache"
msgstr "EHCache"

#. Tag: entry
#, no-c-format
msgid "<literal>org.hibernate.cache.EhCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.EhCacheProvider</literal> "

#. Tag: entry
#, no-c-format
msgid "memory, disk"
msgstr "memory，disk"

#. Tag: entry
#, no-c-format
msgid "OSCache"
msgstr "OSCache"

#. Tag: entry
#, no-c-format
msgid "<literal>org.hibernate.cache.OSCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.OSCacheProvider</literal> "

#. Tag: entry
#, no-c-format
msgid "SwarmCache"
msgstr "SwarmCache"

#. Tag: entry
#, no-c-format
msgid "<literal>org.hibernate.cache.SwarmCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.SwarmCacheProvider</literal>"

#. Tag: entry
#, no-c-format
msgid "clustered (ip multicast)"
msgstr "clustered (ip multicast)"

#. Tag: entry
#, no-c-format
msgid "yes (clustered invalidation)"
msgstr "yes (clustered invalidation)"

#. Tag: entry
#, no-c-format
msgid "JBoss Cache 1.x"
msgstr "JBoss Cache 1.x"

#. Tag: entry
#, no-c-format
msgid "<literal>org.hibernate.cache.TreeCacheProvider</literal>"
msgstr "<literal>org.hibernate.cache.TreeCacheProvider</literal> "

#. Tag: entry
#, no-c-format
msgid "clustered (ip multicast), transactional"
msgstr "clustered (ip multicast), transactional"

#. Tag: entry
#, no-c-format
msgid "yes (replication)"
msgstr "yes (replication)"

#. Tag: entry
#, no-c-format
msgid "yes (clock sync req.)"
msgstr "yes (clock sync req.)"

#. Tag: entry
#, no-c-format
msgid "JBoss Cache 2"
msgstr "JBoss Cache 2"

#. Tag: entry
#, no-c-format
msgid "<literal>org.hibernate.cache.jbc.JBossCacheRegionFactory</literal>"
msgstr "<literal>org.hibernate.cache.jbc.JBossCacheRegionFactory</literal>"

#. Tag: entry
#, no-c-format
msgid "yes (replication or invalidation)"
msgstr "yes (replication or invalidation)"

#. Tag: title
#, no-c-format
msgid "Cache mappings"
msgstr "缓存映射（Cache mappings）"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>&lt;cache&gt;</literal> element of a class or collection "
"mapping has the following form:"
msgstr ""
"类或者集合映射的“<literal>&lt;cache&gt;</literal> 元素”可以有下列形式："

#. Tag: para
#, no-c-format
msgid ""
"<literal>usage</literal> (required) specifies the caching strategy: "
"<literal>transactional</literal>, <literal>read-write</literal>, "
"<literal>nonstrict-read-write</literal> or <literal>read-only</literal>"
msgstr ""
"<literal>usage</literal>（必须）说明了缓存的策略：<literal>transactional</"
"literal>、 <literal>read-write</literal>、<literal>nonstrict-read-write</"
"literal> 或 <literal>read-only</literal>。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>region</literal> (optional: defaults to the class or collection "
"role name): specifies the name of the second level cache region"
msgstr ""
"<literal>region</literal> （可选，默认为类或者集合的名字（class or "
"collection role name）） 指定第二级缓存的区域名（name of the second level "
"cache region） "

#. Tag: para
#, no-c-format
msgid ""
"<literal>include</literal> (optional: defaults to <literal>all</literal>) "
"<literal>non-lazy</literal>: specifies that properties of the entity mapped "
"with <literal>lazy=\"true\"</literal> cannot be cached when attribute-level "
"lazy fetching is enabled"
msgstr ""
"<literal>include</literal>（可选,默认为 <literal>all</literal>） "
"<literal>non-lazy</literal> 当属性级延迟抓取打开时，标记为 <literal>lazy="
"\"true\"</literal> 的实体的属性可能无法被缓存 "

#. Tag: para
#, no-c-format
msgid ""
"Alternatively, you can specify <literal>&lt;class-cache&gt;</literal> and "
"<literal>&lt;collection-cache&gt;</literal> elements in <literal>hibernate."
"cfg.xml</literal>."
msgstr ""
"另外（首选?），你可以在<literal>hibernate.cfg.xml</literal> 中指定 "
"<literal>&lt;class-cache&gt;</literal> 和 <literal>&lt;collection-cache&gt;</"
"literal> 元素。"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>usage</literal> attribute specifies a <emphasis>cache "
"concurrency strategy</emphasis>."
msgstr ""
"这里的 <literal>usage</literal> 属性指明了<emphasis>缓存并发策略（cache "
"concurrency strategy）</emphasis>。"

#. Tag: title
#, no-c-format
msgid "Strategy: read only"
msgstr "策略：只读缓存（Strategy：read only）"

#. Tag: para
#, no-c-format
msgid ""
"If your application needs to read, but not modify, instances of a persistent "
"class, a <literal>read-only</literal> cache can be used. This is the "
"simplest and optimal performing strategy. It is even safe for use in a "
"cluster."
msgstr ""
"如果你的应用程序只需读取一个持久化类的实例，而无需对其修改， 那么就可以对其进"
"行<literal>只读</literal> 缓存。这是最简单，也是实用性最好的方法。甚至在集群"
"中，它也能完美地运作。 "

#. Tag: title
#, no-c-format
msgid "Strategy: read/write"
msgstr "策略：读写/缓存（Strategy：read/write）"

#. Tag: para
#, no-c-format
msgid ""
"If the application needs to update data, a <literal>read-write</literal> "
"cache might be appropriate. This cache strategy should never be used if "
"serializable transaction isolation level is required. If the cache is used "
"in a JTA environment, you must specify the property <literal>hibernate."
"transaction.manager_lookup_class</literal> and naming a strategy for "
"obtaining the JTA <literal>TransactionManager</literal>. In other "
"environments, you should ensure that the transaction is completed when "
"<literal>Session.close()</literal> or <literal>Session.disconnect()</"
"literal> is called. If you want to use this strategy in a cluster, you "
"should ensure that the underlying cache implementation supports locking. The "
"built-in cache providers <emphasis>do not</emphasis> support locking."
msgstr ""
"如果应用程序需要更新数据，那么使用<literal>读/写缓存</literal> 比较合适。 如"
"果应用程序要求“序列化事务”的隔离级别（serializable transaction isolation "
"level），那么就决不能使用这种缓存策略。 如果在 JTA 环境中使用缓存，你必须指"
"定 <literal>hibernate.transaction.manager_lookup_class</literal> 属性的值， "
"通过它，Hibernate 才能知道该应用程序中 JTA 的<literal>TransactionManager</"
"literal>的具体策略。 在其它环境中，你必须保证在 <literal>Session.close()</"
"literal>、或 <literal>Session.disconnect()</literal> 调用前， 整个事务已经结"
"束。 如果你想在集群环境中使用此策略，你必须保证底层的缓存实现支持锁定"
"（locking）。Hibernate 内置的缓存策略并不支持锁定功能。 "

#. Tag: title
#, no-c-format
msgid "Strategy: nonstrict read/write"
msgstr "策略：非严格读/写缓存（Strategy：nonstrict read/write）"

#. Tag: para
#, no-c-format
msgid ""
"If the application only occasionally needs to update data (i.e. if it is "
"extremely unlikely that two transactions would try to update the same item "
"simultaneously), and strict transaction isolation is not required, a "
"<literal>nonstrict-read-write</literal> cache might be appropriate. If the "
"cache is used in a JTA environment, you must specify <literal>hibernate."
"transaction.manager_lookup_class</literal>. In other environments, you "
"should ensure that the transaction is completed when <literal>Session.close()"
"</literal> or <literal>Session.disconnect()</literal> is called."
msgstr ""
"如果应用程序只偶尔需要更新数据（也就是说，两个事务同时更新同一记录的情况很不"
"常见），也不需要十分严格的事务隔离，那么比较适合使用<literal>非严格读/写缓存"
"</literal>策略。如果在 JTA 环境中使用该策略，你必须为其指定 "
"<literal>hibernate.transaction.manager_lookup_class</literal> 属性的值，在其"
"它环境中，你必须保证在<literal>Session.close()</literal>、或 "
"<literal>Session.disconnect()</literal> 调用前，整个事务已经结束。 "

#. Tag: title
#, no-c-format
msgid "Strategy: transactional"
msgstr "策略：事务缓存（transactional）"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>transactional</literal> cache strategy provides support for "
"fully transactional cache providers such as JBoss TreeCache. Such a cache "
"can only be used in a JTA environment and you must specify "
"<literal>hibernate.transaction.manager_lookup_class</literal>."
msgstr ""
"Hibernate 的<literal>事务缓存</literal>策略提供了全事务的缓存支持，例如对 "
"JBoss TreeCache 的支持。这样的缓存只能用于 JTA 环境中，你必须指定为其  "
"<literal>hibernate.transaction.manager_lookup_class</literal> 属性。 "

#. Tag: title
#, no-c-format
msgid "Cache-provider/concurrency-strategy compatibility"
msgstr "各种缓存提供商/缓存并发策略的兼容性"

#. Tag: para
#, no-c-format
msgid ""
"None of the cache providers support all of the cache concurrency strategies."
msgstr ""
"没有一种缓存提供商能够支持上列的所有缓存并发策略。下表中列出了各种提供器、及"
"其各自适用的并发策略。 "

#. Tag: para
#, no-c-format
msgid ""
"The following table shows which providers are compatible with which "
"concurrency strategies."
msgstr ""
"没有一种缓存提供商能够支持上列的所有缓存并发策略。下表中列出了各种提供器、及"
"其各自适用的并发策略。 "

#. Tag: title
#, no-c-format
msgid "Cache Concurrency Strategy Support"
msgstr ""
"各种缓存提供商对缓存并发策略的支持情况（Cache Concurrency Strategy Support）"

#. Tag: entry
#, no-c-format
msgid "read-only"
msgstr "read-only"

#. Tag: entry
#, no-c-format
msgid "nonstrict-read-write"
msgstr "nonstrict-read-write"

#. Tag: entry
#, no-c-format
msgid "read-write"
msgstr "read-write"

#. Tag: entry
#, no-c-format
msgid "transactional"
msgstr "transactional"

#. Tag: title
#, no-c-format
msgid "Managing the caches"
msgstr "管理缓存（Managing the caches）"

#. Tag: para
#, no-c-format
msgid ""
"Whenever you pass an object to <literal>save()</literal>, <literal>update()</"
"literal> or <literal>saveOrUpdate()</literal>, and whenever you retrieve an "
"object using <literal>load()</literal>, <literal>get()</literal>, "
"<literal>list()</literal>, <literal>iterate()</literal> or <literal>scroll()"
"</literal>, that object is added to the internal cache of the "
"<literal>Session</literal>."
msgstr ""
"无论何时，当你给 <literal>save()</literal>、<literal>update()</literal> 或  "
"<literal>saveOrUpdate()</literal> 方法传递一个对象时，或使用 <literal>load()"
"</literal>、<literal>get()</literal>、<literal>list()</literal>、"
"<literal>iterate()</literal> 或 <literal>scroll()</literal> 方法获得一个对象"
"时，该对象都将被加入到 <literal>Session</literal> 的内部缓存中。 "

#. Tag: para
#, no-c-format
msgid ""
"When <literal>flush()</literal> is subsequently called, the state of that "
"object will be synchronized with the database. If you do not want this "
"synchronization to occur, or if you are processing a huge number of objects "
"and need to manage memory efficiently, the <literal>evict()</literal> method "
"can be used to remove the object and its collections from the first-level "
"cache."
msgstr ""
"当随后 flush() 方法被调用时，对象的状态会和数据库取得同步。如果你不希望此同步"
"操作发生，或者你正处理大量对象、需要对有效管理内存时，你可以调用 "
"<literal>evict()</literal> 方法，从一级缓存中去掉这些对象及其集合。 "

#. Tag: para
#, no-c-format
msgid ""
"The <literal>Session</literal> also provides a <literal>contains()</literal> "
"method to determine if an instance belongs to the session cache."
msgstr ""
"Session 还提供了一个 <literal>contains()</literal> 方法，用来判断某个实例是否"
"处于当前 session 的缓存中。"

#. Tag: para
#, no-c-format
msgid ""
"To evict all objects from the session cache, call <literal>Session.clear()</"
"literal>"
msgstr ""
"如若要把所有的对象从 session 缓存中彻底清除，则需要调用 <literal>Session."
"clear()</literal>。 "

#. Tag: para
#, no-c-format
msgid ""
"For the second-level cache, there are methods defined on "
"<literal>SessionFactory</literal> for evicting the cached state of an "
"instance, entire class, collection instance or entire collection role."
msgstr ""
"对于二级缓存来说，在 <literal>SessionFactory</literal> 中定义了许多方法，清除"
"缓存中实例、整个类、集合实例或者整个集合。"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>CacheMode</literal> controls how a particular session interacts "
"with the second-level cache:"
msgstr ""
"<literal>CacheMode</literal> 参数用于控制具体的 Session 如何与二级缓存进行交"
"互。 "

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.NORMAL</literal>: will read items from and write items to "
"the second-level cache"
msgstr "<literal>CacheMode.NORMAL</literal>：从二级缓存中读、写数据。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.GET</literal>: will read items from the second-level "
"cache. Do not write to the second-level cache except when updating data"
msgstr ""
"<literal>CacheMode.GET</literal>：从二级缓存中读取数据，仅在数据更新时对二级"
"缓存写数据。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.PUT</literal>: will write items to the second-level "
"cache. Do not read from the second-level cache"
msgstr ""
"<literal>CacheMode.PUT</literal>：仅向二级缓存写数据，但不从二级缓存中读数"
"据。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>CacheMode.REFRESH</literal>: will write items to the second-level "
"cache. Do not read from the second-level cache. Bypass the effect of "
"<literal>hibernate.cache.use_minimal_puts</literal> forcing a refresh of the "
"second-level cache for all items read from the database"
msgstr ""
"<literal>CacheMode.REFRESH</literal>：仅向二级缓存写数据，但不从二级缓存中读"
"数据。通过 <literal>hibernate.cache.use_minimal_puts</literal> 的设置，强制二"
"级缓存从数据库中读取数据，刷新缓存内容。"

#. Tag: para
#, no-c-format
msgid ""
"To browse the contents of a second-level or query cache region, use the "
"<literal>Statistics</literal> API:"
msgstr ""
"如若需要查看二级缓存或查询缓存区域的内容，你可以使用<literal>统计"
"（Statistics）</literal> API。"

#. Tag: para
#, no-c-format
msgid ""
"You will need to enable statistics and, optionally, force Hibernate to keep "
"the cache entries in a more readable format:"
msgstr ""
"此时，你必须手工打开统计选项。可选的，你可以让 Hibernate 更人工可读的方式维护"
"缓存内容。 "

#. Tag: title
#, no-c-format
msgid "The Query Cache"
msgstr "查询缓存（The Query Cache）"

#. Tag: para
#, no-c-format
msgid ""
"Query result sets can also be cached. This is only useful for queries that "
"are run frequently with the same parameters."
msgstr ""
"查询的结果集也可以被缓存。只有当经常使用同样的参数进行查询时，这才会有些用"
"处。"

#. Tag: title
#, no-c-format
msgid "Enabling query caching"
msgstr "启用查询缓存"

#. Tag: para
#, no-c-format
msgid ""
"Caching of query results introduces some overhead in terms of your "
"applications normal transactional processing. For example, if you cache "
"results of a query against Person Hibernate will need to keep track of when "
"those results should be invalidated because changes have been committed "
"against Person. That, coupled with the fact that most applications simply "
"gain no benefit from caching query results, leads Hibernate to disable "
"caching of query results by default. To use query caching, you will first "
"need to enable the query cache:"
msgstr ""
"按照应用程序的事务性处理过程，查询结果的缓存将产生一些负荷。例如，如果缓存针"
"对 Person 的查询结果，在 Person 发生了修改时，Hibernate 将需要跟踪这些结果什"
"么时候失效。因为大多数应用程序不会从缓存查询结果中受益，所以 Hibernate 在缺省"
"情况下将禁用缓存。要使用查询缓存，你首先需要启用查询缓存："

#. Tag: para
#, no-c-format
msgid "This setting creates two new cache regions:"
msgstr "这个设置创建了两个新的缓存 region："

#. Tag: para
#, no-c-format
msgid ""
"<classname>org.hibernate.cache.StandardQueryCache</classname>, holding the "
"cached query results"
msgstr ""
"<classname>org.hibernate.cache.StandardQueryCache</classname>，保存缓存的查询"
"结果"

#. Tag: para
#, no-c-format
msgid ""
"<classname>org.hibernate.cache.UpdateTimestampsCache</classname>, holding "
"timestamps of the most recent updates to queryable tables. These are used to "
"validate the results as they are served from the query cache."
msgstr ""
"<classname>org.hibernate.cache.UpdateTimestampsCache</classname>，保存对可查"
"询表的最近更新的时间戳。它们用于检验查询结果。"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you configure your underlying cache implementation to use expiry or "
"timeouts is is very important that the cache timeout of the underlying cache "
"region for the UpdateTimestampsCache be set to a higher value than the "
"timeouts of any of the query caches. In fact, we recommend that the the "
"UpdateTimestampsCache region not be configured for expiry at all. Note, in "
"particular, that an LRU cache expiry policy is never appropriate."
msgstr ""
"如果你配置底层缓存实现来使用过期（expiry）或超时（timeout），把用于 "
"UpdateTimestampsCache 的底层缓存 region 的缓存超时时间设置为比任何查询缓存的"
"超时时间更长的值是非常重要的。事实上，我们推荐根本不把 UpdateTimestampsCache "
"region 用于 expiry。请注意，特别是 LRU 缓存 expiry 策略总是不合适的。"

#. Tag: para
#, no-c-format
msgid ""
"As mentioned above, most queries do not benefit from caching or their "
"results. So by default, individual queries are not cached even after "
"enabling query caching. To enable results caching for a particular query, "
"call <literal>org.hibernate.Query.setCacheable(true)</literal>. This call "
"allows the query to look for existing cache results or add its results to "
"the cache when it is executed."
msgstr ""
"如上面所提及的，绝大多数的查询并不能从查询缓存中受益，所以 Hibernate 默认是不"
"进行查询缓存的。如若需要进行缓存，请调用 <literal>org.hibernate.Query."
"setCacheable（true）</literal>方法。这个调用会让查询在执行过程中时先从缓存中"
"查找结果，并将自己的结果集放到缓存中去。 "

#. Tag: para
#, no-c-format
msgid ""
"The query cache does not cache the state of the actual entities in the "
"cache; it caches only identifier values and results of value type. For this "
"reaso, the query cache should always be used in conjunction with the second-"
"level cache for those entities expected to be cached as part of a query "
"result cache (just as with collection caching)."
msgstr ""
"查询缓存不会缓存缓存中实际实体的状态；它只缓存标识符值和值类型的结果。出于这"
"个原因，对于那些作为查询结果缓存的一部分（和集合缓存一样）进行缓存的实体，查"
"询缓存应该和二级缓存一起使用。"

#. Tag: title
#, no-c-format
msgid "Query cache regions"
msgstr "查询缓存区"

#. Tag: para
#, no-c-format
msgid ""
"If you require fine-grained control over query cache expiration policies, "
"you can specify a named cache region for a particular query by calling "
"<literal>Query.setCacheRegion()</literal>."
msgstr ""
"如果你要对查询缓存的失效政策进行精确的控制，你必须调用 <literal>Query."
"setCacheRegion()</literal> 方法，为每个查询指定其命名的缓存区域。 "

#. Tag: para
#, no-c-format
msgid ""
"If you want to force the query cache to refresh one of its regions "
"(disregard any cached results it finds there) you can use <literal>org."
"hibernate.Query.setCacheMode(CacheMode.REFRESH)</literal>. In conjunction "
"with the region you have defined for the given query, Hibernate will "
"selectively force the results cached in that particular region to be "
"refreshed. This is particularly useful in cases where underlying data may "
"have been updated via a separate process and is a far more efficient "
"alternative to bulk eviction of the region via <literal>org.hibernate."
"SessionFactory.evictQueries()</literal>."
msgstr ""
"如果查询需要强行刷新其查询缓存区域，那么你应该调用 <literal>org.hibernate."
"Query.setCacheMode（CacheMode.REFRESH）</literal>方法。 这对在其他进程中修改"
"底层数据（例如，不通过Hibernate修改数据），或对那些需要选择性更新特定查询结果"
"集的情况特别有用。这是对 <literal>org.hibernate.SessionFactory.evictQueries()"
"</literal> 的更为有效的替代方案，同样可以清除查询缓存区域。"

#. Tag: title
#, no-c-format
msgid "Understanding Collection performance"
msgstr "理解集合性能（Understanding Collection performance）"

#. Tag: para
#, no-c-format
msgid ""
"In the previous sections we have covered collections and their applications. "
"In this section we explore some more issues in relation to collections at "
"runtime."
msgstr ""
"在前面的章节里我们已经讨论了集合和相关应用程序。在本节我么将探索运行时集合的"
"更多问题。"

#. Tag: title
#, no-c-format
msgid "Taxonomy"
msgstr "分类（Taxonomy）"

#. Tag: para
#, no-c-format
msgid "Hibernate defines three basic kinds of collections:"
msgstr "Hibernate 定义了三种基本类型的集合："

#. Tag: para
#, no-c-format
msgid "collections of values"
msgstr "值数据集合"

#. Tag: para
#, no-c-format
msgid "one-to-many associations"
msgstr "一对多关联（One-to-many Associations） "

#. Tag: para
#, no-c-format
msgid "many-to-many associations"
msgstr "多对多关联 "

#. Tag: para
#, no-c-format
msgid ""
"This classification distinguishes the various table and foreign key "
"relationships but does not tell us quite everything we need to know about "
"the relational model. To fully understand the relational structure and "
"performance characteristics, we must also consider the structure of the "
"primary key that is used by Hibernate to update or delete collection rows. "
"This suggests the following classification:"
msgstr ""
"这个分类是区分了不同的表和外键关系类型，但是它没有告诉我们关系模型的所有内"
"容。 要完全理解他们的关系结构和性能特点，我们必须同时考虑“用于 Hibernate 更新"
"或删除集合行数据的主键的结构”。因此得到了如下的分类："

#. Tag: para
#, no-c-format
msgid "indexed collections"
msgstr "有序集合类"

#. Tag: para
#, no-c-format
msgid "sets"
msgstr "集合（sets）"

#. Tag: para
#, no-c-format
msgid "bags"
msgstr "包（bags）"

#. Tag: para
#, no-c-format
msgid ""
"All indexed collections (maps, lists, and arrays) have a primary key "
"consisting of the <literal>&lt;key&gt;</literal> and <literal>&lt;index&gt;</"
"literal> columns. In this case, collection updates are extremely efficient. "
"The primary key can be efficiently indexed and a particular row can be "
"efficiently located when Hibernate tries to update or delete it."
msgstr ""
"所有的有序集合类（maps，lists，arrays）都拥有一个由 <literal>&lt;key&gt;</"
"literal> 和 <literal>&lt;index&gt;</literal> 组成的主键。这种情况下集合类的更"
"新是非常高效的 — 主键已经被有效的索引，因此当 Hibernate 试图更新或删除一行"
"时，可以迅速找到该行数据。 "

#. Tag: para
#, no-c-format
msgid ""
"Sets have a primary key consisting of <literal>&lt;key&gt;</literal> and "
"element columns. This can be less efficient for some types of collection "
"element, particularly composite elements or large text or binary fields, as "
"the database may not be able to index a complex primary key as efficiently. "
"However, for one-to-many or many-to-many associations, particularly in the "
"case of synthetic identifiers, it is likely to be just as efficient. If you "
"want <literal>SchemaExport</literal> to actually create the primary key of a "
"<literal>&lt;set&gt;</literal>, you must declare all columns as <literal>not-"
"null=\"true\"</literal>."
msgstr ""
"集合（sets）的主键由 <literal>&lt;key&gt;</literal> 和其他元素字段构成。对于"
"有些元素类型来说，这很低效，特别是组合元素或者大文本、大二进制字段；数据库可"
"能无法有效的对复杂的主键进行索引。另一方面，对于一对多、多对多关联，特别是合"
"成的标识符来说，集合也可以达到同样的高效性能。（ 附注：如果你希望 "
"<literal>SchemaExport</literal> 为你的 <literal>&lt;set&gt;</literal> 创建主"
"键，你必须把所有的字段都声明为 <literal>not-null=\"true\"</literal>。） "

#. Tag: para
#, no-c-format
msgid ""
"<literal>&lt;idbag&gt;</literal> mappings define a surrogate key, so they "
"are efficient to update. In fact, they are the best case."
msgstr ""
"<literal>&lt;idbag&gt;</literal> 映射定义了代理键，因此它总是可以很高效的被更"
"新。事实上，<literal>&lt;idbag&gt;</literal> 拥有着最好的性能表现。 "

#. Tag: para
#, no-c-format
msgid ""
"Bags are the worst case since they permit duplicate element values and, as "
"they have no index column, no primary key can be defined. Hibernate has no "
"way of distinguishing between duplicate rows. Hibernate resolves this "
"problem by completely removing in a single <literal>DELETE</literal> and "
"recreating the collection whenever it changes. This can be inefficient."
msgstr ""
"Bag 是最差的。因为 bag 允许重复的元素值，也没有索引字段，因此不可能定义主"
"键。 Hibernate 无法判断出重复的行。当这种集合被更改时，Hibernate 将会先完整地"
"移除 （通过一个（in a single <literal>DELETE</literal>））整个集合，然后再重"
"新创建整个集合。因此 Bag 是非常低效的。 "

#. Tag: para
#, no-c-format
msgid ""
"For a one-to-many association, the \"primary key\" may not be the physical "
"primary key of the database table. Even in this case, the above "
"classification is still useful. It reflects how Hibernate \"locates\" "
"individual rows of the collection."
msgstr ""
"请注意：对于一对多关联来说，“主键”很可能并不是数据库表的物理主键。但就算在此"
"情况下，上面的分类仍然是有用的。（它仍然反映了 Hibernate 在集合的各数据行中是"
"如何进行“定位”的。） "

#. Tag: title
#, no-c-format
msgid ""
"Lists, maps, idbags and sets are the most efficient collections to update"
msgstr "Lists，maps 和 sets 用于更新效率最高"

#. Tag: para
#, no-c-format
msgid ""
"From the discussion above, it should be clear that indexed collections and "
"sets allow the most efficient operation in terms of adding, removing and "
"updating elements."
msgstr ""
"根据我们上面的讨论，显然有序集合类型和大多数 set 都可以在增加、删除、修改元素"
"中拥有最好的性能。 "

#. Tag: para
#, no-c-format
msgid ""
"There is, arguably, one more advantage that indexed collections have over "
"sets for many-to-many associations or collections of values. Because of the "
"structure of a <literal>Set</literal>, Hibernate does not <literal>UPDATE</"
"literal> a row when an element is \"changed\". Changes to a <literal>Set</"
"literal> always work via <literal>INSERT</literal> and <literal>DELETE</"
"literal> of individual rows. Once again, this consideration does not apply "
"to one-to-many associations."
msgstr ""
"可论证的是对于多对多关联、值数据集合而言，有序集合类比集合（set）有一个好处。"
"因为 <literal>Set</literal> 的内在结构， 如果“改变”了一个元素，Hibernate 并不"
"会<literal>更新（UPDATE）</literal>这一行。对于 <literal>Set</literal> 来说，"
"只有在<literal>插入（INSERT）</literal>和<literal>删除（DELETE）</literal> 操"
"作时“改变”才有效。再次强调：这段讨论对“一对多关联”并不适用。 "

#. Tag: para
#, no-c-format
msgid ""
"After observing that arrays cannot be lazy, you can conclude that lists, "
"maps and idbags are the most performant (non-inverse) collection types, with "
"sets not far behind. You can expect sets to be the most common kind of "
"collection in Hibernate applications. This is because the \"set\" semantics "
"are most natural in the relational model."
msgstr ""
"注意到数组无法延迟载入，我们可以得出结论，list，map 和 idbags 是最高效的（非"
"反向）集合类型，set 则紧随其后。 在 Hibernate 中，set 应该时最通用的集合类"
"型，这时因为“set”的语义在关系模型中是最自然的。 "

#. Tag: para
#, no-c-format
msgid ""
"However, in well-designed Hibernate domain models, most collections are in "
"fact one-to-many associations with <literal>inverse=\"true\"</literal>. For "
"these associations, the update is handled by the many-to-one end of the "
"association, and so considerations of collection update performance simply "
"do not apply."
msgstr ""
"但是，在设计良好的 Hibernate 领域模型中，我们通常可以看到更多的集合事实上是带"
"有  <literal>inverse=\"true\"</literal> 的一对多的关联。对于这些关联，更新操"
"作将会在多对一的这一端进行处理。因此对于此类情况，无需考虑其集合的更新性能。 "

#. Tag: title
#, no-c-format
msgid "Bags and lists are the most efficient inverse collections"
msgstr "Bag 和 list 是反向集合类中效率最高的"

#. Tag: para
#, no-c-format
msgid ""
"There is a particular case, however, in which bags, and also lists, are much "
"more performant than sets. For a collection with <literal>inverse=\"true\"</"
"literal>, the standard bidirectional one-to-many relationship idiom, for "
"example, we can add elements to a bag or list without needing to initialize "
"(fetch) the bag elements. This is because, unlike a <literal>set</literal>, "
"<literal>Collection.add()</literal> or <literal>Collection.addAll()</"
"literal> must always return true for a bag or <literal>List</literal>. This "
"can make the following common code much faster:"
msgstr ""
"在把 bag 扔进水沟之前，你必须了解，在一种情况下，bag 的性能（包括list）要比 "
"set 高得多：对于指明了 <literal>inverse=\"true\"</literal> 的集合类（比如说，"
"标准的双向的一对多关联），我们可以在未初始化（fetch）包元素的情况下直接向 "
"bag 或 list 添加新元素！ 这是因为 <literal>Collection.add()</literal>）或者 "
"<literal>Collection.addAll()</literal> 方法对 bag 或者 List 总是返回 true（这"
"点与与 Set 不同）。因此对于下面的相同代码来说，速度会快得多。 "

#. Tag: title
#, no-c-format
msgid "One shot delete"
msgstr "一次性删除（One shot delete）"

#. Tag: para
#, no-c-format
msgid ""
"Deleting collection elements one by one can sometimes be extremely "
"inefficient. Hibernate knows not to do that in the case of an newly-empty "
"collection (if you called <literal>list.clear()</literal>, for example). In "
"this case, Hibernate will issue a single <literal>DELETE</literal>."
msgstr ""
"偶尔的，逐个删除集合类中的元素是相当低效的。Hibernate 并没那么笨，如果你想要"
"把整个集合都删除（比如说调用 list.clear()），Hibernate 只需要一个 DELETE 就搞"
"定了。 "

#. Tag: para
#, no-c-format
msgid ""
"Suppose you added a single element to a collection of size twenty and then "
"remove two elements. Hibernate will issue one <literal>INSERT</literal> "
"statement and two <literal>DELETE</literal> statements, unless the "
"collection is a bag. This is certainly desirable."
msgstr ""
"假设我们在一个长度为20的集合类中新增加了一个元素，然后再删除两个。Hibernate "
"会安排一条 <literal>INSERT</literal> 语句和两条 <literal>DELETE</literal> 语"
"句（除非集合类是一个 bag）。这当然是令人满意的。 "

#. Tag: para
#, no-c-format
msgid ""
"However, suppose that we remove eighteen elements, leaving two and then add "
"thee new elements. There are two possible ways to proceed"
msgstr ""
"但是，假设我们删除了 18 个数据，只剩下 2 个，然后新增 3 个。则有两种处理方"
"式："

#. Tag: para
#, no-c-format
msgid "delete eighteen rows one by one and then insert three rows"
msgstr "逐一的删除这 18 个数据，再新增三个；"

#. Tag: para
#, no-c-format
msgid ""
"remove the whole collection in one SQL <literal>DELETE</literal> and insert "
"all five current elements one by one"
msgstr "删除整个集合类（只用一句 DELETE 语句），然后逐一添加 5 个数据。"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate cannot know that the second option is probably quicker. It would "
"probably be undesirable for Hibernate to be that intuitive as such behavior "
"might confuse database triggers, etc."
msgstr ""
"Hibernate 还没那么聪明，知道第二种选择可能会比较快。（也许让 Hibernate 不这么"
"聪明也是好事，否则可能会引发意外的“数据库触发器”之类的问题。）"

#. Tag: para
#, no-c-format
msgid ""
"Fortunately, you can force this behavior (i.e. the second strategy) at any "
"time by discarding (i.e. dereferencing) the original collection and "
"returning a newly instantiated collection with all the current elements."
msgstr ""
"幸运的是，你可以强制使用第二种策略。你需要取消原来的整个集合类（解除其引"
"用），然后再返回一个新的实例化的集合类，只包含需要的元素。有些时候这是非常有"
"用的。 "

#. Tag: para
#, no-c-format
msgid ""
"One-shot-delete does not apply to collections mapped <literal>inverse=\"true"
"\"</literal>."
msgstr ""
"显然，一次性删除并不适用于被映射为 <literal>inverse=\"true\"</literal> 的集"
"合。 "

#. Tag: title
#, no-c-format
msgid "Monitoring performance"
msgstr "监测性能（Monitoring performance）"

#. Tag: para
#, no-c-format
msgid ""
"Optimization is not much use without monitoring and access to performance "
"numbers. Hibernate provides a full range of figures about its internal "
"operations. Statistics in Hibernate are available per "
"<literal>SessionFactory</literal>."
msgstr ""
"没有监测和性能参数而进行优化是毫无意义的。Hibernate 为其内部操作提供了一系列"
"的示意图，因此可以从 每个 <literal>SessionFactory</literal> 抓取其统计数据。"

#. Tag: title
#, no-c-format
msgid "Monitoring a SessionFactory"
msgstr "监测 SessionFactory"

#. Tag: para
#, no-c-format
msgid ""
"You can access <literal>SessionFactory</literal> metrics in two ways. Your "
"first option is to call <literal>sessionFactory.getStatistics()</literal> "
"and read or display the <literal>Statistics</literal> yourself."
msgstr ""
"你可以有两种方式访问 <literal>SessionFactory</literal> 的数据记录，第一种就是"
"自己直接调用 <literal>sessionFactory.getStatistics()</literal> 方法读取、显示"
"<literal>统计</literal>数据。"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate can also use JMX to publish metrics if you enable the "
"<literal>StatisticsService</literal> MBean. You can enable a single MBean "
"for all your <literal>SessionFactory</literal> or one per factory. See the "
"following code for minimalistic configuration examples:"
msgstr ""
"此外，如果你打开 <literal>StatisticsService</literal> MBean 选项，那么 "
"Hibernate 则可以使用 JMX 技术 发布其数据记录。你可以让应用中所有的 "
"<literal>SessionFactory</literal> 同时共享一个 MBean，也可以每个 "
"SessionFactory 分配一个 MBean。下面的代码即是其演示代码： "

#. Tag: para
#, no-c-format
msgid ""
"You can activate and deactivate the monitoring for a "
"<literal>SessionFactory</literal>:"
msgstr ""
"你可以通过以下方法打开或关闭 <literal>SessionFactory</literal> 的监测功能： "

#. Tag: para
#, no-c-format
msgid ""
"at configuration time, set <literal>hibernate.generate_statistics</literal> "
"to <literal>false</literal>"
msgstr ""
"在配置期间，将 <literal>hibernate.generate_statistics</literal> 设置为 "
"<literal>true</literal> 或 <literal>false</literal>；"

#. Tag: para
#, no-c-format
msgid ""
"at runtime: <literal>sf.getStatistics().setStatisticsEnabled(true)</literal> "
"or <literal>hibernateStatsBean.setStatisticsEnabled(true)</literal>"
msgstr ""
"在运行期间，则可以可以通过 <literal>sf.getStatistics().setStatisticsEnabled"
"(true)</literal> 或 <literal>hibernateStatsBean.setStatisticsEnabled(true)</"
"literal>"

#. Tag: para
#, no-c-format
msgid ""
"Statistics can be reset programmatically using the <literal>clear()</"
"literal> method. A summary can be sent to a logger (info level) using the "
"<literal>logSummary()</literal> method."
msgstr ""
"你也可以在程序中调用 <literal>clear()</literal> 方法重置统计数据，调用 "
"<literal>logSummary()</literal> 在日志中记录（info 级别）其总结。 "

#. Tag: title
#, no-c-format
msgid "Metrics"
msgstr "数据记录（Metrics）"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate provides a number of metrics, from basic information to more "
"specialized information that is only relevant in certain scenarios. All "
"available counters are described in the <literal>Statistics</literal> "
"interface API, in three categories:"
msgstr ""
"Hibernate 提供了一系列数据记录，其记录的内容包括从最基本的信息到与具体场景的"
"特殊信息。所有的测量值都可以由 <literal>Statistics</literal> 接口 API 进行访"
"问，主要分为三类："

#. Tag: para
#, no-c-format
msgid ""
"Metrics related to the general <literal>Session</literal> usage, such as "
"number of open sessions, retrieved JDBC connections, etc."
msgstr ""
"使用 <literal>Session</literal> 的普通数据记录，例如打开的 Session 的个数、取"
"得的 JDBC 的连接数等；"

#. Tag: para
#, no-c-format
msgid ""
"Metrics related to the entities, collections, queries, and caches as a whole "
"(aka global metrics)."
msgstr "实体、集合、查询、缓存等内容的统一数据记录。"

#. Tag: para
#, no-c-format
msgid ""
"Detailed metrics related to a particular entity, collection, query or cache "
"region."
msgstr "和具体实体、集合、查询、缓存相关的详细数据记录"

#. Tag: para
#, no-c-format
msgid ""
"For example, you can check the cache hit, miss, and put ratio of entities, "
"collections and queries, and the average time a query needs. Be aware that "
"the number of milliseconds is subject to approximation in Java. Hibernate is "
"tied to the JVM precision and on some platforms this might only be accurate "
"to 10 seconds."
msgstr ""
"例如：你可以检查缓存的命中成功次数，缓存的命中失败次数，实体、集合和查询的使"
"用概率，查询的平均时间等。请注意 Java 中时间的近似精度是毫秒。Hibernate 的数"
"据精度和具体的 JVM 有关，在有些平台上其精度甚至只能精确到 10 秒。 "

#. Tag: para
#, no-c-format
msgid ""
"Simple getters are used to access the global metrics (i.e. not tied to a "
"particular entity, collection, cache region, etc.). You can access the "
"metrics of a particular entity, collection or cache region through its name, "
"and through its HQL or SQL representation for queries. Please refer to the "
"<literal>Statistics</literal>, <literal>EntityStatistics</literal>, "
"<literal>CollectionStatistics</literal>, "
"<literal>SecondLevelCacheStatistics</literal>, and <literal>QueryStatistics</"
"literal> API Javadoc for more information. The following code is a simple "
"example:"
msgstr ""
"你可以直接使用 getter 方法得到全局数据记录（例如，和具体的实体、集合、缓存区"
"无关的数据），你也可以在具体查询中通过标记实体名、 或 HQL、SQL 语句得到某实体"
"的数据记录。请参考 <literal>Statistics</literal>、<literal>EntityStatistics</"
"literal>、<literal>CollectionStatistics</literal>、"
"<literal>SecondLevelCacheStatistics</literal> 和 <literal>QueryStatistics</"
"literal> 的 API 文档以抓取更多信息。下面的代码则是个简单的例子： "

#. Tag: para
#, no-c-format
msgid ""
"You can work on all entities, collections, queries and region caches, by "
"retrieving the list of names of entities, collections, queries and region "
"caches using the following methods: <literal>getQueries()</literal>, "
"<literal>getEntityNames()</literal>, <literal>getCollectionRoleNames()</"
"literal>, and <literal>getSecondLevelCacheRegionNames()</literal>."
msgstr ""
"如果你想得到所有实体、集合、查询和缓存区的数据，你可以通过以下方法获得实体、"
"集合、查询和缓存区列表：<literal>getQueries()</literal>、"
"<literal>getEntityNames()</literal>、<literal>getCollectionRoleNames()</"
"literal> 和 <literal>getSecondLevelCacheRegionNames()</literal>。"

#~ msgid ""
#~ "This setting creates two new cache regions: one holding cached query "
#~ "result sets (<literal>org.hibernate.cache.StandardQueryCache</literal>), "
#~ "the other holding timestamps of the most recent updates to queryable "
#~ "tables (<literal>org.hibernate.cache.UpdateTimestampsCache</literal>). "
#~ "Note that the query cache does not cache the state of the actual entities "
#~ "in the result set; it caches only identifier values and results of value "
#~ "type. The query cache should always be used in conjunction with the "
#~ "second-level cache."
#~ msgstr ""
#~ "该设置将会创建两个缓存区域 — 一个用于保存查询结果集（<literal>org."
#~ "hibernate.cache.StandardQueryCache</literal>）； 另一个则用于保存最近查询"
#~ "的一系列表的时间戳（<literal>org.hibernate.cache.UpdateTimestampsCache</"
#~ "literal>）。请注意：在查询缓存中，它并不缓存结果集中所包含的实体的确切状"
#~ "态；它只缓存这些实体的标识符属性的值、以及各值类型的结果。所以查询缓存通常"
#~ "会和二级缓存一起使用。 "

#~ msgid ""
#~ "<![CDATA[s = sessions.openSession();\n"
#~ "Transaction tx = s.beginTransaction();\n"
#~ "            \n"
#~ "User u = (User) s.createQuery(\"from User u where u.name=:userName\")\n"
#~ "    .setString(\"userName\", userName).uniqueResult();\n"
#~ "Map permissions = u.getPermissions();\n"
#~ "\n"
#~ "tx.commit();\n"
#~ "s.close();\n"
#~ "\n"
#~ "Integer accessLevel = (Integer) permissions.get(\"accounts\");  // "
#~ "Error!]]>"
#~ msgstr ""
#~ "<![CDATA[s = sessions.openSession();\n"
#~ "Transaction tx = s.beginTransaction();\n"
#~ "            \n"
#~ "User u = (User) s.createQuery(\"from User u where u.name=:userName\")\n"
#~ "    .setString(\"userName\", userName).uniqueResult();\n"
#~ "Map permissions = u.getPermissions();\n"
#~ "\n"
#~ "tx.commit();\n"
#~ "s.close();\n"
#~ "\n"
#~ "Integer accessLevel = (Integer) permissions.get(\"accounts\");  // "
#~ "Error!]]>"

#~ msgid ""
#~ "<![CDATA[<set name=\"permissions\" \n"
#~ "            fetch=\"join\">\n"
#~ "    <key column=\"userId\"/>\n"
#~ "    <one-to-many class=\"Permission\"/>\n"
#~ "</set]]>"
#~ msgstr ""
#~ "<![CDATA[<set name=\"permissions\" \n"
#~ "            fetch=\"join\">\n"
#~ "    <key column=\"userId\"/>\n"
#~ "    <one-to-many class=\"Permission\"/>\n"
#~ "</set]]>"

#~ msgid ""
#~ "<![CDATA[<many-to-one name=\"mother\" class=\"Cat\" fetch=\"join\"/>]]>"
#~ msgstr ""
#~ "<![CDATA[<many-to-one name=\"mother\" class=\"Cat\" fetch=\"join\"/>]]>"

#~ msgid ""
#~ "<![CDATA[User user = (User) session.createCriteria(User.class)\n"
#~ "                .setFetchMode(\"permissions\", FetchMode.JOIN)\n"
#~ "                .add( Restrictions.idEq(userId) )\n"
#~ "                .uniqueResult();]]>"
#~ msgstr ""
#~ "<![CDATA[User user = (User) session.createCriteria(User.class)\n"
#~ "                .setFetchMode(\"permissions\", FetchMode.JOIN)\n"
#~ "                .add( Restrictions.idEq(userId) )\n"
#~ "                .uniqueResult();]]>"

#~ msgid ""
#~ "<![CDATA[<class name=\"Cat\" proxy=\"Cat\">\n"
#~ "    ......\n"
#~ "    <subclass name=\"DomesticCat\">\n"
#~ "        .....\n"
#~ "    </subclass>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "<![CDATA[<class name=\"Cat\" proxy=\"Cat\">\n"
#~ "    ......\n"
#~ "    <subclass name=\"DomesticCat\">\n"
#~ "        .....\n"
#~ "    </subclass>\n"
#~ "</class>]]>"

#~ msgid ""
#~ "<![CDATA[Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a "
#~ "proxy (does not hit the db)\n"
#~ "if ( cat.isDomesticCat() ) {                  // hit the db to initialize "
#~ "the proxy\n"
#~ "    DomesticCat dc = (DomesticCat) cat;       // Error!\n"
#~ "    ....\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a "
#~ "proxy (does not hit the db)\n"
#~ "if ( cat.isDomesticCat() ) {                  // hit the db to initialize "
#~ "the proxy\n"
#~ "    DomesticCat dc = (DomesticCat) cat;       // Error!\n"
#~ "    ....\n"
#~ "}]]>"

#~ msgid ""
#~ "<![CDATA[Cat cat = (Cat) session.load(Cat.class, id);            // "
#~ "instantiate a Cat proxy\n"
#~ "DomesticCat dc = \n"
#~ "        (DomesticCat) session.load(DomesticCat.class, id);  // acquire "
#~ "new DomesticCat proxy!\n"
#~ "System.out.println(cat==dc);                            // false]]>"
#~ msgstr ""
#~ "<![CDATA[Cat cat = (Cat) session.load(Cat.class, id);            // "
#~ "instantiate a Cat proxy\n"
#~ "DomesticCat dc = \n"
#~ "        (DomesticCat) session.load(DomesticCat.class, id);  // acquire "
#~ "new DomesticCat proxy!\n"
#~ "System.out.println(cat==dc);                            // false]]>"

#~ msgid ""
#~ "<![CDATA[cat.setWeight(11.0);  // hit the db to initialize the proxy\n"
#~ "System.out.println( dc.getWeight() );  // 11.0]]>"
#~ msgstr ""
#~ "<![CDATA[cat.setWeight(11.0);  // hit the db to initialize the proxy\n"
#~ "System.out.println( dc.getWeight() );  // 11.0]]>"

#~ msgid ""
#~ "<![CDATA[<class name=\"CatImpl\" proxy=\"Cat\">\n"
#~ "    ......\n"
#~ "    <subclass name=\"DomesticCatImpl\" proxy=\"DomesticCat\">\n"
#~ "        .....\n"
#~ "    </subclass>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "<![CDATA[<class name=\"CatImpl\" proxy=\"Cat\">\n"
#~ "    ......\n"
#~ "    <subclass name=\"DomesticCatImpl\" proxy=\"DomesticCat\">\n"
#~ "        .....\n"
#~ "    </subclass>\n"
#~ "</class>]]>"

#~ msgid ""
#~ "<![CDATA[Cat cat = (Cat) session.load(CatImpl.class, catid);\n"
#~ "Iterator iter = session.createQuery(\"from CatImpl as cat where cat."
#~ "name='fritz'\").iterate();\n"
#~ "Cat fritz = (Cat) iter.next();]]>"
#~ msgstr ""
#~ "<![CDATA[Cat cat = (Cat) session.load(CatImpl.class, catid);\n"
#~ "Iterator iter = session.createQuery(\"from CatImpl as cat where cat."
#~ "name='fritz'\").iterate();\n"
#~ "Cat fritz = (Cat) iter.next();]]>"

#~ msgid ""
#~ "<![CDATA[( (Integer) s.createFilter( collection, \"select count(*)\" )."
#~ "list().get(0) ).intValue()]]>"
#~ msgstr ""
#~ "<![CDATA[( (Integer) s.createFilter( collection, \"select count(*)\" )."
#~ "list().get(0) ).intValue()]]>"

#~ msgid ""
#~ "<![CDATA[s.createFilter( lazyCollection, \"\").setFirstResult(0)."
#~ "setMaxResults(10).list();]]>"
#~ msgstr ""
#~ "<![CDATA[s.createFilter( lazyCollection, \"\").setFirstResult(0)."
#~ "setMaxResults(10).list();]]>"

#~ msgid "<![CDATA[<class name=\"Person\" batch-size=\"10\">...</class>]]>"
#~ msgstr "<![CDATA[<class name=\"Person\" batch-size=\"10\">...</class>]]>"

#~ msgid ""
#~ "<![CDATA[<class name=\"Person\">\n"
#~ "    <set name=\"cats\" batch-size=\"3\">\n"
#~ "        ...\n"
#~ "    </set>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "<![CDATA[<class name=\"Person\">\n"
#~ "    <set name=\"cats\" batch-size=\"3\">\n"
#~ "        ...\n"
#~ "    </set>\n"
#~ "</class>]]>"

#~ msgid ""
#~ "<![CDATA[<class name=\"Document\">\n"
#~ "       <id name=\"id\">\n"
#~ "        <generator class=\"native\"/>\n"
#~ "    </id>\n"
#~ "    <property name=\"name\" not-null=\"true\" length=\"50\"/>\n"
#~ "    <property name=\"summary\" not-null=\"true\" length=\"200\" lazy="
#~ "\"true\"/>\n"
#~ "    <property name=\"text\" not-null=\"true\" length=\"2000\" lazy=\"true"
#~ "\"/>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "<![CDATA[<class name=\"Document\">\n"
#~ "       <id name=\"id\">\n"
#~ "        <generator class=\"native\"/>\n"
#~ "    </id>\n"
#~ "    <property name=\"name\" not-null=\"true\" length=\"50\"/>\n"
#~ "    <property name=\"summary\" not-null=\"true\" length=\"200\" lazy="
#~ "\"true\"/>\n"
#~ "    <property name=\"text\" not-null=\"true\" length=\"2000\" lazy=\"true"
#~ "\"/>\n"
#~ "</class>]]>"

#~ msgid ""
#~ "<![CDATA[<target name=\"instrument\" depends=\"compile\">\n"
#~ "    <taskdef name=\"instrument\" classname=\"org.hibernate.tool."
#~ "instrument.InstrumentTask\">\n"
#~ "        <classpath path=\"${jar.path}\"/>\n"
#~ "        <classpath path=\"${classes.dir}\"/>\n"
#~ "        <classpath refid=\"lib.class.path\"/>\n"
#~ "    </taskdef>\n"
#~ "\n"
#~ "    <instrument verbose=\"true\">\n"
#~ "        <fileset dir=\"${testclasses.dir}/org/hibernate/auction/model\">\n"
#~ "            <include name=\"*.class\"/>\n"
#~ "        </fileset>\n"
#~ "    </instrument>\n"
#~ "</target>]]>"
#~ msgstr ""
#~ "<![CDATA[<target name=\"instrument\" depends=\"compile\">\n"
#~ "    <taskdef name=\"instrument\" classname=\"org.hibernate.tool."
#~ "instrument.InstrumentTask\">\n"
#~ "        <classpath path=\"${jar.path}\"/>\n"
#~ "        <classpath path=\"${classes.dir}\"/>\n"
#~ "        <classpath refid=\"lib.class.path\"/>\n"
#~ "    </taskdef>\n"
#~ "\n"
#~ "    <instrument verbose=\"true\">\n"
#~ "        <fileset dir=\"${testclasses.dir}/org/hibernate/auction/model\">\n"
#~ "            <include name=\"*.class\"/>\n"
#~ "        </fileset>\n"
#~ "    </instrument>\n"
#~ "</target>]]>"

#~ msgid "<entry>yes</entry>"
#~ msgstr "<entry>yes</entry>"

#~ msgid ""
#~ "<![CDATA[<cache \n"
#~ "    usage=\"transactional|read-write|nonstrict-read-write|read-only\"\n"
#~ "    region=\"RegionName\"\n"
#~ "    include=\"all|non-lazy\"\n"
#~ "/>]]>"
#~ msgstr ""
#~ "<![CDATA[<cache \n"
#~ "    usage=\"transactional|read-write|nonstrict-read-write|read-only\"\n"
#~ "    region=\"RegionName\"\n"
#~ "    include=\"all|non-lazy\"\n"
#~ "/>]]>"

#~ msgid ""
#~ "<![CDATA[<class name=\"eg.Immutable\" mutable=\"false\">\n"
#~ "    <cache usage=\"read-only\"/>\n"
#~ "    ....\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "<![CDATA[<class name=\"eg.Immutable\" mutable=\"false\">\n"
#~ "    <cache usage=\"read-only\"/>\n"
#~ "    ....\n"
#~ "</class>]]>"

#~ msgid ""
#~ "<![CDATA[<class name=\"eg.Cat\" .... >\n"
#~ "    <cache usage=\"read-write\"/>\n"
#~ "    ....\n"
#~ "    <set name=\"kittens\" ... >\n"
#~ "        <cache usage=\"read-write\"/>\n"
#~ "        ....\n"
#~ "    </set>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "<![CDATA[<class name=\"eg.Cat\" .... >\n"
#~ "    <cache usage=\"read-write\"/>\n"
#~ "    ....\n"
#~ "    <set name=\"kittens\" ... >\n"
#~ "        <cache usage=\"read-write\"/>\n"
#~ "        ....\n"
#~ "    </set>\n"
#~ "</class>]]>"

#~ msgid ""
#~ "<![CDATA[ScrollableResult cats = sess.createQuery(\"from Cat as cat\")."
#~ "scroll(); //a huge result set\n"
#~ "while ( cats.next() ) {\n"
#~ "    Cat cat = (Cat) cats.get(0);\n"
#~ "    doSomethingWithACat(cat);\n"
#~ "    sess.evict(cat);\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[ScrollableResult cats = sess.createQuery(\"from Cat as cat\")."
#~ "scroll(); //a huge result set\n"
#~ "while ( cats.next() ) {\n"
#~ "    Cat cat = (Cat) cats.get(0);\n"
#~ "    doSomethingWithACat(cat);\n"
#~ "    sess.evict(cat);\n"
#~ "}]]>"

#~ msgid ""
#~ "<![CDATA[sessionFactory.evict(Cat.class, catId); //evict a particular "
#~ "Cat\n"
#~ "sessionFactory.evict(Cat.class);  //evict all Cats\n"
#~ "sessionFactory.evictCollection(\"Cat.kittens\", catId); //evict a "
#~ "particular collection of kittens\n"
#~ "sessionFactory.evictCollection(\"Cat.kittens\"); //evict all kitten "
#~ "collections]]>"
#~ msgstr ""
#~ "<![CDATA[sessionFactory.evict(Cat.class, catId); //evict a particular "
#~ "Cat\n"
#~ "sessionFactory.evict(Cat.class);  //evict all Cats\n"
#~ "sessionFactory.evictCollection(\"Cat.kittens\", catId); //evict a "
#~ "particular collection of kittens\n"
#~ "sessionFactory.evictCollection(\"Cat.kittens\"); //evict all kitten "
#~ "collections]]>"

#~ msgid ""
#~ "<![CDATA[Map cacheEntries = sessionFactory.getStatistics()\n"
#~ "        .getSecondLevelCacheStatistics(regionName)\n"
#~ "        .getEntries();]]>"
#~ msgstr ""
#~ "<![CDATA[Map cacheEntries = sessionFactory.getStatistics()\n"
#~ "        .getSecondLevelCacheStatistics(regionName)\n"
#~ "        .getEntries();]]>"

#~ msgid ""
#~ "<![CDATA[hibernate.generate_statistics true\n"
#~ "hibernate.cache.use_structured_entries true]]>"
#~ msgstr ""
#~ "<![CDATA[hibernate.generate_statistics true\n"
#~ "hibernate.cache.use_structured_entries true]]>"

#~ msgid "<![CDATA[hibernate.cache.use_query_cache true]]>"
#~ msgstr "<![CDATA[hibernate.cache.use_query_cache true]]>"

#~ msgid ""
#~ "<![CDATA[List blogs = sess.createQuery(\"from Blog blog where blog."
#~ "blogger = :blogger\")\n"
#~ "    .setEntity(\"blogger\", blogger)\n"
#~ "    .setMaxResults(15)\n"
#~ "    .setCacheable(true)\n"
#~ "    .setCacheRegion(\"frontpages\")\n"
#~ "    .list();]]>"
#~ msgstr ""
#~ "<![CDATA[List blogs = sess.createQuery(\"from Blog blog where blog."
#~ "blogger = :blogger\")\n"
#~ "    .setEntity(\"blogger\", blogger)\n"
#~ "    .setMaxResults(15)\n"
#~ "    .setCacheable(true)\n"
#~ "    .setCacheRegion(\"frontpages\")\n"
#~ "    .list();]]>"

#~ msgid ""
#~ "<![CDATA[Parent p = (Parent) sess.load(Parent.class, id);\n"
#~ "Child c = new Child();\n"
#~ "c.setParent(p);\n"
#~ "p.getChildren().add(c);  //no need to fetch the collection!\n"
#~ "sess.flush();]]>"
#~ msgstr ""
#~ "<![CDATA[Parent p = (Parent) sess.load(Parent.class, id);\n"
#~ "Child c = new Child();\n"
#~ "c.setParent(p);\n"
#~ "p.getChildren().add(c);  //no need to fetch the collection!\n"
#~ "sess.flush();]]>"

#~ msgid ""
#~ "<![CDATA[// MBean service registration for a specific SessionFactory\n"
#~ "Hashtable tb = new Hashtable();\n"
#~ "tb.put(\"type\", \"statistics\");\n"
#~ "tb.put(\"sessionFactory\", \"myFinancialApp\");\n"
#~ "ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
#~ "\n"
#~ "StatisticsService stats = new StatisticsService(); // MBean "
#~ "implementation\n"
#~ "stats.setSessionFactory(sessionFactory); // Bind the stats to a "
#~ "SessionFactory\n"
#~ "server.registerMBean(stats, on); // Register the Mbean on the server]]>"
#~ msgstr ""
#~ "<![CDATA[// MBean service registration for a specific SessionFactory\n"
#~ "Hashtable tb = new Hashtable();\n"
#~ "tb.put(\"type\", \"statistics\");\n"
#~ "tb.put(\"sessionFactory\", \"myFinancialApp\");\n"
#~ "ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
#~ "\n"
#~ "StatisticsService stats = new StatisticsService(); // MBean "
#~ "implementation\n"
#~ "stats.setSessionFactory(sessionFactory); // Bind the stats to a "
#~ "SessionFactory\n"
#~ "server.registerMBean(stats, on); // Register the Mbean on the server]]>"

#~ msgid ""
#~ "<![CDATA[// MBean service registration for all SessionFactory's\n"
#~ "Hashtable tb = new Hashtable();\n"
#~ "tb.put(\"type\", \"statistics\");\n"
#~ "tb.put(\"sessionFactory\", \"all\");\n"
#~ "ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
#~ "\n"
#~ "StatisticsService stats = new StatisticsService(); // MBean "
#~ "implementation\n"
#~ "server.registerMBean(stats, on); // Register the MBean on the server]]>"
#~ msgstr ""
#~ "<![CDATA[// MBean service registration for all SessionFactory's\n"
#~ "Hashtable tb = new Hashtable();\n"
#~ "tb.put(\"type\", \"statistics\");\n"
#~ "tb.put(\"sessionFactory\", \"all\");\n"
#~ "ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
#~ "\n"
#~ "StatisticsService stats = new StatisticsService(); // MBean "
#~ "implementation\n"
#~ "server.registerMBean(stats, on); // Register the MBean on the server]]>"

#~ msgid ""
#~ "<![CDATA[Statistics stats = HibernateUtil.sessionFactory.getStatistics"
#~ "();\n"
#~ "\n"
#~ "double queryCacheHitCount  = stats.getQueryCacheHitCount();\n"
#~ "double queryCacheMissCount = stats.getQueryCacheMissCount();\n"
#~ "double queryCacheHitRatio =\n"
#~ "  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);\n"
#~ "\n"
#~ "log.info(\"Query Hit ratio:\" + queryCacheHitRatio);\n"
#~ "\n"
#~ "EntityStatistics entityStats =\n"
#~ "  stats.getEntityStatistics( Cat.class.getName() );\n"
#~ "long changes =\n"
#~ "        entityStats.getInsertCount()\n"
#~ "        + entityStats.getUpdateCount()\n"
#~ "        + entityStats.getDeleteCount();\n"
#~ "log.info(Cat.class.getName() + \" changed \" + changes + \"times\"  );]]>"
#~ msgstr ""
#~ "<![CDATA[Statistics stats = HibernateUtil.sessionFactory.getStatistics"
#~ "();\n"
#~ "\n"
#~ "double queryCacheHitCount  = stats.getQueryCacheHitCount();\n"
#~ "double queryCacheMissCount = stats.getQueryCacheMissCount();\n"
#~ "double queryCacheHitRatio =\n"
#~ "  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);\n"
#~ "\n"
#~ "log.info(\"Query Hit ratio:\" + queryCacheHitRatio);\n"
#~ "\n"
#~ "EntityStatistics entityStats =\n"
#~ "  stats.getEntityStatistics( Cat.class.getName() );\n"
#~ "long changes =\n"
#~ "        entityStats.getInsertCount()\n"
#~ "        + entityStats.getUpdateCount()\n"
#~ "        + entityStats.getDeleteCount();\n"
#~ "log.info(Cat.class.getName() + \" changed \" + changes + \"times\"  );]]>"
