msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-04T04:51:22\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, no-c-format
msgid "Configuration"
msgstr "구성"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate is designed to operate in many different environments and, as "
"such, there is a broad range of configuration parameters. Fortunately, most "
"have sensible default values and Hibernate is distributed with an example "
"<literal>hibernate.properties</literal> file in <literal>etc/</literal> that "
"displays the various options. Simply put the example file in your classpath "
"and customize it to suit your needs."
msgstr ""
"Hibernate가 많은 다른 환경들에서 동작하도록 설계되어 있으므로, 많은 개수의 구"
"성 파라미터들이 존재한다. 다행히 대부분은 유의미한 디폴트 값들이고 Hibernate"
"는 다양한 옵션들을 보여주는 <literal>etc/</literal> 내의 예제 파일 "
"<literal>hibernate.properties</literal>로 배포된다. 당신은 단지 당신의 "
"classpath 경로 속에 그 파일을 집어넣고 그것을 커스트마이징하기만 해야 한다."

#. Tag: title
#, no-c-format
msgid "Programmatic configuration"
msgstr "프로그램 상의 구성"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"An instance of <classname>org.hibernate.cfg.Configuration</classname> "
"represents an entire set of mappings of an application's Java types to an "
"SQL database. The <classname>org.hibernate.cfg.Configuration</classname> is "
"used to build an immutable <interfacename>org.hibernate.SessionFactory</"
"interfacename>. The mappings are compiled from various XML mapping files."
msgstr ""
"<literal>org.hibernate.cfg.Configuration</literal>의 인스턴스는 어플리케이션"
"의 Java 타입들을 SQL 데이터베이스 타입으로의 전체 매핑 집합을 표현한다. "
"<literal>Configuration</literal>은 (불변의) <literal>SessionFactory</literal>"
"를 빌드하는데 사용된다. 매핑들은 여러 XML 매핑 파일들로부터 컴파일 된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can obtain a <classname>org.hibernate.cfg.Configuration</classname> "
"instance by instantiating it directly and specifying XML mapping documents. "
"If the mapping files are in the classpath, use <literal>addResource()</"
"literal>. For example:"
msgstr ""
"당신은 <literal>Configuration</literal> 인스턴스를 초기화 시키고 XML 매핑 문"
"서들을 지정함으로써 <literal>Configuration</literal> 인스턴스를 얻을 수 있"
"다. 만일 매핑 파일들이 classpath 내에 있다면, <literal>addResource()</"
"literal>를 사용하라:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"An alternative way is to specify the mapped class and allow Hibernate to "
"find the mapping document for you:"
msgstr ""
"(때때로 더 나은) 다른 방법은 매핑된 클래스를 지정하는 것이고, Hibernate로 하"
"여금 당신을 위해 매핑 문서를 찾도록 하라:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate will then search for mapping files named <filename>/org/hibernate/"
"auction/Item.hbm.xml</filename> and <filename>/org/hibernate/auction/Bid.hbm."
"xml</filename> in the classpath. This approach eliminates any hardcoded "
"filenames."
msgstr ""
"그때 Hibernate는 classpath 내에서 <literal>/org/hibernate/auction/Item.hbm."
"xml</literal>과 <literal>/org/hibernate/auction/Bid.hbm.xml</literal>로 명명"
"된 매핑 파일들을 룩업할 것이다. 이 접근법은 임의의 하드코딩된 파일 이름들을 "
"제거한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A <classname>org.hibernate.cfg.Configuration</classname> also allows you to "
"specify configuration properties. For example:"
msgstr ""
"<literal>Configuration</literal>은 또한 구성 프로퍼티들을 지정하는 것을 허용"
"해준다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This is not the only way to pass configuration properties to Hibernate. Some "
"alternative options include:"
msgstr ""
"이것은 컨피그레이션 프로퍼티들을 Hibernate에 전달하는 유일한 방법이 아니다. "
"여러 가지 옵션들은 다음을 포함한다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Pass an instance of <classname>java.util.Properties</classname> to "
"<literal>Configuration.setProperties()</literal>."
msgstr ""
"<literal>java.util.Properties</literal>의 인스턴스를 <literal>Configuration."
"setProperties()</literal>에 전달한다 ."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Place a file named <filename>hibernate.properties</filename> in a root "
"directory of the classpath."
msgstr ""
"classpath의 루트 디렉토리에 <literal>hibernate.properties</literal>를 위치지"
"운다."

#. Tag: para
#, no-c-format
msgid ""
"Set <literal>System</literal> properties using <literal>java -"
"Dproperty=value</literal>."
msgstr ""
"<literal>java -Dproperty=value</literal>를 사용하여 <literal>System</"
"literal> 프로퍼티들을 설정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Include <literal>&lt;property&gt;</literal> elements in <literal>hibernate."
"cfg.xml</literal> (this is discussed later)."
msgstr ""
"<literal>hibernate.cfg.xml</literal>에 <literal>&lt;property&gt;</literal> 요"
"소들을 포함한다 (나중에 논의됨)."

#. Tag: para
#, no-c-format
msgid ""
"If you want to get started quickly<filename>hibernate.properties</filename> "
"is the easiest approach."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <classname>org.hibernate.cfg.Configuration</classname> is intended as a "
"startup-time object that will be discarded once a <literal>SessionFactory</"
"literal> is created."
msgstr ""
"<literal>Configuration</literal>은 시작 시(startup-time) 객체로서 일단 "
"<literal>SessionFactory</literal>가 생성되면 폐기되게끔 예정되어 있다."

#. Tag: title
#, no-c-format
msgid "Obtaining a SessionFactory"
msgstr "SessionFactory 얻기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"When all mappings have been parsed by the <classname>org.hibernate.cfg."
"Configuration</classname>, the application must obtain a factory for "
"<interfacename>org.hibernate.Session</interfacename> instances. This factory "
"is intended to be shared by all application threads:"
msgstr ""
"모든 매핑들이 <literal>Configuration</literal>에 의해 파싱되었을 때, 어플리케"
"이션은 <literal>Session</literal> 인스턴스들에 대한 팩토리를 얻어야 한다. 이 "
"팩토리는 모든 어플리케이션 쓰레드들에 의해 공유되도록 고안되었다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate does allow your application to instantiate more than one "
"<interfacename>org.hibernate.SessionFactory</interfacename>. This is useful "
"if you are using more than one database."
msgstr ""
"하지만 Hibernate는 당신의 어플리케이션이 하나 이상의 "
"<literal>SessionFactory</literal>를 초기화 시키는 것을 허용한다. 이것은 당신"
"이 하나 이상의 데이터베이스를 사용하는 경우에 유용하다."

#. Tag: title
#, no-c-format
msgid "JDBC connections"
msgstr "JDBC 커넥션들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is advisable to have the <interfacename>org.hibernate.SessionFactory</"
"interfacename> create and pool JDBC connections for you. If you take this "
"approach, opening a <interfacename>org.hibernate.Session</interfacename> is "
"as simple as:"
msgstr ""
"대개 당신은 <literal>SessionFactory</literal>로 하여금 당신을 위한 JDBC 커넥"
"션들을 생성시키고 풀링시키는 것을 원한다. 만일 당신이 이 접근법을 취할 경우, "
"한 개의 <literal>Session</literal>을 여는 것은 다음과 같이 간단하다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Once you start a task that requires access to the database, a JDBC "
"connection will be obtained from the pool."
msgstr ""
"당신이 데이터베이스에 대한 접근을 요청하는 어떤 것을 행하자 마자, 한 개의 "
"JDBC 커넥션이 그 풀로부터 얻어질 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Before you can do this, you first need to pass some JDBC connection "
"properties to Hibernate. All Hibernate property names and semantics are "
"defined on the class <classname>org.hibernate.cfg.Environment</classname>. "
"The most important settings for JDBC connection configuration are outlined "
"below."
msgstr ""
"이것이 동작하도록 하기 위해서, 우리는 몇몇 JDBC 커넥션 프로퍼티들을 Hibernate"
"에 전달할 필요가 있다. 모든 Hibernate 프로퍼티 이름들과 의미론들은 "
"<literal>org.hibernate.cfg.Environment</literal> 클래스 상에 정의되어 있다. "
"우리는 이제 JDBC 커넥션 구성을 위한 가장 중요한 설정들을 설명할 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate will obtain and pool connections using <classname>java.sql."
"DriverManager</classname> if you set the following properties:"
msgstr ""
"만일 당신이 다음 프로퍼티들을 설정할 경우 Hibernate는 <literal>java.sql."
"DriverManager</literal>를 사용하여 커넥션들을 얻을 것이다(그리고 풀링시킬 것"
"이다):"

#. Tag: title
#, no-c-format
msgid "Hibernate JDBC Properties"
msgstr "Hibernate JDBC 프로퍼티들"

#. Tag: entry
#, no-c-format
msgid "Property name"
msgstr "프로퍼티 이름"

#. Tag: entry
#, no-c-format
msgid "Purpose"
msgstr "용도"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.connection.driver_class</property>"
msgstr "hibernate.connection.driver_class"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<emphasis>JDBC driver class</emphasis>"
msgstr "jdbc 드라이버 클래스"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.connection.url</property>"
msgstr "hibernate.connection.url"

#. Tag: entry
#, no-c-format
msgid "<emphasis>JDBC URL</emphasis>"
msgstr ""

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.connection.username</property>"
msgstr "hibernate.connection.username"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<emphasis>database user</emphasis>"
msgstr "데이터베이스 사용자 패스워드"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.connection.password</property>"
msgstr "hibernate.connection.password"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<emphasis>database user password</emphasis>"
msgstr "데이터베이스 사용자 패스워드"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.connection.pool_size</property>"
msgstr "hibernate.connection.pool_size"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<emphasis>maximum number of pooled connections</emphasis>"
msgstr "풀링된 커넥션들의 최대 개수"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate's own connection pooling algorithm is, however, quite rudimentary. "
"It is intended to help you get started and is <emphasis>not intended for use "
"in a production system</emphasis>, or even for performance testing. You "
"should use a third party pool for best performance and stability. Just "
"replace the <property>hibernate.connection.pool_size</property> property "
"with connection pool specific settings. This will turn off Hibernate's "
"internal pool. For example, you might like to use c3p0."
msgstr ""
"하지만 Hibernate 자신의 커넥션 풀링 알고리즘은 아주 기본적이다. 그것은 당신"
"이 시작하는 것을 도와주려고 의도되었고 <emphasis>제품 시스템 용도 또는 퍼포먼"
"스 테스트용으로는 고안되지 않았다</emphasis>. 최상의 퍼포먼스와 안정성을 위해"
"서는 제 3의 풀을 사용하라. 즉 <literal>hibernate.connection.pool_size</"
"literal> 프로퍼티를 커넥션 풀 지정 설정들로 대체하라. 이것은 Hibernate의 내"
"부 pool을 오프시킬 것이다. 예를 들어 당신은 C3P0를 사용할 수도 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"C3P0 is an open source JDBC connection pool distributed along with Hibernate "
"in the <filename>lib</filename> directory. Hibernate will use its "
"<classname>org.hibernate.connection.C3P0ConnectionProvider</classname> for "
"connection pooling if you set <property>hibernate.c3p0.*</property> "
"properties. If you would like to use Proxool, refer to the packaged "
"<filename>hibernate.properties</filename> and the Hibernate web site for "
"more information."
msgstr ""
"C3P0는 <literal>lib</literal> 디펙토리 속에 Hibernate에 배포된 오픈 소스 "
"JDBC 커넥션 풀이다. 당신이 <literal>hibernate.c3p0.*</literal> 프로퍼티들을 "
"설정할 경우 Hibernate는 커넥션 풀링을 위해 그것의 "
"<literal>C3P0ConnectionProvider</literal>를 사용할 것이다. 만일 당신이 "
"Proxool을 사용하고자 원할 경우 패키지화 된 <literal>hibernate.properties</"
"literal>를 참조하고 추가 정보는 Hibernate 웹 사이트를 참조하라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The following is an example <filename>hibernate.properties</filename> file "
"for c3p0:"
msgstr ""
"다음은 C3P0에 대한 사용하는 예제 <literal>hibernate.properties</literal> 파일"
"이다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For use inside an application server, you should almost always configure "
"Hibernate to obtain connections from an application server "
"<interfacename>javax.sql.Datasource</interfacename> registered in JNDI. You "
"will need to set at least one of the following properties:"
msgstr ""
"어플리케이션 서버 내부의 용도로, 당신은 JNDI로 등록된 어플리케이션 서버 "
"<literal>Datasource</literal>로부터 커넥션을 얻기 위해 항상 Hibernate를 구성"
"해야 한다. 당신은 적어도 다음 프로퍼티들 중 하나를 최소한으로 설정할 필요가 "
"있을 것이다."

#. Tag: title
#, no-c-format
msgid "Hibernate Datasource Properties"
msgstr "Hibernate Datasource Properties"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.connection.datasource</property>"
msgstr "hibernate.connection.datasource"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<emphasis>datasource JNDI name</emphasis>"
msgstr "데이터소스 JNDI 이름"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.jndi.url</property>"
msgstr "hibernate.jndi.url"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<emphasis>URL of the JNDI provider</emphasis> (optional)"
msgstr "JNDI 프로바이더의 URL"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.jndi.class</property>"
msgstr "hibernate.jndi.class"

#. Tag: entry
#, no-c-format
msgid ""
"<emphasis>class of the JNDI <literal>InitialContextFactory</literal></"
"emphasis> (optional)"
msgstr ""

#. Tag: entry
#, no-c-format
msgid "<emphasis>database user</emphasis> (optional)"
msgstr ""

#. Tag: entry
#, no-c-format
msgid "<emphasis>database user password</emphasis> (optional)"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Here is an example <filename>hibernate.properties</filename> file for an "
"application server provided JNDI datasource:"
msgstr ""
"다음은 어플리케이션 서버 제공 JNDI 데이터소스용 예제 <literal>hibernate."
"properties</literal> 파일이다:"

#. Tag: para
#, no-c-format
msgid ""
"JDBC connections obtained from a JNDI datasource will automatically "
"participate in the container-managed transactions of the application server."
msgstr ""
"JNDI datasource로부터 얻어진 JDBC 커넥션들은 어플리케이션 서버의 컨테이너에 "
"의해 관리되는 트랜잭션들에 자동적으로 참여할 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Arbitrary connection properties can be given by prepending "
"\"<literal>hibernate.connection</literal>\" to the connection property name. "
"For example, you can specify a <property>charSet</property> connection "
"property using <property>hibernate.connection.charSet</property>."
msgstr ""
"임의의 커넥션 프로퍼티들은 프로퍼티 이름 앞에 \"<literal>hibernate."
"connnection</literal>\"을 첨가하여 부여될 수 있다. 예를 들어 당신은 "
"<literal>hibernate.connection.charSet</literal>을 사용하여 <literal>charSet</"
"literal>을 지정할 수도 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can define your own plugin strategy for obtaining JDBC connections by "
"implementing the interface <interfacename>org.hibernate.connection."
"ConnectionProvider</interfacename>, and specifying your custom "
"implementation via the <property>hibernate.connection.provider_class</"
"property> property."
msgstr ""
"당신은 <literal>org.hibernate.connection.ConnectionProvider</literal> 인터페"
"이스를 구현함으로써 JDBC 커넥션들을 얻는 당신 자신의 플러그인 방도를 정의할수"
"도 있다. 당신은 <literal>hibernate.connection.provider_class</literal>를 설정"
"하여 맞춤형 구현을 선택할 수도 있다."

#. Tag: title
#, no-c-format
msgid "Optional configuration properties"
msgstr "선택적인 구성 프로퍼티들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"There are a number of other properties that control the behavior of "
"Hibernate at runtime. All are optional and have reasonable default values."
msgstr ""
"실행 시에 Hibernate의 행위를 제어하는 많은 다른 프로퍼티들이 존재한다. 모든 "
"것이 옵션이지만 합당한 디폴트 값들을 갖는다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis>Some of these properties are \"system-level\" only.</emphasis> "
"System-level properties can be set only via <literal>java -Dproperty=value</"
"literal> or <filename>hibernate.properties</filename>. They "
"<emphasis>cannot</emphasis> be set by the other techniques described above."
msgstr ""
"<emphasis>경고: 이들 프로퍼티들 중 몇몇은 \"system-level\" 전용이다.</"
"emphasis> 시스템 레벨 프로퍼티들은 오직 <literal>java -Dproperty=value</"
"literal> 또는 <literal>hibernate.properties</literal>를 통해서만 설정될 수 있"
"다. 그것들은 위에 설명된 다른 기법들에 의해 설정될 수 <emphasis>없다</"
"emphasis>."

#. Tag: title
#, no-c-format
msgid "Hibernate Configuration Properties"
msgstr "Hibernate 구성 프로퍼티들"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.dialect</property>"
msgstr "hibernate.dialect"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"The classname of a Hibernate <classname>org.hibernate.dialect.Dialect</"
"classname> which allows Hibernate to generate SQL optimized for a particular "
"relational database."
msgstr ""
"특정 관계형 데이터베이스에 최적화 된 SQL을 생성시키는 것을 Hibernate에게 허용"
"해주는 Hibernate <placeholder-1/>의 클래스명. <placeholder-2/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>full.classname.of."
"Dialect</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: para
#, no-c-format
msgid ""
"In most cases Hibernate will actually be able to choose the correct "
"<classname>org.hibernate.dialect.Dialect</classname> implementation based on "
"the <literal>JDBC metadata</literal> returned by the JDBC driver."
msgstr ""

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.show_sql</property>"
msgstr "hibernate.show_sql"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Write all SQL statements to console. This is an alternative to setting the "
"log category <literal>org.hibernate.SQL</literal> to <literal>debug</"
"literal>."
msgstr ""
"모든 SQL 문장들을 콘솔에 기록한다. 이것은 로그 카테고리 <placeholder-1/>를 "
"<placeholder-2/>로 설정하는 것에 대한 하나의 다른 방법이다. <placeholder-3/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>true</literal> | "
"<literal>false</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.format_sql</property>"
msgstr "hibernate.format_sql"

#. Tag: entry
#, fuzzy, no-c-format
msgid "Pretty print the SQL in the log and console."
msgstr "로그와 콘솔 속에 SQL을 깔끔하게 프린트한다. <placeholder-1/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.default_schema</property>"
msgstr "hibernate.default_schema"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Qualify unqualified table names with the given schema/tablespace in "
"generated SQL."
msgstr ""
"생성된 SQL 내에 주어진 schema/tablespace로서 수식이 없는 테이블이름들을 수식"
"한다. <placeholder-1/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>SCHEMA_NAME</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.default_catalog</property>"
msgstr "hibernate.default_catalog"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Qualifies unqualified table names with the given catalog in generated SQL."
msgstr ""
"주어진 SQL 내에 주어진 카타록으로서 수식이 없는 테이블이름들을 수식한다. "
"<placeholder-1/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>CATALOG_NAME</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.session_factory_name</property>"
msgstr "hibernate.session_factory_name"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"The <interfacename>org.hibernate.SessionFactory</interfacename> will be "
"automatically bound to this name in JNDI after it has been created."
msgstr ""
"<placeholder-1/>는 그것이 생성된 후에 JNDI 내에서 이 이름에 자동적으로 바인"
"드 될 것이다. <placeholder-2/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>jndi/composite/name</"
"literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.max_fetch_depth</property>"
msgstr "hibernate.max_fetch_depth"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Sets a maximum \"depth\" for the outer join fetch tree for single-ended "
"associations (one-to-one, many-to-one). A <literal>0</literal> disables "
"default outer join fetching."
msgstr ""
"single-ended 연관관계들(one-to-one, many-to-one)의 경우에 outer join fetch 트"
"리의 최대 \"깊이\"를 설정한다. <placeholder-1/>은 디폴트 outer join fetching"
"을 사용불가능하게 만든다. <placeholder-2/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> recommended values between "
"<literal>0</literal> and <literal>3</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>0</literal>과 <literal>3</"
"literal> 사이의 값들이권장된다"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.default_batch_fetch_size</property>"
msgstr "hibernate.default_batch_fetch_size"

#. Tag: entry
#, fuzzy, no-c-format
msgid "Sets a default size for Hibernate batch fetching of associations."
msgstr ""
"연관들의 Hibernate 배치 페칭에 대한 디폴트 크기를 설정한다. <placeholder-1/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> recommended values <literal>4</"
"literal>, <literal>8</literal>, <literal>16</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis> 권장되는 값들은 <literal>4</"
"literal>, <literal>8</literal>, <literal>16</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.default_entity_mode</property>"
msgstr "hibernate.default_entity_mode"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Sets a default mode for entity representation for all sessions opened from "
"this <literal>SessionFactory</literal>"
msgstr ""
"이 <placeholder-1/>로부터 열려진 모든 세션들에 대해 엔티티 표현을 디폴트 모드"
"로 설정한다 <placeholder-2/>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>dynamic-map</literal>, <literal>dom4j</literal>, <literal>pojo</"
"literal>"
msgstr ""
"<literal>dynamic-map</literal>, <literal>dom4j</literal>, <literal>pojo</"
"literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.order_updates</property>"
msgstr "hibernate.order_updates"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Forces Hibernate to order SQL updates by the primary key value of the items "
"being updated. This will result in fewer transaction deadlocks in highly "
"concurrent systems."
msgstr ""
"업데이트 중인 항목들의 프라이머리 키 값에 의해 SQL 업데이트들이 순서"
"(ordering)지워지도록 Hibernate에게 강제시킨다. 이것은 고도의 동시성 시스템들"
"에서 더 적은 트랜잭션 데드락(deadlock)들로 귀결될 것이다 <placeholder-1/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.generate_statistics</property>"
msgstr "hibernate.generate_statistics"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"If enabled, Hibernate will collect statistics useful for performance tuning."
msgstr ""
"이용 가능하게 되면, Hibernate는 퍼포먼스 튜닝에 유용한 통계들을 수집할 것이"
"다. <placeholder-1/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.use_identifier_rollback</property>"
msgstr "hibernate.use_identifer_rollback"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"If enabled, generated identifier properties will be reset to default values "
"when objects are deleted."
msgstr ""
"이용 가능하게 되면, 객체가 삭제될 때 생성된 식별자 프로퍼티들은 디폴트 값들"
"로 재설정될 것이다. <placeholder-1/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.use_sql_comments</property>"
msgstr "hibernate.use_sql_comments"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"If turned on, Hibernate will generate comments inside the SQL, for easier "
"debugging, defaults to <literal>false</literal>."
msgstr ""
"이용 가능하게 되면, Hibernate는 보다 쉬운 디버깅을 위해 SQL 내에 주석들을 생"
"성시킬 것이다. 디폴트는 <placeholder-1/>. <placeholder-2/>"

#. Tag: title
#, no-c-format
msgid "Hibernate JDBC and Connection Properties"
msgstr "Hibernate JDBC 및 커넥션 프로퍼티들"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.jdbc.fetch_size</property>"
msgstr "hibernate.jdbc.fetch_size"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"A non-zero value determines the JDBC fetch size (calls <literal>Statement."
"setFetchSize()</literal>)."
msgstr ""
"0 아닌 값은 JDBC fetch 사이즈를 결정한다(<placeholder-1/>을 호출한다 )."

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.jdbc.batch_size</property>"
msgstr "hibernate.jdbc.batch_size"

#. Tag: entry
#, fuzzy, no-c-format
msgid "A non-zero value enables use of JDBC2 batch updates by Hibernate."
msgstr ""
"0 아닌 값은 Hibernate에 의한 JDBC2 배치 업데이트의 사용을 이용 가능하게 한"
"다. <placeholder-1/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> recommended values between "
"<literal>5</literal> and <literal>30</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>5</literal>와 <literal>30</"
"literal> 사이의 값들이 권장된다"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.jdbc.batch_versioned_data</property>"
msgstr "hibernate.jdbc.batch_versioned_data"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Set this property to <literal>true</literal> if your JDBC driver returns "
"correct row counts from <literal>executeBatch()</literal>. Iit is usually "
"safe to turn this option on. Hibernate will then use batched DML for "
"automatically versioned data. Defaults to <literal>false</literal>."
msgstr ""
"당신의 JDBC 드라이버가 <placeholder-1/>로부터 정확한 행 카운트들을 반환할 경"
"우에 이 프로퍼티를 <placeholder-2/>로 설정하라(대개 이 옵션을 사용 가능하게 "
"하는 것이 안전하다). 그러면 Hibernate는 자동적으로 버전화 된 데이터에 대해 배"
"치화된(batched) DML을 사용할 것이다. 디폴트는 <placeholder-3/>. <placeholder-"
"4/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.jdbc.factory_class</property>"
msgstr "hibernate.jdbc.factory_class"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Select a custom <interfacename>org.hibernate.jdbc.Batcher</interfacename>. "
"Most applications will not need this configuration property."
msgstr ""
"맞춤형 <placeholder-1/>를 선택한다. 대부분의 어플리케이션들은 이 구성 프로퍼"
"티를 필요로 하지 않을 것이다. <placeholder-2/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>classname.of."
"BatcherFactory</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.jdbc.use_scrollable_resultset</property>"
msgstr "hibernate.jdbc.use_scrollable_resultset"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Enables use of JDBC2 scrollable resultsets by Hibernate. This property is "
"only necessary when using user-supplied JDBC connections. Hibernate uses "
"connection metadata otherwise."
msgstr ""
"Hibernate에 의한 JDBC2 스크롤 가능한 결과셋들의 사용을 가능하게 해준다. 이 프"
"로퍼티는 사용자가 제공한 JDBC커넥션들을 사용할 때에만 필수적이고, 그 밖의 경"
"우 Hibernate는 커넥션 메타데이터를 사용한다. <placeholder-1/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.jdbc.use_streams_for_binary</property>"
msgstr "hibernate.jdbc.use_streams_for_binary"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Use streams when writing/reading <literal>binary</literal> or "
"<literal>serializable</literal> types to/from JDBC. <emphasis>*system-level "
"property*</emphasis>"
msgstr ""
"FUZZY! <placeholder-1/> 또는 <placeholder-2/> 타입들을 읽어들일 때 스트림들"
"을 사용한다(시스템-레벨 프로퍼티). <placeholder-3/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.jdbc.use_get_generated_keys</property>"
msgstr "hibernate.jdbc.use_get_generated_keys"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Enables use of JDBC3 <literal>PreparedStatement.getGeneratedKeys()</literal> "
"to retrieve natively generated keys after insert. Requires JDBC3+ driver and "
"JRE1.4+, set to false if your driver has problems with the Hibernate "
"identifier generators. By default, it tries to determine the driver "
"capabilities using connection metadata."
msgstr ""
"insert 후에 고유하게 생성된 키들을 검색하는데 JDBC3 <placeholder-1/>의 사용"
"을 이용 가능하도록 만든다. JDBC3+ 드라이버와 JRE1.4+를 필요로 하고, 당신의 드"
"라이버가 Hibernate 식별자 생성자들에 문제가 있을 경우에 false로 설정하라. 디"
"폴트로 커넥션 메타 데이터를 사용하여 드라이버 가용성들을 결정하려고 시도하"
"라. <placeholder-2/>"

#. Tag: para
#, fuzzy, no-c-format
msgid "<emphasis role=\"strong\">e.g.</emphasis> <literal>true|false</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.connection.provider_class</property>"
msgstr "hibernate.connection.provider_class"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"The classname of a custom <interfacename>org.hibernate.connection."
"ConnectionProvider</interfacename> which provides JDBC connections to "
"Hibernate."
msgstr ""
"Hibernate에 JDBC 커넥션들을 제공하는 맞춤형 <placeholder-1/>의 클래스명. "
"<placeholder-2/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>classname.of."
"ConnectionProvider</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.connection.isolation</property>"
msgstr "hibernate.connection.isolation"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Sets the JDBC transaction isolation level. Check <interfacename>java.sql."
"Connection</interfacename> for meaningful values, but note that most "
"databases do not support all isolation levels and some define additional, "
"non-standard isolations."
msgstr ""
"JDBC transaction isolation 레벨을 설정한다. 의미있는 값들로 <placeholder-1/>"
"을 체크하지만 대부분의 데이터베이스들이 모든 격리(isolate) 레벨들을 지원하지 "
"않음을 노트하라. <placeholder-2/>"

#. Tag: para
#, fuzzy, no-c-format
msgid "<emphasis role=\"strong\">e.g.</emphasis> <literal>1, 2, 4, 8</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.connection.autocommit</property>"
msgstr "hibernate.connection.autocommit"

#. Tag: entry
#, fuzzy, no-c-format
msgid "Enables autocommit for JDBC pooled connections (it is not recommended)."
msgstr ""
"JDBC 풀링된 커넥션들에 대해 자동커밋을 이용 가능하도록 한다(권장되지 않음). "
"<placeholder-1/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<property>hibernate.connection.release_mode</property>"
msgstr "hibernate.connection.release_mode"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Specifies when Hibernate should release JDBC connections. By default, a JDBC "
"connection is held until the session is explicitly closed or disconnected. "
"For an application server JTA datasource, use <literal>after_statement</"
"literal> to aggressively release connections after every JDBC call. For a "
"non-JTA connection, it often makes sense to release the connection at the "
"end of each transaction, by using <literal>after_transaction</literal>. "
"<literal>auto</literal> will choose <literal>after_statement</literal> for "
"the JTA and CMT transaction strategies and <literal>after_transaction</"
"literal> for the JDBC transaction strategy."
msgstr ""
"Hibernate가 JDBC 커넥션들을 해제하게 될 시점을 지정한다. 디폴트로 한 개의 "
"JDBC 커넥션은 그 세션이 명시적으로 닫히거나 연결해제되기 전까지 보관된다. 어"
"플리케이션 트랜잭션 서버 JTA 데이터소스의 경우, 당신은 모든 JDBC 호출 후에 커"
"넥션들을 과감하게 해제시키기 위해 <placeholder-1/>를 사용해야 한다. 비-JTA 연"
"결의 경우, <placeholder-2/>을 사용하여 각각의 트랜잭션의 끝에서 커넥션들을 해"
"제시키는 것이 종종 의미가 있다. <placeholder-3/>는 JTA 및 CMT 트랜잭션 방도들"
"의 경우에 <placeholder-4/>를 선택하고 JDBC 트랜잭션 방도에 대해 <placeholder-"
"5/>를 선택할 것이다. <placeholder-6/><placeholder-7/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>auto</literal> (default) "
"| <literal>on_close</literal> | <literal>after_transaction</literal> | "
"<literal>after_statement</literal>"
msgstr ""
"<emphasis role=\"strong\">eg.</emphasis><literal>auto</literal> (디폴트) | "
"<literal>on_close</literal> | <literal>after_transaction</literal> | "
"<literal>after_statement</literal>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This setting only affects <literal>Session</literal>s returned from "
"<literal>SessionFactory.openSession</literal>. For <literal>Session</"
"literal>s obtained through <literal>SessionFactory.getCurrentSession</"
"literal>, the <literal>CurrentSessionContext</literal> implementation "
"configured for use controls the connection release mode for those "
"<literal>Session</literal>s. See <xref linkend=\"architecture-current-session"
"\" />"
msgstr ""
"이 설정이 <literal>SessionFactory.openSession</literal>로부터 반환된 "
"<literal>Session</literal>들에만 영향을 준다는 점을 노트하라. "
"<literal>SessionFactory.getCurrentSession</literal>을 통해 얻어진 "
"<literal>Session</literal>들의 경우, 사용하기 위해 구성된 "
"<literal>CurrentSessionContext</literal> 구현이 그들 <literal>Session</"
"literal>들에 대한 연결 해제를 제어한다. <xref linkend=\"architecture-current-"
"session\"/>를 보라."

#. Tag: entry
#, no-c-format
msgid ""
"<property>hibernate.connection.</property><emphasis>&lt;propertyName&gt;</"
"emphasis>"
msgstr ""

#. Tag: entry
#, no-c-format
msgid ""
"Pass the JDBC property <emphasis>&lt;propertyName&gt;</emphasis> to "
"<literal>DriverManager.getConnection()</literal>."
msgstr ""

#. Tag: entry
#, no-c-format
msgid ""
"<property>hibernate.jndi.</property><emphasis>&lt;propertyName&gt;</emphasis>"
msgstr ""

#. Tag: entry
#, no-c-format
msgid ""
"Pass the property <emphasis>&lt;propertyName&gt;</emphasis> to the JNDI "
"<literal>InitialContextFactory</literal>."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Hibernate Cache Properties"
msgstr "Hibernate Cache 프로퍼티들"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.cache.provider_class</literal>"
msgstr "hibernate.cache.provider_class"

#. Tag: entry
#, fuzzy, no-c-format
msgid "The classname of a custom <literal>CacheProvider</literal>."
msgstr "맞춤형 <placeholder-1/>의 클래스명. <placeholder-2/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>classname.of."
"CacheProvider</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.cache.use_minimal_puts</literal>"
msgstr "hibernate.cache.use_minimal_puts"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Optimizes second-level cache operation to minimize writes, at the cost of "
"more frequent reads. This setting is most useful for clustered caches and, "
"in Hibernate3, is enabled by default for clustered cache implementations."
msgstr ""
"읽기가 매우 빈번한 경우에, 쓰기를 최소화 시키기 위해 second-level 캐시 연산"
"을 최적화 시킨다. 이 설정은 Hibernate3에서 클러스터링 된 캐시들에 가장 유용하"
"고, Hibernate3에서는 클러스터링된 캐시 구현들에 대해 디폴트로 이용 가능하다. "
"<placeholder-1/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.cache.use_query_cache</literal>"
msgstr "hibernate.cache.use_query_cache"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Enables the query cache. Individual queries still have to be set cachable."
msgstr ""
"질의 캐시를 가능하게 만든다. 개별 질의들은 여전히 캐시 가능한 것으로 설정되어"
"야 한다. <placeholder-1/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.cache.use_second_level_cache</literal>"
msgstr "hibernate.cache.use_second_level_cache"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Can be used to completely disable the second level cache, which is enabled "
"by default for classes which specify a <literal>&lt;cache&gt;</literal> "
"mapping."
msgstr ""
"second-level 캐시를 완전히 사용 불가능하게 하는데 사용될 수 있고, 그것은 "
"<placeholder-1/> 매핑을 지정하는 클래스들에 대해 디폴트로 이용 가능이다. "
"<placeholder-2/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.cache.query_cache_factory</literal>"
msgstr "hibernate.cache.query_cache_factory"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"The classname of a custom <literal>QueryCache</literal> interface, defaults "
"to the built-in <literal>StandardQueryCache</literal>."
msgstr ""
"맞춤형 <placeholder-1/> 인터페이스의 클래스명. 디폴트는 미리 빌드된 "
"<placeholder-2/>. <placeholder-3/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>classname.of.QueryCache</"
"literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.cache.region_prefix</literal>"
msgstr "hibernate.cache.region_prefix"

#. Tag: entry
#, fuzzy, no-c-format
msgid "A prefix to use for second-level cache region names."
msgstr "second-level 캐시 영역 이름들에 사용할 접두어. <placeholder-1/>"

#. Tag: para
#, fuzzy, no-c-format
msgid "<emphasis role=\"strong\">e.g.</emphasis> <literal>prefix</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.cache.use_structured_entries</literal>"
msgstr "hibernate.cache.use_structured_entries"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Forces Hibernate to store data in the second-level cache in a more human-"
"friendly format."
msgstr ""
"인간에게 보다 더 친숙한 형식으로 second-level 캐시 속에 데이터를 저장하도록 "
"Hibernate에게 강제시킨다.. <placeholder-1/>"

#. Tag: title
#, no-c-format
msgid "Hibernate Transaction Properties"
msgstr "Hibernate 트랜잭션 프로퍼티들"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.transaction.factory_class</literal>"
msgstr "hibernate.transaction.factory_class"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"The classname of a <literal>TransactionFactory</literal> to use with "
"Hibernate <literal>Transaction</literal> API (defaults to "
"<literal>JDBCTransactionFactory</literal>)."
msgstr ""
"Hibernate <placeholder-1/> API 에 사용할 <placeholder-2/>의 클래스 이름.(디폴"
"트는 <placeholder-3/>). <placeholder-4/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>classname.of."
"TransactionFactory</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>jta.UserTransaction</literal>"
msgstr "jta.UserTransaction"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"A JNDI name used by <literal>JTATransactionFactory</literal> to obtain the "
"JTA <literal>UserTransaction</literal> from the application server."
msgstr ""
"어플리케이션 서버로부터 JTA <placeholder-1/>을 얻기 위해 <placeholder-2/>에 "
"의해 사용되는 JNDI 이름. <placeholder-3/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.transaction.manager_lookup_class</literal>"
msgstr "hibernate.transaction.manager_lookup_class"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"The classname of a <literal>TransactionManagerLookup</literal>. It is "
"required when JVM-level caching is enabled or when using hilo generator in a "
"JTA environment."
msgstr ""
"<placeholder-1/>의 클래스명- JVM 레벨의 캐싱이 이용 가능할 때 또는 JTA 환경에"
"서 hilo generator를 사용할 때 필요하다. <placeholder-2/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>classname.of."
"TransactionManagerLookup</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.transaction.flush_before_completion</literal>"
msgstr "hibernate.transaction.flush_before_completion"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"If enabled, the session will be automatically flushed during the before "
"completion phase of the transaction. Built-in and automatic session context "
"management is preferred, see <xref linkend=\"architecture-current-session\" /"
">."
msgstr ""
"만일 사용가능하도록 되면, 세션은 트랜잭션의 before completion 단계 동안에 자"
"동적으로 flush 될 것이다. 빌드되어 있는 자동적인 세션 컨텍스트 관리가 선호되"
"는데, <xref linkend=\"architecture-current-session\"/>를 보라. <placeholder-"
"1/>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.transaction.auto_close_session</literal>"
msgstr "hibernate.transaction.auto_close_session"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"If enabled, the session will be automatically closed during the after "
"completion phase of the transaction. Built-in and automatic session context "
"management is preferred, see <xref linkend=\"architecture-current-session\" /"
">."
msgstr ""
"만일 사용가능토록 하면, after completion 단계 동안에 세션이 자동적으로 닫혀"
"질 것이다. (CMT에 대해 Hibernate를 사용할 때 매우 유용하다.) <placeholder-1/>"

#. Tag: title
#, no-c-format
msgid "Miscellaneous Properties"
msgstr "여러가지 프로퍼티들"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.current_session_context_class</literal>"
msgstr "hibernate.current_session_context_class"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Supply a custom strategy for the scoping of the \"current\" "
"<literal>Session</literal>. See <xref linkend=\"architecture-current-session"
"\" /> for more information about the built-in strategies."
msgstr ""
"\"현재\" <placeholder-1/>의 영역화를 위한 하나의 (맞춤) 방도를 제공한다. 빌드"
"되어 있는 방도들에 대한 추가 정보는 <xref linkend=\"architecture-current-"
"session\"/>를 보라. <placeholder-2/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>jta</literal> | "
"<literal>thread</literal> | <literal>managed</literal> | <literal>custom."
"Class</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>jta</literal> | "
"<literal>thread</literal> | <literal>managed</literal> | <literal>custom."
"Class</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.query.factory_class</literal>"
msgstr "hibernate.query.factory_class"

#. Tag: entry
#, fuzzy, no-c-format
msgid "Chooses the HQL parser implementation."
msgstr "Chooses the HQL 파서 구현을 선택한다. <placeholder-1/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>org.hibernate.hql.ast."
"ASTQueryTranslatorFactory</literal> or <literal>org.hibernate.hql.classic."
"ClassicQueryTranslatorFactory</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>org.hibernate.hql.ast."
"ASTQueryTranslatorFactory</literal> or <literal>org.hibernate.hql.classic."
"ClassicQueryTranslatorFactory</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.query.substitutions</literal>"
msgstr "hibernate.query.substitutions"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Is used to map from tokens in Hibernate queries to SQL tokens (tokens might "
"be function or literal names, for example)."
msgstr ""
"Hibernate 질의들 내의 토큰들로부터 SQL 토큰들로의 매핑 (예를 들어 토큰들은 함"
"수 이름 또는 리터럴 이름일 수 있다). <placeholder-1/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>hqlLiteral=SQL_LITERAL, "
"hqlFunction=SQLFUNC</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>true</literal> | "
"<literal>false</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.hbm2ddl.auto</literal>"
msgstr "hibernate.hbm2ddl.auto"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Automatically validates or exports schema DDL to the database when the "
"<literal>SessionFactory</literal> is created. With <literal>create-drop</"
"literal>, the database schema will be dropped when the "
"<literal>SessionFactory</literal> is closed explicitly."
msgstr ""
"<placeholder-1/>가 생성될 때, 자동적으로 유효성을 검사하거나 schema DDL을 데"
"이터베이스로 내보내기 한다. <placeholder-2/>의 경우, <placeholder-3/>가 명시"
"적으로 닫혀질 때 데이터베이스 스키마가 드롭될 것이다. <placeholder-4/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"strong\">e.g.</emphasis> <literal>validate</literal> | "
"<literal>update</literal> | <literal>create</literal> | <literal>create-"
"drop</literal>"
msgstr ""
"<emphasis role=\"strong\">예.</emphasis><literal>validate</literal> | "
"<literal>update</literal> | <literal>create</literal> | <literal>create-"
"drop</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>hibernate.cglib.use_reflection_optimizer</literal>"
msgstr "hibernate.cglib.use_reflection_optimizer"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Enables the use of CGLIB instead of runtime reflection (System-level "
"property). Reflection can sometimes be useful when troubleshooting. "
"Hibernate always requires CGLIB even if you turn off the optimizer. You "
"cannot set this property in <literal>hibernate.cfg.xml</literal>."
msgstr ""
"런타임 reflection 대신에 CGLIB의 사용을 가능하도록 만든다(시스템 레벨 프로퍼"
"티). Reflection은 문제가 발생할 시에 때때로 유용할 수 있고, 당신이 optimizer"
"를 사용하지 않을 경우조차도 Hibernate는 항상 필요로 함을 유의하라. 당신은 "
"<placeholder-1/> 속에 이 프로퍼티를 설정할수 없다. <placeholder-2/>"

#. Tag: title
#, no-c-format
msgid "SQL Dialects"
msgstr "SQL Dialects"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Always set the <literal>hibernate.dialect</literal> property to the correct "
"<literal>org.hibernate.dialect.Dialect</literal> subclass for your database. "
"If you specify a dialect, Hibernate will use sensible defaults for some of "
"the other properties listed above. This means that you will not have to "
"specify them manually."
msgstr ""
"당신은 항상 당신의 데이터베이스를 위해 <literal>hibernate.dialect</literal> "
"프로퍼티를 정확한 <literal>org.hibernate.dialect.Dialect</literal> 서브클래스"
"로 설정해야 한다. 만일 당신이 dialect를 지정할 경우, 당신이 프로퍼티들을 수작"
"업으로 지정하는 노력을 절약하도록 Hibernate는 위에 열거된 다른 프로퍼티들 중 "
"몇몇에 대해 의미있는 디폴트들을 사용할 것이다."

#. Tag: title
#, no-c-format
msgid "Hibernate SQL Dialects (<literal>hibernate.dialect</literal>)"
msgstr "Hibernate SQL Dialects (<literal>hibernate.dialect</literal>)"

#. Tag: entry
#, no-c-format
msgid "RDBMS"
msgstr "RDBMS"

#. Tag: entry
#, no-c-format
msgid "Dialect"
msgstr "Dialect"

#. Tag: entry
#, no-c-format
msgid "DB2"
msgstr "DB2"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.DB2Dialect</literal>"
msgstr "org.hibernate.dialect.DB2Dialect"

#. Tag: entry
#, no-c-format
msgid "DB2 AS/400"
msgstr "DB2 AS/400"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.DB2400Dialect</literal>"
msgstr "org.hibernate.dialect.DB2400Dialect"

#. Tag: entry
#, no-c-format
msgid "DB2 OS390"
msgstr "DB2 OS390"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.DB2390Dialect</literal>"
msgstr "org.hibernate.dialect.DB2390Dialect"

#. Tag: entry
#, no-c-format
msgid "PostgreSQL"
msgstr "PostgreSQL"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.PostgreSQLDialect</literal>"
msgstr "org.hibernate.dialect.PostgreSQLDialect"

#. Tag: entry
#, no-c-format
msgid "MySQL"
msgstr "MySQL"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.MySQLDialect</literal>"
msgstr "org.hibernate.dialect.MySQLDialect"

#. Tag: entry
#, no-c-format
msgid "MySQL with InnoDB"
msgstr "MySQL with InnoDB"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.MySQLInnoDBDialect</literal>"
msgstr "org.hibernate.dialect.MySQLInnoDBDialect"

#. Tag: entry
#, no-c-format
msgid "MySQL with MyISAM"
msgstr "MySQL with MyISAM"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.MySQLMyISAMDialect</literal>"
msgstr "org.hibernate.dialect.MySQLMyISAMDialect"

#. Tag: entry
#, no-c-format
msgid "Oracle (any version)"
msgstr "Oracle (any version)"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.OracleDialect</literal>"
msgstr "org.hibernate.dialect.OracleDialect"

#. Tag: entry
#, fuzzy, no-c-format
msgid "Oracle 9i"
msgstr "Oracle 9i/10g"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.Oracle9iDialect</literal>"
msgstr "org.hibernate.dialect.Oracle9Dialect"

#. Tag: entry
#, fuzzy, no-c-format
msgid "Oracle 10g"
msgstr "Oracle 9i/10g"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.Oracle10gDialect</literal>"
msgstr "org.hibernate.dialect.OracleDialect"

#. Tag: entry
#, no-c-format
msgid "Sybase"
msgstr "Sybase"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.SybaseDialect</literal>"
msgstr "org.hibernate.dialect.SybaseDialect"

#. Tag: entry
#, no-c-format
msgid "Sybase Anywhere"
msgstr "Sybase Anywhere"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.SybaseAnywhereDialect</literal>"
msgstr "org.hibernate.dialect.SybaseAnywhereDialect"

#. Tag: entry
#, no-c-format
msgid "Microsoft SQL Server"
msgstr "Microsoft SQL Server"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.SQLServerDialect</literal>"
msgstr "org.hibernate.dialect.SQLServerDialect"

#. Tag: entry
#, no-c-format
msgid "SAP DB"
msgstr "SAP DB"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.SAPDBDialect</literal>"
msgstr "org.hibernate.dialect.SAPDBDialect"

#. Tag: entry
#, no-c-format
msgid "Informix"
msgstr "Informix"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.InformixDialect</literal>"
msgstr "org.hibernate.dialect.InformixDialect"

#. Tag: entry
#, no-c-format
msgid "HypersonicSQL"
msgstr "HypersonicSQL"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.HSQLDialect</literal>"
msgstr "org.hibernate.dialect.HSQLDialect"

#. Tag: entry
#, no-c-format
msgid "Ingres"
msgstr "Ingres"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.IngresDialect</literal>"
msgstr "org.hibernate.dialect.IngresDialect"

#. Tag: entry
#, no-c-format
msgid "Progress"
msgstr "Progress"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.ProgressDialect</literal>"
msgstr "org.hibernate.dialect.ProgressDialect"

#. Tag: entry
#, no-c-format
msgid "Mckoi SQL"
msgstr "Mckoi SQL"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.MckoiDialect</literal>"
msgstr "org.hibernate.dialect.MckoiDialect"

#. Tag: entry
#, no-c-format
msgid "Interbase"
msgstr "Interbase"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.InterbaseDialect</literal>"
msgstr "org.hibernate.dialect.InterbaseDialect"

#. Tag: entry
#, no-c-format
msgid "Pointbase"
msgstr "Pointbase"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.PointbaseDialect</literal>"
msgstr "org.hibernate.dialect.PointbaseDialect"

#. Tag: entry
#, no-c-format
msgid "FrontBase"
msgstr "FrontBase"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.FrontbaseDialect</literal>"
msgstr "org.hibernate.dialect.FrontbaseDialect"

#. Tag: entry
#, no-c-format
msgid "Firebird"
msgstr "Firebird"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.dialect.FirebirdDialect</literal>"
msgstr "org.hibernate.dialect.FirebirdDialect"

#. Tag: title
#, no-c-format
msgid "Outer Join Fetching"
msgstr "Outer Join Fetching"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If your database supports ANSI, Oracle or Sybase style outer joins, "
"<emphasis>outer join fetching</emphasis> will often increase performance by "
"limiting the number of round trips to and from the database. This is, "
"however, at the cost of possibly more work performed by the database itself. "
"Outer join fetching allows a whole graph of objects connected by many-to-"
"one, one-to-many, many-to-many and one-to-one associations to be retrieved "
"in a single SQL <literal>SELECT</literal>."
msgstr ""
"만일 당신의 데이터베이스가 ANSI, Oracle, 또는 Sybase 스타일의 outer join들을 "
"지원할 경우, <emphasis>outer join fetching</emphasis>은 (데이터베이스 그 자체"
"에 의해 보다 더 많은 작업이 수행되는 비용으로) 데이터베이스로의 그리고 데이터"
"베이스로부터의 라운드 트립들의 개수를 제한함으로써 종종 퍼포먼스를 증가시킬 "
"것이다. Outer join fetching은 many-to-one, one-to-many, many-to-many,one-to-"
"one 연관관계들이 에 의해 연결된 객체들의 전체 그래프가 하나의 SQL "
"<literal>SELECT</literal> 속에서 검색되게끔 허용해준다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Outer join fetching can be disabled <emphasis>globally</emphasis> by setting "
"the property <literal>hibernate.max_fetch_depth</literal> to <literal>0</"
"literal>. A setting of <literal>1</literal> or higher enables outer join "
"fetching for one-to-one and many-to-one associations that have been mapped "
"with <literal>fetch=\"join\"</literal>."
msgstr ""
"Outer join fetching은 hibernate.max_fetch_depth 프로퍼티를 <literal>0</"
"literal>으로 설정함으로써 <emphasis>전역적으로</emphasis> 사용 불가능하게 할 "
"수 있다. <literal>1</literal> 이상의 값을 설정하는 것은 <literal>fetch=\"join"
"\"</literal>으로 매핑되었던 모든 one-to-one 및 many-to-one 연관관계들에 대해 "
"outer join fetching을 사용 가능하도록 만든다."

#. Tag: para
#, fuzzy, no-c-format
msgid "See <xref linkend=\"performance-fetching\" /> for more information."
msgstr "추가 정보는 <xref linkend=\"performance-fetching\"/>를 보라."

#. Tag: title
#, no-c-format
msgid "Binary Streams"
msgstr "Binary Streams"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Oracle limits the size of <literal>byte</literal> arrays that can be passed "
"to and/or from its JDBC driver. If you wish to use large instances of "
"<literal>binary</literal> or <literal>serializable</literal> type, you "
"should enable <literal>hibernate.jdbc.use_streams_for_binary</literal>. "
"<emphasis>This is a system-level setting only.</emphasis>"
msgstr ""
"Oracle은 JDBC 드라이버 로/부터 전달되는 <literal>byte</literal> 배열들의 크기"
"를 제한시킨다. 만일 당신이 <literal>binary</literal> 또는 "
"<literal>serializable</literal> 타입의 대형 인스턴스를 사용하고자 원할 경우"
"에, 당신은 <literal>hibernate.jdbc.use_streams_for_binary</literal>를 사용 가"
"능하게 해야 할 것이다. <emphasis>이것은 오직 시스템 레벨 설정이다.</emphasis>"

#. Tag: title
#, no-c-format
msgid "Second-level and query cache"
msgstr "Second-level 캐시와 query 캐시"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The properties prefixed by <literal>hibernate.cache</literal> allow you to "
"use a process or cluster scoped second-level cache system with Hibernate. "
"See the <xref linkend=\"performance-cache\" /> for more information."
msgstr ""
"<literal>hibernate.cache</literal> 접두어가 붙은 프로퍼티들은 Hibernate에 대"
"해 프로세스 또는 클러스터 범위의 두 번째 레벨 캐시 시스템을 사용하는 것을 허"
"용해준다. 상세한 것은 <xref linkend=\"performance-cache\"/>를 보라."

#. Tag: title
#, no-c-format
msgid "Query Language Substitution"
msgstr "Query Language 치환"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can define new Hibernate query tokens using <literal>hibernate.query."
"substitutions</literal>. For example:"
msgstr ""
"당신은 <literal>hibernate.query.substitutions</literal>을 사용하여 새로운 "
"Hibernate 질의 토큰들을 정의할 수 있다. 예를 들어:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This would cause the tokens <literal>true</literal> and <literal>false</"
"literal> to be translated to integer literals in the generated SQL."
msgstr ""
"은<literal>true</literal>와 <literal>false</literal> 토큰들이 생성된 SQL 내에"
"서 정수 리터럴들로 번역되도록 강제할 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This would allow you to rename the SQL <literal>LOWER</literal> function."
msgstr ""
"은 SQL <literal>LOWER</literal> function 함수 이름을 변경하는 것을 당신에게 "
"허용해 줄 것이다"

#. Tag: title
#, no-c-format
msgid "Hibernate statistics"
msgstr "Hibernate 통계"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you enable <literal>hibernate.generate_statistics</literal>, Hibernate "
"exposes a number of metrics that are useful when tuning a running system via "
"<literal>SessionFactory.getStatistics()</literal>. Hibernate can even be "
"configured to expose these statistics via JMX. Read the Javadoc of the "
"interfaces in <literal>org.hibernate.stats</literal> for more information."
msgstr ""
"만일 당신이 <literal>hibernate.generate_statistics</literal>를 사용 가능하도"
"록 할 경우, Hibernate는 <literal>SessionFactory.getStatistics()</literal>를 "
"통해 가동 중인 시스템을 튜닝할 때 유용한 많은 통계들을 노출시킬 것이다. "
"Hibernate는 심지어 JMX를 통해 이들 통계들을 노출시키도록 구성될 수 있다. 추"
"가 정보는 <literal>org.hibernate.stats</literal>에 있는 인터페이스들에 관한 "
"Javadoc를 읽어라."

#. Tag: title
#, no-c-format
msgid "Logging"
msgstr "로깅"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate utilizes <ulink url=\"http://www.slf4j.org/\">Simple Logging "
"Facade for Java</ulink> (SLF4J) in order to log various system events. SLF4J "
"can direct your logging output to several logging frameworks (NOP, Simple, "
"log4j version 1.2, JDK 1.4 logging, JCL or logback) depending on your chosen "
"binding. In order to setup logging you will need <filename>slf4j-api.jar</"
"filename> in your classpath together with the jar file for your preferred "
"binding - <filename>slf4j-log4j12.jar</filename> in the case of Log4J. See "
"the SLF4J <ulink url=\"http://www.slf4j.org/manual.html\">documentation</"
"ulink> for more detail. To use Log4j you will also need to place a "
"<filename>log4j.properties</filename> file in your classpath. An example "
"properties file is distributed with Hibernate in the <literal>src/</literal> "
"directory."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is recommended that you familiarize yourself with Hibernate's log "
"messages. A lot of work has been put into making the Hibernate log as "
"detailed as possible, without making it unreadable. It is an essential "
"troubleshooting device. The most interesting log categories are the "
"following:"
msgstr ""
"우리는 당신이 Hibernate의 로그 메시지들에 익숙해지기를 강력히 권장한다. 읽기 "
"불가능하지 않게끔 가능한 한 상세하게 Hibernate 로그를 만들도록 많은 작업이 행"
"해졌다. 그것은 본질적인 문제던지기 장치이다. 가장 흥미로운 로그 카테고리들이 "
"다음에 있다:"

#. Tag: title
#, no-c-format
msgid "Hibernate Log Categories"
msgstr "Hibernate 로그 카테고리들"

#. Tag: entry
#, no-c-format
msgid "Category"
msgstr "카테고리"

#. Tag: entry
#, no-c-format
msgid "Function"
msgstr "기능"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.SQL</literal>"
msgstr "org.hibernate.SQL"

#. Tag: entry
#, no-c-format
msgid "Log all SQL DML statements as they are executed"
msgstr "SQL DML 문장들이 실행될 때 그것들 모두를 로그 시킨다"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.type</literal>"
msgstr "org.hibernate.type"

#. Tag: entry
#, no-c-format
msgid "Log all JDBC parameters"
msgstr "모든 JDBC 파라미터들을 로그시킨다"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.tool.hbm2ddl</literal>"
msgstr "org.hibernate.tool.hbm2ddl"

#. Tag: entry
#, no-c-format
msgid "Log all SQL DDL statements as they are executed"
msgstr "SQL DDL 문장들이 실행될 때 그것들 모두를 로그 시킨다"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.pretty</literal>"
msgstr "org.hibernate.pretty"

#. Tag: entry
#, no-c-format
msgid ""
"Log the state of all entities (max 20 entities) associated with the session "
"at flush time"
msgstr ""
"flush 시점에서 세션과 연관된 모든 엔티티들(최대 20개의 엔티티들)의 상태를 로"
"그 시킨다"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.cache</literal>"
msgstr "org.hibernate.cache"

#. Tag: entry
#, no-c-format
msgid "Log all second-level cache activity"
msgstr "모든 second-level 캐시 액티비티를 로그시킨다"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.transaction</literal>"
msgstr "org.hibernate.transaction"

#. Tag: entry
#, no-c-format
msgid "Log transaction related activity"
msgstr "트랜잭션 관련 액티비티를 로그 시킨다"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.jdbc</literal>"
msgstr "org.hibernate.jdbc"

#. Tag: entry
#, no-c-format
msgid "Log all JDBC resource acquisition"
msgstr "모든 JDBC 리소스 취득을 로그 시킨다"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.hql.ast.AST</literal>"
msgstr "org.hibernate.hql.ast.AST"

#. Tag: entry
#, no-c-format
msgid "Log HQL and SQL ASTs during query parsing"
msgstr "질의 파싱 동안에 HQL AST와 SQL AST를 로그시킨다"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.secure</literal>"
msgstr "org.hibernate.secure"

#. Tag: entry
#, no-c-format
msgid "Log all JAAS authorization requests"
msgstr "모든 JAAS 허가 요청들을 로그시킨다"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>org.hibernate</literal>"
msgstr "JNDI-bound <literal>SessionFactory</literal>"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"Log everything. This is a lot of information but it is useful for "
"troubleshooting"
msgstr "모든 것을 로그시킨다(많은 정보이지만, 문제해결에 매우 유용하다)"

#. Tag: para
#, no-c-format
msgid ""
"When developing applications with Hibernate, you should almost always work "
"with <literal>debug</literal> enabled for the category <literal>org."
"hibernate.SQL</literal>, or, alternatively, the property <literal>hibernate."
"show_sql</literal> enabled."
msgstr ""
"Hibernate로 어플리케이션들을 개발할 때, 당신은 거의 항상 <literal>org."
"hibernate.SQL</literal> 카테고리에 대해 이용 가능한 <literal>debug</literal> "
"모드로 작업하거나, 다른 방법으로 <literal>hibernate.show_sql</literal> 프로퍼"
"티를 이용가능하게 하여 작업해야 할 것이다."

#. Tag: title
#, no-c-format
msgid "Implementing a <literal>NamingStrategy</literal>"
msgstr "<literal>NamingStrategy</literal> 구현하기"

#. Tag: para
#, no-c-format
msgid ""
"The interface <literal>org.hibernate.cfg.NamingStrategy</literal> allows you "
"to specify a \"naming standard\" for database objects and schema elements."
msgstr ""
"<literal>org.hibernate.cfg.NamingStrategy</literal> 인터페이스는 데이터베이"
"스 객체들과 스키마 요소들에 대한 \"네이밍 표준\"을 지정하는 것을 당신에게 허"
"용해준다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can provide rules for automatically generating database identifiers from "
"Java identifiers or for processing \"logical\" column and table names given "
"in the mapping file into \"physical\" table and column names. This feature "
"helps reduce the verbosity of the mapping document, eliminating repetitive "
"noise (<literal>TBL_</literal> prefixes, for example). The default strategy "
"used by Hibernate is quite minimal."
msgstr ""
"당신은 Java 식별자들로부터 데이터베이스 식별자들을 자동적으로 생성시키거나 매"
"핑 파일에 주어진 \"논리적\" 컬럼과 테이블 이름들을 \"물리적\" 테이블과 컬럼 "
"이름들로 자동적으로 처리하는 규칙들을 제공할 수 있다. 이 특징은 반복되는 잡음"
"(예를 들어 <literal>TBL_</literal>접두어들)을 제거함으로써, 매핑 문서의 말많"
"은 장황함을 감소시키도록 도와준다. Hibernate에 의해 사용되는 디폴트 방도는 아"
"주 작은 작품이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can specify a different strategy by calling <literal>Configuration."
"setNamingStrategy()</literal> before adding mappings:"
msgstr ""
"당신은 매핑들을 추가하기 이전에 <literal>Configuration.setNamingStrategy()</"
"literal>를 호출함으로써 다른 방도를 지정할 수 있다:"

#. Tag: para
#, no-c-format
msgid ""
"<literal>org.hibernate.cfg.ImprovedNamingStrategy</literal> is a built-in "
"strategy that might be a useful starting point for some applications."
msgstr ""
"<literal>org.hibernate.cfg.ImprovedNamingStrategy</literal>는 어떤 어플리케이"
"션들에 대한 유용한 시작점일 수 있는 미리 빌드된 방도이다."

#. Tag: title
#, no-c-format
msgid "XML configuration file"
msgstr "XML 구성 파일"

#. Tag: para
#, no-c-format
msgid ""
"An alternative approach to configuration is to specify a full configuration "
"in a file named <literal>hibernate.cfg.xml</literal>. This file can be used "
"as a replacement for the <literal>hibernate.properties</literal> file or, if "
"both are present, to override properties."
msgstr ""
"구성에 대한 다른 접근법은 <literal>hibernate.cfg.xml</literal>로 명명된 파일 "
"속에 전체 구성을 지정하는 것이다. 이 파일은 <literal>hibernate.properties</"
"literal> 파일에 대한 대용물로서 사용될 수 있거나, 만일 둘 다 존재할 경우에 프"
"로퍼티들을 중복정의하는데 사용될 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The XML configuration file is by default expected to be in the root of your "
"<literal>CLASSPATH</literal>. Here is an example:"
msgstr ""
"XML 구성 파일은 디폴트로 당신의 <literal>CLASSPATH</literal>의 루트에 존재하"
"는 것이 기대된다. 다음은 예제이다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The advantage of this approach is the externalization of the mapping file "
"names to configuration. The <literal>hibernate.cfg.xml</literal> is also "
"more convenient once you have to tune the Hibernate cache. It is your choice "
"to use either <literal>hibernate.properties</literal> or <literal>hibernate."
"cfg.xml</literal>. Both are equivalent, except for the above mentioned "
"benefits of using the XML syntax."
msgstr ""
"당신이 볼 수 있듯이, 이 접근법의 장점은 구성에 대한 매핑 파일 이름들을 구체"
"화 시키는 것이다. <literal>hibernate.cfg.xml</literal>은 또한 당신이 "
"Hibernate 캐시를 튜닝해야할 때 보다 편리하다. <literal>hibernate.properties</"
"literal> 또는 <literal>hibernate.cfg.xml</literal> 중 어느 것을 사용하는가는 "
"당신의 선택이다. XML 구문을 사용하는 위에 언급된 이점들을 제외하면 둘다 같은 "
"것임을 노트하라."

#. Tag: para
#, fuzzy, no-c-format
msgid "With the XML configuration, starting Hibernate is then as simple as:"
msgstr "Hibernate 구성으로, Hibernate를 시작하는 것은 다음과 같이 간단하다"

#. Tag: para
#, fuzzy, no-c-format
msgid "You can select a different XML configuration file using:"
msgstr "당신은 다음을 사용하여 다른 XML 구성 파일을 찾아낼 수 있다"

#. Tag: title
#, no-c-format
msgid "J2EE Application Server integration"
msgstr "J2EE 어플리케이션 서버 통합"

#. Tag: para
#, no-c-format
msgid "Hibernate has the following integration points for J2EE infrastructure:"
msgstr "Hibernate는 J2EE 인프라스트럭처에 대한 다음 통합 점들을 갖고 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis>Container-managed datasources</emphasis>: Hibernate can use JDBC "
"connections managed by the container and provided through JNDI. Usually, a "
"JTA compatible <literal>TransactionManager</literal> and a "
"<literal>ResourceManager</literal> take care of transaction management "
"(CMT), especially distributed transaction handling across several "
"datasources. You can also demarcate transaction boundaries programmatically "
"(BMT), or you might want to use the optional Hibernate <literal>Transaction</"
"literal> API for this to keep your code portable."
msgstr ""
"<emphasis>Container-managed datasources</emphasis>: Hibernate는 컨테이너에 의"
"해 관리되는 JDBC 커넥션들을 사용할 수 있고 JNDI를 통해 제공된다. 대개 JTA 호"
"환 <literal>TransactionManager</literal>와 <literal>ResourceManager</literal>"
"는 트랜잭션 관리(CMT), 특히 몇몇 데이터소스들을 가로질러 분산된 트랜잭션 핸들"
"링을 처리한다. 물론 당신은 또한 프로그램 상으로 트랜잭션 경계들을 한정할 수"
"도 있거나(BMT) 당신은 당신의 코드가 이식성을 유지하도록 이것에 대한 선택적인 "
"Hibernate <literal>Transaction</literal> API를 사용하고자 원할 수도 있다."

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Automatic JNDI binding</emphasis>: Hibernate can bind its "
"<literal>SessionFactory</literal> to JNDI after startup."
msgstr ""
"<emphasis>자동적인 JNDI 바인딩</emphasis>: Hibernate는 시작 후에 그것의 "
"<literal>SessionFactory</literal>를 JNDI에 바인드 시킬 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis>JTA Session binding:</emphasis> the Hibernate <literal>Session</"
"literal> can be automatically bound to the scope of JTA transactions. Simply "
"lookup the <literal>SessionFactory</literal> from JNDI and get the current "
"<literal>Session</literal>. Let Hibernate manage flushing and closing the "
"<literal>Session</literal> when your JTA transaction completes. Transaction "
"demarcation is either declarative (CMT) or programmatic (BMT/"
"UserTransaction)."
msgstr ""
"<emphasis>JTA Session 바인딩</emphasis>: Hibernate <literal>Session</literal>"
"은 JTA 트랜잭션들의 영역(scope)에 자동적으로 바인드 시킬 수도 있다. 간단하게 "
"JNDI로부터 <literal>SessionFactory</literal>를 룩업하고 현재 "
"<literal>Session</literal>을 얻어라. Hibernate로 하여금 당신의 JTA 트랜잭션"
"이 완료될 때 <literal>Session</literal>을 flush시키고 닫는 것을 처리하도록 하"
"라. 트랜잭션 경계 구분은 선언적(CMT)이거나 프로그래밍적((BMT/"
"UserTransaction))이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis>JMX deployment:</emphasis> if you have a JMX capable application "
"server (e.g. JBoss AS), you can choose to deploy Hibernate as a managed "
"MBean. This saves you the one line startup code to build your "
"<literal>SessionFactory</literal> from a <literal>Configuration</literal>. "
"The container will startup your <literal>HibernateService</literal> and also "
"take care of service dependencies (datasource has to be available before "
"Hibernate starts, etc)."
msgstr ""
"<emphasis>JMX 배치</emphasis>: 만일 당신이 JMX 가용성이 있는 어플리케이션 서"
"버(예를 들면 JBoss AS)를 갖고 있다면, 당신은 Hibernate를 하나의 managed MBean"
"으로서 배치하는 것을 선택할 수 있다. 이것은 <literal>Configuration</literal>"
"으로부터 당신의 <literal>SessionFactory</literal>를 빌드 시키는 한 줄의 시작 "
"코드를 절약해준다. 컨테이너는 당신의 <literal>HibernateService</literal>를 시"
"작할 것이고, 또한 이상적으로 서비스 의존성들을 처리할 것이다(데이터소스는 "
"Hibernate가 시작되기 전에 이용 가능해야 한다)."

#. Tag: para
#, no-c-format
msgid ""
"Depending on your environment, you might have to set the configuration "
"option <literal>hibernate.connection.aggressive_release</literal> to true if "
"your application server shows \"connection containment\" exceptions."
msgstr ""
"당신의 환경에 따라, 당신은 당신의 어플리케이션 서버가 \"connection "
"containment(연결 봉쇄)\" 예외상황들을 보일 경우에 구성 옵션 "
"<literal>hibernate.connection.aggressive_release</literal>를 true로 설정해야 "
"될 수도 있다."

#. Tag: title
#, no-c-format
msgid "Transaction strategy configuration"
msgstr "트랜잭션 방도 구성"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The Hibernate <literal>Session</literal> API is independent of any "
"transaction demarcation system in your architecture. If you let Hibernate "
"use JDBC directly through a connection pool, you can begin and end your "
"transactions by calling the JDBC API. If you run in a J2EE application "
"server, you might want to use bean-managed transactions and call the JTA API "
"and <literal>UserTransaction</literal> when needed."
msgstr ""
"Hibernate <literal>Session</literal> API는 당신의 아카텍처 내에서 임의의 트랜"
"잭션 관할 시스템에 독립적이다. 만일 당신이 Hibernate로 하여금 커넥션 풀을 통"
"해 직접 JDBC를 사용하도록 강제할 경우, 당신은 JDBC API를 호출하여 당신의 트랜"
"잭션을 시작하고 끝낼 수 있다. 만일 당신이 J2EE 어플리케이션 서버를 실행 중이"
"라면, 당신은 필요할 때 bean-managed 트랜잭션들을 사용하고 JTA API와 "
"<literal>UserTransaction</literal>을 호출하고자 원할 수 있다."

#. Tag: para
#, no-c-format
msgid ""
"To keep your code portable between these two (and other) environments we "
"recommend the optional Hibernate <literal>Transaction</literal> API, which "
"wraps and hides the underlying system. You have to specify a factory class "
"for <literal>Transaction</literal> instances by setting the Hibernate "
"configuration property <literal>hibernate.transaction.factory_class</"
"literal>."
msgstr ""
"이들 두 개의 (그리고 다른) 환경들에서 당신의 코드에 이식성을 유지하기 위해 우"
"리는 기본 시스템을 포장하고 은폐시키는 선택적인 Hibernate "
"<literal>Transaction</literal> API를 권장한다. 당신은 Hibernate 구성 프로퍼"
"티 <literal>hibernate.transaction.factory_class</literal>를 사용하여 "
"<literal>Transaction</literal> 인스턴스들에 대한 팩토리 클래스를 지정해야 한"
"다."

#. Tag: para
#, fuzzy, no-c-format
msgid "There are three standard, or built-in, choices:"
msgstr "세 개의 표준(미리 만들어진) 선택들이 존재한다:"

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.transaction.JDBCTransactionFactory</literal>"
msgstr "org.hibernate.transaction.JDBCTransactionFactory"

#. Tag: para
#, no-c-format
msgid "delegates to database (JDBC) transactions (default)"
msgstr "데이터베이스 (JDBC) 트랜잭션들에게 위임시킨다(디폴트)"

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.transaction.JTATransactionFactory</literal>"
msgstr "org.hibernate.transaction.JTATransactionFactory"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"delegates to container-managed transactions if an existing transaction is "
"underway in this context (for example, EJB session bean method). Otherwise, "
"a new transaction is started and bean-managed transactions are used."
msgstr ""
"기존의 트랜잭션이 이 컨텍스트(예를 들면 EJB session bean 메소드) 내에서 진행 "
"중일 경우에 container-managed transaction에게 위임시키고, 그 밖의 경우 새로"
"운 트랜잭션이 시작되고 bean-managed transaction이 사용된다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>org.hibernate.transaction.CMTTransactionFactory</literal>"
msgstr "org.hibernate.transaction.CMTTransactionFactory"

#. Tag: para
#, no-c-format
msgid "delegates to container-managed JTA transactions"
msgstr "container-managed JTA 트랜잭션들에게 위임시킨다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can also define your own transaction strategies (for a CORBA transaction "
"service, for example)."
msgstr ""
"당신은 또한 당신 자신의 트랜잭션 방도들(예를 들면 CORBA 트랜잭션 서비스)을 정"
"의할 수도 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Some features in Hibernate (i.e., the second level cache, Contextual "
"Sessions with JTA, etc.) require access to the JTA "
"<literal>TransactionManager</literal> in a managed environment. In an "
"application server, since J2EE does not standardize a single mechanism, you "
"have to specify how Hibernate should obtain a reference to the "
"<literal>TransactionManager</literal>:"
msgstr ""
"Hibernate에 있는 몇몇 특징들(예를 들면. second level 캐시, JTA를 가진 컨텍스"
"트 상의 세션들, 기타.)은 관리되는 환경에서 JTA <literal>TransactionManager</"
"literal>에 대한 접근을 필요로 한다. 어플리케이션 서버에서 당신은 Hibernate가 "
"<literal>TransactionManager</literal>에 대한 참조를 획득하는 방법을 지정해야 "
"한다. 왜냐하면 J2EE가 한 개의 메커니즘을 표준화 시키고 있지 않기 때문이다:"

#. Tag: title
#, no-c-format
msgid "JTA TransactionManagers"
msgstr "JTA TransactionManagers"

#. Tag: entry
#, no-c-format
msgid "Transaction Factory"
msgstr "트랜잭션 팩토리"

#. Tag: entry
#, no-c-format
msgid "Application Server"
msgstr "어플리케이션 서버"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"<literal>org.hibernate.transaction.JBossTransactionManagerLookup</literal>"
msgstr "org.hibernate.transaction.JBossTransactionManagerLookup"

#. Tag: entry
#, no-c-format
msgid "JBoss"
msgstr "JBoss"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"<literal>org.hibernate.transaction.WeblogicTransactionManagerLookup</literal>"
msgstr "org.hibernate.transaction.WeblogicTransactionManagerLookup"

#. Tag: entry
#, no-c-format
msgid "Weblogic"
msgstr "Weblogic"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"<literal>org.hibernate.transaction.WebSphereTransactionManagerLookup</"
"literal>"
msgstr "org.hibernate.transaction.WebSphereTransactionManagerLookup"

#. Tag: entry
#, no-c-format
msgid "WebSphere"
msgstr "WebSphere"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"<literal>org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</"
"literal>"
msgstr "org.hibernate.transaction.WebSphereExtendedJTATransactionLookup"

#. Tag: entry
#, no-c-format
msgid "WebSphere 6"
msgstr "WebSphere 6"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"<literal>org.hibernate.transaction.OrionTransactionManagerLookup</literal>"
msgstr "org.hibernate.transaction.OrionTransactionManagerLookup"

#. Tag: entry
#, no-c-format
msgid "Orion"
msgstr "Orion"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"<literal>org.hibernate.transaction.ResinTransactionManagerLookup</literal>"
msgstr "org.hibernate.transaction.ResinTransactionManagerLookup"

#. Tag: entry
#, no-c-format
msgid "Resin"
msgstr "Resin"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"<literal>org.hibernate.transaction.JOTMTransactionManagerLookup</literal>"
msgstr "org.hibernate.transaction.JOTMTransactionManagerLookup"

#. Tag: entry
#, no-c-format
msgid "JOTM"
msgstr "JOTM"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"<literal>org.hibernate.transaction.JOnASTransactionManagerLookup</literal>"
msgstr "org.hibernate.transaction.JOnASTransactionManagerLookup"

#. Tag: entry
#, no-c-format
msgid "JOnAS"
msgstr "JOnAS"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"<literal>org.hibernate.transaction.JRun4TransactionManagerLookup</literal>"
msgstr "org.hibernate.transaction.JRun4TransactionManagerLookup"

#. Tag: entry
#, no-c-format
msgid "JRun4"
msgstr "JRun4"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"<literal>org.hibernate.transaction.BESTransactionManagerLookup</literal>"
msgstr "org.hibernate.transaction.BESTransactionManagerLookup"

#. Tag: entry
#, no-c-format
msgid "Borland ES"
msgstr "Borland ES"

#. Tag: title
#, no-c-format
msgid "JNDI-bound <literal>SessionFactory</literal>"
msgstr "JNDI-bound <literal>SessionFactory</literal>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A JNDI-bound Hibernate <literal>SessionFactory</literal> can simplify the "
"lookup function of the factory and create new <literal>Session</literal>s. "
"This is not, however, related to a JNDI bound <literal>Datasource</literal>; "
"both simply use the same registry."
msgstr ""
"하나의 JNDI 바인드된 Hibernate <literal>SessionFactory</literal>는 그 팩토리"
"에 대한 룩업과 새로운 <literal>Session</literal>들의 생성을 단순화 시킬 수 있"
"다. 이것은 JNDI 바인드된 <literal>Datasource</literal>에 관련되어 있지 않고, "
"단순하게 둘 다 동일한 레지스트리를 사용한다는 점을 노트하라!"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you wish to have the <literal>SessionFactory</literal> bound to a JNDI "
"namespace, specify a name (e.g. <literal>java:hibernate/SessionFactory</"
"literal>) using the property <literal>hibernate.session_factory_name</"
"literal>. If this property is omitted, the <literal>SessionFactory</literal> "
"will not be bound to JNDI. This is especially useful in environments with a "
"read-only JNDI default implementation (in Tomcat, for example)."
msgstr ""
"만일 당신이 <literal>SessionFactory</literal>를 하나의 JNDI namespace에 바인"
"드 시키고자 원할 경우, <literal>hibernate.session_factory_name</literal> 프로"
"퍼티를 사용하여 한 개의 이름(예를 들면. <literal>java:hibernate/"
"SessionFactory</literal>)을 지정하라. 만일 이 프로퍼티가 생략될 경우, "
"<literal>SessionFactory</literal>는 JNDI에 바인드 되지 않을 것이다. (이것은 "
"읽기-전용 JNDI 디폴트 구현을 가진 환경들, 예를 들면 Tomcat에서 특히 유용하"
"다.)"

#. Tag: para
#, no-c-format
msgid ""
"When binding the <literal>SessionFactory</literal> to JNDI, Hibernate will "
"use the values of <literal>hibernate.jndi.url</literal>, <literal>hibernate."
"jndi.class</literal> to instantiate an initial context. If they are not "
"specified, the default <literal>InitialContext</literal> will be used."
msgstr ""
"<literal>SessionFactory</literal>를 JNDI에 바인드 시킬 때, Hibernate는 초기 "
"컨텍스트를 초기화 시키기 위해 <literal>hibernate.jndi.url</literal>, "
"<literal>hibernate.jndi.class</literal>의 값들을 사용할 것이다. 만일 그것들"
"이 지정되어 있지 않을 경우, 디폴트 <literal>InitialContext</literal>가 사용"
"될 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate will automatically place the <literal>SessionFactory</literal> in "
"JNDI after you call <literal>cfg.buildSessionFactory()</literal>. This means "
"you will have this call in some startup code, or utility class in your "
"application, unless you use JMX deployment with the "
"<literal>HibernateService</literal> (this is discussed later in greater "
"detail)."
msgstr ""
"Hibernate는 당신이 <literal>cfg.buildSessionFactory()</literal>를 호출한 후"
"에 <literal>SessionFactory</literal>를 JNDI 내에 자동적으로 위치지울 것이다. "
"이것은 당신이 (나중에 논의되는) <literal>HibernateService</literal>를 가진 "
"JMX 배치를 사용하지 않는 한, 당신이 적어도 당신의 어플리케이션 내에 있는 어"
"떤 시작 코드 (또는 유틸리티 클래스) 내에서 이것을 호출할 것임을 의미한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you use a JNDI <literal>SessionFactory</literal>, an EJB or any other "
"class, you can obtain the <literal>SessionFactory</literal> using a JNDI "
"lookup."
msgstr ""
"만일 당신이 하나의 JNDI <literal>SessionFactory</literal>를 사용할 경우, 하나"
"의 EJB 또는 어떤 다른 클래스는 JNDI 룩업을 사용하여 <literal>SessionFactory</"
"literal>를 얻을 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is recommended that you bind the <literal>SessionFactory</literal> to "
"JNDI in a managed environment and use a <literal>static</literal> singleton "
"otherwise. To shield your application code from these details, we also "
"recommend to hide the actual lookup code for a <literal>SessionFactory</"
"literal> in a helper class, such as <literal>HibernateUtil.getSessionFactory"
"()</literal>. Note that such a class is also a convenient way to startup "
"Hibernate&mdash;see chapter 1."
msgstr ""
"우리는 관리되는 환경들에서 <literal>SessionFactory</literal>를 JNDI에 바인드 "
"시키고 그 밖의 경우에는 하나의 <literal>static</literal> 싱글톤을 사용하는 것"
"을 권장한다. 이들 상세로부터 당신의 어플리케이션 코드를 은폐시키기 위해, 우리"
"는 또한 <literal>HibernateUtil.getSessionFactory()</literal>과 같은 하나의 "
"helper 클래스 내에서 <literal>SessionFactory</literal>에 대한 실제 룩업 코드"
"를 은폐시키기를 권장한다. 그런 클래스는 또한 Hibernate를 시작하는 편리한 방법"
"임을 노트하라&mdash; 1장을 보라."

#. Tag: title
#, no-c-format
msgid "Current Session context management with JTA"
msgstr "Current Session context management with JTA"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The easiest way to handle <literal>Sessions</literal> and transactions is "
"Hibernate's automatic \"current\" <literal>Session</literal> management. For "
"a discussion of contextual sessions see <xref linkend=\"architecture-current-"
"session\" />. Using the <literal>\"jta\"</literal> session context, if there "
"is no Hibernate <literal>Session</literal> associated with the current JTA "
"transaction, one will be started and associated with that JTA transaction "
"the first time you call <literal>sessionFactory.getCurrentSession()</"
"literal>. The <literal>Session</literal>s retrieved via "
"<literal>getCurrentSession()</literal> in the<literal>\"jta\"</literal> "
"context are set to automatically flush before the transaction completes, "
"close after the transaction completes, and aggressively release JDBC "
"connections after each statement. This allows the <literal>Session</"
"literal>s to be managed by the life cycle of the JTA transaction to which it "
"is associated, keeping user code clean of such management concerns. Your "
"code can either use JTA programmatically through <literal>UserTransaction</"
"literal>, or (recommended for portable code) use the Hibernate "
"<literal>Transaction</literal> API to set transaction boundaries. If you run "
"in an EJB container, declarative transaction demarcation with CMT is "
"preferred."
msgstr ""
"당신 자신의 <literal>ThreadLocal</literal> 유틸리티를 작동시키는 대신에, 우리"
"는 또한 Hibernate <literal>Session</literal>를 얻기 위해 "
"<literal>SessionFactory</literal> 상의 <literal>getCurrentSession()</"
"literal> 메소드 사용을 권장한다. <xref linkend=\"architecture-current-session"
"\">현재 세션들</xref>에 관한 논의를 보라. <literal>\"jta\"</literal> 세션 컨"
"텍스트를 사용하고 있는 경우에, 현재의 JTA 트랜잭션으로 시작되고 연관된 "
"Hibernate <literal>Session</literal>이 존재하지 않을 경우, 우리는 JTA 트랜잭"
"션으로 시작되고 연관될 것이다. <literal>\"jta\"</literal> 컨텍스트에서 "
"<literal>getCurrentSession()</literal>를 통해 검색된 <literal>Session</"
"literal>들은 그 트랜잭션이 완료되기 전에 자동적으로 flush될 것이고 트랜잭션 "
"완료 후에 닫혀질 것이고, 그리고 각각의 문장 뒤에 JDBC 커넥션들을 적극적으로 "
"해제할 것이다. 이것은 그런 관리 사항들에 대해 사용자 코드를 명료하게 유지시켜"
"서, 연관되어 있는 JTA 트랜잭션의 생명주기에 의해 <literal>Session</literal>들"
"이 관리되도록 허용해준다. 이것은 그런 관리 사항들에 대해 사용자 코드를 명료하"
"게 유지시켜서, 세션이 연관되어 있는 JTA 트랜잭션의 생명주기에 의해 관리되는 "
"것을 <literal>Session</literal>들에게 허용해준다. 당신의 코드는 "
"<literal>Session</literal>들과 트랜잭션들을 처리하는 가장 손쉬운 방법은 "
"Hibernate의 자동적인 \"현재\" <literal>Session</literal>이다. <xref linkend="
"\"architecture-current-session\">current sessions</xref>에 관한 논의를 보라. "
"<literal>\"jta\"</literal> 세션 컨텍스트를 사용하는 경우, 현재의 JTA 트랜잭션"
"으로 시작되고 연관된 Hibernate <literal>Session</literal>들이 존재하지 않을 "
"경우, 당신이 <literal>sessionFactory.getCurrentSession()</literal>을 처음 호"
"출할 때 하나의 세션이 현재의 JTA 트랜잭션에 대해 시작되고 연관될 것이다. "
"<literal>\"jta\"</literal> 컨텍스트에서 <literal>getCurrentSession()</"
"literal>을 통해 검색된 <literal>Session</literal>들은 그 트랜잭션이 완료되기 "
"전에 자동적으로 flush될 것이고 그 트랜잭션 완료들 후에 닫혀질 것이고 각각의 "
"문장 후에 JDBC 커넥션들을 적극적으로 해제할 것이다. 이것은 그런 관리 사항들"
"에 대해 사용자 코드를 명료하게 유지시켜서, 연관되어 있는 JTA 트랜잭션의 생명"
"주기에 의해 <literal>Session</literal>들이 관리되도록 허용해준다. 이것은 그"
"런 관리 사항들에 대해 사용자 코드를 명료하게 유지시켜서, 세션이 연관되어 있"
"는 JTA 트랜잭션의 생명주기에 의해 관리되는 것을 <literal>Session</literal>들"
"에게 허용해준다. 당신의 코드는 트랜잭션 경계들을 설정하는데 "
"<literal>UserTransaction</literal>을 통해 프로그램 상으로 JTA를 사용하거나, "
"Hibernate <literal>Transaction</literal> API를 (이식성을 위한 코드로 권장됨) "
"사용할 수 있다. 만일 당신이 하나의 EJB 컨테이너에서 실행하고 있을 경우, CMT"
"의 경우에 선언적인 트랜잭션 경계설정이 선호된다."

#. Tag: title
#, no-c-format
msgid "JMX deployment"
msgstr "JMX 배치"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The line <literal>cfg.buildSessionFactory()</literal> still has to be "
"executed somewhere to get a <literal>SessionFactory</literal> into JNDI. You "
"can do this either in a <literal>static</literal> initializer block, like "
"the one in <literal>HibernateUtil</literal>, or you can deploy Hibernate as "
"a <emphasis>managed service</emphasis>."
msgstr ""
"<literal>cfg.buildSessionFactory()</literal> 줄은 여전히 JNDI에 붙은 하나의 "
"<literal>SessionFactory</literal>를 얻기 위해 어딘가에서 실행되어야 한다. 당"
"신은 (<literal>HibernateUtil</literal> 내에 있는 것처럼) <literal>static</"
"literal> initializer 블록 속에서 이것을 행할 수 있거나 당신은 Hibernate를 "
"<emphasis>managed service</emphasis>로서 배치할 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate is distributed with <literal>org.hibernate.jmx.HibernateService</"
"literal> for deployment on an application server with JMX capabilities, such "
"as JBoss AS. The actual deployment and configuration is vendor-specific. "
"Here is an example <literal>jboss-service.xml</literal> for JBoss 4.0.x:"
msgstr ""
"Hibernate는 JBoss AS와 같은 JMX 가용성들을 가진 어플리케이션 서버 상의 배치"
"를 위해 <literal>org.hibernate.jmx.HibernateService</literal>를 배포하고 있"
"다. 실제 배치와 구성은 벤더 지정적이다. 다음은 JBoss 4.0.x를 위한 "
"<literal>jboss-service.xml</literal> 예제이다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This file is deployed in a directory called <literal>META-INF</literal> and "
"packaged in a JAR file with the extension <literal>.sar</literal> (service "
"archive). You also need to package Hibernate, its required third-party "
"libraries, your compiled persistent classes, as well as your mapping files "
"in the same archive. Your enterprise beans (usually session beans) can be "
"kept in their own JAR file, but you can include this EJB JAR file in the "
"main service archive to get a single (hot-)deployable unit. Consult the "
"JBoss AS documentation for more information about JMX service and EJB "
"deployment."
msgstr ""
"이 파일은 <literal>META-INF</literal>로 명명된 디렉토리 속에 배치되고 확장자 "
"<literal>.sar</literal> (service archive)를 가진 한 개의 JAR 파일 속에 패키징"
"된다. 당신은 또한 Hibernate, 그것의 필요한 제 3의 라이브러리들, 당신의 컴파일"
"된 영속 클래스들 뿐만 아니라 당신의 매핑 파일들을 동일한 아카이브 속에 패키징"
"할 필요가 있다. 당신의 엔터프라이즈 빈즈(대개 session beans)는 그것들 자신의 "
"JAR 파일 속에 유지될 수 있지만, 당신은 한 개의 (hot-)배치 가능한 단위를 얻기 "
"위해 메인 서비스 아카이브 속에 이 EJB JAR 파일을 포함시킬 수도 있다. JMX 서비"
"스와 EJB 배치에 관한 추가 정보는 JBoss AS 문서를 참조하라."

#~ msgid "JDBC URL"
#~ msgstr "jdbc URL"

#~ msgid "database user"
#~ msgstr "데이터베이스 사용자"

#~ msgid "hibernate.query.substitutions true=1, false=0"
#~ msgstr "hibernate.query.substitutions true=1, false=0"

#~ msgid "hibernate.query.substitutions toLowercase=LOWER"
#~ msgstr "hibernate.query.substitutions toLowercase=LOWER"

#~ msgid "org.hibernate"
#~ msgstr "org.hibernate"

#~ msgid ""
#~ "<literal>hibernate.properties</literal> is the easiest approach if you "
#~ "want to get started quickly."
#~ msgstr ""
#~ "당신이 빠르게 시작하고 원할 경우 <literal>hibernate.properties</literal>"
#~ "는 가장 쉬운 접근법이다."

#~ msgid "Hibernate logs various events using Apache commons-logging."
#~ msgstr ""
#~ "Hibernate는 Apache commons-logging를 사용하여 다양한 이벤트들을 로그시킨"
#~ "다."

#~ msgid ""
#~ "The commons-logging service will direct output to either Apache Log4j (if "
#~ "you include <literal>log4j.jar</literal> in your classpath) or JDK1.4 "
#~ "logging (if running under JDK1.4 or above). You may download Log4j from "
#~ "<literal>http://jakarta.apache.org</literal>. To use Log4j you will need "
#~ "to place a <literal>log4j.properties</literal> file in your classpath, an "
#~ "example properties file is distributed with Hibernate in the <literal>src/"
#~ "</literal> directory."
#~ msgstr ""
#~ "commons-logging 서비스는 (만일 당신이 classpath 내에 <literal>log4j.jar</"
#~ "literal>를 포함할 경우) Apache Log4j로 또는 (JDK1.4 이상의 버전에서 실행"
#~ "될 경우) JDK 1.4 로깅으로 직접 출력할 것이다. 당신은 <literal>http://"
#~ "jakarta.apache.org</literal>에서 Log4j를 다운로드 할 수 있다. Log4j를 사용"
#~ "하기 위해, 당신은 <literal>log4j.properties</literal> 파일을 당신의 "
#~ "classpath 내에 위치지울 필요가 있을 것이고, 예제 properties 파일은 "
#~ "Hibernate의 <literal>src/</literal> 디렉토리 내에 배포되어 있다."

#~ msgid "<placeholder-1/> (optional)"
#~ msgstr "<placeholder-1/> (옵션)"

#~ msgid "InitialContextFactory"
#~ msgstr "InitialContextFactory"

#~ msgid "class of the JNDI <placeholder-1/>"
#~ msgstr "JNDI <placeholder-1/>의 클래스"

#~ msgid "eg."
#~ msgstr "예."

#~ msgid "full.classname.of.Dialect"
#~ msgstr "full.classname.of.Dialect"

#~ msgid "debug"
#~ msgstr "debug"

#~ msgid "SCHEMA_NAME"
#~ msgstr "SCHEMA_NAME"

#~ msgid "CATALOG_NAME"
#~ msgstr "CATALOG_NAME"

#~ msgid "SessionFactory"
#~ msgstr "SessionFactory"

#~ msgid "jndi/composite/name"
#~ msgstr "jndi/composite/name"

#~ msgid "0"
#~ msgstr "0"

#~ msgid "false"
#~ msgstr "false"

#~ msgid "Statement.setFetchSize()"
#~ msgstr "Statement.setFetchSize()"

#~ msgid "true"
#~ msgstr "executeBatch()"

#~ msgid "executeBatch()"
#~ msgstr "true"

#~ msgid "Batcher"
#~ msgstr "Batcher"

#~ msgid "classname.of.BatcherFactory"
#~ msgstr "classname.of.BatcherFactory"

#~ msgid "binary"
#~ msgstr "binary"

#~ msgid "serializable"
#~ msgstr "serializable"

#~ msgid "PreparedStatement.getGeneratedKeys()"
#~ msgstr "PreparedStatement.getGeneratedKeys()"

#~ msgid "true|false"
#~ msgstr "true|false"

#~ msgid "ConnectionProvider"
#~ msgstr "ConnectionProvider"

#~ msgid "classname.of.ConnectionProvider"
#~ msgstr "classname.of.ConnectionProvider"

#~ msgid "java.sql.Connection"
#~ msgstr "java.sql.Connection"

#~ msgid "1, 2, 4, 8"
#~ msgstr "1, 2, 4, 8"

#~ msgid "after_statement"
#~ msgstr "after_statement"

#~ msgid "after_transaction"
#~ msgstr "after_transaction"

#~ msgid "auto"
#~ msgstr "auto"

#~ msgid "hibernate.connection."
#~ msgstr "&lt;propertyName&gt;"

#, fuzzy
#~ msgid "&lt;propertyName&gt;"
#~ msgstr ""
#~ "#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
#~ "hibernate.connection.<placeholder-1/>\n"
#~ "#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
#~ "propertyName\n"
#~ "#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
#~ "hibernate.jndi.<placeholder-1/>\n"
#~ "#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
#~ "propertyName"

#~ msgid "DriverManager.getConnection()"
#~ msgstr "DriverManager.getConnection()"

#~ msgid "Pass the JDBC property <placeholder-1/> to <placeholder-2/>."
#~ msgstr "JDBC 프로퍼티 <placeholder-1/>을 <placeholder-2/>에 전달한다."

#~ msgid "hibernate.jndi."
#~ msgstr "&lt;propertyName&gt;"

#~ msgid "Pass the property <placeholder-1/> to the JNDI <placeholder-2/>."
#~ msgstr "<placeholder-1/> 프로퍼티를 JNDI <placeholder-2/>에 전달한다."

#~ msgid "CacheProvider"
#~ msgstr "CacheProvider"

#~ msgid "classname.of.CacheProvider"
#~ msgstr "classname.of.CacheProvider"

#~ msgid "&lt;cache&gt;"
#~ msgstr "&lt;cache&gt;"

#~ msgid "QueryCache"
#~ msgstr "QueryCache"

#~ msgid "StandardQueryCache"
#~ msgstr "StandardQueryCache"

#~ msgid "classname.of.QueryCache"
#~ msgstr "classname.of.QueryCache"

#~ msgid "prefix"
#~ msgstr "prefix"

#~ msgid "TransactionFactory"
#~ msgstr "Transaction"

#~ msgid "Transaction"
#~ msgstr "TransactionFactory"

#~ msgid "JDBCTransactionFactory"
#~ msgstr "JDBCTransactionFactory"

#~ msgid "classname.of.TransactionFactory"
#~ msgstr "classname.of.TransactionFactory"

#~ msgid "JTATransactionFactory"
#~ msgstr "UserTransaction"

#~ msgid "UserTransaction"
#~ msgstr "JTATransactionFactory"

#~ msgid "TransactionManagerLookup"
#~ msgstr "TransactionManagerLookup"

#~ msgid "classname.of.TransactionManagerLookup"
#~ msgstr "classname.of.TransactionManagerLookup"

#~ msgid "Session"
#~ msgstr "Session"

#~ msgid "hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC"
#~ msgstr "hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC"

#~ msgid "create-drop"
#~ msgstr "create-drop"

#~ msgid "hibernate.cfg.xml"
#~ msgstr "hibernate.cfg.xml"
