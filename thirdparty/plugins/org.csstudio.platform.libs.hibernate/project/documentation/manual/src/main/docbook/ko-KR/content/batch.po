msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-04T04:51:21\n"
"PO-Revision-Date: 2010-01-12 23:37+0900\n"
"Last-Translator: Jongdae Kim <jdkim528@korea.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, no-c-format
msgid "Batch processing"
msgstr "Batch 처리"

#. Tag: para
#, no-c-format
msgid ""
"A naive approach to inserting 100,000 rows in the database using Hibernate "
"might look like this:"
msgstr ""
"하이버네이트를 사용하여 데이터베이스 내에서 100,000 개의 행들을 삽입시키는 원"
"시 접근법은 다음과 같을 수 있다:"

#. Tag: para
#, no-c-format
msgid ""
"This would fall over with an <literal>OutOfMemoryException</literal> "
"somewhere around the 50,000th row. That is because Hibernate caches all the "
"newly inserted <literal>Customer</literal> instances in the session-level "
"cache. In this chapter we will show you how to avoid this problem."
msgstr ""
"이것은 50 000번째 행 근처에서 <literal>OutOfMemoryException</literal>으로 떨"
"어질 것이다. 그것은 하이버네이트가 모든 새로이 삽입된 <literal>Customer</"
"literal> 인스턴스들을 session-level 캐시 내에 캐시시키기 때문이다. 이 장에서 "
"우리는 이 문제를 회피하는 방법을 보여줄 것이다."

#. Tag: para
#, no-c-format
msgid ""
"If you are undertaking batch processing you will need to enable the use of "
"JDBC batching. This is absolutely essential if you want to achieve optimal "
"performance. Set the JDBC batch size to a reasonable number (10-50, for "
"example):"
msgstr ""
"만일 당신이 배치 처리를 행하는 중이라면, 당신은 JDBC 배치 사용을 이용 가능하"
"도록 할 필요가 있을 것이다. 만일 당신이 최적의 성능을 성취하고자 원한다면 이"
"것이 절대적으로 필수적이다. JDBC 배치 사이즈를 적당한 숫자로 설정하라(예를 들"
"면,10-50):"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate disables insert batching at the JDBC level transparently if you "
"use an <literal>identity</literal> identifier generator."
msgstr ""
"만일 당신이 <literal>identiy</literal> 식별자 생성자를 사용할 경우에 하이버네"
"이트는 JDBC 레벨에서 투명하게 insert 배치작업을 사용불가능하도록 만든다."

#. Tag: para
#, no-c-format
msgid ""
"You can also do this kind of work in a process where interaction with the "
"second-level cache is completely disabled:"
msgstr ""
"당신은 또한 second-level 캐시를 가진 상호작용이 전적으로 사용불가능한 프로세"
"스 내에서 이런 종류의 작업을 행할 수 있다:"

#. Tag: para
#, no-c-format
msgid ""
"However, this is not absolutely necessary, since we can explicitly set the "
"<literal>CacheMode</literal> to disable interaction with the second-level "
"cache."
msgstr ""
"하지만 이것은 절대적으로 필요하지 않다. 왜냐하면 우리는 second-level 캐시와"
"의 상호작용을 불가능하도록 하기 위해 명시적으로 <literal>CacheMode</literal>"
"를 설정할 수 있기 때문이다."

#. Tag: title
#, no-c-format
msgid "Batch inserts"
msgstr "Batch inserts"

#. Tag: para
#, no-c-format
msgid ""
"When making new objects persistent <literal>flush()</literal> and then "
"<literal>clear()</literal> the session regularly in order to control the "
"size of the first-level cache."
msgstr ""
"새로운 객체들을 영속화 시킬 때 당신은 first-level 캐시의 사이즈를 제어하기 위"
"해 세션을 정기적으로 <literal>flush()</literal> 시키고 나서 <literal>clear()"
"</literal> 하라."

#. Tag: title
#, no-c-format
msgid "Batch updates"
msgstr "Batch updates"

#. Tag: para
#, no-c-format
msgid ""
"For retrieving and updating data, the same ideas apply. In addition, you "
"need to use <literal>scroll()</literal> to take advantage of server-side "
"cursors for queries that return many rows of data."
msgstr ""
"데이터 검색하고 업데이트할 때, 동일한 개념들이 적용된다. 게다가 당신은 많은 "
"데이터 행들을 반환하는 질의들을 위한 서버-측 커서들의 장점을 취하하기 위해 "
"<literal>scroll()</literal>을 사용할 필요가 있다."

#. Tag: title
#, no-c-format
msgid "The StatelessSession interface"
msgstr "StatelessSession 인터페이스"

#. Tag: para
#, no-c-format
msgid ""
"Alternatively, Hibernate provides a command-oriented API that can be used "
"for streaming data to and from the database in the form of detached objects. "
"A <literal>StatelessSession</literal> has no persistence context associated "
"with it and does not provide many of the higher-level life cycle semantics. "
"In particular, a stateless session does not implement a first-level cache "
"nor interact with any second-level or query cache. It does not implement "
"transactional write-behind or automatic dirty checking. Operations performed "
"using a stateless session never cascade to associated instances. Collections "
"are ignored by a stateless session. Operations performed via a stateless "
"session bypass Hibernate's event model and interceptors. Due to the lack of "
"a first-level cache, Stateless sessions are vulnerable to data aliasing "
"effects. A stateless session is a lower-level abstraction that is much "
"closer to the underlying JDBC."
msgstr ""
"다른 방법으로 하이버네이트는 분리된(detached) 객체들의 형식으로 데이터베이스"
"로 그리고 데이터베이스로부터 데이터를 스트리밍하는데 사용될 수 있는 명령-지"
"향 API를 제공한다. <literal>StatelessSession</literal>은 그것과 연관된 영속 "
"컨텍스트를 갖지 않고 많은 보다 높은 레벨의 생명 주기 의미를 제공하지 않는다. "
"특히 하나의 상태 없는 세션은 첫 번째 레벨 캐시를 구현하지 않으며 임의의 두 번"
"째 레벨 캐시 또는 질의 캐시와 상호작용하지 않는다. 그것은 트랜잭션 상의 쓰기-"
"이면(write-behind)의 체킹이나 자동적인 dirty 체킹을 구현하지 않는다. 상태 없"
"는 세션을 사용하여 수행된 연산들은 결코 연관된 인스턴스들에 대해 케스케이드 "
"되지 않는다. 콜렉션들은 상태 없는 세션에 의해 무시된다. 상태없는 세션을 통해 "
"수행된 연산들은 하이버네이트의 이벤트 모형과 인터셉터들을 우회한다. 첫번째-레"
"벨의 캐시의 부재으로 인해, 상태없는 세션들은 데이터 alias 효과들에 취약하다. "
"상태없는 세션은 기반 JDBC에 훨씬 더 가까운 하나의 보다 낮은 레벨의 추상이다."

#. Tag: para
#, no-c-format
msgid ""
"In this code example, the <literal>Customer</literal> instances returned by "
"the query are immediately detached. They are never associated with any "
"persistence context."
msgstr ""
"이 코드 예제에서, 질의에 의해 반환된 <literal>Customer</literal> 인스턴스들"
"은 곧바고 분리된다(detached). 그것들은 임의의 영속 컨텍스트와 결코 연관되지 "
"않는다."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>insert(), update()</literal> and <literal>delete()</literal> "
"operations defined by the <literal>StatelessSession</literal> interface are "
"considered to be direct database row-level operations. They result in the "
"immediate execution of a SQL <literal>INSERT, UPDATE</literal> or "
"<literal>DELETE</literal> respectively. They have different semantics to the "
"<literal>save(), saveOrUpdate()</literal> and <literal>delete()</literal> "
"operations defined by the <literal>Session</literal> interface."
msgstr ""
"<literal>StatelessSession</literal> 인터페이스에 의해 정의된 <literal>insert"
"(), update()</literal> 그리고 <literal>delete()</literal> 연산들은 직접적인 "
"데이터베이스 행 레벨의 연산들로 갖주된다. 그것들은 각각 하나의 SQL "
"<literal>INSERT, UPDATE</literal> 또는 <literal>DELETE</literal>의 즉각적인 "
"실행으로 귀결된다. 그것들은 <literal>Session</literal> 인터페이스에 의해 정의"
"된 <literal>save(), saveOrUpdate()</literal>와 <literal>delete()</literal> 연"
"산들과는 다른 의미들을 갖는다."

#. Tag: title
#, no-c-format
msgid "DML-style operations"
msgstr "DML-스타일 연산들"

#. Tag: para
#, no-c-format
msgid ""
"As already discussed, automatic and transparent object/relational mapping is "
"concerned with the management of the object state. The object state is "
"available in memory. This means that manipulating data directly in the "
"database (using the SQL <literal>Data Manipulation Language</literal> (DML) "
"the statements: <literal>INSERT</literal>, <literal>UPDATE</literal>, "
"<literal>DELETE</literal>) will not affect in-memory state. However, "
"Hibernate provides methods for bulk SQL-style DML statement execution that "
"is performed through the Hibernate Query Language (<link linkend=\"queryhql"
"\">HQL</link>)."
msgstr ""
"이미 논의했듯이, 자동적이고 투명한 객체/관계형 매핑은 객체 상태에 대한 관리"
"와 관계된다. 객체의 상태는 메모리 내에서 이용 가능하다. (SQL <literal>데이터 "
"처리 언어</literal>(DML) 문장들 : <literal>INSERT</literal>, "
"<literal>UPDATE</literal>, <literal>DELETE</literal>를 사용하여) 데이터베이스"
"에서 직접 데이터 처리하는 것이 메모리 내 상태에 영향을 주지 않음을 의미한다. "
"하지만 하이버네이트는 하이버네이트 질의 언어(<xref linkend=\"queryhql\">HQL</"
"xref>)를 통해 실행되는 대량 SQL-스타일의 DML 문장 실행을 위한 메소드들을 제공"
"한다."

#. Tag: para
#, no-c-format
msgid ""
"The pseudo-syntax for <literal>UPDATE</literal> and <literal>DELETE</"
"literal> statements is: <literal>( UPDATE | DELETE ) FROM? EntityName (WHERE "
"where_conditions)?</literal>."
msgstr ""
"<literal>UPDATE</literal>와 <literal>DELETE</literal> 문장들에 대한 유사 구문"
"은 다음과 같다: <literal>( UPDATE | DELETE ) FROM? EntityName (WHERE "
"where_conditions)?</literal>."

#. Tag: para
#, no-c-format
msgid "Some points to note:"
msgstr "노트할 몇 가지:"

#. Tag: para
#, no-c-format
msgid "In the from-clause, the FROM keyword is optional"
msgstr "from-절에서, FROM 키워드는 옵션이다"

#. Tag: para
#, no-c-format
msgid ""
"There can only be a single entity named in the from-clause. It can, however, "
"be aliased. If the entity name is aliased, then any property references must "
"be qualified using that alias. If the entity name is not aliased, then it is "
"illegal for any property references to be qualified."
msgstr ""
"from-절 내에 단지 명명된 한 개의 엔티티가 존재할 수 있다. 하지만 그것은 선택"
"적으로 alias될 수 있다. 만일 엔티티 이름이 alias되면, 그때 임의의 프로퍼티 참"
"조들은 그 alias를 사용하여 수식되어야 한다; 만일 엔티티 이름이 alias되지 않"
"을 경우, 임의의 프로퍼티 참조들이 수식되는 것은 규칙에 어긋난다."

#. Tag: para
#, no-c-format
msgid ""
"No <link linkend=\"queryhql-joins-forms\">joins</link>, either implicit or "
"explicit, can be specified in a bulk HQL query. Sub-queries can be used in "
"the where-clause, where the subqueries themselves may contain joins."
msgstr ""
"함축적이든 명시적이든 <xref linkend=\"queryhql-joins-forms\">join들</xref>은 "
"대량 HQL 질의 속에 지정될 수 없다. 서브-질의들이 where-절에 사용될 수 있는"
"데, 여기서 서브질의들 그 자신들은 조인들을 포함할 수 있다."

#. Tag: para
#, no-c-format
msgid "The where-clause is also optional."
msgstr "where-절 또한 옵션이다."

#. Tag: para
#, no-c-format
msgid ""
"As an example, to execute an HQL <literal>UPDATE</literal>, use the "
"<literal>Query.executeUpdate()</literal> method. The method is named for "
"those familiar with JDBC's <literal>PreparedStatement.executeUpdate()</"
"literal>:"
msgstr ""
"하나의 예제로서, 한 개의 HQL <literal>UPDATE</literal>를 실행하기 위해, "
"<literal>Query.executeUpdate()</literal> 메소드를 사용하라. 그 메소드는 JDBC"
"의 <literal>PreparedStatement.executeUpdate()</literal>와 유사하게 명명된다:"

#. Tag: para
#, no-c-format
msgid ""
"In keeping with the EJB3 specification, HQL <literal>UPDATE</literal> "
"statements, by default, do not effect the <link linkend=\"mapping-"
"declaration-version\">version</link> or the <link linkend=\"mapping-"
"declaration-timestamp\">timestamp</link> property values for the affected "
"entities. However, you can force Hibernate to reset the <literal>version</"
"literal> or <literal>timestamp</literal> property values through the use of "
"a <literal>versioned update</literal>. This is achieved by adding the "
"<literal>VERSIONED</literal> keyword after the <literal>UPDATE</literal> "
"keyword."
msgstr ""
"이것은 EJB3 명세서에서 유지되고 있듯이, HQL <literal>UPDATE</literal> 문장들"
"은 디폴트로 영향받는 엔티티들에 대한 <xref linkend=\"mapping-declaration-"
"version\">version</xref> 또는 <xref linkend=\"mapping-declaration-timestamp"
"\">timestamp</xref> 프로퍼티 값들에 영향을 주지 않는다. 하지만 당신은 하이버"
"네이트로 하여금 <literal>versioned update</literal>의 사용을 통해 "
"<literal>version</literal> 또는 <literal>timestamp</literal> 프로퍼티 값들을 "
"적절하게 재설정하도록 강제시킬 수 있다. 이것은 <literal>UPDATE</literal> 키워"
"드 뒤에 <literal>VERSIONED</literal> 키워드를 추가시킴으로써 달성된다."

#. Tag: para
#, no-c-format
msgid ""
"Custom version types, <literal>org.hibernate.usertype.UserVersionType</"
"literal>, are not allowed in conjunction with a <literal>update versioned</"
"literal> statement."
msgstr ""
"맞춤형 version 타입들, <literal>org.hibernate.usertype.UserVersionType</"
"literal>은 <literal>update versioned</literal>과 문장과 함께 사용하는 것이 허"
"용되지 않는다."

#. Tag: para
#, no-c-format
msgid ""
"To execute an HQL <literal>DELETE</literal>, use the same <literal>Query."
"executeUpdate()</literal> method:"
msgstr ""
"HQL <literal>DELETE</literal>를 실행하려면, 같은 메소드 <literal>Query."
"executeUpdate()</literal>를 사용하라:"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>int</literal> value returned by the <literal>Query.executeUpdate"
"()</literal> method indicates the number of entities effected by the "
"operation. This may or may not correlate to the number of rows effected in "
"the database. An HQL bulk operation might result in multiple actual SQL "
"statements being executed (for joined-subclass, for example). The returned "
"number indicates the number of actual entities affected by the statement. "
"Going back to the example of joined-subclass, a delete against one of the "
"subclasses may actually result in deletes against not just the table to "
"which that subclass is mapped, but also the \"root\" table and potentially "
"joined-subclass tables further down the inheritance hierarchy."
msgstr ""
"<literal>Query.executeUpdate()</literal> 메소드에 의해 반환되는 "
"<literal>int</literal> 값은 그 오퍼레이션에 의해 영향받은 엔티티들의 개수를 "
"나타낸다. 이것이 데이터베이스 내에서 영향받은 행들의 개수와 상관이 있을 수도 "
"없을 수도 있다. HQL 대량 오퍼레이션은 (예를 들어 joined-subclass에 대해) 실"
"행 중인 여러 개의 실제 SQL 문장들로 귀결될 수 있다. 반환되는 숫자는 그 문장"
"에 의해 영향받은 실제 엔티티들의 개수를 나타낸다. joined-subclass 예제로 되돌"
"아가면, 서브클래스들 중 하나에 대한 삭제는 단지 그 서브클래스가 매핑되어 있"
"는 테이블에 대한 삭제로 귀결될 뿐만 아니라 또한 \"루트\" 테이블과 상속 계층에"
"서 더 내려온 잠정적으로 조인된-서브클래스 테이블들에 대한 삭제들로 귀결될 수 "
"있다."

#. Tag: para
#, no-c-format
msgid ""
"The pseudo-syntax for <literal>INSERT</literal> statements is: "
"<literal>INSERT INTO EntityName properties_list select_statement</literal>. "
"Some points to note:"
msgstr ""
"장래의 배포본들에서 전달될 대량 HQL 오퍼레이션들에 대한 몇 가지 제한들이 현"
"재 존재함을 노트하라; 상세한 것은 JIRA 로드맵을 참조하라. <literal>INSERT</"
"literal> 문장들을 위한 유사-구문은 다음과 같다: <literal>INSERT INTO "
"EntityName properties_list select_statement</literal>. 노트할 몇 가지:"

#. Tag: para
#, no-c-format
msgid ""
"Only the INSERT INTO ... SELECT ... form is supported; not the INSERT "
"INTO ... VALUES ... form."
msgstr ""
"오직 INSERT INTO ... SELECT ... 형식 만일 지원된다; INSERT INTO ... "
"VALUES ... 형식은 지원되지 않는다."

#. Tag: para
#, no-c-format
msgid ""
"The properties_list is analogous to the <literal>column specification</"
"literal> in the SQL <literal>INSERT</literal> statement. For entities "
"involved in mapped inheritance, only properties directly defined on that "
"given class-level can be used in the properties_list. Superclass properties "
"are not allowed and subclass properties do not make sense. In other words, "
"<literal>INSERT</literal> statements are inherently non-polymorphic."
msgstr ""
"properties_list는 SQL <literal>INSERT</literal> 문장에서 <literal>컬럼 명세</"
"literal>와 유사하다. 매핑된 상속에 참여하는 엔티티들의 경우, 그 주어진 클래"
"스-레벨 상에 직접 정의된 프로퍼티들 만이 properties_list에 사용될 수 있다. 슈"
"퍼클래스 프로퍼티들은 허용되지 않고, 서브클래스 프로퍼티들은 의미가 없다. 달"
"리 말해 <literal>INSERT</literal> 문장들은 본래적으로 다형적이지 않다(non-"
"polymorphic)."

#. Tag: para
#, no-c-format
msgid ""
"select_statement can be any valid HQL select query, with the caveat that the "
"return types must match the types expected by the insert. Currently, this is "
"checked during query compilation rather than allowing the check to relegate "
"to the database. This might, however, cause problems between Hibernate "
"<literal>Type</literal>s which are <emphasis>equivalent</emphasis> as "
"opposed to <emphasis>equal</emphasis>. This might cause issues with "
"mismatches between a property defined as a <literal>org.hibernate.type."
"DateType</literal> and a property defined as a <literal>org.hibernate.type."
"TimestampType</literal>, even though the database might not make a "
"distinction or might be able to handle the conversion."
msgstr ""
"반환 타입들이 insert에 의해 기대되는 타입들과 일치해야 한다는 단서 하에, "
"select_statement는 임의의 유효한 HQL select 질의일 수 있다. 현재 이것은 데이"
"터베이스로 강등시킬 체크를 허용하기 보다는 질의 컴파일 동안에 체크된다. 하지"
"만 이것은 <emphasis>equal</emphasis>과는 대조적으로 <emphasis>등가인"
"(equivalent)</emphasis> Hibernate <literal>Type</literal>들 사이에 문제점들"
"을 일으킬 수도 있다. 비록 데이터베이스가 구별할수 없거나 변환을 처리할 수 있"
"을 지라도, 이것은 <literal>org.hibernate.type.DateType</literal>로 정의된 프"
"로퍼티와 <literal>org.hibernate.type.TimestampType</literal>으로 정의된 프로"
"퍼티 사이에 불일치 쟁점들을 유발시킬 수도 있다."

#. Tag: para
#, no-c-format
msgid ""
"For the id property, the insert statement gives you two options. You can "
"either explicitly specify the id property in the properties_list, in which "
"case its value is taken from the corresponding select expression, or omit it "
"from the properties_list, in which case a generated value is used. This "
"latter option is only available when using id generators that operate in the "
"database; attempting to use this option with any \"in memory\" type "
"generators will cause an exception during parsing. For the purposes of this "
"discussion, in-database generators are considered to be <literal>org."
"hibernate.id.SequenceGenerator</literal> (and its subclasses) and any "
"implementers of <literal>org.hibernate.id.PostInsertIdentifierGenerator</"
"literal>. The most notable exception here is <literal>org.hibernate.id."
"TableHiLoGenerator</literal>, which cannot be used because it does not "
"expose a selectable way to get its values."
msgstr ""
"id 프로퍼티의 경우, insert 문장은 당신에게 두 개의 옵션을 준다. 당신은 "
"properties_list 내에 id 프로퍼티를 명시적으로 지정할 수 있는데 이 경우에 그것"
"의 값은 대응하는 SELECT 표현식으로부터 얻어진다. 또는 properties_list에서 그"
"것을 생략할 수 있는데 이 경우에 생성된 값이 사용된다. 이 후자의 옵션의 데이터"
"베이스 내에서 연산되는 id 연산자들을 사용할 때에만 이용 가능하다; 임의의 \"메"
"모리 내\" 타입 생성기들로서 이 옵션을 사용하고자 시도하는 것은 파싱 동안에 예"
"외상황을 일으킬 것이다. 이 논의의 목적 상, 데이터베이스 내 생성기들은 "
"<literal>org.hibernate.id.SequenceGenerator</literal> (그리고 그것의 서브클래"
"스들) 그리고 임의의 <literal>org.hibernate.id.PostInsertIdentifierGenerator</"
"literal>의 구현자들이라고 간주된다. 여기서 가장 주목할 만한 예외는 "
"<literal>org.hibernate.id.TableHiLoGenerator</literal>인데, 그것이 그것의 값"
"들을 얻기 위한 select 가능한 방법을 노출시키지 않기 때문에 사용될 수 없다."

#. Tag: para
#, no-c-format
msgid ""
"For properties mapped as either <literal>version</literal> or "
"<literal>timestamp</literal>, the insert statement gives you two options. "
"You can either specify the property in the properties_list, in which case "
"its value is taken from the corresponding select expressions, or omit it "
"from the properties_list, in which case the <literal>seed value</literal> "
"defined by the <literal>org.hibernate.type.VersionType</literal> is used."
msgstr ""
"<literal>version</literal> 또는 <literal>timestamp</literal>로 매핑된 프로퍼"
"티들의 경우에, insert 문장은 당신에게 두 개의 옵션들을 준다. 당신은 "
"properties_list 내에 그 프로퍼티를 지정할 수 있는데 그 경우 그것의 값이 대응"
"하는 select 표현식으로부터 얻어진다. 또는 당신은 properties_list에서 그것을 "
"생략할 수 있는데 그 경우에 <literal>org.hibernate.type.VersionType</literal>"
"에 의해 정의된 <literal>seed value</literal> 값이 사용된다."

#. Tag: para
#, no-c-format
msgid ""
"The following is an example of an HQL <literal>INSERT</literal> statement "
"execution:"
msgstr "다음은 HQL <literal>INSERT</literal> 문장 실행 예제이다:"

#~ msgid ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "for ( int i=0; i<100000; i++ ) {\n"
#~ "    Customer customer = new Customer(.....);\n"
#~ "    session.save(customer);\n"
#~ "}\n"
#~ "tx.commit();\n"
#~ "session.close();]]>"
#~ msgstr ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "for ( int i=0; i<100000; i++ ) {\n"
#~ "    Customer customer = new Customer(.....);\n"
#~ "    session.save(customer);\n"
#~ "}\n"
#~ "tx.commit();\n"
#~ "session.close();]]>"

#~ msgid "<![CDATA[hibernate.jdbc.batch_size 20]]>"
#~ msgstr "<![CDATA[hibernate.jdbc.batch_size 20]]>"

#~ msgid "<![CDATA[hibernate.cache.use_second_level_cache false]]>"
#~ msgstr "<![CDATA[hibernate.cache.use_second_level_cache false]]>"

#~ msgid ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "   \n"
#~ "for ( int i=0; i<100000; i++ ) {\n"
#~ "    Customer customer = new Customer(.....);\n"
#~ "    session.save(customer);\n"
#~ "    if ( i % 20 == 0 ) { //20, same as the JDBC batch size\n"
#~ "        //flush a batch of inserts and release memory:\n"
#~ "        session.flush();\n"
#~ "        session.clear();\n"
#~ "    }\n"
#~ "}\n"
#~ "   \n"
#~ "tx.commit();\n"
#~ "session.close();]]>"
#~ msgstr ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "   \n"
#~ "for ( int i=0; i<100000; i++ ) {\n"
#~ "    Customer customer = new Customer(.....);\n"
#~ "    session.save(customer);\n"
#~ "    if ( i % 20 == 0 ) { //20, same as the JDBC batch size\n"
#~ "        //flush a batch of inserts and release memory:\n"
#~ "        session.flush();\n"
#~ "        session.clear();\n"
#~ "    }\n"
#~ "}\n"
#~ "   \n"
#~ "tx.commit();\n"
#~ "session.close();]]>"

#~ msgid ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "   \n"
#~ "ScrollableResults customers = session.getNamedQuery(\"GetCustomers\")\n"
#~ "    .setCacheMode(CacheMode.IGNORE)\n"
#~ "    .scroll(ScrollMode.FORWARD_ONLY);\n"
#~ "int count=0;\n"
#~ "while ( customers.next() ) {\n"
#~ "    Customer customer = (Customer) customers.get(0);\n"
#~ "    customer.updateStuff(...);\n"
#~ "    if ( ++count % 20 == 0 ) {\n"
#~ "        //flush a batch of updates and release memory:\n"
#~ "        session.flush();\n"
#~ "        session.clear();\n"
#~ "    }\n"
#~ "}\n"
#~ "   \n"
#~ "tx.commit();\n"
#~ "session.close();]]>"
#~ msgstr ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "   \n"
#~ "ScrollableResults customers = session.getNamedQuery(\"GetCustomers\")\n"
#~ "    .setCacheMode(CacheMode.IGNORE)\n"
#~ "    .scroll(ScrollMode.FORWARD_ONLY);\n"
#~ "int count=0;\n"
#~ "while ( customers.next() ) {\n"
#~ "    Customer customer = (Customer) customers.get(0);\n"
#~ "    customer.updateStuff(...);\n"
#~ "    if ( ++count % 20 == 0 ) {\n"
#~ "        //flush a batch of updates and release memory:\n"
#~ "        session.flush();\n"
#~ "        session.clear();\n"
#~ "    }\n"
#~ "}\n"
#~ "   \n"
#~ "tx.commit();\n"
#~ "session.close();]]>"

#~ msgid ""
#~ "<![CDATA[StatelessSession session = sessionFactory.openStatelessSession"
#~ "();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "   \n"
#~ "ScrollableResults customers = session.getNamedQuery(\"GetCustomers\")\n"
#~ "    .scroll(ScrollMode.FORWARD_ONLY);\n"
#~ "while ( customers.next() ) {\n"
#~ "    Customer customer = (Customer) customers.get(0);\n"
#~ "    customer.updateStuff(...);\n"
#~ "    session.update(customer);\n"
#~ "}\n"
#~ "   \n"
#~ "tx.commit();\n"
#~ "session.close();]]>"
#~ msgstr ""
#~ "<![CDATA[StatelessSession session = sessionFactory.openStatelessSession"
#~ "();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "   \n"
#~ "ScrollableResults customers = session.getNamedQuery(\"GetCustomers\")\n"
#~ "    .scroll(ScrollMode.FORWARD_ONLY);\n"
#~ "while ( customers.next() ) {\n"
#~ "    Customer customer = (Customer) customers.get(0);\n"
#~ "    customer.updateStuff(...);\n"
#~ "    session.update(customer);\n"
#~ "}\n"
#~ "   \n"
#~ "tx.commit();\n"
#~ "session.close();]]>"

#~ msgid ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "\n"
#~ "String hqlUpdate = \"update Customer c set c.name = :newName where c.name "
#~ "= :oldName\";\n"
#~ "// or String hqlUpdate = \"update Customer set name = :newName where name "
#~ "= :oldName\";\n"
#~ "int updatedEntities = s.createQuery( hqlUpdate )\n"
#~ "        .setString( \"newName\", newName )\n"
#~ "        .setString( \"oldName\", oldName )\n"
#~ "        .executeUpdate();\n"
#~ "tx.commit();\n"
#~ "session.close();]]>"
#~ msgstr ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "\n"
#~ "String hqlUpdate = \"update Customer c set c.name = :newName where c.name "
#~ "= :oldName\";\n"
#~ "// or String hqlUpdate = \"update Customer set name = :newName where name "
#~ "= :oldName\";\n"
#~ "int updatedEntities = s.createQuery( hqlUpdate )\n"
#~ "        .setString( \"newName\", newName )\n"
#~ "        .setString( \"oldName\", oldName )\n"
#~ "        .executeUpdate();\n"
#~ "tx.commit();\n"
#~ "session.close();]]>"

#~ msgid ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "String hqlVersionedUpdate = \"update versioned Customer set name = :"
#~ "newName where name = :oldName\";\n"
#~ "int updatedEntities = s.createQuery( hqlUpdate )\n"
#~ "        .setString( \"newName\", newName )\n"
#~ "        .setString( \"oldName\", oldName )\n"
#~ "        .executeUpdate();\n"
#~ "tx.commit();\n"
#~ "session.close();]]>"
#~ msgstr ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "String hqlVersionedUpdate = \"update versioned Customer set name = :"
#~ "newName where name = :oldName\";\n"
#~ "int updatedEntities = s.createQuery( hqlUpdate )\n"
#~ "        .setString( \"newName\", newName )\n"
#~ "        .setString( \"oldName\", oldName )\n"
#~ "        .executeUpdate();\n"
#~ "tx.commit();\n"
#~ "session.close();]]>"

#~ msgid ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "\n"
#~ "String hqlDelete = \"delete Customer c where c.name = :oldName\";\n"
#~ "// or String hqlDelete = \"delete Customer where name = :oldName\";\n"
#~ "int deletedEntities = s.createQuery( hqlDelete )\n"
#~ "        .setString( \"oldName\", oldName )\n"
#~ "        .executeUpdate();\n"
#~ "tx.commit();\n"
#~ "session.close();]]>"
#~ msgstr ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "\n"
#~ "String hqlDelete = \"delete Customer c where c.name = :oldName\";\n"
#~ "// or String hqlDelete = \"delete Customer where name = :oldName\";\n"
#~ "int deletedEntities = s.createQuery( hqlDelete )\n"
#~ "        .setString( \"oldName\", oldName )\n"
#~ "        .executeUpdate();\n"
#~ "tx.commit();\n"
#~ "session.close();]]>"

#~ msgid ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "\n"
#~ "String hqlInsert = \"insert into DelinquentAccount (id, name) select c."
#~ "id, c.name from Customer c where ...\";\n"
#~ "int createdEntities = s.createQuery( hqlInsert )\n"
#~ "        .executeUpdate();\n"
#~ "tx.commit();\n"
#~ "session.close();]]>"
#~ msgstr ""
#~ "<![CDATA[Session session = sessionFactory.openSession();\n"
#~ "Transaction tx = session.beginTransaction();\n"
#~ "\n"
#~ "String hqlInsert = \"insert into DelinquentAccount (id, name) select c."
#~ "id, c.name from Customer c where ...\";\n"
#~ "int createdEntities = s.createQuery( hqlInsert )\n"
#~ "        .executeUpdate();\n"
#~ "tx.commit();\n"
#~ "session.close();]]>"
