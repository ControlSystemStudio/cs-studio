msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-04T04:51:21\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, no-c-format
msgid "Basic O/R Mapping"
msgstr "기본 O/R 매핑"

#. Tag: title
#, no-c-format
msgid "Mapping declaration"
msgstr "매핑 선언"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Object/relational mappings are usually defined in an XML document. The "
"mapping document is designed to be readable and hand-editable. The mapping "
"language is Java-centric, meaning that mappings are constructed around "
"persistent class declarations and not table declarations."
msgstr ""
"객체/관계형 매핑들은 대개 XML 문서 내에 정의된다. 매핑 문서는 가독성이 있고 "
"수작업 편집이 가능하도록 설계되어 있다. 매핑 언어는 매핑들이 테이블 선언들이 "
"아닌, 영속 클래스 선언들로 생성된다는 의미에서 자바 중심적이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Please note that even though many Hibernate users choose to write the XML by "
"hand, a number of tools exist to generate the mapping document. These "
"include XDoclet, Middlegen and AndroMDA."
msgstr ""
"심지어 많은 Hibernate 사용자들이 수작업으로 XML을 작성하고자 선택할지라도, "
"XDoclet, Middlegen, 그리고 AndroMDA를 포함하는, 매핑 문서를 생성시키는 많은 "
"도구들이 존재한다는 점을 노트하라."

#. Tag: para
#, fuzzy, no-c-format
msgid "Here is an example mapping:"
msgstr "예제 매핑으로 시작하자:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"We will now discuss the content of the mapping document. We will only "
"describe, however, the document elements and attributes that are used by "
"Hibernate at runtime. The mapping document also contains some extra optional "
"attributes and elements that affect the database schemas exported by the "
"schema export tool (for example, the <literal> not-null</literal> attribute)."
msgstr ""
"우리는 이제 매핑 문서의 내용을 논의할 것이다. 우리는 Hibernate에 의해 실행 시"
"에 사용되는 문서 요소들과 속성들 만을 설명할 것이다. 매핑 문서는 또한 스키마 "
"내보내기 도구에 의해 내보내진 데이터베이스 스키마에 영향을 주는 어떤 특별한 "
"옵션 속성들과 요소들을 포함한다. (예를 들어 <literal>not-null</literal> 속"
"성.)"

#. Tag: title
#, no-c-format
msgid "Doctype"
msgstr "Doctype"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"All XML mappings should declare the doctype shown. The actual DTD can be "
"found at the URL above, in the directory <literal>hibernate-x.x.x/src/org/"
"hibernate </literal>, or in <literal>hibernate3.jar</literal>. Hibernate "
"will always look for the DTD in its classpath first. If you experience "
"lookups of the DTD using an Internet connection, check the DTD declaration "
"against the contents of your classpath."
msgstr ""
"모든 XML 매핑들은 doctype이 보이게 선언해야 한다. 실제 DTD는 위의 URL에서, "
"<literal>hibernate-x.x.x/src/org/hibernate</literal> 디렉토리 내에서 또는 "
"<literal>hibernate3.jar</literal> 내에서 찾을 수 있다. Hibernate는 항상 첫 번"
"째로 그것의 classpath 속에서 DTD를 찾게 될 것이다. 만일 당신이 인터넷 연결을 "
"사용하는 DTD에 대한 룩업들을 겪게 될 경우, 당신의 classpath의 컨텐츠에 대해 "
"당신의 DTD 선언을 체크하라."

#. Tag: title
#, no-c-format
msgid "EntityResolver"
msgstr "EntityResolver"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate will first attempt to resolve DTDs in its classpath. It does this "
"is by registering a custom <literal>org.xml.sax.EntityResolver</literal> "
"implementation with the SAXReader it uses to read in the xml files. This "
"custom <literal>EntityResolver</literal> recognizes two different systemId "
"namespaces:"
msgstr ""
"앞서 언급했듯이, Hibernate는 먼저 그것의 classpath에서 DTD들을 해석하려고 시"
"도할 것이다. Hibernate가 이것을 행하는 방법은 그것이 xml 파일들을 읽어들이는"
"데 사용하는 SAXReader에 맞춤형 <literal>org.xml.sax.EntityResolver</literal> "
"구현을 등록하는 것이다. 이 맞춤형 <literal>EntityResolver</literal>는 두 개"
"의 다른 systemId namespace들을 인지해낸다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"a <literal>hibernate namespace</literal> is recognized whenever the resolver "
"encounters a systemId starting with <literal>http://hibernate.sourceforge."
"net/</literal>. The resolver attempts to resolve these entities via the "
"classloader which loaded the Hibernate classes."
msgstr ""
"<literal>hibernate namespace</literal>는 resolver가 <literal>http://"
"hibernate.sourceforge.net/</literal>로 시작하는 하나의 systemId와 만날때마다 "
"인지된다; resolver는 Hibernate 클래스들을 로드시켰던 클래스로더를 통해 이들 "
"엔티티들을 해석하려고 시도한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"a <literal>user namespace</literal> is recognized whenever the resolver "
"encounters a systemId using a <literal>classpath://</literal> URL protocol. "
"The resolver will attempt to resolve these entities via (1) the current "
"thread context classloader and (2) the classloader which loaded the "
"Hibernate classes."
msgstr ""
"<literal>user namespace</literal>는 resolver가 <literal>classpath://</"
"literal> URL 프로토콜을 사용하는 systemId를 만날때마다 인지된다; resolver는 "
"(1)현재 쓰레드 컨텍스트 클래스로더와 (2)Hibernate 클래스들을 로드시켰던 클래"
"스로더를 통해 이들 엔티티들을 해석하려고 시도할 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid "The following is an example of utilizing user namespacing:"
msgstr "user namespacing을 활용하는 예제:"

#. Tag: para
#, no-c-format
msgid ""
"Where <literal>types.xml</literal> is a resource in the <literal>your."
"domain</literal> package and contains a custom <link linkend=\"mapping-types-"
"custom\">typedef</link>."
msgstr ""
"여기서 <literal>types.xml</literal>은 <literal>your.domain</literal> 패키지 "
"내에 있는 리소스이고 맞춤형 <xref linkend=\"mapping-types-custom\">typedef</"
"xref>를 포함한다."

#. Tag: title
#, fuzzy, no-c-format
msgid "Hibernate-mapping"
msgstr "hibernate-mapping"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This element has several optional attributes. The <literal>schema</literal> "
"and <literal>catalog</literal> attributes specify that tables referred to in "
"this mapping belong to the named schema and/or catalog. If they are "
"specified, tablenames will be qualified by the given schema and catalog "
"names. If they are missing, tablenames will be unqualified. The "
"<literal>default-cascade</literal> attribute specifies what cascade style "
"should be assumed for properties and collections that do not specify a "
"<literal>cascade</literal> attribute. By default, the <literal>auto-import</"
"literal> attribute allows you to use unqualified class names in the query "
"language."
msgstr ""
"이 요소는 몇 개의 선택적인 속성들을 갖는다. <literal>schema</literal> 속성과 "
"<literal>catalog</literal> 속성은 이 매핑 내에서 참조된 테이블들이 명명된 "
"schema 와/또는 catalog에 속한다는 점을 지정한다. 만일 지정될 경우, 테이블 이"
"름들은 주어진 schema 이름과 catalog 이름에 의해 한정(수식)될 것이다. 누락될 "
"경우, 테이블 이름들은 한정되지((수식어가 붙지) 않을 것이다. <literal>default-"
"cascade</literal> 속성은 <literal>cascade</literal> 속성을 지정하지 않은 프로"
"퍼티들과 콜렉션들에 대해 전제될 <literal>cascade</literal> 스타일이 무엇인지"
"를 지정한다. <literal>auto-import</literal> 속성은 디폴트로 우리가 질의 언어 "
"속에서 수식어가 붙지 않은(unqualified) 클래스 이름들을 사용하게 할 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>schema</literal> (optional): the name of a database schema."
msgstr "<literal>schema</literal> (옵션): 데이터베이스 스키마의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>catalog</literal> (optional): the name of a database catalog."
msgstr "<literal>catalog</literal> (옵션): 데이터베이스 카다록의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>default-cascade</literal> (optional - defaults to <literal>none</"
"literal>): a default cascade style."
msgstr ""
"<literal>default-cascade</literal> (옵션 - 디폴트는 <literal>none</"
"literal>): 디폴트 cascade 스타일."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>default-access</literal> (optional - defaults to <literal>property</"
"literal>): the strategy Hibernate should use for accessing all properties. "
"It can be a custom implementation of <literal>PropertyAccessor</literal>."
msgstr ""
"<literal>default-access</literal> (옵션 - 디폴트는 <literal>property</"
"literal>): Hibernate가 모든 프로퍼티들에 액세스하는데 사용하게 될 방도. "
"<literal>PropertyAccessor</literal>에 대한 맞춤형 구현일 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>default-lazy</literal> (optional - defaults to <literal>true</"
"literal>): the default value for unspecified <literal>lazy</literal> "
"attributes of class and collection mappings."
msgstr ""
"<literal>default-lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"class 및 collection 매핑들의 지정되지 않은 <literal>lazy</literal> 속성들에 "
"대한 디폴트 값."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>auto-import</literal> (optional - defaults to <literal>true</"
"literal>): specifies whether we can use unqualified class names of classes "
"in this mapping in the query language."
msgstr ""
"<literal>auto-import</literal> (옵션 - 디폴트는 <literal>true</literal>): 우"
"리가 질의 언어 내에 (이 매핑에서 클래스들에 대해) 수식어가 붙지 않은 클래스 "
"이름들을 사용할 수 있는지를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>package</literal> (optional): specifies a package prefix to use for "
"unqualified class names in the mapping document."
msgstr ""
"<literal>package</literal> (옵션): 매핑 문서 내에서 수식어가 붙지 않은 클래"
"스 이름들에 대해 가정할 패키지 접두어를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you have two persistent classes with the same unqualified name, you "
"should set <literal>auto-import=\"false\"</literal>. An exception will "
"result if you attempt to assign two classes to the same \"imported\" name."
msgstr ""
"만일 당신이 동일한 (수식어가 붙지 않은) 이름을 가진 두 개의 영속 클래스들을 "
"갖고 있다면, 당신은 <literal>auto-import=\"false\"</literal>를 설정해야 한"
"다. 만일 당신이 두 개의 클래스들에 동일한 \"imported\" 이름을 할당하려고 시도"
"할 경우에 Hibernate는 예외상황을 던질 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>hibernate-mapping</literal> element allows you to nest several "
"persistent <literal>&lt;class&gt;</literal> mappings, as shown above. It is, "
"however, good practice (and expected by some tools) to map only a single "
"persistent class, or a single class hierarchy, in one mapping file and name "
"it after the persistent superclass. For example, <literal>Cat.hbm.xml</"
"literal>, <literal>Dog.hbm.xml</literal>, or if using inheritance, "
"<literal>Animal.hbm.xml</literal>."
msgstr ""
"위에 보여진 것처럼 <literal>hibernate-mapping</literal> 요소는 몇몇 영속 "
"<literal>&lt;class&gt;</literal> 매핑들을 내부에 포함하는 것을 허용해준다는 "
"점을 노트하라. 하지만 한 개의 매핑 파일 속에 한 개의 영속 클래스(또는 한 개"
"의 클래스 계층구조) 만을 매핑하고 영속 서브 클래스 뒤에 그것을 명명하는 것이 "
"좋은 연습이다 (그리고 몇몇 도구들에 의해 기대된다). 예를 들면 <literal>Cat."
"hbm.xml</literal>, <literal>Dog.hbm.xml</literal> 또는 상속을 사용할 경우에"
"는 <literal>Animal.hbm.xml</literal>."

#. Tag: title
#, fuzzy, no-c-format
msgid "Class"
msgstr "class"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can declare a persistent class using the <literal>class</literal> "
"element. For example:"
msgstr ""
"당신은 <literal>class</literal> 요소를 사용하여 영속 클래스를 선언할 수도 있"
"다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>name</literal> (optional): the fully qualified Java class name of "
"the persistent class or interface. If this attribute is missing, it is "
"assumed that the mapping is for a non-POJO entity."
msgstr ""
"<literal>name</literal> (옵션): 영속 클래스(또는 인터페이스)의 전체 수식어가 "
"붙은 Java 클래스 이름. 만일 이 속성이 누락될 경우, 매핑이 non-POJO 엔티티라"
"고 가정된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>table</literal> (optional - defaults to the unqualified class "
"name): the name of its database table."
msgstr ""
"<literal>table</literal> (옵션 - 디폴트는 수식어가 붙지 않은 클래스명): 그것"
"의 데이터베이스 테이블의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>discriminator-value</literal> (optional - defaults to the class "
"name): a value that distinguishes individual subclasses that is used for "
"polymorphic behavior. Acceptable values include <literal>null</literal> and "
"<literal>not null</literal>."
msgstr ""
"<literal>discriminator-value</literal> (옵션 - 디폴트는 클래스 이름): 다형성"
"(polymorphic) 특징에 사용되는, 개별 서브 클래스들를 구별짓는 값. 허용가능한 "
"값들은<literal>null</literal>과 <literal>not null</literal>을 포함한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>mutable</literal> (optional - defaults to <literal>true</literal>): "
"specifies that instances of the class are (not) mutable."
msgstr ""
"<literal>mutable</literal> (옵션 - 디폴트는 <literal>true</literal>): 클래스"
"들의 인스턴스들이 가변적인지를 (가변적이지 않은지를) 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>schema</literal> (optional): overrides the schema name specified by "
"the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>schema</literal> (옵션): 루트 <literal>&lt;hibernate-mapping&gt;</"
"literal> 요소에 의해 지정된 스키마 이름을 오버라이드 시킨다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>schema</literal> (옵션): 루트 <literal>&lt;hibernate-mapping&gt;</"
"literal> 요소에 의해 지정된 스키마 이름을 오버라이드 시킨다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>catalog</literal> (optional): overrides the catalog name specified "
"by the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>catalog</literal> (옵션): 루트 <literal>&lt;hibernate-mapping&gt;</"
"literal> 요소에 의해 지정된 카다록 이름을 오버라이드 시킨다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>catalog</literal> (옵션): 루트 <literal>&lt;hibernate-mapping&gt;</"
"literal> 요소에 의해 지정된 카타록 이름을 오버라이드 시킨다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>proxy</literal> (optional): specifies an interface to use for lazy "
"initializing proxies. You can specify the name of the class itself."
msgstr ""
"<literal>proxy</literal> (옵션): lazy initializing proxy들에 사용할 인터페이"
"스를 지정한다. 당신은 클래스 그 자체의 이름을 지정할 수 도 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>dynamic-update</literal> (optional - defaults to <literal>false</"
"literal>): specifies that <literal>UPDATE</literal> SQL should be generated "
"at runtime and can contain only those columns whose values have changed."
msgstr ""
"<literal>dynamic-update</literal> (옵션 - 디폴트는 <literal>false</"
"literal>): <literal>UPDATE</literal> SQL이 실행 시에 생성되고 그들 컬럼들의 "
"값들이 변경된 그들 컬럼들 만을 포함할 것인지를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>dynamic-insert</literal> (optional - defaults to <literal>false</"
"literal>): specifies that <literal>INSERT</literal> SQL should be generated "
"at runtime and contain only the columns whose values are not null."
msgstr ""
"<literal>dynamic-insert</literal> (옵션 - 디폴트는 <literal>false</"
"literal>): 생성될 <literal>INSERT</literal>이 실행 시에 생성되고 그들 컬럼들"
"의 값이 null이 아닌 컬럼들 만을 포함할 것인지를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>select-before-update</literal> (optional - defaults to "
"<literal>false</literal>): specifies that Hibernate should <emphasis>never</"
"emphasis> perform an SQL <literal>UPDATE</literal> unless it is certain that "
"an object is actually modified. Only when a transient object has been "
"associated with a new session using <literal>update()</literal>, will "
"Hibernate perform an extra SQL <literal>SELECT</literal> to determine if an "
"<literal>UPDATE</literal> is actually required."
msgstr ""
"<literal>select-before-update</literal> (옵션 - 디폴트는 <literal>false</"
"literal>): 객체가 실제로 변경되는 것이 확실하지 않는 한, Hibernate가 SQL "
"<literal>UPDATE</literal>를 <emphasis>결코</emphasis> 실행하지 않을 것임을 지"
"정한다. 어떤 경우들에서(실제로 transient 객체가 <literal>update()</literal>"
"를 사용하여 새로운 session에 연관되었을 때에만), 이것은 하나의 "
"<literal>UPDATE</literal>가 실제로 필요한 경우인지 여부를 결정하기 위해 "
"Hibernate는 특별한 SQL <literal>SELECT</literal>를 실행할 것임을 의미한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>polymorphism</literal> (optional - defaults to <literal>implicit</"
"literal>): determines whether implicit or explicit query polymorphism is "
"used."
msgstr ""
"<literal>polymorphism</literal> (옵션 - 디폴트는 <literal>implicit</"
"literal>): implicit 질의 다형성이나 explicit 질의 다형성 중 어느 것이 사용될 "
"것인지를 결정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>where</literal> (optional): specifies an arbitrary SQL "
"<literal>WHERE</literal> condition to be used when retrieving objects of "
"this class."
msgstr ""
"<literal>where</literal> (옵션) 이 클래스의 객체들을 검색할 때 사용될 임의적"
"인 SQL <literal>WHERE</literal> 조건을 지정한다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>persister</literal> (optional): specifies a custom "
"<literal>ClassPersister</literal>."
msgstr ""
"<literal>persister</literal> (옵션): 맞춤형 <literal>ClassPersister</literal>"
"를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>batch-size</literal> (optional - defaults to <literal>1</literal>): "
"specifies a \"batch size\" for fetching instances of this class by "
"identifier."
msgstr ""
"<literal>batch-size</literal> (옵션 - 디폴트는 <literal>1</literal>) 식별자"
"에 의해 이 클래스의 인스턴스들을 페치시키는 \"배치 사이즈\"를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>version</"
"literal>): determines the optimistic locking strategy."
msgstr ""
"<literal>optimistic-lock</literal> (옵션 - 디폴트는 <literal>version</"
"literal>): optimistic 잠금 방도를 결정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional): lazy fetching can be disabled by setting "
"<literal>lazy=\"false\"</literal>."
msgstr ""
"<literal>lazy</literal> (옵션): <literal>lazy=\"false\"</literal>를 설정함으"
"로써 Lazy fetching이 전체적으로 사용불가능하게 될 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>entity-name</literal> (optional - defaults to the class name): "
"Hibernate3 allows a class to be mapped multiple times, potentially to "
"different tables. It also allows entity mappings that are represented by "
"Maps or XML at the Java level. In these cases, you should provide an "
"explicit arbitrary name for the entity. See <xref linkend=\"persistent-"
"classes-dynamicmodels\" /> and <xref linkend=\"xml\" /> for more information."
msgstr ""
"<literal>entity-name</literal>(옵션, 디폴트는 클래스 이름): Hibernate3는 하나"
"의 클래스가 (잠정적으로 다른 테이블들로) 여러번 매핑되는 것을 허용해주고, "
"Java 레벨에서 Map 또는 XML에 의해 표현 되는 엔티티 매핑들을 허용한다. 이들 경"
"우들에서, 당신은 그 엔티티에 대한 명시적인 임의의 이름을 제공해야 한다. "
"<literal>entity-name</literal> (옵션): Hibernate3는 하나의 클래스가 (잠정적으"
"로 다른 테이블들로) 여러 번 매핑되는 것을 허용하며, 자바 레벨에서 Map들 또는 "
"XML에 의해 표현되는 엔티티 매핑들을 허용한다. 이들 경우들에서, 당신은 그 엔티"
"티들에 대한 명시적인 임의의 이름을 제공해야 한다. 추가 정보는 <xref linkend="
"\"persistent-classes-dynamicmodels\"/>과 <xref linkend=\"xml\"/>을 보라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>check</literal> (optional): an SQL expression used to generate a "
"multi-row <emphasis>check</emphasis> constraint for automatic schema "
"generation."
msgstr ""
"<literal>check</literal> (옵션): 자동적인 스키마 생성을 위한 다중-행 "
"<emphasis>check</emphasis> constraint를 생성시키는데 사용되는 SQL 표현식."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>rowid</literal> (optional): Hibernate can use ROWIDs on databases. "
"On Oracle, for example, Hibernate can use the <literal>rowid</literal> extra "
"column for fast updates once this option has been set to <literal>rowid</"
"literal>. A ROWID is an implementation detail and represents the physical "
"location of a stored tuple."
msgstr ""
"<literal>rowid</literal> (옵션): Hibernate는 지원되는 데이터베이스들, 예를 들"
"어 Oracle 상에서 이른바 ROWID들을 사용할 수 있고, Hibernate는 당신이 이 옵션"
"을 <literal>rowid</literal>로 설정하는 경우에 빠른 업데이트를 위한 특별한 "
"<literal>rowid</literal> 컬럼을 사용할 수 있다. ROWID는 구현 상세이고 저장된 "
"튜플(tuple)의 물리적이니 위치를 표현한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>subselect</literal> (optional): maps an immutable and read-only "
"entity to a database subselect. This is useful if you want to have a view "
"instead of a base table. See below for more information."
msgstr ""
"<literal>subselect</literal> (옵션): 불변의 읽기 전용 엔티티를 데이터베이스 "
"subselect로 매핑시킨다. 당신이 기본 테이블 대신에 뷰를 갖고자 원할 경우에 유"
"용하지만, 사용을 자제하라. 추가 정보는 아래를 보라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>abstract</literal> (optional): is used to mark abstract "
"superclasses in <literal>&lt;union-subclass&gt;</literal> hierarchies."
msgstr ""
"<literal>abstract</literal> (옵션): <literal>&lt;union-subclass&gt;</"
"literal> 계층 구조들 내에서 abstract 슈퍼클래스들을 마크하는데 사용된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is acceptable for the named persistent class to be an interface. You can "
"declare implementing classes of that interface using the <literal>&lt;"
"subclass&gt;</literal> element. You can persist any <emphasis>static</"
"emphasis> inner class. Specify the class name using the standard form i.e. "
"<literal>e.g.Foo$Bar</literal>."
msgstr ""
"명명된 영속 클래스가 인터페이스가 되는 것은 완전히 수용가능하다. 그런 다음 당"
"신은 <literal>&lt;subclass&gt;</literal> 요소를 사용하여 그 인터페이스에 대"
"한 구현 클래스들을 선언할 것이다. 당신은 임의의 <emphasis>static</emphasis> "
"inner 클래스를 영속화 시킬 수 있다. 당신은 표준 형식, 예를 들어 <literal>eg."
"Foo$Bar</literal>를 사용하여 클래스 이름을 지정해야 한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Immutable classes, <literal>mutable=\"false\"</literal>, cannot be updated "
"or deleted by the application. This allows Hibernate to make some minor "
"performance optimizations."
msgstr ""
"불변의 클래스, <literal>mutable=\"false\"</literal>는 어플리케이션에 의해 업"
"데이트되지 않을 것이거나 삭제되지 않을 것이다. 이것은 Hibernate로 하여금 어"
"떤 마이너 퍼포먼스 최적화를 행하게끔 허용해준다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The optional <literal>proxy</literal> attribute enables lazy initialization "
"of persistent instances of the class. Hibernate will initially return CGLIB "
"proxies that implement the named interface. The persistent object will load "
"when a method of the proxy is invoked. See \"Initializing collections and "
"proxies\" below."
msgstr ""
"선택적인 <literal>proxy</literal> 속성은 그 클래스의 영속 인스턴스들에 대한 "
"lazy 초기화를 가능하게 해준다. Hibernate는 명명된 인터페이스를 구현하는 "
"CGLIB 프락시들을 초기에 반환할 것이다. 실제 영속 객체는 프락시의 메소드가 호"
"출될 때 로드될 것이다. 아래 \"Lazy 초기화를 위한 프락시들\"을 보라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<emphasis>Implicit</emphasis> polymorphism means that instances of the class "
"will be returned by a query that names any superclass or implemented "
"interface or class, and that instances of any subclass of the class will be "
"returned by a query that names the class itself. <emphasis>Explicit</"
"emphasis> polymorphism means that class instances will be returned only by "
"queries that explicitly name that class. Queries that name the class will "
"return only instances of subclasses mapped inside this <literal>&lt;class&gt;"
"</literal> declaration as a <literal>&lt;subclass&gt;</literal> or "
"<literal>&lt;joined-subclass&gt;</literal>. For most purposes, the default "
"<literal>polymorphism=\"implicit\"</literal> is appropriate. Explicit "
"polymorphism is useful when two different classes are mapped to the same "
"table This allows a \"lightweight\" class that contains a subset of the "
"table columns."
msgstr ""
"<emphasis>Implicit</emphasis> 다형성은 클래스의 인스턴스들이 어떤 서브클래스"
"나 구현된 인터페이스 또는 클래스를 명명하는 질의에 의해 반환될 것임을 의미하"
"고 그 클래스의 어떤 서브클래스에 대한 인스턴스들이 그 클래스 자체를 명명하는 "
"질의에 의해 반환될 것임을 의미한다. <emphasis>Explicit</emphasis> 다형성은 클"
"래스 인스턴스들이 그 클래스를 명시적으로 명명하는 질의들에 의해서만 반환될 것"
"임을 의미고 그 클래스를 명명하는 질의들이 이 <literal>&lt;class&gt;</"
"literal> 선언 내부에서 <literal>&lt;subclass&gt;</literal> 또는 <literal>&lt;"
"joined-subclass&gt;</literal>로 매핑된 서브 클래스들의 인스턴스들 만을 반환하"
"게 될 것임을 의미한다. 대부분의 용도로, 디폴트인 <literal>polymorphism="
"\"implicit\"</literal>가 적절하다.두 개의 다른 클래스들이 동일한 테이블로 매"
"핑될 때 Explicit 다형성이 유용하다(이것은 테이블 컬럼들의 서브셋을 포함하는 "
"\"경량급\" 클래스를 허용한다)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>persister</literal> attribute lets you customize the "
"persistence strategy used for the class. You can, for example, specify your "
"own subclass of <literal>org.hibernate.persister.EntityPersister</literal>, "
"or you can even provide a completely new implementation of the interface "
"<literal>org.hibernate.persister.ClassPersister</literal> that implements, "
"for example, persistence via stored procedure calls, serialization to flat "
"files or LDAP. See <literal>org.hibernate.test.CustomPersister</literal> for "
"a simple example of \"persistence\" to a <literal>Hashtable</literal>."
msgstr ""
"<literal>persister</literal> 속성은 클래스에 사용되는 영속화 방도를 당신이 커"
"스트마이징 할 수 있도록 해준다. 예를 들어 당신은 <literal>org.hibernate."
"persister.EntityPersister</literal>에 대한 당신 자신의 서브클래스를 지정할 수"
"도 있거나 당신은 심지어 예를 들어 플랫 파일들이나 LDAP로의 직렬화,내장 프로시"
"저 호출들을 통해 영속화를 구현하는 인터페이스 <literal>org.hibernate."
"persister.ClassPersister</literal>에 대한 완전히 새로운 구현을 제공할 수도 있"
"다. (<literal>Hashtable</literal>로의 \"영속성\"에 관한) 간단한 예제는 "
"<literal>org.hibernate.test.CustomPersister</literal>를 보라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>dynamic-update</literal> and <literal>dynamic-insert</literal> "
"settings are not inherited by subclasses, so they can also be specified on "
"the <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</"
"literal> elements. Although these settings can increase performance in some "
"cases, they can actually decrease performance in others."
msgstr ""
"<literal>dynamic-update</literal> 설정과 <literal>dynamic-insert</literal> 설"
"정은 서브클래스들에 의해 상속되지 않고 따라서 또한 <literal>&lt;subclass&gt;"
"</literal> 또는 <literal>&lt;joined-subclass&gt;</literal> 요소들 상에 지정"
"될 수도 있음을 노트하라. 이들 설정들은 몇몇 경우들에서 퍼포먼스를 증가시키지"
"만 다른 경우들에서는 퍼포먼스를 실제로 감소시킬 수도 있다. 적절하게 사용하라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Use of <literal>select-before-update</literal> will usually decrease "
"performance. It is useful to prevent a database update trigger being called "
"unnecessarily if you reattach a graph of detached instances to a "
"<literal>Session</literal>."
msgstr ""
"<literal>select-before-update</literal> 사용은 대개 퍼포먼스를 감소시킬 것이"
"다. 당신이 detached 인스턴스들의 그래프를 <literal>Session</literal>에 다시 "
"첨부할 경우에 그것은 데이터베이스 업데이트 트리거가 불필요하게 호출되는 것을 "
"방지하는데 매우 유용하다."

#. Tag: para
#, no-c-format
msgid ""
"If you enable <literal>dynamic-update</literal>, you will have a choice of "
"optimistic locking strategies:"
msgstr ""
"<literal>dynamic-update</literal>를 사용가능하게 할 경우, 당신은 다음 "
"optimistic 잠금 전략들을 선택하게 될 것이다:"

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>version</literal>: check the version/timestamp columns"
msgstr "<literal>version</literal>은 version/timestamp 컬럼들을 체크한다"

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>all</literal>: check all columns"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>dirty</literal>: check the changed columns, allowing some "
"concurrent updates"
msgstr ""
"<literal>dirty</literal>는 몇몇 동시성 업데이트들을 허용하여, 변경된 컬럼들"
"을 체크한다"

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>none</literal>: do not use optimistic locking"
msgstr "<literal>none</literal>은 optimistic 잠금을 사용하지 않는다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is <emphasis>strongly</emphasis> recommended that you use version/"
"timestamp columns for optimistic locking with Hibernate. This strategy "
"optimizes performance and correctly handles modifications made to detached "
"instances (i.e. when <literal>Session.merge()</literal> is used)."
msgstr ""
"우리는 당신이 Hibernate에서 optimistic 잠금을 위해 version/timestamp 컬럼들"
"을 사용할 것을 <emphasis>매우</emphasis> 강력하게 권장한다. 이것은 퍼포먼스"
"에 대해 최적의 방도이고 detached 인스턴스들에 대해 행해진 변경들을 정확하게 "
"핸들링하는 유일한 방도이다(예를 들어 <literal>Session.merge()</literal>가 사"
"용될 때)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"There is no difference between a view and a base table for a Hibernate "
"mapping. This is transparent at the database level, although some DBMS do "
"not support views properly, especially with updates. Sometimes you want to "
"use a view, but you cannot create one in the database (i.e. with a legacy "
"schema). In this case, you can map an immutable and read-only entity to a "
"given SQL subselect expression:"
msgstr ""
"Hibernate 매핑의 경우에 베이스 테이블과 뷰 사이에 차이점이 존재하지 않는다. "
"왜냐하면 이것이 데이터베이스 레벨에서는 투명하다고 기대되기 때문이다(몇몇 "
"DBMS는 뷰를 고유하게 지원하지 않고 특히 뷰 업데이트를 지원하지 않음을 노트하"
"라). 때때로 당신이 뷰를 사용하고자 원하지만, (예를 들어 리거시 스키마로) 데이"
"터베이스 속에 뷰를 생성시킬 수 없다. 이 경우에, 당신은 불변의 읽기 전용 엔티"
"티를 주어진 SQL subselect 표현식으로 매핑시킬 수 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Declare the tables to synchronize this entity with, ensuring that auto-flush "
"happens correctly and that queries against the derived entity do not return "
"stale data. The <literal>&lt;subselect&gt;</literal> is available both as an "
"attribute and a nested mapping element."
msgstr ""
"auto-flush가 정확하게 발생하도록 하고, 그리고 파생된 엔티티에 대한 질의들이 "
"쓸효성 없는 데이터를 반환하지 않도록 함으로써, 이 엔티티와 동기화 될 테이블"
"을 선언하라. <literal>&lt;subselect&gt;</literal>는 속성과 내포된 매핑 요소 "
"양자로서 이용 가능하다."

#. Tag: title
#, no-c-format
msgid "id"
msgstr "id"

#. Tag: para
#, no-c-format
msgid ""
"Mapped classes <emphasis>must</emphasis> declare the primary key column of "
"the database table. Most classes will also have a JavaBeans-style property "
"holding the unique identifier of an instance. The <literal>&lt;id&gt;</"
"literal> element defines the mapping from that property to the primary key "
"column."
msgstr ""
"매핑된 클래스들은 데이터베이스 테이블의 프라이머리 키 컬럼을 선언<emphasis>해"
"야 한다</emphasis>. 대부분의 클래스들은 또한 인스턴스의 유일 식별자를 소유하"
"는 자바빈즈-스타일 프로퍼티를 가질 것이다. <literal>&lt;id&gt;</literal> 요소"
"는 그 프로퍼티로부터 프라이머리 키 컬럼으로의 매핑을 정의한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>name</literal> (optional): the name of the identifier property."
msgstr "<literal>name</literal> (옵션): 식별자 프로퍼티의 이름."

#. Tag: para
#, no-c-format
msgid ""
"<literal>type</literal> (optional): a name that indicates the Hibernate type."
msgstr "<literal>type</literal> (옵션): Hibernate 타입을 나타내는 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): the "
"name of the primary key column."
msgstr ""
"<literal>column</literal> (옵션 - 디폴트는 프로퍼티 이름): 프라이머리 키 컬럼"
"의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>unsaved-value</literal> (optional - defaults to a \"sensible\" "
"value): an identifier property value that indicates an instance is newly "
"instantiated (unsaved), distinguishing it from detached instances that were "
"saved or loaded in a previous session."
msgstr ""
"<literal>unsaved-value</literal> (옵션 - 디폴트는 \"sensible\" 값): 이전 세션"
"에서 저장되었거나 로드되었던 detached(분리된) 인스턴스들로부터 그것을 구분지"
"우도록, 인스턴스가 새로이 초기화되어 있음(저장되어 있지 않음)을 나타내는 식별"
"자 프로퍼티 값."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>access</literal> (optional - defaults to <literal>property</"
"literal>): the strategy Hibernate should use for accessing the property "
"value."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 액세스하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 액세스하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근 하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 액세스하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도."

#. Tag: para
#, no-c-format
msgid ""
"If the <literal>name</literal> attribute is missing, it is assumed that the "
"class has no identifier property."
msgstr ""
"<literal>name</literal> 속성이 누락되면, 클래스는 식별자 프로퍼티를 갖지 않는"
"다고 가정된다."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>unsaved-value</literal> attribute is almost never needed in "
"Hibernate3."
msgstr ""
"<literal>unsaved-value</literal> 속성은 Hibernate3에서는 거의 필요하지 않다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"There is an alternative <literal>&lt;composite-id&gt;</literal> declaration "
"that allows access to legacy data with composite keys. Its use is strongly "
"discouraged for anything else."
msgstr ""
"composite 키들로서 리거시 데이터에 액세스하는 것을 허용해주는 대체적인 "
"<literal>&lt;composite-id&gt;</literal> 선언이 존재한다. 우리는 그 밖의 어떤"
"것에 대한 그것의 사용에 대해 강력하게 반대한다."

#. Tag: title
#, no-c-format
msgid "Generator"
msgstr "Generator"

#. Tag: para
#, no-c-format
msgid ""
"The optional <literal>&lt;generator&gt;</literal> child element names a Java "
"class used to generate unique identifiers for instances of the persistent "
"class. If any parameters are required to configure or initialize the "
"generator instance, they are passed using the <literal>&lt;param&gt;</"
"literal> element."
msgstr ""
"선택적인 <literal>&lt;generator&gt;</literal> 자식 요소는 영속 클래스의 인스"
"턴스들에 대한 유일 식별자들을 생성시키는데 사용되는 자바 클래스를 명명한다. "
"만일 임의의 파라미터들이 생성기 인스턴스를 구성하거나 초기화 시키는데 필요할 "
"경우, 그것들은 <literal>&lt;param&gt;</literal> 요소 를 사용하여 전달된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"All generators implement the interface <literal>org.hibernate.id."
"IdentifierGenerator</literal>. This is a very simple interface. Some "
"applications can choose to provide their own specialized implementations, "
"however, Hibernate provides a range of built-in implementations. The "
"shortcut names for the built-in generators are as follows:"
msgstr ""
"모든 생성기들은 <literal>org.hibernate.id.IdentifierGenerator</literal> 인터"
"페이스를 구현한다. 이것은 매우 간단한 인터페이스이다; 몇몇 어플리케이션들은 "
"그것들 자신의 특화된 구현들을 제공하도록 선택할 수 있다. 하지만 Hibernate는 "
"미리 빈드된 구현들의 영역들을 제공한다. 빌드-인 생성기(generator)들에 대한 단"
"축 이름들이 존재한다: <placeholder-1/>"

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>increment</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, no-c-format
msgid ""
"generates identifiers of type <literal>long</literal>, <literal>short</"
"literal> or <literal>int</literal> that are unique only when no other "
"process is inserting data into the same table. <emphasis>Do not use in a "
"cluster.</emphasis>"
msgstr ""
"동일한 테이블 속으로 데이터를 입력하는 다른 프로세스가 없을 때에만 유일한 "
"<literal>long</literal>, <literal>short</literal> 또는 <literal>int</"
"literal> 타입의 식별자들을 생성시킨다. <emphasis>클러스터 내에서는 사용하지 "
"말라.</emphasis>"

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>identity</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, no-c-format
msgid ""
"supports identity columns in DB2, MySQL, MS SQL Server, Sybase and "
"HypersonicSQL. The returned identifier is of type <literal>long</literal>, "
"<literal>short</literal> or <literal>int</literal>."
msgstr ""
"DB2, MySQL, MS SQL Server, Sybase, HypersonicSQL에서 식별 컬럼들을 지원한다. "
"반환되는 식별자는 <literal>long</literal>, <literal>short</literal> 또는 "
"<literal>int</literal> 타입이다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>sequence</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, no-c-format
msgid ""
"uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator in "
"Interbase. The returned identifier is of type <literal>long</literal>, "
"<literal>short</literal> or <literal>int</literal>"
msgstr ""
"DB2, PostgreSQL, Oracle, SAP DB, McKoi에서 시퀀스를 사용하거나 Interbase에서 "
"생성기(generator)를 사용한다. 반환되는 식별자는 <literal>long</literal>, "
"<literal>short</literal> 또는 <literal>int</literal> 타입이다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>hilo</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, no-c-format
msgid ""
"uses a hi/lo algorithm to efficiently generate identifiers of type "
"<literal>long</literal>, <literal>short</literal> or <literal>int</literal>, "
"given a table and column (by default <literal>hibernate_unique_key</literal> "
"and <literal>next_hi</literal> respectively) as a source of hi values. The "
"hi/lo algorithm generates identifiers that are unique only for a particular "
"database."
msgstr ""
"테이블과 컬럼(디폴트로 각각 <literal>hibernate_unique_key</literal>와 "
"<literal>next_hi</literal>)이 hi 값들의 소스로서 주어지면, <literal>long</"
"literal>, <literal>short</literal> 또는 <literal>int</literal> 타입의 식별자"
"들을 효과적으로 생성시키는데 hi/lo 알고리즘을 사용한다. hi/lo 알고리즘은 특"
"정 데이터베이스에 대해서만 유일한 식별자들을 생성시킨다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>seqhilo</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, no-c-format
msgid ""
"uses a hi/lo algorithm to efficiently generate identifiers of type "
"<literal>long</literal>, <literal>short</literal> or <literal>int</literal>, "
"given a named database sequence."
msgstr ""
"명명된 데이터베이스 시퀀스가 주어지면, <literal>long</literal>, "
"<literal>short</literal> 또는 <literal>int</literal> 타입의 식별자들을 효과적"
"으로 생성시키는데 hi/lo 알고리즘을 사용한다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>uuid</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"uses a 128-bit UUID algorithm to generate identifiers of type string that "
"are unique within a network (the IP address is used). The UUID is encoded as "
"a string of 32 hexadecimal digits in length."
msgstr ""
"네트웍 내에서 유일한(IP 주소가 사용된다) string 타입의 식별자들을 생성시키기 "
"위해 128 비트 UUID 알고리즘을 사용한다. UUID는 길이가 32인 16진수들의 문자열"
"로서 인코딩 된다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>guid</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, no-c-format
msgid "uses a database-generated GUID string on MS SQL Server and MySQL."
msgstr "MS SQL Server와 MySQL 상에서 데이터베이스 생성 GUID 문자열을 사용한다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>native</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"selects <literal>identity</literal>, <literal>sequence</literal> or "
"<literal>hilo</literal> depending upon the capabilities of the underlying "
"database."
msgstr ""
"기본 데이터베이스의 가용성들에 의존하여 <literal>identity</literal>, "
"<literal>sequence</literal> 또는 <literal>hilo</literal>를 찾아낸다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>assigned</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"lets the application assign an identifier to the object before <literal>save"
"()</literal> is called. This is the default strategy if no <literal>&lt;"
"generator&gt;</literal> element is specified."
msgstr ""
"어플리케이션으로 하여금 <literal>save()</literal>가 호출되기 전에 식별자를 객"
"체에 할당하도록 한다. <literal>&lt;generator&gt;</literal> 요소가 지정되지 않"
"을 경우 이것이 디폴트 방도이다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>select</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"retrieves a primary key, assigned by a database trigger, by selecting the "
"row by some unique key and retrieving the primary key value."
msgstr ""
"어떤 유일 키에 의해 행을 select하고 프라이머리 키 값을 검색함으로써 데이터베"
"이스 트리거에 의해 할당된 프라이머리 키를 검색한다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>foreign</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"uses the identifier of another associated object. It is usually used in "
"conjunction with a <literal>&lt;one-to-one&gt;</literal> primary key "
"association."
msgstr ""
"또 다른 연관된 객체의 식별자를 사용한다. 대개 <literal>&lt;one-to-one&gt;</"
"literal> 프라이머리 키 연관관계와 함께 사용된다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>sequence-identity</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"a specialized sequence generation strategy that utilizes a database sequence "
"for the actual value generation, but combines this with JDBC3 "
"getGeneratedKeys to return the generated identifier value as part of the "
"insert statement execution. This strategy is only supported on Oracle 10g "
"drivers targeted for JDK 1.4. Comments on these insert statements are "
"disabled due to a bug in the Oracle drivers."
msgstr ""
"실제 값 생성을 위해 데이터베이스 시퀀스를 활용하지만, 생성된 식별자 값을 "
"insert 문장 실행의 부분으로서 실제로 반환시키기 위해 이것을 JDBC3 "
"getGeneratedKeys와 결합시킨 특화된 시퀀스 생성 방도. 이 방도는 JDK 1.4에 대상"
"화된 Oracle 10g 드라이버들 상에서만 지원되는 거승로 알려져 있다. 이들 insert "
"문장들에 대한 주석들은 Oracle 드라이버들 내에 있는 버그 때문에 사용불가능하"
"게 되어 있음을 노트하라."

#. Tag: title
#, no-c-format
msgid "Hi/lo algorithm"
msgstr "Hi/lo algorithm"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>hilo</literal> and <literal>seqhilo</literal> generators "
"provide two alternate implementations of the hi/lo algorithm. The first "
"implementation requires a \"special\" database table to hold the next "
"available \"hi\" value. Where supported, the second uses an Oracle-style "
"sequence."
msgstr ""
"<literal>hilo</literal>와 <literal>seqhilo</literal> 생성기들은 식별자 생성"
"에 대한 마음에 드는 접근법인, hi/lo 알고리즘에 대한 두 개의 대체 구현들은 제"
"공한다. 첫 번째 구현은 다음에 이용 가능한 \"hi\" 값을 수용하기 위한 \"특별한"
"\" 데이터베이스 테이블을 필요로 한다. 두 번째는 (지원되는) Oracle 스타일의 시"
"퀀스를 사용한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Unfortunately, you cannot use <literal>hilo</literal> when supplying your "
"own <literal>Connection</literal> to Hibernate. When Hibernate uses an "
"application server datasource to obtain connections enlisted with JTA, you "
"must configure the <literal>hibernate.transaction.manager_lookup_class</"
"literal>."
msgstr ""
"불행히도 당신은 Hibernate에 당신 자신의 <literal>Connection</literal>을 제공"
"할 때 <literal>hilo</literal>를 사용할 수 없다. Hibernate가 JTA의 도움을 받"
"는 커넥션들을 얻기 위해 어플리케이션 서버 데이터소스를 사용할 때 당신은 "
"<literal>hibernate.transaction.manager_lookup_class</literal>를 적절하게 구성"
"해야 한다."

#. Tag: title
#, no-c-format
msgid "UUID algorithm"
msgstr "UUID 알고리즘"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The UUID contains: IP address, startup time of the JVM that is accurate to a "
"quarter second, system time and a counter value that is unique within the "
"JVM. It is not possible to obtain a MAC address or memory address from Java "
"code, so this is the best option without using JNI."
msgstr ""
"UUID 는 다음을 포함한다: IP 주소, JVM의 시작 시간(정확히 1/4 초), 시스템 시간"
"과 (JVM 내에서 유일한) counter 값. Java 코드로부터 MAC 주소 또는 메모리 주소"
"를 얻는 것은 불가능하여서, 이것은 우리가 JNI를 사용하지 않고서 행할 수 있는 "
"최상의 것이다."

#. Tag: title
#, no-c-format
msgid "Identity columns and sequences"
msgstr "식별 컬럼들과 시퀀스들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For databases that support identity columns (DB2, MySQL, Sybase, MS SQL), "
"you can use <literal>identity</literal> key generation. For databases that "
"support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you "
"can use <literal>sequence</literal> style key generation. Both of these "
"strategies require two SQL queries to insert a new object. For example:"
msgstr ""
"식별 컬럼들을 지원하는 데이터베이스들(DB2, MySQL, Sybase, MS SQL)의 경우, 당"
"신은 <literal>identity</literal> 키 생성을 사용할 수 있다. 시퀀스들을 지원하"
"는 데이터베이스들(DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB)의 경우, "
"당신은 <literal>sequence</literal> 스타일 키 생성을 사용할 수도 있다. 이들 방"
"도들 모두 새로운 객체를 insert하기 위해 두 개의 SQL 질의들을 필요로 한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For cross-platform development, the <literal>native</literal> strategy will, "
"depending on the capabilities of the underlying database, choose from the "
"<literal>identity</literal>, <literal>sequence</literal> and <literal>hilo</"
"literal> strategies."
msgstr ""
"크로스 플랫폼 개발을 위해서, <literal>native</literal> 방도가 기준 데이터베이"
"스들의 가용성들에 따라 <literal>identity</literal>, <literal>sequence</"
"literal>, <literal>hilo</literal> 방도 중에서 선택될 것이다."

#. Tag: title
#, no-c-format
msgid "Assigned identifiers"
msgstr "할당된 식별자들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you want the application to assign identifiers, as opposed to having "
"Hibernate generate them, you can use the <literal>assigned</literal> "
"generator. This special generator uses the identifier value already assigned "
"to the object's identifier property. The generator is used when the primary "
"key is a natural key instead of a surrogate key. This is the default "
"behavior if you do not specify a <literal>&lt;generator&gt;</literal> "
"element."
msgstr ""
"(Hibernate로 하여금 식별자들을 생성시키도록 하는 것과는 반대로) 당신이 어플리"
"케이션으로 하여금 식별자들을 할당하도록 원할 경우, 당신은 <literal>assigned</"
"literal> 생성기를 사용할 수 있다. 이 특별한 생성기는 객체의 identifier 프로퍼"
"티에 이미 할당된 식별자 값을 사용할 것이다. 이 생성기(generator)는 프라이머"
"리 키가 대용(surrogate ) 키 대신에 natural 키일 때 사용된다. 당신이 "
"<literal>&lt;generator&gt;</literal> 요소를 지정하지 않을 경우에 이것이 디폴"
"트 특징이다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>assigned</literal> generator makes Hibernate use "
"<literal>unsaved-value=\"undefined\"</literal>. This forces Hibernate to go "
"to the database to determine if an instance is transient or detached, unless "
"there is a version or timestamp property, or you define <literal>Interceptor."
"isUnsaved()</literal>."
msgstr ""
"<literal>assigned</literal> 생성기(generator)를 선택하는 것은 , version 또는 "
"timestamp 프로퍼티가 존재하지 않는 한 또는 당신이 <literal>Interceptor."
"isUnsaved()</literal>를 정의하지 않는 한, 하나의 인스턴스가 transient 또는 "
"detached인지를 결정하기 위해 Hibernae로 하여금 데이터베이스에 접촉하도록 강제"
"하는, <literal>unsaved-value=\"undefined\"</literal>를 Hibernate에게 사용하도"
"록 한다."

#. Tag: title
#, no-c-format
msgid "Primary keys assigned by triggers"
msgstr "트리거들에 의해 할당된 프라이머리 키들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate does not generate DDL with triggers. It is for legacy schemas only."
msgstr ""
"리거시 스키마에 대해서만(Hibernate는 트리거들을 가진 DDL을 생성시키지 않는"
"다)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"In the above example, there is a unique valued property named "
"<literal>socialSecurityNumber</literal>. It is defined by the class, as a "
"natural key and a surrogate key named <literal>person_id</literal>, whose "
"value is generated by a trigger."
msgstr ""
"위의 예제에서, natural 키로서 클래스에 의해 <literal>socialSecurityNumber</"
"literal>로 명명된 유일 값을 가진 프로퍼티가 존재하고, 트리거에 의해 그 값이 "
"생성되는 <literal>person_id</literal>로 명명된 대용키가 존재한다."

#. Tag: title
#, no-c-format
msgid "Enhanced identifier generators"
msgstr "NOT TRANSLATED!Enhanced identifier generators"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Starting with release 3.2.3, there are 2 new generators which represent a re-"
"thinking of 2 different aspects of identifier generation. The first aspect "
"is database portability; the second is optimization Optimization means that "
"you do not have to query the database for every request for a new identifier "
"value. These two new generators are intended to take the place of some of "
"the named generators described above, starting in 3.3.x. However, they are "
"included in the current releases and can be referenced by FQN."
msgstr ""
"Starting with release 3.2.3, there are 2 new generators which represent a re-"
"thinking of 2 different aspects of identifier generation. The first aspect "
"is database portability; the second is optimization (not having to query the "
"database for every request for a new identifier value). These two new "
"generators are intended to take the place of some of the named generators "
"described above (starting in 3.3.x); however, they are included in the "
"current releases and can be referenced by FQN."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The first of these new generators is <literal>org.hibernate.id.enhanced."
"SequenceStyleGenerator</literal> which is intended, firstly, as a "
"replacement for the <literal>sequence</literal> generator and, secondly, as "
"a better portability generator than <literal>native</literal>. This is "
"because <literal>native</literal> generally chooses between "
"<literal>identity</literal> and <literal>sequence</literal> which have "
"largely different semantics that can cause subtle issues in applications "
"eyeing portability. <literal>org.hibernate.id.enhanced."
"SequenceStyleGenerator</literal>, however, achieves portability in a "
"different manner. It chooses between a table or a sequence in the database "
"to store its incrementing values, depending on the capabilities of the "
"dialect being used. The difference between this and <literal>native</"
"literal> is that table-based and sequence-based storage have the same exact "
"semantic. In fact, sequences are exactly what Hibernate tries to emulate "
"with its table-based generators. This generator has a number of "
"configuration parameters:"
msgstr ""
"The first of these new generators is <literal>org.hibernate.id.enhanced."
"SequenceStyleGenerator</literal> which is intended firstly as a replacement "
"for the <literal>sequence</literal> generator and secondly as a better "
"portability generator than <literal>native</literal> (because "
"<literal>native</literal> (generally) chooses between <literal>identity</"
"literal> and <literal>sequence</literal> which have largely different "
"semantics which can cause subtle isssues in applications eyeing "
"portability). <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</"
"literal> however achieves portability in a different manner. It chooses "
"between using a table or a sequence in the database to store its "
"incrementing values depending on the capabilities of the dialect being used. "
"The difference between this and <literal>native</literal> is that table-"
"based and sequence-based storage have the same exact semantic (in fact "
"sequences are exactly what Hibernate tries to emmulate with its table-based "
"generators). This generator has a number of configuration parameters: "
"<placeholder-1/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>sequence_name</literal> (optional, defaults to "
"<literal>hibernate_sequence</literal>): the name of the sequence or table to "
"be used."
msgstr ""
"<literal>sequence_name</literal> (optional, defaults to "
"<literal>hibernate_sequence</literal>): The name of the sequence (or table) "
"to be used."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>initial_value</literal> (optional, defaults to <literal>1</"
"literal>): the initial value to be retrieved from the sequence/table. In "
"sequence creation terms, this is analogous to the clause typically named "
"\"STARTS WITH\"."
msgstr ""
"<literal>initial_value</literal> (optional, defaults to <literal>1</"
"literal>): The initial value to be retrieved from the sequence/table. In "
"sequence creation terms, this is analogous to the clause typical named "
"\"STARTS WITH\"."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>increment_size</literal> (optional - defaults to <literal>1</"
"literal>): the value by which subsequent calls to the sequence/table should "
"differ. In sequence creation terms, this is analogous to the clause "
"typically named \"INCREMENT BY\"."
msgstr ""
"<literal>increment_size</literal> (optional, defaults to <literal>1</"
"literal>): The value by which subsequent calls to the sequence/table should "
"differ. In sequence creation terms, this is analogous to the clause typical "
"named \"INCREMENT BY\"."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>force_table_use</literal> (optional - defaults to <literal>false</"
"literal>): should we force the use of a table as the backing structure even "
"though the dialect might support sequence?"
msgstr ""
"<literal>force_table_use</literal> (optional, defaults to <literal>false</"
"literal>): Should we force the use of a table as the backing structure even "
"though the dialect might support sequence?"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>value_column</literal> (optional - defaults to <literal>next_val</"
"literal>): only relevant for table structures, it is the name of the column "
"on the table which is used to hold the value."
msgstr ""
"<literal>value_column</literal> (optional, defaults to <literal>next_val</"
"literal>): Only relevant for table structures! The name of the column on the "
"table which is used to hold the value."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>optimizer</literal> (optional - defaults to <literal>none</"
"literal>): See <xref linkend=\"mapping-declaration-id-enhanced-optimizers\" /"
">"
msgstr ""
"<literal>optimizer</literal> (optional, defaults to <literal>none</"
"literal>): See <xref linkend=\"mapping-declaration-id-enhanced-optimizers\"/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The second of these new generators is <literal>org.hibernate.id.enhanced."
"TableGenerator</literal>, which is intended, firstly, as a replacement for "
"the <literal>table</literal> generator, even though it actually functions "
"much more like <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</"
"literal>, and secondly, as a re-implementation of <literal>org.hibernate.id."
"MultipleHiLoPerTableGenerator</literal> that utilizes the notion of "
"pluggable optimizers. Essentially this generator defines a table capable of "
"holding a number of different increment values simultaneously by using "
"multiple distinctly keyed rows. This generator has a number of configuration "
"parameters:"
msgstr ""
"The second of these new generators is <literal>org.hibernate.id.enhanced."
"TableGenerator</literal> which is intended firstly as a replacement for the "
"<literal>table</literal> generator (although it actually functions much more "
"like <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal>) and "
"secondly as a re-implementation of <literal>org.hibernate.id."
"MultipleHiLoPerTableGenerator</literal> utilizing the notion of pluggable "
"optimiziers. Essentially this generator defines a table capable of holding a "
"number of different increment values simultaneously by using multiple "
"distinctly keyed rows. This generator has a number of configuration "
"parameters: <placeholder-1/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>table_name</literal> (optional - defaults to "
"<literal>hibernate_sequences</literal>): the name of the table to be used."
msgstr ""
"<literal>table_name</literal> (optional, defaults to "
"<literal>hibernate_sequences</literal>): The name of the table to be used."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>value_column_name</literal> (optional - defaults to "
"<literal>next_val</literal>): the name of the column on the table that is "
"used to hold the value."
msgstr ""
"<literal>value_column_name</literal> (optional, defaults to "
"<literal>next_val</literal>): The name of the column on the table which is "
"used to hold the value."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>segment_column_name</literal> (optional - defaults to "
"<literal>sequence_name</literal>): the name of the column on the table that "
"is used to hold the \"segment key\". This is the value which identifies "
"which increment value to use."
msgstr ""
"<literal>segment_column_name</literal> (optional, defaults to "
"<literal>sequence_name</literal>): The name of the column on the table which "
"is used to hold the \"segement key\". This is the value which distinctly "
"identifies which increment value to use."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>segment_value</literal> (optional - defaults to <literal>default</"
"literal>): The \"segment key\" value for the segment from which we want to "
"pull increment values for this generator."
msgstr ""
"<literal>segment_value</literal> (optional, defaults to <literal>default</"
"literal>): The \"segment key\" value for the segment from which we want to "
"pull increment values for this generator."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>segment_value_length</literal> (optional - defaults to "
"<literal>255</literal>): Used for schema generation; the column size to "
"create this segment key column."
msgstr ""
"<literal>segment_value_length</literal> (optional, defaults to <literal>255</"
"literal>): Used for schema generation; the column size to create this "
"segment key column."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>initial_value</literal> (optional - defaults to <literal>1</"
"literal>): The initial value to be retrieved from the table."
msgstr ""
"<literal>initial_value</literal> (optional, defaults to <literal>1</"
"literal>): The initial value to be retrieved from the table."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>increment_size</literal> (optional - defaults to <literal>1</"
"literal>): The value by which subsequent calls to the table should differ."
msgstr ""
"<literal>increment_size</literal> (optional, defaults to <literal>1</"
"literal>): The value by which subsequent calls to the table should differ."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>optimizer</literal> (optional - defaults to <literal></literal>): "
"See <xref linkend=\"mapping-declaration-id-enhanced-optimizers\" />"
msgstr ""
"<literal>optimizer</literal> (optional, defaults to <literal>none</"
"literal>): See <xref linkend=\"mapping-declaration-id-enhanced-optimizers\"/>"

#. Tag: title
#, no-c-format
msgid "Identifier generator optimization"
msgstr "NOT TRANSLATED! Identifier generator optimization"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For identifier generators that store values in the database, it is "
"inefficient for them to hit the database on each and every call to generate "
"a new identifier value. Instead, you can group a bunch of them in memory and "
"only hit the database when you have exhausted your in-memory value group. "
"This is the role of the pluggable optimizers. Currently only the two "
"enhanced generators (<xref linkend=\"mapping-declaration-id-enhanced\" /> "
"support this operation."
msgstr ""
"For identifier generators which store values in the database, it is "
"inefficient for them to hit the database on each and every call to generate "
"a new identifier value. Instead, you'd ideally want to group a bunch of them "
"in memory and only hit the database when you have exhausted your in-memory "
"value group. This is the role of the pluggable optimizers. Currently only "
"the two enhanced generators (<xref linkend=\"mapping-declaration-id-enhanced"
"\"/> support this notion. <placeholder-1/>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>none</literal> (generally this is the default if no optimizer was "
"specified): this will not perform any optimizations and hit the database for "
"each and every request."
msgstr ""
"<literal>none</literal> (generally this is the default if no optimizer was "
"specified): This says to not perform any optimizations, and hit the database "
"each and every request."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>hilo</literal>: applies a hi/lo algorithm around the database "
"retrieved values. The values from the database for this optimizer are "
"expected to be sequential. The values retrieved from the database structure "
"for this optimizer indicates the \"group number\". The "
"<literal>increment_size</literal> is multiplied by that value in memory to "
"define a group \"hi value\"."
msgstr ""
"<literal>hilo</literal>: applies a hi/lo algorithm around the database "
"retrieved values. The values from the database for this optimizer are "
"expected to be sequential. The values retrieved from the database structure "
"for this optimizer indicates the \"group number\"; the "
"<literal>increment_size</literal> is multiplied by that value in memory to "
"define a group \"hi value\"."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>pooled</literal>: as with the case of <literal>hilo</literal>, this "
"optimizer attempts to minimize the number of hits to the database. Here, "
"however, we simply store the starting value for the \"next group\" into the "
"database structure rather than a sequential value in combination with an in-"
"memory grouping algorithm. Here, <literal>increment_size</literal> refers to "
"the values coming from the database."
msgstr ""
"<literal>pooled</literal>: like was discussed for <literal>hilo</literal>, "
"this optimizers attempts to minimize the number of hits to the database. "
"Here, however, we simply store the starting value for the \"next group\" "
"into the database structure rather than a sequential value in combination "
"with an in-memory grouping algorithm. <literal>increment_size</literal> here "
"refers to the values coming from the database."

#. Tag: title
#, no-c-format
msgid "composite-id"
msgstr "composite-id"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A table with a composite key can be mapped with multiple properties of the "
"class as identifier properties. The <literal>&lt;composite-id&gt;</literal> "
"element accepts <literal>&lt;key-property&gt;</literal> property mappings "
"and <literal>&lt;key-many-to-one&gt;</literal> mappings as child elements."
msgstr ""
"composite 키를 가진 테이블의 경우, 당신은 클래스의 여러 프로퍼티들을 식별자 "
"프로퍼티들로서 매핑할 수 있다. <literal>&lt;composite-id&gt;</literal> 요소"
"는 자식 요소들로서 <literal>&lt;key-property&gt;</literal> 프로퍼티 매핑과 "
"<literal>&lt;key-many-to-one&gt;</literal> 매핑들을 허용한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The persistent class <emphasis>must</emphasis> override <literal>equals()</"
"literal> and <literal>hashCode()</literal> to implement composite identifier "
"equality. It must also implement <literal>Serializable</literal>."
msgstr ""
"당신의 영속 클래스는 composite 식별자 동등성을 구현하기 위해서 "
"<literal>equals()</literal>와 <literal>hashCode()</literal>를 오버라이드 "
"<emphasis>시켜야 한다</emphasis>. 그것은 또한 <literal>Serializable</literal>"
"을 구현해야 한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Unfortunately, this approach means that a persistent object is its own "
"identifier. There is no convenient \"handle\" other than the object itself. "
"You must instantiate an instance of the persistent class itself and populate "
"its identifier properties before you can <literal>load()</literal> the "
"persistent state associated with a composite key. We call this approach an "
"<emphasis>embedded</emphasis> composite identifier, and discourage it for "
"serious applications."
msgstr ""
"불행히도, composite 식별자들에 대한 이 접근법은 영속 객체가 그것 자신의 식별"
"자라는 점을 의미한다. 객체 자신 외의 다른 \"핸들\"이 존재하지 않는다. 당신은 "
"당신이 composite key로 연관된 영속 상태를 <literal>load()</literal> 할 수 있"
"기 이전에 영속 클래스 그 자체의 인스턴스를 초기화 하고 그것의 식별자 프로퍼티"
"들을 군집화 시켜야 한다. 우리는 이 접근법을 <emphasis>embedded</emphasis> "
"composite 식별자로 부르고, 중대한 어플리케이션들에 대해 그것을 억제시킨다."

#. Tag: para
#, no-c-format
msgid ""
"A second approach is what we call a <emphasis>mapped</emphasis> composite "
"identifier, where the identifier properties named inside the <literal>&lt;"
"composite-id&gt;</literal> element are duplicated on both the persistent "
"class and a separate identifier class."
msgstr ""
"두 번째 접근법은 우리가 <emphasis>mapped</emphasis> composite 식별자라고 부르"
"는 것인데, 여기서 <literal>&lt;composite-id&gt;</literal> 요소 내에 명명된 여"
"기서 식별자 프로퍼티들은 영속 클래스와 별도의 식별자 클래스 양자 상에 중복된"
"다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"In this example, both the composite identifier class, <literal>MedicareId</"
"literal>, and the entity class itself have properties named "
"<literal>medicareNumber</literal> and <literal>dependent</literal>. The "
"identifier class must override <literal>equals()</literal> and "
"<literal>hashCode()</literal> and implement <literal>Serializable</literal>. "
"The main disadvantage of this approach is code duplication."
msgstr ""
"이 예제에서, composite 식별자 클래스인 <literal>MedicareId</literal>와 엔티"
"티 크래스 그 자체 양자는 <literal>medicareNumber</literal>와 "
"<literal>dependent</literal>로 명명된 프로퍼티들을 갖는다. 식별자 클래스는 "
"<literal>equals()</literal>와 <literal>hashCode()</literal>를 오버라이드 시켜"
"고 <literal>Serializable</literal>을 구현해야 한다. 이 접근법의 단점은 아주 "
"명백한&mdash;코드 중복이다."

#. Tag: para
#, no-c-format
msgid ""
"The following attributes are used to specify a mapped composite identifier:"
msgstr "다음 속성들은 매핑된 composite 식별자를 지정하는데 사용된다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>mapped</literal> (optional - defaults to <literal>false</literal>): "
"indicates that a mapped composite identifier is used, and that the contained "
"property mappings refer to both the entity class and the composite "
"identifier class."
msgstr ""
"<literal>mapped</literal> (옵션, 디폴트는 <literal>false</literal>): 하나의 "
"매핑된 composite 식별자가 사용됨을, 그리고 포함된 프로퍼티 매핑들이 엔티티 클"
"래스와 composite 식별자 클래스 양자를 참조함을 나타낸다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>class</literal> (optional - but required for a mapped composite "
"identifier): the class used as a composite identifier."
msgstr ""
"<literal>class</literal> (옵션, 하지만 하나의 매핑된 commposite 식별자에 대해"
"서는 필수적임): 하나의 composite 식별자로서 사용되는 클래스."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"We will describe a third, even more convenient approach, where the composite "
"identifier is implemented as a component class in <xref linkend=\"components-"
"compositeid\" />. The attributes described below apply only to this "
"alternative approach:"
msgstr ""
"우리는 <xref linkend=\"components-compositeid\"/>에서 composite 식별자가 하나"
"의 component 클래스로서 구현되는 보다 편리한 접근법인 세번째 방도를 설명할 것"
"이다. 아래에 설명되어 있는 속성들은 이 대체적인 접근법에만 적용된다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>name</literal> (optional - required for this approach): a property "
"of component type that holds the composite identifier. Please see chapter 9 "
"for more information."
msgstr ""
"<literal>name</literal> (옵션, 이 접근법의 경우에는 필수임): 하나의 "
"component 식별자를 소유하는 컴포넌트 타입의 프로퍼티(9장을 보라)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>access</literal> (optional - defaults to <literal>property</"
"literal>): the strategy Hibernate uses for accessing the property value."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 액세스하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 액세스하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근 하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 액세스하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>class</literal> (optional - defaults to the property type "
"determined by reflection): the component class used as a composite "
"identifier. Please see the next section for more information."
msgstr ""
"<literal>class</literal> (옵션 - 디폴트는 reflection에 의해 결정된 프로퍼티 "
"타입): 하나의 composite 식별자로서 사용되는 컴포넌트 클래스(다음 절을 보라)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The third approach, an <emphasis>identifier component</emphasis>, is "
"recommended for almost all applications."
msgstr ""
"이 세번째 접근법, <emphasis>identifier component</emphasis>은 거의 모든 어플"
"리케이션들에 대해 우리가 권장하는 것이다."

#. Tag: title
#, fuzzy, no-c-format
msgid "Discriminator"
msgstr "discriminator"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;discriminator&gt;</literal> element is required for "
"polymorphic persistence using the table-per-class-hierarchy mapping "
"strategy. It declares a discriminator column of the table. The discriminator "
"column contains marker values that tell the persistence layer what subclass "
"to instantiate for a particular row. A restricted set of types can be used: "
"<literal>string</literal>, <literal>character</literal>, <literal>integer</"
"literal>, <literal>byte</literal>, <literal>short</literal>, "
"<literal>boolean</literal>, <literal>yes_no</literal>, <literal>true_false</"
"literal>."
msgstr ""
"<literal>&lt;discriminator&gt;</literal> 요소는 table-per-class-hierarchy(테"
"이블 당 클래스 계층구조) 매핑 방도를 사용하는 다형성 영속화에 필요하고 테이블"
"의 discriminator(판별자) 컬럼을 선언한다. discriminator 컬럼은 특정 행에 대"
"해 초기화 시킬 서브 클래스가 무엇인지를 영속 계층에 알려주는 표시자 값들을 포"
"함한다. 타입들의 제한적인 집합이 사용될 수 있다: <literal>string</literal>, "
"<literal>character</literal>, <literal>integer</literal>, <literal>byte</"
"literal>, <literal>short</literal>, <literal>boolean</literal>, "
"<literal>yes_no</literal>, <literal>true_false</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to <literal>class</literal>): "
"the name of the discriminator column."
msgstr ""
"<literal>column</literal> (옵션 - 디폴트는 <literal>class</literal>) "
"discriminator 컬럼명."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>type</literal> (optional - defaults to <literal>string</literal>): "
"a name that indicates the Hibernate type"
msgstr ""
"<literal>type</literal> (옵션 - 디폴트는 <literal>string</literal>) "
"Hibernate 타입을 나타내는 이름"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>force</literal> (optional - defaults to <literal>false</literal>): "
"\"forces\" Hibernate to specify the allowed discriminator values, even when "
"retrieving all instances of the root class."
msgstr ""
"<literal>force</literal> (옵션 - 디폴트는 <literal>false</literal>) 이것은 "
"Hibernate로 하여금 루트 클래스의 모든 인스턴스들을 검색할 때조차도 허용된 "
"discriminator 값들을 지정하도록 \"강제한다\"."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>insert</literal> (optional - defaults to <literal>true</literal>): "
"set this to <literal>false</literal> if your discriminator column is also "
"part of a mapped composite identifier. It tells Hibernate not to include the "
"column in SQL <literal>INSERTs</literal>."
msgstr ""
"<literal>insert</literal> (옵션 - 디폴트는 <literal>true</literal>) 당신의 "
"discriminator 컬럼이 또한 매핑된 composite 식별자의 부분일 경우에 이것을 "
"<literal>false</literal>로 설정하라. (Hibernate에게 SQL <literal>INSERT</"
"literal>들 속에 그 컬럼을 포함하지 않도록 통보한다.)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>formula</literal> (optional): an arbitrary SQL expression that is "
"executed when a type has to be evaluated. It allows content-based "
"discrimination."
msgstr ""
"<literal>formula</literal> (옵션) 타입이 평가 되어야 할 때 실행되는 임의의 "
"SQL 표현식. 컨텐츠 기반의 판별을 허용해준다."

#. Tag: para
#, no-c-format
msgid ""
"Actual values of the discriminator column are specified by the "
"<literal>discriminator-value</literal> attribute of the <literal>&lt;"
"class&gt;</literal> and <literal>&lt;subclass&gt;</literal> elements."
msgstr ""
"discriminator 컬럼의 실제 값들은 <literal>&lt;class&gt;</literal> 요소와 "
"<literal>&lt;subclass&gt;</literal> 요소의 <literal>discriminator-value</"
"literal> 속성에 의해 지정된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>force</literal> attribute is only useful if the table contains "
"rows with \"extra\" discriminator values that are not mapped to a persistent "
"class. This will not usually be the case."
msgstr ""
"<literal>force</literal> 속성은 테이블이 영속 클래스로 매핑되지 않는 \"특별한"
"\" discriminator 값들을 가진 행들을 포함할 경우에(만) 유용하다. 이것은 대개 "
"그 경우가 아닐 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>formula</literal> attribute allows you to declare an arbitrary "
"SQL expression that will be used to evaluate the type of a row. For example:"
msgstr ""
"<literal>formula</literal> 속성을 사용하여 당신은 행의 타입을 판단하는데 사용"
"될 임의의 SQL 표현식을 선언할 수 있다:"

#. Tag: title
#, fuzzy, no-c-format
msgid "Version (optional)"
msgstr "version (옵션)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;version&gt;</literal> element is optional and indicates "
"that the table contains versioned data. This is particularly useful if you "
"plan to use <emphasis>long transactions</emphasis>. See below for more "
"information:"
msgstr ""
"<literal>&lt;version&gt;</literal> 요소는 옵션이고 테이블이 버전화된 데이터"
"를 포함한다는 것을 나타낸다. 이것은 당신이 <emphasis>긴 트랜잭션(long "
"transaction)들</emphasis>을 사용할 계획이라면 특히 유용하다 (아래를 보라)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): the "
"name of the column holding the version number."
msgstr ""
"<literal>column</literal> (옵션 - 디폴트는 프로퍼티 명): 버전 번호를 가진 컬"
"럼의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>name</literal>: the name of a property of the persistent class."
msgstr "<literal>name</literal>: 영속 클래스의 프로퍼티 명."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>type</literal> (optional - defaults to <literal>integer</literal>): "
"the type of the version number."
msgstr ""
"<literal>type</literal> (옵션 - 디폴트는 <literal>integer</literal>): 버전 번"
"호의 타입."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>access</literal> (optional - defaults to <literal>property</"
"literal>): the strategy Hibernate uses to access the property value."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 액세스하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 액세스하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근 하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 액세스하는데 사용할 방도.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (옵션 - 디폴트는 <literal>property</literal>): "
"Hibernate가 프로퍼티 값에 접근하는데 사용할 방도."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>unsaved-value</literal> (optional - defaults to <literal>undefined</"
"literal>): a version property value that indicates that an instance is newly "
"instantiated (unsaved), distinguishing it from detached instances that were "
"saved or loaded in a previous session. <literal>Undefined</literal> "
"specifies that the identifier property value should be used."
msgstr ""
"<literal>unsaved-value</literal> (옵션 - 디폴트는 <literal>undefined</"
"literal>): 이전 세션에서 저장되었거나 로드되었던 detached 인스턴스로부터 구별"
"지어서, 인스턴스가 새로이 초기화됨(unsaved)을 나타내는 version 프로퍼티 값."
"(<literal>undefined</literal>는 식별자 프로퍼티 값이 사용될 것임을 지정한다.)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>generated</literal> (optional - defaults to <literal>never</"
"literal>): specifies that this version property value is generated by the "
"database. See the discussion of <link linkend=\"mapping-generated"
"\">generated properties</link> for more information."
msgstr ""
"<literal>generated</literal> (옵션 - 디폴트는 <literal>never</literal>): 이 "
"version 프로퍼티 값이 데이터베이스에 의해 실제로 산출되는지를 지정한다. "
"<xref linkend=\"mapping-generated\">산출되는 프로퍼티들</xref>에 관한 논의를 "
"보라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>insert</literal> (optional - defaults to <literal>true</literal>): "
"specifies whether the version column should be included in SQL insert "
"statements. It can be set to <literal>false</literal> if the database column "
"is defined with a default value of <literal>0</literal>."
msgstr ""
"<literal>insert</literal> (옵션 - 디폴트는 <literal>true</literal>): version "
"컬럼이 SQL insert 문장들 속에 포함될 것인지 여부를 지정한다. 데이터베이스 컬"
"럼이 디폴트 값 <literal>0</literal>으로 정의되는 경우에만 <literal>false</"
"literal>로 설정될 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Version numbers can be of Hibernate type <literal>long</literal>, "
"<literal>integer</literal>, <literal>short</literal>, <literal>timestamp</"
"literal> or <literal>calendar</literal>."
msgstr ""
"버전 번호들은 <literal>long</literal>, <literal>integer</literal>, "
"<literal>short</literal>, <literal>timestamp</literal> 또는 "
"<literal>calendar</literal> 타입일 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A version or timestamp property should never be null for a detached "
"instance. Hibernate will detect any instance with a null version or "
"timestamp as transient, irrespective of what other <literal>unsaved-value</"
"literal> strategies are specified. <emphasis>Declaring a nullable version or "
"timestamp property is an easy way to avoid problems with transitive "
"reattachment in Hibernate. It is especially useful for people using assigned "
"identifiers or composite keys</emphasis>."
msgstr ""
"version 또는 timestamp 프로퍼티는 detached 인스턴스에 대해 결코 null일 수가 "
"없어서, Hibernate는 다른 <literal>unsaved-value</literal> 방도들이 지정되는 "
"것에 상관없이, null version이나 timestamp를 가진 임의의 인스턴스를 transient"
"로서 검출할 것이다. <emphasis>null 허용되는 version 이나 property를 선언하는 "
"것은 Hibernate에서 transitive reattachment에 대한 임의의 문제들을 피하는 쉬"
"운 방법이고, assigned 식별자들이나 composite key들을 사용하는 사람들에게 특"
"히 유용하다!</emphasis>"

#. Tag: title
#, fuzzy, no-c-format
msgid "Timestamp (optional)"
msgstr "timestamp (옵션)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The optional <literal>&lt;timestamp&gt;</literal> element indicates that the "
"table contains timestamped data. This provides an alternative to versioning. "
"Timestamps are a less safe implementation of optimistic locking. However, "
"sometimes the application might use the timestamps in other ways."
msgstr ""
"옵션 <literal>&lt;timestamp&gt;</literal> 요소는 테이블이 타임스탬프화 된 데"
"이터를 포함함을 나타낸다. 이것은 버전화에 대한 대체물로서 고안되었다. "
"Timestamp은 고유하게 optimistic 잠금에 대한 다소 안전한 구현이다. 하지만 때때"
"로 어플리케이션은 다른 방법들로 timestamp들을 사용할 수도 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): the "
"name of a column holding the timestamp."
msgstr ""
"<literal>column</literal> (옵션 - 디폴트는 프로퍼티 명): 타임스탬프를 포함하"
"는 컬럼 명."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>name</literal>: the name of a JavaBeans style property of Java type "
"<literal>Date</literal> or <literal>Timestamp</literal> of the persistent "
"class."
msgstr ""
"<literal>name</literal>: 영속 클래스에 대해 자바 <literal>Date</literal> 또"
"는 <literal>Timestamp</literal> 타입을 가진 자바빈즈 스타일의 프로퍼티 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>unsaved-value</literal> (optional - defaults to <literal>null</"
"literal>): a version property value that indicates that an instance is newly "
"instantiated (unsaved), distinguishing it from detached instances that were "
"saved or loaded in a previous session. <literal>Undefined</literal> "
"specifies that the identifier property value should be used."
msgstr ""
"<literal>unsaved-value</literal> (옵션 - 디폴트는 <literal>null</literal>): "
"이전 세션에서 저장되었거나 로드되었던 detached 인스턴스로부터 인스턴스를 구별"
"지우는, 인스턴스가 새로이 초기화됨(unsaved)을 나타내는 version 프로퍼티 값."
"(<literal>undefined</literal>는 식별자 프로퍼티 값이 사용될 것임을 지정한다.)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>source</literal> (optional - defaults to <literal>vm</literal>): "
"Where should Hibernate retrieve the timestamp value from? From the database, "
"or from the current JVM? Database-based timestamps incur an overhead because "
"Hibernate must hit the database in order to determine the \"next value\". It "
"is safer to use in clustered environments. Not all <literal>Dialects</"
"literal> are known to support the retrieval of the database's current "
"timestamp. Others may also be unsafe for usage in locking due to lack of "
"precision (Oracle 8, for example)."
msgstr ""
"<literal>source</literal> (옵션 - 디폴트는 <literal>vm</literal>): Hibernate"
"는 어디서 timestamp 값을 검색할 것인가? 데이터베이스로부터인가 현재의 JVM으로"
"부터인가? 데이터베이스 기반의 timestamp들은 Hibernate가 \"다음 값\"을 결정하"
"기 위해 데이터베이스에 접속해야 하기 때문에 오버헤드를 초래하지만, 클러스터링"
"된 환경들에서의 용도로 보다 더 안전할 것이다. 또한 모든 <literal>Dialect</"
"literal>들이 데이터베이스의 현재의 timestamp에 대한 검색을 지원하는 것으로 알"
"려져 있지 않지만, 다른 <literal>Dialect</literal>들은 정밀도 결핍 때문에 잠금"
"에 있어 사용이 안전하지 않을 수 있음을 노트하라(예를 들면 오라클 8)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>generated</literal> (optional - defaults to <literal>never</"
"literal>): specifies that this timestamp property value is actually "
"generated by the database. See the discussion of <link linkend=\"mapping-"
"generated\">generated properties</link> for more information."
msgstr ""
"<literal>generated</literal> (옵션 - 디폴트는 <literal>never</literal>): 이 "
"timestamp 프로퍼티 값이 데이터베이스에 의해 실제로 생성됨을 지정한다. <xref "
"linkend=\"mapping-generated\">산출되는 프로퍼티들</xref>에 대한 논의들 보라."

#. Tag: title
#, no-c-format
msgid "Note"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>&lt;Timestamp&gt;</literal> is equivalent to <literal>&lt;version "
"type=\"timestamp\"&gt;</literal>. And <literal>&lt;timestamp source=\"db"
"\"&gt;</literal> is equivalent to <literal>&lt;version type=\"dbtimestamp"
"\"&gt;</literal>"
msgstr ""
"<literal>&lt;timestamp&gt;</literal>는 <literal>&lt;version type=\"timestamp"
"\"&gt;</literal>과 같음을 노트하라. 그리고 <literal>&lt;timestamp use-db="
"\"true\"&gt;</literal>는 <literal>&lt;version type=\"dbtimestamp\"&gt;</"
"literal>과 같다"

#. Tag: title
#, fuzzy, no-c-format
msgid "Property"
msgstr "프로퍼티"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;property&gt;</literal> element declares a persistent "
"JavaBean style property of the class."
msgstr ""
"<literal>&lt;property&gt;</literal> 요소는 클래스의 자바빈즈 스타일의 영속 프"
"로퍼티를 선언한다."

#. Tag: para
#, no-c-format
msgid ""
"<literal>name</literal>: the name of the property, with an initial lowercase "
"letter."
msgstr "<literal>name</literal>: 첫 소문자로 시작하는 프로퍼티 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): the "
"name of the mapped database table column. This can also be specified by "
"nested <literal>&lt;column&gt;</literal> element(s)."
msgstr ""
"<literal>column</literal> (옵션 - 디폴트는 프로퍼티 이름): 매핑된 데이터베이"
"스 테이블 컬럼의 이름. 이것은 또한 내부에 포함되는 <literal>&lt;column&gt;</"
"literal> 요소(들)에 의해 지정될 수도 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>update, insert</literal> (optional - defaults to <literal>true</"
"literal>): specifies that the mapped columns should be included in SQL "
"<literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. "
"Setting both to <literal>false</literal> allows a pure \"derived\" property "
"whose value is initialized from some other property that maps to the same "
"column(s), or by a trigger or other application."
msgstr ""
"<literal>update, insert</literal> (옵션 - 디폴트는 <literal>true</"
"literal>) : 매핑된 컬럼들이 <literal>UPDATE</literal>와/또는 "
"<literal>INSERT</literal> 문장들속에 포함될 것임을 지정한다. 둘다 "
"<literal>false</literal>로 설정하는 것은 그 값이 동일한 컬럼(들)로 매핑되는 "
"어떤 다른 프로퍼티로부터 또는 트리거에 의해 또는 다른 어플리케이션으로부터 초"
"기화 되는 순수하게 \"파생된(derived)\" 프로퍼티를 허용해준다."

#. Tag: para
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): an SQL expression that defines the "
"value for a <emphasis>computed</emphasis> property. Computed properties do "
"not have a column mapping of their own."
msgstr ""
"<literal>formula</literal> (옵션): <emphasis>계산되는</emphasis> 프로퍼티에 "
"대해 값을 정의하는 SQL 표현식. 계산되는 프로퍼티들은 그것들 자신에 대한 컬럼 "
"매핑을 갖지 않는다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
"specifies that this property should be fetched lazily when the instance "
"variable is first accessed. It requires build-time bytecode instrumentation."
msgstr ""
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>false</literal>): 인스턴스 "
"변수가 처음으로 액세스 될 때 이 프로퍼티가 lazily하게 페치될 것임을 지정한다"
"(빌드-시 바이트코드 수단을 필요로 한다)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>unique</literal> (optional): enables the DDL generation of a unique "
"constraint for the columns. Also, allow this to be the target of a "
"<literal>property-ref</literal>."
msgstr ""
"<literal>unique</literal> (옵션): 컬럼들에 대한 유일 컨스트레인트의 DDL 생성"
"을 가능하게 만든다. 또한 이것이 <literal>property-ref</literal>의 타켓이 되"
"는 것을 허용해준다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>not-null</literal> (optional): enables the DDL generation of a "
"nullability constraint for the columns."
msgstr ""
"<literal>not-null</literal> (옵션): 컬럼들에 대해 null 가능 컨스트레인트의 "
"DDL 생성을 가능하게 만든다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): specifies that updates to this property do or do not require "
"acquisition of the optimistic lock. In other words, it determines if a "
"version increment should occur when this property is dirty."
msgstr ""
"<literal>optimistic-lock</literal> (옵션 - 디폴트는 <literal>true</"
"literal>): 이 프로퍼티에 대한 업데이트들이 optimistic 잠금을 획득하는 것을 필"
"요로 하거나 필요로 하지 않음을 지정한다. 달리말해, 이 프로퍼티가 dirty일 때 "
"버전 증가가 발생할 경우인지를 결정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>generated</literal> (optional - defaults to <literal>never</"
"literal>): specifies that this property value is actually generated by the "
"database. See the discussion of <link linkend=\"mapping-generated"
"\">generated properties</link> for more information."
msgstr ""
"<literal>generated</literal> (옵션 - 디폴트는 <literal>never</literal>): 이 "
"프로퍼티 값이 데이터베이스에 의해 실제로 산출되는지를 지정한다. <xref "
"linkend=\"mapping-generated\">산출되는 프로퍼티들</xref>에 대한 논의를 보라."

#. Tag: para
#, no-c-format
msgid "<emphasis>typename</emphasis> could be:"
msgstr "<emphasis>typename</emphasis>은 다음일 수 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The name of a Hibernate basic type: <literal>integer, string, character, "
"date, timestamp, float, binary, serializable, object, blob</literal> etc."
msgstr ""
"Hibernate 기본 타입의 이름 (예를 들어. <literal>integer, string, character, "
"date, timestamp, float, binary, serializable, object, blob</literal>)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The name of a Java class with a default basic type: <literal>int, float, "
"char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</"
"literal> etc."
msgstr ""
"디폴트 기본 타입을 가진 Java 클래스의 이름(예를 들어. <literal>int, float, "
"char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</"
"literal>)."

#. Tag: para
#, no-c-format
msgid "The name of a serializable Java class."
msgstr "serializable Java 클래스의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The class name of a custom type: <literal>com.illflow.type.MyCustomType</"
"literal> etc."
msgstr ""
"맞춤 타입의 클래스 이름(예를 들어. <literal>com.illflow.type.MyCustomType</"
"literal>)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you do not specify a type, Hibernate will use reflection upon the named "
"property and guess the correct Hibernate type. Hibernate will attempt to "
"interpret the name of the return class of the property getter using, in "
"order, rules 2, 3, and 4. In certain cases you will need the <literal>type</"
"literal> attribute. For example, to distinguish between <literal>Hibernate."
"DATE</literal> and <literal>Hibernate.TIMESTAMP</literal>, or to specify a "
"custom type."
msgstr ""
"만일 당신이 타입을 지정하지 않을 경우, Hibernate는 정확한 Hibernate 타입을 추"
"정하기 위해 명명된 프로퍼티에 대해 reflection을 사용할 것이다. Hibernate는 "
"그 순서에서 2,3,4 규칙들을 사용하여 프로퍼티 getter의 반환 클래스의 이름을 해"
"석하려고 시도할 것이다. 하지만 이것은 항상 충분하지는 않다. 어떤 경우들에서, "
"당신은 여전히 <literal>type</literal> 속성을 필요로 할 것이다.(예를 들어, "
"<literal>Hibernate.DATE</literal>와 <literal>Hibernate.TIMESTAMP</literal> 사"
"이를 구별하기 위해, 또는 맞춤 타입을 지정하기 위해.)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>access</literal> attribute allows you to control how Hibernate "
"accesses the property at runtime. By default, Hibernate will call the "
"property get/set pair. If you specify <literal>access=\"field\"</literal>, "
"Hibernate will bypass the get/set pair and access the field directly using "
"reflection. You can specify your own strategy for property access by naming "
"a class that implements the interface <literal>org.hibernate.property."
"PropertyAccessor</literal>."
msgstr ""
"<literal>access</literal> 속성은 당신으로 하여금 Hibernate가 런타임 시에 프로"
"퍼티에 액세스하는 방법을 제어하도록 해준다. 디폴트로 Hibernate는 프로퍼티 "
"get/set 쌍을 호출할 것이다. 만일 당신이 <literal>access=\"field\"</literal>"
"를 지정할 경우, Hibernate는 get/set 쌍을 피하고 reflection을 사용하여 직접 필"
"드에 액세스 할 것이다. 당신은 <literal>org.hibernate.property."
"PropertyAccessor</literal> 인터페이스를 구현하는 클래스를 명명함으로써 프로퍼"
"티 접근을 위한 당신 자신의 방도를 지정할 수도 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A powerful feature is derived properties. These properties are by definition "
"read-only. The property value is computed at load time. You declare the "
"computation as an SQL expression. This then translates to a <literal>SELECT</"
"literal> clause subquery in the SQL query that loads an instance:"
msgstr ""
"특별히 강력한 특징은 파생된 플로퍼티들이다. 이들 프로퍼티들은 정의상 읽기 전"
"용이고, 그 프로퍼티 값은 로드 시에 계산된다. 당신은 그 계산을 SQL 표현식으로 "
"선언하고, 이것은 인스턴스를 로드시키는 SQL 질의 내의 <literal>SELECT</"
"literal> 절 서브질의로 번역된다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can reference the entity table by not declaring an alias on a particular "
"column. This would be <literal>customerId</literal> in the given example. "
"You can also use the nested <literal>&lt;formula&gt;</literal> mapping "
"element if you do not want to use the attribute."
msgstr ""
"당신은 특정 컬럼(주어진 예제에서는 <literal>customerId</literal>)에 대해 "
"alias를 선언하지 않음으로써 엔티티들 자신의 테이블을 참조할 수 있음을 노트하"
"라. 또한 당신은 만일 당신이 그 속성을 사용하고 싶지 않을 경우에 내포된 "
"<literal>&lt;formula&gt;</literal> 매핑 요소를 사용할 수 있음을 노트하라."

#. Tag: title
#, fuzzy, no-c-format
msgid "Many-to-one"
msgstr "many-to-one"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"An ordinary association to another persistent class is declared using a "
"<literal>many-to-one</literal> element. The relational model is a many-to-"
"one association; a foreign key in one table is referencing the primary key "
"column(s) of the target table."
msgstr ""
"또 다른 영속 클래스에 대한 정규 연관관계는 <literal>many-to-one</literal> 요"
"소를 사용하여 선언된다. 관계형 모형은 many-to-one 연관관계이다.: 하나의 테이"
"블 내에 있는 foreign 키는 대상 테이블의 프라이머리 키 컬럼(들)을 참조하고 있"
"다."

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>name</literal>: the name of the property."
msgstr "<literal>name</literal>: 프로퍼티의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>column</literal> (optional): the name of the foreign key column. "
"This can also be specified by nested <literal>&lt;column&gt;</literal> "
"element(s)."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>column</literal> (옵션): foreign key 컬럼의 이름. 이것은 또한 내포"
"된 <literal>&lt;column&gt;</literal> 요소(들)에 의해 지정된다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>column</literal> (옵션): foreign key 컬럼의 이름. 이것은 또한 내포"
"된 <literal>&lt;column&gt;</literal> 요소(들)에 의해 지정될 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>class</literal> (optional - defaults to the property type "
"determined by reflection): the name of the associated class."
msgstr ""
"<literal>class</literal> (옵션 - 디폴트는 reflection에 의해 결정된 프로퍼티 "
"타입): 연관된 클래스의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>cascade</literal> (optional): specifies which operations should be "
"cascaded from the parent object to the associated object."
msgstr ""
"<literal>cascade</literal> (옵션) 어느 오퍼레이션들이 부모 객체로부터 연관된 "
"객체로 케스케이드 될 것인지를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>fetch</literal> (optional - defaults to <literal>select</literal>): "
"chooses between outer-join fetching or sequential select fetching."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>fetch</literal> (옵션 - 디폴트는 <literal>select</literal>): outer-"
"join 페칭 또는 sequential select 페칭 사이에서 선택하라.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>fetch</literal> (옵션 - 디폴트는 <literal>select</literal>): outer-"
"join 페칭 또는 순차적인 select 페칭 중에서 선택하라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>update, insert</literal> (optional - defaults to <literal>true</"
"literal>): specifies that the mapped columns should be included in SQL "
"<literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. "
"Setting both to <literal>false</literal> allows a pure \"derived\" "
"association whose value is initialized from another property that maps to "
"the same column(s), or by a trigger or other application."
msgstr ""
"<literal>update, insert</literal> (옵션 - 디폴트는 <literal>true</literal>) "
"매핑된 컬럼들이 SQL <literal>UPDATE</literal>와/또는 <literal>INSERT</"
"literal> 문장들 속에 포함될 것인지를 지정한다. 둘다 <literal>false</literal>"
"로 설정하는 것은 그 값이 동일한 컬럼(들)로 매핑시키는 어떤 다른 컬럼들로부터 "
"초기화 되거나 트리거나 다른 어플리케이션에 의해 초기화되는 단순한 \"파생된\" "
"연관관계 값을 허용한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>property-ref</literal> (optional): the name of a property of the "
"associated class that is joined to this foreign key. If not specified, the "
"primary key of the associated class is used."
msgstr ""
"<literal>property-ref</literal>: (옵션) 이 foreign key에 조인되는 연관된 클래"
"스의 프로퍼티 이름. 지정되지 않을 경우, 연관 클래스의 프라이머리 키가 사용된"
"다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>unique</literal> (optional): enables the DDL generation of a unique "
"constraint for the foreign-key column. By allowing this to be the target of "
"a <literal>property-ref</literal>, you can make the association multiplicity "
"one-to-one."
msgstr ""
"<literal>unique</literal> (옵션): foreign-key 컬럼을 위한 유일 컨스트레인트"
"의 DDL 생성을 가능하도록 해준다. 또한 이것이 property-ref의 대상이 되는 것을 "
"허용해준다. 이것은 연관 다중성(association multiplicity)을 효율적으로 일 대 "
"일로 만든다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>not-null</literal> (optional): enables the DDL generation of a "
"nullability constraint for the foreign key columns."
msgstr ""
"<literal>not-null</literal> (옵션): foreign key 컬럼들을 위한 null 가능한 컨"
"스트레인트의 DDL 생성을 가능하도록 해준다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): "
"by default, single point associations are proxied. <literal>lazy=\"no-proxy"
"\"</literal> specifies that the property should be fetched lazily when the "
"instance variable is first accessed. This requires build-time bytecode "
"instrumentation. <literal>lazy=\"false\"</literal> specifies that the "
"association will always be eagerly fetched."
msgstr ""
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>proxy</literal>): 디폴트"
"로, 단일 포인트 연관들이 프락시된다. <literal>lazy=\"no-proxy\"</literal>는 "
"인스턴스 변수가 처음으로 접근될 때 그 프로퍼티가 lazily 페치될 것임을 지정한"
"다(빌드-시 바이트코드 수단을 필요로 한다). <literal>lazy=\"false\"</literal>"
"는 그 연관이 항상 eagerly 페치될 것임을 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>not-found</literal> (optional - defaults to <literal>exception</"
"literal>): specifies how foreign keys that reference missing rows will be "
"handled. <literal>ignore</literal> will treat a missing row as a null "
"association."
msgstr ""
"<literal>not-found</literal> (옵션 - 디폴트는 <literal>exception</literal>): "
"누락된 행들을 참조하는 foreign key들이 어떻게 처리될 것인지를 지정한다: "
"<literal>ignore</literal>는 한 개의 누락된 행을 한 개의 null 연관으로 취급할 "
"것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>entity-name</literal> (optional): the entity name of the associated "
"class."
msgstr "<literal>entity-name</literal> (옵션): 연관된 클래스의 엔티티 이름."

#. Tag: para
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): an SQL expression that defines the "
"value for a <emphasis>computed</emphasis> foreign key."
msgstr ""
"<literal>formula</literal> (옵션): <emphasis>계산된</emphasis> foreign key에 "
"대한 값을 정의하는 SQL 표현식."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Setting a value of the <literal>cascade</literal> attribute to any "
"meaningful value other than <literal>none</literal> will propagate certain "
"operations to the associated object. The meaningful values are divided into "
"three categories. First, basic operations, which include: <literal>persist, "
"merge, delete, save-update, evict, replicate, lock and refresh</literal>; "
"second, special values: <literal>delete-orphan</literal>; and third,"
"<literal>all</literal> comma-separated combinations of operation names: "
"<literal>cascade=\"persist,merge,evict\"</literal> or <literal>cascade=\"all,"
"delete-orphan\"</literal>. See <xref linkend=\"objectstate-transitive\" /> "
"for a full explanation. Note that single valued, many-to-one and one-to-one, "
"associations do not support orphan delete."
msgstr ""
"<literal>cascade</literal> 속성 값을 <literal>none</literal> 아닌 어떤 의미있"
"는 다른 값으로 설정하는 것은 어떤 오퍼레이션들을 연관된 객체에게 보급할 것이"
"다. 유의미한 값들은 Hibernate의 기본 오퍼레이션들의 이름들, 즉 "
"<literal>persist, merge, delete, save-update, evict, replicate, lock, "
"refresh</literal> 뿐만 아니라 특별한 값들, 즉 <literal>delete-orphan</"
"literal>과 <literal>all</literal> 그리고 오퍼레이션 이름들의 쉼표 분리된 조합"
"들, 예를 들면 <literal>cascade=\"persist,merge,evict\"</literal> 또는 "
"<literal>cascade=\"all,delete-orphan\"</literal>이다. 전체 설명은 <xref "
"linkend=\"objectstate-transitive\"/>를 보라. 단일값 연관들(many-to-one 연관"
"과 one-to-one 연관)은 orphan delete를 지원하지 않음을 노트하라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Here is an example of a typical <literal>many-to-one</literal> declaration:"
msgstr ""
"일반적인 <literal>many-to-one</literal> 선언은 다음과 같이 간단하게 보여진다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>property-ref</literal> attribute should only be used for "
"mapping legacy data where a foreign key refers to a unique key of the "
"associated table other than the primary key. This is a complicated and "
"confusing relational model. For example, if the <literal>Product</literal> "
"class had a unique serial number that is not the primary key. The "
"<literal>unique</literal> attribute controls Hibernate's DDL generation with "
"the SchemaExport tool."
msgstr ""
"<literal>property-ref</literal> 속성은 오직 foreign key가 프라이머리 키가 아"
"닌 연관된 테이블의 유일 키를 참조하는 리거시 데이터를 매핑하는데만 사용된다. "
"이것은 꼴사나운 관계형 모형이다. 예를 들어, <literal>Product</literal> 클래스"
"가 프라이머리 키를 아닌, 유일한 시리얼 번호를 갖는다고 가정하자."
"(<literal>unique</literal> 속성은 SchemaExport 도구로 Hibernate의 DDL 생성을 "
"제어한다.)"

#. Tag: para
#, no-c-format
msgid "Then the mapping for <literal>OrderItem</literal> might use:"
msgstr ""
"그런 다음 <literal>OrderItem</literal>에 대한 매핑은 다음을 사용할 것이다:"

#. Tag: para
#, fuzzy, no-c-format
msgid "This is not encouraged, however."
msgstr "하지만 이것은 확실히 권장되지 않는다."

#. Tag: para
#, no-c-format
msgid ""
"If the referenced unique key comprises multiple properties of the associated "
"entity, you should map the referenced properties inside a named <literal>&lt;"
"properties&gt;</literal> element."
msgstr ""
"만일 참조된 유일 키가 연관된 엔티티의 여러 프로퍼티들을 포함할 경우, 당신은 "
"명명된 <literal>&lt;properties&gt;</literal> 요소 내부에 참조된 프로퍼티들을 "
"매핑할 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If the referenced unique key is the property of a component, you can specify "
"a property path:"
msgstr ""
"만일 참조된 유일키가 컴포넌트의 프로퍼티일 경우, 당신은 하나의 프로퍼티 경로"
"를 지정할 수 있다:"

#. Tag: title
#, fuzzy, no-c-format
msgid "One-to-one"
msgstr "one-to-one"

#. Tag: para
#, no-c-format
msgid ""
"A one-to-one association to another persistent class is declared using a "
"<literal>one-to-one</literal> element."
msgstr ""
"또 다른 영속 클래스에 대한 one-to-one 연관관계는 <literal>one-to-one</"
"literal> 요소를 사용하여 선언된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>constrained</literal> (optional): specifies that a foreign key "
"constraint on the primary key of the mapped table and references the table "
"of the associated class. This option affects the order in which <literal>save"
"()</literal> and <literal>delete()</literal> are cascaded, and determines "
"whether the association can be proxied. It is also used by the schema export "
"tool."
msgstr ""
"<literal>constrained</literal> (옵션) 매핑된 테이블의 프라이머리 키에 대한 "
"foreign 키 컨스트레인트가 연관된 클래스의 테이블을 참조하는지 여부를 지정한"
"다. 이 옵션은 <literal>save()</literal>와 <literal>delete()</literal>가 케스"
"케이드 되는 순서에 영향을 주고, 그 연관이 프락시 될 것인지 여부를 결정한다 "
"(또한 스키마 내보내기 도구에 의해 사용된다)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>property-ref</literal> (optional): the name of a property of the "
"associated class that is joined to the primary key of this class. If not "
"specified, the primary key of the associated class is used."
msgstr ""
"<literal>property-ref</literal>: (옵션) 이 클래스의 프라이머리 키에 연결된 연"
"관 클래스의 프로퍼티의 이름. 만일 지정되지 않을 경우, 연관 클래스의 프라이머"
"리 키가 사용된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>formula</literal> (optional): almost all one-to-one associations "
"map to the primary key of the owning entity. If this is not the case, you "
"can specify another column, columns or expression to join on using an SQL "
"formula. See <literal>org.hibernate.test.onetooneformula</literal> for an "
"example."
msgstr ""
"<literal>formula</literal> (옵션): 거의 모든 one to one 연관관계들은 소유하"
"는 엔티티의 프라이머리 키로 매핑된다. 이것이 그 경우가 아닌 드문 경우들에서, "
"당신은 SQL formula 사용에 결합시킬 몇몇 다른 컬럼, 컬럼들, 또는 표현식을 지정"
"할 수 있다.(예제는 <literal>org.hibernate.test.onetooneformula</literal>를 보"
"라.)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): "
"by default, single point associations are proxied. <literal>lazy=\"no-proxy"
"\"</literal> specifies that the property should be fetched lazily when the "
"instance variable is first accessed. It requires build-time bytecode "
"instrumentation. <literal>lazy=\"false\"</literal> specifies that the "
"association will always be eagerly fetched. <emphasis>Note that if "
"<literal>constrained=\"false\"</literal>, proxying is impossible and "
"Hibernate will eagerly fetch the association</emphasis>."
msgstr ""
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>proxy</literal>): 디폴트로 "
"한쪽 끝 연관들이 프락시 된다. <literal>lazy=\"no-proxy\"</literal>는 인스턴"
"스 변수가 처음 접근될 때 그 프로퍼티가 lazily 페치될 것임을 지정한다(빌드-시 "
"바이트코드 수단을 필요로 한다). <literal>lazy=\"false\"</literal>는 그 연관들"
"이 항상 eagerly 페치될 것임을 지정한다. <emphasis>만일 <literal>constrained="
"\"false\"</literal>인 경우에, 프락싱은 불가능하고 Hibernate는 그 연관을 "
"eager 페치시킬 것이다!</emphasis>"

#. Tag: para
#, fuzzy, no-c-format
msgid "There are two varieties of one-to-one associations:"
msgstr "one-to-one 연관관계에는 두 가지 변종이 존재한다:"

#. Tag: para
#, no-c-format
msgid "primary key associations"
msgstr "프라이머리 키 연관관계들"

#. Tag: para
#, no-c-format
msgid "unique foreign key associations"
msgstr "유일 foreign 키 연관관계들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Primary key associations do not need an extra table column. If two rows are "
"related by the association, then the two table rows share the same primary "
"key value. To relate two objects by a primary key association, ensure that "
"they are assigned the same identifier value."
msgstr ""
"프라이머리 키 연관들은 특별한 테이블 컬럼을 필요로 하지 않는다; 만일 두 개의 "
"행들이 그 연관에 의해 관계지워지면, 두 개의 테이블 행들은 동일한 프라이머리 "
"키 값을 공유한다. 따라서 만일 두 개의 객체들이 프라이머리 키 연관에 의해 관계"
"지워지도록 당신이 원할 경우, 당신은 그것들에 동일한 식별자 값이 할당되도록 해"
"야 한다!"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For a primary key association, add the following mappings to "
"<literal>Employee</literal> and <literal>Person</literal> respectively:"
msgstr ""
"프라이머리 키 연관에 대해, 다음 매핑들을 <literal>Employee</literal>와 "
"<literal>Person</literal> 각각에 추가하라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Ensure that the primary keys of the related rows in the PERSON and EMPLOYEE "
"tables are equal. You use a special Hibernate identifier generation strategy "
"called <literal>foreign</literal>:"
msgstr ""
"이제 우리는 PERSON 과 EMPLOYEE 테이블들에서 관계지워진 행들의 프라이머리 키들"
"이 동일함을 확실히 해야 한다! 우리는 <literal>foreign</literal>로 명명되는 특"
"별한 Hibernate 식별자 생성 방도를 사용한다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A newly saved instance of <literal>Person</literal> is assigned the same "
"primary key value as the <literal>Employee</literal> instance referred with "
"the <literal>employee</literal> property of that <literal>Person</literal>."
msgstr ""
"그때 <literal>Person</literal>의 새로이 저장된 인스턴스는 그 "
"<literal>Person</literal>의 <literal>employee</literal> 프로퍼티에 대해 참조"
"된 <literal>Employee</literal> 인스턴스와 동일한 프라이머리 키를 할당받는다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Alternatively, a foreign key with a unique constraint, from "
"<literal>Employee</literal> to <literal>Person</literal>, can be expressed "
"as:"
msgstr ""
"달리, <literal>Employee</literal>로부터 <literal>Person</literal>으로의 유일 "
"컨스트레인트를 가진 하나의 foreign key는 다음과 같이 표현될 수 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This association can be made bidirectional by adding the following to the "
"<literal>Person</literal> mapping:"
msgstr ""
"그리고 이 연관은 다음을 <literal>Person</literal> 매핑에 추가함으로써 양방향"
"이 될 수 있다:"

#. Tag: title
#, fuzzy, no-c-format
msgid "Natural-id"
msgstr "natural-id"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Although we recommend the use of surrogate keys as primary keys, you should "
"try to identify natural keys for all entities. A natural key is a property "
"or combination of properties that is unique and non-null. It is also "
"immutable. Map the properties of the natural key inside the <literal>&lt;"
"natural-id&gt;</literal> element. Hibernate will generate the necessary "
"unique key and nullability constraints and, as a result, your mapping will "
"be more self-documenting."
msgstr ""
"비록 우리가 프라이머리 키들로서 대용키들을 사용하는 것을 권장했을지라도, 당신"
"은 여전히 모든 엔티티들에 대한 natural 키들을 식별하고자 원할 것이다. "
"narutal 키는 유일(unique)하고 null이 아닌 프로퍼티 또는 프로퍼티들의 조합이"
"다. 그것이 또한 불변하는 것일 경우가 더 좋다. <literal>&lt;natural-id&gt;</"
"literal> 요소 내부에 있는 natural 키의 프로퍼티들을 매핑하라. Hibernate는 필"
"수적인 유일 키와 null 허용가능한 컨스트레인트들을 생성시킬 것이고, 당신의 매"
"핑은 보다 자가 설명적이게 될 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is recommended that you implement <literal>equals()</literal> and "
"<literal>hashCode()</literal> to compare the natural key properties of the "
"entity."
msgstr ""
"우리는 당신이 엔티티에 대한 narutal 키 프로퍼티들을 비교하는데 "
"<literal>equals()</literal>와 <literal>hashCode()</literal>를 구현할 것을 강"
"력하게 권장한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This mapping is not intended for use with entities that have natural primary "
"keys."
msgstr ""
"이 매핑은 natural 프라이머리 키들을 가진 엔티티들을 위한 용도로 고안된 것은 "
"아니다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>mutable</literal> (optional - defaults to <literal>false</"
"literal>): by default, natural identifier properties are assumed to be "
"immutable (constant)."
msgstr ""
"<literal>mutable</literal> (옵션, 디폴트는 <literal>false</literal>): 디폴트"
"로, narutal 식별자 프로퍼티들은 변경될 수 없는 것(상수)으로 가정된다."

#. Tag: title
#, fuzzy, no-c-format
msgid "Component and dynamic-component"
msgstr "component, dynamic-component"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;component&gt;</literal> element maps properties of a child "
"object to columns of the table of a parent class. Components can, in turn, "
"declare their own properties, components or collections. See the \"Component"
"\" examples below:"
msgstr ""
"<literal>&lt;component&gt;</literal> 요소는 자식 객체의 프로퍼티들을 부모 클"
"래스에 대한 테이블의 컬럼들로 매핑시킨다. 컴포넌트들은 그것들 자신의 프로퍼티"
"들, 컴포넌트들, 또는 콜렉션들을 선언한다. 이래 \"컴포넌트들\"을 보라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>class</literal> (optional - defaults to the property type "
"determined by reflection): the name of the component (child) class."
msgstr ""
"<literal>class</literal> (옵션 - 디폴트는 reflection에 의해 결정된 프로퍼티 "
"타입): 컴포넌트(자식) 클래스의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>insert</literal>: do the mapped columns appear in SQL "
"<literal>INSERTs</literal>?"
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>insert</literal>: 매핑된 컬럼들이 SQL <literal>INSERT</literal>들 속"
"에 나타나야 하는가?\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>insert</literal>: 매핑된 컬럼들이 SQL <literal>INSERT</literal>들 내"
"에 나타날 것인가?"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>update</literal>: do the mapped columns appear in SQL "
"<literal>UPDATEs</literal>?"
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>update</literal>: 매핑된 컬럼들이 SQL <literal>UPDATE</literal>들 속"
"에 나타나야 하는가?\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>update</literal>: 매핑된 컬럼들이 SQL <literal>UPDATE</literal>들 내"
"에 나타날 것인가?"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
"specifies that this component should be fetched lazily when the instance "
"variable is first accessed. It requires build-time bytecode instrumentation."
msgstr ""
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>false</literal>): 인스턴스 "
"변수가 처음으로 액세스될 때 이 컴포넌트가 lazily(느리게) 페치되어야 하는지 여"
"부를 지정한다 (빌드 시 바이트코드 수단을 필요로 한다)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): specifies that updates to this component either do or do not "
"require acquisition of the optimistic lock. It determines if a version "
"increment should occur when this property is dirty."
msgstr ""
"<literal>optimistic-lock</literal> (옵션 - 디폴트는 <literal>true</"
"literal>): 이 컴포넌트에 대한 업데이트들이 optimistic 잠금을 획득하는 것을 필"
"요로 하는지 여부를 지정한다. 달리 말해 이 프로퍼티가 dirty 일 때 버전 증가가 "
"발생할 것인지 여부를 결정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>unique</literal> (optional - defaults to <literal>false</literal>): "
"specifies that a unique constraint exists upon all mapped columns of the "
"component."
msgstr ""
"<literal>unique</literal> (옵션 - 디폴트는 <literal>false</literal>): 유일 컨"
"스트레인트가 컴포넌트의 모든 매핑된 컬럼들에 대해 존재하는지 여부를 지정한다."

#. Tag: para
#, no-c-format
msgid ""
"The child <literal>&lt;property&gt;</literal> tags map properties of the "
"child class to table columns."
msgstr ""
"자식 <literal>&lt;property&gt;</literal> 태그들은 자식 클래스의 프로퍼티들을 "
"테이블 컬럼들로 매핑시킨다."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;"
"parent&gt;</literal> subelement that maps a property of the component class "
"as a reference back to the containing entity."
msgstr ""
"<literal>&lt;component&gt;</literal> 요소는 컴포넌트 클래스의 프로퍼티를 포함"
"하는 엔티티에 대한 참조로서 매핑시키는 <literal>&lt;parent&gt;</literal> 서브"
"요소를 허용한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;dynamic-component&gt;</literal> element allows a "
"<literal>Map</literal> to be mapped as a component, where the property names "
"refer to keys of the map. See <xref linkend=\"components-dynamic\" /> for "
"more information."
msgstr ""
"<literal>&lt;dynamic-component&gt;</literal> 요소는 컴포넌트로서 매핑될"
"<literal>Map</literal>을 허용한다. 여기서 프로퍼티 이름들은 map의 키들을 참조"
"한다. <xref linkend=\"components-dynamic\"/>을 보라."

#. Tag: title
#, fuzzy, no-c-format
msgid "Properties"
msgstr "properties"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;properties&gt;</literal> element allows the definition of a "
"named, logical grouping of the properties of a class. The most important use "
"of the construct is that it allows a combination of properties to be the "
"target of a <literal>property-ref</literal>. It is also a convenient way to "
"define a multi-column unique constraint. For example:"
msgstr ""
"<literal>&lt;properties&gt;</literal> 요소는 클래스의 프로퍼티들의 명명된, 논"
"리적 그룹핑에 대한 정의를 허용한다. 그 구조에 대한 가장 중요한 사용은 그것이 "
"프로퍼티들의 조합이 <literal>property-ref</literal>의 대상이 되는 것을 허용해"
"준다는 점이다. 또한 그것은 다중 컬럼 유일 컨스트레인느를 정의하는 편리한 방법"
"이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>name</literal>: the logical name of the grouping. It is "
"<emphasis>not</emphasis> an actual property name."
msgstr ""
"<literal>name</literal>: 그룹핑의 논리적 이름 - 실제 프로퍼티 이름이 "
"<emphasis>아니다</emphasis>."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): specifies that updates to these properties either do or do not "
"require acquisition of the optimistic lock. It determines if a version "
"increment should occur when these properties are dirty."
msgstr ""
"<literal>optimistic-lock</literal> (옵션 - 디폴트는 <literal>true</"
"literal>): 이들 프로퍼티들에 대한 업데이트들이 optimistic 잠금의 획득을 필요"
"로 하는지 여부를 지정한다. 달리 말해 이 프로퍼티가 dirty 일 때 버전 증가가 발"
"생할 것인지 여부를 결정한다."

#. Tag: para
#, no-c-format
msgid ""
"For example, if we have the following <literal>&lt;properties&gt;</literal> "
"mapping:"
msgstr ""
"예를 들어, 만일 우리가 다음 <literal>&lt;properties&gt;</literal> 매핑을 가"
"질 경우:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You might have some legacy data association that refers to this unique key "
"of the <literal>Person</literal> table, instead of to the primary key:"
msgstr ""
"그 때 우리는 프라이머리 키가 아닌, <literal>Person</literal> 테이블의 이 유"
"일 키를 참조하는 어떤 리거시 데이터 연관을 가질 수 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The use of this outside the context of mapping legacy data is not "
"recommended."
msgstr ""
"우리는 리거시 데이터를 매핑시키는 컨텍스트 바깥에서 이런 종류의 것을 사용하"
"는 것을 권장하지 않는다."

#. Tag: title
#, fuzzy, no-c-format
msgid "Subclass"
msgstr "subclass"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Polymorphic persistence requires the declaration of each subclass of the "
"root persistent class. For the table-per-class-hierarchy mapping strategy, "
"the <literal>&lt;subclass&gt;</literal> declaration is used. For example:"
msgstr ""
"마지막으로, 다형성 영속성은 루트 영속 클래스에 대한 각각의 서브클래스 선언을 "
"필요로 한다.(권장되는) table-per-class-hierarchy(테이블 당 클래스 계층구조) "
"매핑 방도의 경우, <literal>&lt;subclass&gt;</literal> 선언이 사용된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>name</literal>: the fully qualified class name of the subclass."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>name</literal>: 서브클래스의 전체 수식어가 붙은 클래스 이름.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>name</literal>: 서브클래스의 전체 수식어가 붙은 클래스 명.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>name</literal>: 서브클래스의 전체 수식어가 붙은 클래스 명."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>discriminator-value</literal> (optional - defaults to the class "
"name): a value that distinguishes individual subclasses."
msgstr ""
"<literal>discriminator-value</literal> (옵션 - 디폴트는 클래스 이름): 개개의 "
"서브클래스들을 구분짓는 값."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>proxy</literal> (optional): specifies a class or interface used for "
"lazy initializing proxies."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (옵션): lazy 초기화 프락시들을 사용하는데 클래스 또"
"는 인터페이스를 지정한다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (옵션): 프락시들을 lazy 초기화 시키는데 사용할 클래"
"스 또는 인터페이스를 지정한다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (옵션): 프락시들을 lazy 초기화 시키는데 사용할 클래"
"스 또는 인터페이스를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>true</literal>): "
"setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"<literal>lazy=\"false\"</literal> 설정은 lazy 페칭의 사용을 불가능하게 만든"
"다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"<literal>lazy=\"false\"</literal> 설정은 lazy 페칭을 사용불가능하게 만든다\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"<literal>lazy=\"false\"</literal> 설정은 lazy 페칭을 사용불가능하게 만든다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Each subclass declares its own persistent properties and subclasses. "
"<literal>&lt;version&gt;</literal> and <literal>&lt;id&gt;</literal> "
"properties are assumed to be inherited from the root class. Each subclass in "
"a hierarchy must define a unique <literal>discriminator-value</literal>. If "
"this is not specified, the fully qualified Java class name is used."
msgstr ""
"각각의 서브클래스는 그것 자신의 영속 프로퍼티들과 서브클래스들을 선언할 것이"
"다. <literal>&lt;version&gt;</literal> 프로퍼티와 <literal>&lt;id&gt;</"
"literal> 프로퍼티는 루트 클래스로부터 상속된다고 가정된다. 계층구조 내에서 각"
"각의 서브클래스는 유일한 <literal>discriminator-value</literal>를 정의해야 한"
"다. none이 지정될 경우, 전체 수식어가 붙은 자바 클래스 이름이 사용된다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For information about inheritance mappings see <xref linkend=\"inheritance"
"\" />."
msgstr "상속 매핑들에 대한 정보는 <xref linkend=\"inheritance\"/>을 보라."

#. Tag: title
#, fuzzy, no-c-format
msgid "Joined-subclass"
msgstr "joined-subclass"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Each subclass can also be mapped to its own table. This is called the table-"
"per-subclass mapping strategy. An inherited state is retrieved by joining "
"with the table of the superclass. To do this you use the <literal>&lt;joined-"
"subclass&gt;</literal> element. For example:"
msgstr ""
"다른 방법으로 각각의 서브클래스는 그것 자신이 테이블로 매핑될 수 있다(table-"
"per-subclass 매핑 방도). 상속된 상태는 슈퍼클래스의 테이블과 조인함으로써 검"
"색된다. 우리는 <literal>&lt;joined-subclass&gt;</literal> 요소를 사용한다."

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>table</literal>: the name of the subclass table."
msgstr "<literal>table</literal>: 서브클래스 테이블의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>proxy</literal> (optional): specifies a class or interface to use "
"for lazy initializing proxies."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (옵션): lazy 초기화 프락시들을 사용하는데 클래스 또"
"는 인터페이스를 지정한다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (옵션): 프락시들을 lazy 초기화 시키는데 사용할 클래"
"스 또는 인터페이스를 지정한다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (옵션): 프락시들을 lazy 초기화 시키는데 사용할 클래"
"스 또는 인터페이스를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional, defaults to <literal>true</literal>): "
"setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"<literal>lazy=\"false\"</literal> 설정은 lazy 페칭의 사용을 불가능하게 만든"
"다.\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"<literal>lazy=\"false\"</literal> 설정은 lazy 페칭을 사용불가능하게 만든다\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (옵션 - 디폴트는 <literal>true</literal>): "
"<literal>lazy=\"false\"</literal> 설정은 lazy 페칭을 사용불가능하게 만든다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A discriminator column is not required for this mapping strategy. Each "
"subclass must, however, declare a table column holding the object identifier "
"using the <literal>&lt;key&gt;</literal> element. The mapping at the start "
"of the chapter would then be re-written as:"
msgstr ""
"판별자(discriminator) 컬럼은 이 매핑 방도에 필요하지 않다. 하지만 각각의 서브"
"클래스는 <literal>&lt;key&gt;</literal> 요소를 사용하여 객체 식별자를 보관하"
"는 테이블 컬럼을 선언해야 한다. 이 장의 시작 부분에 있는 매핑은 다음과 같이 "
"다시 작성될 것이다:"

#. Tag: title
#, fuzzy, no-c-format
msgid "Union-subclass"
msgstr "union-subclass"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A third option is to map only the concrete classes of an inheritance "
"hierarchy to tables. This is called the table-per-concrete-class strategy. "
"Each table defines all persistent states of the class, including the "
"inherited state. In Hibernate, it is not necessary to explicitly map such "
"inheritance hierarchies. You can map each class with a separate <literal>&lt;"
"class&gt;</literal> declaration. However, if you wish use polymorphic "
"associations (e.g. an association to the superclass of your hierarchy), you "
"need to use the <literal>&lt;union-subclass&gt;</literal> mapping. For "
"example:"
msgstr ""
"제3의 옵션은 상속 계층구조의 concrete 클래스들 만을 테이블들로 매핑하는 것이"
"다 (table-per-concrete-class 방도). 여기서 각각의 테이블은 상속된 상태를 포함"
"하여 클래스의 모든 영속 상태를 정의한다. Hibernate에서, 그것은 그런 상속 계층"
"구조들을 명시적으로 매핑하는데 필수적이지 않다. 당신은 별도의 <literal>&lt;"
"class&gt;</literal> 선언을 가진 각각의 클래스를 간단히 매핑시킬 수 있다. 하지"
"만 당신이 다형성 연관관계들(예를 들면 당신의 계층구조의 슈퍼클래스에 대한 연"
"관)을 사용하고자 원할 경우, 당신은 <literal>&lt;union-subclass&gt;</literal> "
"매핑을 사용할 필요가 있다."

#. Tag: para
#, no-c-format
msgid ""
"No discriminator column or key column is required for this mapping strategy."
msgstr "이 매핑 방도에는 판별자 컬럼이나 키 컬럼이 필요하지 않다."

#. Tag: title
#, fuzzy, no-c-format
msgid "Join"
msgstr "join"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Using the <literal>&lt;join&gt;</literal> element, it is possible to map "
"properties of one class to several tables that have a one-to-one "
"relationship. For example:"
msgstr ""
"<literal>&lt;join&gt;</literal>요소를 사용하면, 테이블들 사이에 1대일 관계가 "
"존재할 때, 하나의 클래스에 속한 프로퍼티들을 여러 테이블들로 매핑시키는 것이 "
"가능하다."

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>table</literal>: the name of the joined table."
msgstr "<literal>table</literal>: 조인된 테이블의 이름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>fetch</literal> (optional - defaults to <literal>join</literal>): "
"if set to <literal>join</literal>, the default, Hibernate will use an inner "
"join to retrieve a <literal>&lt;join&gt;</literal> defined by a class or its "
"superclasses. It will use an outer join for a <literal>&lt;join&gt;</"
"literal> defined by a subclass. If set to <literal>select</literal> then "
"Hibernate will use a sequential select for a <literal>&lt;join&gt;</literal> "
"defined on a subclass. This will be issued only if a row represents an "
"instance of the subclass. Inner joins will still be used to retrieve a "
"<literal>&lt;join&gt;</literal> defined by the class and its superclasses."
msgstr ""
"<literal>fetch</literal> (옵션 - 디폴트는 <literal>join</literal>): "
"<literal>join</literal>으로 설정될 경우, 디폴트로 Hibernate는 하나의 클래스 "
"또는 그것의 슈퍼 클래스들에 의해 정의된 <literal>&lt;join&gt;</literal>을 검"
"색하는데 inner join을 사용하고 서브클래스에 의해 정의된 <literal>&lt;join&gt;"
"</literal>을 검색하는데 outer join을 사용할 것이다. 만일 <literal>select</"
"literal>로 설정할 경우, Hibernate는 서브클래스 상에 정의된 <literal>&lt;"
"join&gt;</literal>에 대해 sequential select를 사용할 것이고, 그것은 한 행이 "
"서브클래스의 인스턴스를 표현하는 것으로 판명되는 경우에만 명령이 내려질 것이"
"다. inner join들은 여전히 클래스와 그것의 슈퍼클래스들에 의해 정의된 "
"<literal>&lt;join&gt;</literal>을 검색하는데 사용될 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>inverse</literal> (optional - defaults to <literal>false</"
"literal>): if enabled, Hibernate will not insert or update the properties "
"defined by this join."
msgstr ""
"<literal>inverse</literal> (옵션 - 디폴트는 <literal>false</literal>): 이용 "
"가능할 경우, Hibernate는 이 조인에 의해 정의된 프로퍼티들을 삽입시키거나 업데"
"이트하려고 시도하지 않을 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>optional</literal> (optional - defaults to <literal>false</"
"literal>): if enabled, Hibernate will insert a row only if the properties "
"defined by this join are non-null. It will always use an outer join to "
"retrieve the properties."
msgstr ""
"<literal>optional</literal> (옵션 - 디폴트는 <literal>false</literal>): 이용 "
"가능할 경우, Hibernate는 이 조인에 의해 정의된 프로퍼티들이 null이 아닐 경우"
"에만 한 행을 삽입시킬 것이고 그 프로퍼티들을 검색하는데 outer join을 항상 사"
"용할 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For example, address information for a person can be mapped to a separate "
"table while preserving value type semantics for all properties:"
msgstr ""
"예를 들어, (모든 프로퍼티들에 대해 value 타입 의미를 유지하면서) 개인의 주소 "
"정보는 별도의 테이블에 매핑될 수 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This feature is often only useful for legacy data models. We recommend fewer "
"tables than classes and a fine-grained domain model. However, it is useful "
"for switching between inheritance mapping strategies in a single hierarchy, "
"as explained later."
msgstr ""
"이 특징은 자주 리거시 데이터 모형들에 대해서만 유용하고, 우리는 클래스들과 "
"잘 정제된 도메인 모형 보다 더 적은 테이블들을 권장한다. 하지만 뒷 부분에 설명"
"되어 있듯이, 그것은 하나의 계층구조 내에 있는 상속 매핑 방도들 사이를 전환하"
"는 것에 유용하다."

#. Tag: title
#, fuzzy, no-c-format
msgid "Key"
msgstr "key"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;key&gt;</literal> element has featured a few times within "
"this guide. It appears anywhere the parent mapping element defines a join to "
"a new table that references the primary key of the original table. It also "
"defines the foreign key in the joined table:"
msgstr ""
"우리는 지금까지 몇 번 나타났던 <literal>&lt;key&gt;</literal> 요소를 보았다. "
"그것은 부모 매핑 요소가 새로운 테이블에 대한 조인을 정의하는 어느 곳에서나 나"
"타나고, 그것은 조인된 테이블의 foreign 키를 정의하고, 그것은 원래의 테이블의 "
"프라이머리 키를 참조한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>on-delete</literal> (optional - defaults to <literal>noaction</"
"literal>): specifies whether the foreign key constraint has database-level "
"cascade delete enabled."
msgstr ""
"<literal>on-delete</literal> (옵션 - 디폴트는 <literal>noaction</literal>): "
"foreign key 컨스트레인트가 데이터베이스 레벨의 cascade delete를 사용가능하도"
"록 할 것인지 여부를 지정한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>property-ref</literal> (optional): specifies that the foreign key "
"refers to columns that are not the primary key of the original table. It is "
"provided for legacy data."
msgstr ""
"<literal>property-ref</literal> (옵션): foreign key가 원래의 테이블의 프라이"
"머리 키가 아닌 컬럼들을 참조함을 지정한다. (리거시 데이터에 제공됨.)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>not-null</literal> (optional): specifies that the foreign key "
"columns are not nullable. This is implied whenever the foreign key is also "
"part of the primary key."
msgstr ""
"<literal>not-null</literal> (옵션): foreign 키 컬럼들이 not null 임를 지정한"
"다(이것은 foreign 키가 또한 프라이머리 키의 부분일 때마다 함축된다)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>update</literal> (optional): specifies that the foreign key should "
"never be updated. This is implied whenever the foreign key is also part of "
"the primary key."
msgstr ""
"<literal>update</literal> (옵션): foreign 키가 결코 업데이트되지 않아야 함을 "
"지정한다(이것은 foreign 키가 또한 프라이머리 키의 부분일 때마다 함축된다)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>unique</literal> (optional): specifies that the foreign key should "
"have a unique constraint. This is implied whenever the foreign key is also "
"the primary key."
msgstr ""
"<literal>unique</literal> (옵션): foreign 키가 유일 컨스트레인트를 가져야 함"
"을 지정한다 (이것은 foreign 키가 또한 프라이머리 키의 부분일 때마다 함축된"
"다)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For systems where delete performance is important, we recommend that all "
"keys should be defined <literal>on-delete=\"cascade\"</literal>. Hibernate "
"uses a database-level <literal>ON CASCADE DELETE</literal> constraint, "
"instead of many individual <literal>DELETE</literal> statements. Be aware "
"that this feature bypasses Hibernate's usual optimistic locking strategy for "
"versioned data."
msgstr ""
"우리는 delete 퍼포먼스가 중요한 시스템들에 대해 권장하고, 모든 키들은 "
"<literal>on-delete=\"cascade\"</literal>로 정의되고, Hibernate는 많은 "
"<literal>DELETE</literal> 문장들 대신에, 데이터베이스 레벨의 <literal>ON "
"CASCADE DELETE</literal> 컨스트레인트를 사용할 것이다. 이 특징은 Hibernate의 "
"통상적인 버전화된 데이터에 대한 optimistic 잠금 방도를 무시한다는 점을 알고 "
"있어라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>not-null</literal> and <literal>update</literal> attributes are "
"useful when mapping a unidirectional one-to-many association. If you map a "
"unidirectional one-to-many association to a non-nullable foreign key, you "
"<emphasis>must</emphasis> declare the key column using <literal>&lt;key not-"
"null=\"true\"&gt;</literal>."
msgstr ""
"<literal>not-null</literal> 속성과 <literal>update</literal> 속성들은 단방향 "
"one to many 연관관계를 매핑할 때 유용하다. 만일 당신이 단방향 one to many를 "
"null이 허용되지 않는 foreign 키로 매핑할 경우, 당신은 <literal>&lt;key not-"
"null=\"true\"&gt;</literal>를 사용하여 그 키 컬럼을 선언<emphasis>해야 한다</"
"emphasis>."

#. Tag: title
#, fuzzy, no-c-format
msgid "Column and formula elements"
msgstr "column 요소와 formula 요소"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Mapping elements which accept a <literal>column</literal> attribute will "
"alternatively accept a <literal>&lt;column&gt;</literal> subelement. "
"Likewise, <literal>&lt;formula&gt;</literal> is an alternative to the "
"<literal>formula</literal> attribute. For example:"
msgstr ""
"column 속성을 허용하는 임의의 매핑 요소는 대안적으로 하나의 <literal>&lt;"
"column&gt;</literal> 서브요소를 수용할 것이다. 비슷하게 <literal>&lt;"
"formula&gt;</literal>는 <literal>formula</literal> 속성에 대한 대안이다."

#. Tag: para
#, no-c-format
msgid ""
"Most of the attributes on <literal>column</literal> provide a means of "
"tailoring the DDL during automatic schema generation. The <literal>read</"
"literal> and <literal>write</literal> attributes allow you to specify custom "
"SQL that Hibernate will use to access the column's value. For more on this, "
"see the discussion of <link linkend=\"mapping-column-read-and-write\">column "
"read and write expressions</link>."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>column</literal> and <literal>formula</literal> elements can "
"even be combined within the same property or association mapping to express, "
"for example, exotic join conditions."
msgstr ""
"<literal>column</literal> 속성과 <literal>formula</literal> 속성은 예를 들어 "
"신종 조인 조건들을 표현하기 위해 동일한 property 또는 연관관계 매핑 내에 결합"
"될 수 있다."

#. Tag: title
#, fuzzy, no-c-format
msgid "Import"
msgstr "import"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If your application has two persistent classes with the same name, and you "
"do not want to specify the fully qualified package name in Hibernate "
"queries, classes can be \"imported\" explicitly, rather than relying upon "
"<literal>auto-import=\"true\"</literal>. You can also import classes and "
"interfaces that are not explicitly mapped:"
msgstr ""
"당신의 어플리케이션이 동일한 이름을 가진 두 개의 영속 클래스들을 갖고, 당신"
"이 Hibernate 질의들 내에서 전체 수식어가 붙은 (패키지)이름을 지정하는 것을 원"
"하지 않는다고 가정하자. 클래스들은 <literal>auto-import=\"true\"</literal>에 "
"의존하기 보다 명시적으로 \"임포트 될 \" 것이다. 당신은 심지어 명시적으로 매핑"
"되지 않는 클래스들과 인터페이스들을 임포트 시킬 수(가져오기 할 수) 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>class</literal>: the fully qualified class name of any Java class."
msgstr ""
"<literal>class</literal>: 임의의 Java 클래스의 전체 수식어가 붙은 클래스 이"
"름."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>rename</literal> (optional - defaults to the unqualified class "
"name): a name that can be used in the query language."
msgstr ""
"<literal>rename</literal> (옵션 - 디폴트는 수식어가 붙지 않은 클래스 이름): "
"질의 언어 내에서 사용될 이름."

#. Tag: title
#, fuzzy, no-c-format
msgid "Any"
msgstr "any"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"There is one more type of property mapping. The <literal>&lt;any&gt;</"
"literal> mapping element defines a polymorphic association to classes from "
"multiple tables. This type of mapping requires more than one column. The "
"first column contains the type of the associated entity. The remaining "
"columns contain the identifier. It is impossible to specify a foreign key "
"constraint for this kind of association. This is not the usual way of "
"mapping polymorphic associations and you should use this only in special "
"cases. For example, for audit logs, user session data, etc."
msgstr ""
"하나 이상의 프로퍼티 매핑 타입이 존재한다. <literal>&lt;any&gt;</literal> 매"
"핑 요소는 여러 테이블들로부터 클래스들에 대한 하나의 다형성 연관관계를 정의한"
"다. 이 매핑 타입은 언제나 하나 이상의 컬럼을 필요로 한다. 첫 번째 컬럼은 연관"
"된 엔티티의 타입을 보관한다. 나머지 컬럼들은 식별자를 보관한다. 이런 종류의 "
"연관관계들에 대해 foreign key 컨스트레인트를 지정하는 것이 불가능해서, 이것"
"은 (다형성) 연관관계들을 매핑하는 통상적인 방법으로서 가장 확실한 수단이 아니"
"다. 당신은 매우 특별한 경우들 (예를 들어 감사 로그들, 사용자 세션 데이터 등)"
"에서만 이것을 사용해야 한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>meta-type</literal> attribute allows the application to specify "
"a custom type that maps database column values to persistent classes that "
"have identifier properties of the type specified by <literal>id-type</"
"literal>. You must specify the mapping from values of the meta-type to class "
"names."
msgstr ""
"<literal>meta-type</literal> 속성은 어플리케이션으로 하여금 데이터베이스 컬"
"럼 값들을 <literal>id-type</literal>에 의해 지정된 타입의 식별자 프로퍼티들"
"을 가진 영속 클래스들로 매핑시키는 맞춤형 타입을 지정하도록 한다. 당신은 "
"meta-type의 값들로부터 클래스 이름들로의 매핑을 지정해야 한다."

#. Tag: para
#, no-c-format
msgid "<literal>name</literal>: the property name."
msgstr "<literal>name</literal>: 프로퍼티 이름."

#. Tag: para
#, no-c-format
msgid "<literal>id-type</literal>: the identifier type."
msgstr "<literal>id-type</literal>: 식별자 타입."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>meta-type</literal> (optional - defaults to <literal>string</"
"literal>): any type that is allowed for a discriminator mapping."
msgstr ""
"<literal>meta-type</literal> (옵션 - 디폴트는 <literal>string</literal>): "
"discriminator 매핑에 허용되는 임의의 타입."

#. Tag: para
#, no-c-format
msgid ""
"<literal>cascade</literal> (optional- defaults to <literal>none</literal>): "
"the cascade style."
msgstr ""
"<literal>cascade</literal> (optional- defaults to <literal>none</literal>): "
"cascade 스타일."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): specifies that updates to this property either do or do not "
"require acquisition of the optimistic lock. It defines whether a version "
"increment should occur if this property is dirty."
msgstr ""
"<literal>optimistic-lock</literal> (옵션 - 디폴트는 <literal>true</"
"literal>): 이 프로퍼티에 대한 업데이트들이 optimistic 잠금 획득을 필요로 하는"
"지 여부를 지정한다. 달리 말해, 이 프로퍼티가 dirty일 경우에 버전증가가 발생"
"할 것인지 여부를 정의한다."

#. Tag: title
#, fuzzy, no-c-format
msgid "Hibernate types"
msgstr "Hibernate 타입들"

#. Tag: title
#, no-c-format
msgid "Entities and values"
msgstr "엔티티들과 값들"

#. Tag: para
#, no-c-format
msgid ""
"In relation to the persistence service, Java language-level objects are "
"classified into two groups:"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"An <emphasis>entity</emphasis> exists independently of any other objects "
"holding references to the entity. Contrast this with the usual Java model, "
"where an unreferenced object is garbage collected. Entities must be "
"explicitly saved and deleted. Saves and deletions, however, can be "
"<emphasis>cascaded</emphasis> from a parent entity to its children. This is "
"different from the ODMG model of object persistence by reachability and "
"corresponds more closely to how application objects are usually used in "
"large systems. Entities support circular and shared references. They can "
"also be versioned."
msgstr ""
"<emphasis>entity</emphasis>는 엔티티에 대한 참조들을 보관하는 임의의 다른 객"
"체들과는 독립적으로 존재한다. 참조되지 않은 객체가 쓰레기 수집되는 통상의 자"
"바 모형과 이것은 대조적이다. (저장들과 삭제들이 부모 엔티티로부터 그것의 자식"
"으로의 케스케이드 되는 경우를 제외하면) 엔티티들은 명시적으로 저장되고 삭제되"
"어야 한다. 이것은 도달 가능성(reachablity)에 의한 객체 영속성의 ODMG 모형과"
"는 다르다 - 그리고 어플리케이션 객체들이 대형 시스템들에서 대개 어떻게 사용되"
"는가에 훨씬 더 가깝게 대응한다. 엔티티들은 순환 참조와 공유 참조들을 지원한"
"다. 그것들 또한 버전화 될 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"An entity's persistent state consists of references to other entities and "
"instances of <emphasis>value</emphasis> types. Values are primitives: "
"collections (not what is inside a collection), components and certain "
"immutable objects. Unlike entities, values in particular collections and "
"components, <emphasis>are</emphasis> persisted and deleted by reachability. "
"Since value objects and primitives are persisted and deleted along with "
"their containing entity, they cannot be independently versioned. Values have "
"no independent identity, so they cannot be shared by two entities or "
"collections."
msgstr ""
"엔티티의 영속 상태는 다른 엔티티들에 대한 참조들과 <emphasis>value</"
"emphasis> 타입들로 구성된다. 값들은 원시 타입들, 콜렉션들(하나의 콜렉션 내부"
"에 있지 않는 것들), 컴포넌트들, 그리고 어떤 불변의 객체들이다. entities와는 "
"달리, (특별한 콜렉션들과 컴포넌트들에서) 값들은 도달가능성(reachability)에 의"
"해 영속화 <emphasis>되고</emphasis> 삭제 된다. value 객체들(과 원시 타입들)"
"이 그것들의 포함하는 엔티티에 따라 영속화 되고 삭제 되므로, 그것들은 독립적으"
"로 버전화 되지 않는다. 값들은 독립적인 엔티티를 갖지 않아서, 그것들은 두 개"
"의 엔티티들이나 콜렉션들에 의해 공유될 수 없다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Until now, we have been using the term \"persistent class\" to refer to "
"entities. We will continue to do that. Not all user-defined classes with a "
"persistent state, however, are entities. A <emphasis>component</emphasis> is "
"a user-defined class with value semantics. A Java property of type "
"<literal>java.lang.String</literal> also has value semantics. Given this "
"definition, all types (classes) provided by the JDK have value type "
"semantics in Java, while user-defined types can be mapped with entity or "
"value type semantics. This decision is up to the application developer. An "
"entity class in a domain model will normally have shared references to a "
"single instance of that class, while composition or aggregation usually "
"translates to a value type."
msgstr ""
"지금까지 우리는 엔티티들을 참조하기 위해 \"영속 클래스\"를 사용해 왔다. 우리"
"는 그것을 계속 사용할 것이다. 하지만 엄격히 말해, 영속 상태를 가진 모든 사용"
"자 정의 클래스들은 엔티티들이 아니다. <emphasis>컴포넌트</emphasis>는 value "
"의미를 가진 사용자 정의 클래스이다. <literal>java.lang.String</literal> 타입"
"의 자바 프로퍼티는 또한 value 의미를 갖는다. 이 정의가 주어지면, 우리는 JDK"
"에 의해 제공된 모든 타입들(클래스들)이 자바에서 value 타입 의미를 갖고, 반면"
"에 사용자 정의 타입들은 엔티티 또는 type 의미로서 매핑된다고 말할 수 있다. "
"이 판단은 어플리케이션 개발자에게 달려 있다. 도메인 모형에서 엔티티 클래스에 "
"대한 좋은 힌트는 그 클래스의 하나의 인스턴스에 대한 공유된 참조들인 반면에, "
"composition이나 aggregation은 대개 value 타입으로 변환된다."

#. Tag: para
#, fuzzy, no-c-format
msgid "We will revisit both concepts throughout this reference guide."
msgstr "우리는 문서를 통해 두 개념들을 다시 고찰할 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The challenge is to map the Java type system, and the developers' definition "
"of entities and value types, to the SQL/database type system. The bridge "
"between both systems is provided by Hibernate. For entities, <literal>&lt;"
"class&gt;</literal>, <literal>&lt;subclass&gt;</literal> and so on are used. "
"For value types we use <literal>&lt;property&gt;</literal>, <literal>&lt;"
"component&gt;</literal>etc., that usually have a <literal>type</literal> "
"attribute. The value of this attribute is the name of a Hibernate "
"<emphasis>mapping type</emphasis>. Hibernate provides a range of mappings "
"for standard JDK value types out of the box. You can write your own mapping "
"types and implement your own custom conversion strategies."
msgstr ""
"도점점은 Java type 시스템(과 엔티티들 및 value 타입들에 대한 개발자의 정의)"
"를 SQL/데이터베이스 type 타입으로 매핑하는 것이다. 두 시스템들 사이의 다리는 "
"Hibernate에 의해 제공된다: 엔티티들의 경우 우리는 <literal>&lt;class&gt;</"
"literal>, <literal>&lt;subclass&gt;</literal> 등을 사용한다.value 타입들의 경"
"우 우리는 대개<literal>type</literal> 속성을 가진 <literal>&lt;property&gt;</"
"literal>, <literal>&lt;component&gt;</literal> 등을 사용한다. 이 속성의 값은 "
"Hibernate <emphasis>매핑 타입</emphasis>의 이름이다. Hibernate는 (표준 JDK "
"value 타입들에 대해) 많은 매핑들을 제공한다. 나중에 보게 되듯이, 당신은 당신 "
"자신의 매핑 타입들을 작성할 수 있고 마찬가지로 당신의 맞춤형 변환 방도들을 구"
"현할 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"With the exception of collections, all built-in Hibernate types support null "
"semantics."
msgstr ""
"콜렉션들을 제외한 모든 미리 빌드된 Hibernate 타입들은 null 의미를 지원한다."

#. Tag: title
#, no-c-format
msgid "Basic value types"
msgstr "기본 value 타입들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The built-in <emphasis>basic mapping types</emphasis> can be roughly "
"categorized into the following:"
msgstr ""
"미리-만들어진 <emphasis>기본 매핑 타입들</emphasis>은 대략 다음과 같이 카테고"
"리로 분류된다 <placeholder-1/>"

#. Tag: term
#, fuzzy, no-c-format
msgid ""
"<literal>integer, long, short, float, double, character, byte, boolean, "
"yes_no, true_false</literal>"
msgstr ""
"integer, long, short, float, double, character, byte, boolean, yes_no, "
"true_false"

#. Tag: para
#, no-c-format
msgid ""
"Type mappings from Java primitives or wrapper classes to appropriate (vendor-"
"specific) SQL column types. <literal>boolean, yes_no</literal> and "
"<literal>true_false</literal> are all alternative encodings for a Java "
"<literal>boolean</literal> or <literal>java.lang.Boolean</literal>."
msgstr ""
"자바 원시타입들이나 wrapper 클래스들로부터 적절한(벤더-지정적인) SQL 컬럼 타"
"입들로의 타입 매핑. <literal>boolean, yes_no</literal>와 "
"<literal>true_false</literal>는 Java <literal>boolean</literal>이나 "
"<literal>java.lang.Boolean</literal>에 대한 모든 대체적인 인코딩들이다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>string</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, no-c-format
msgid ""
"A type mapping from <literal>java.lang.String</literal> to <literal>VARCHAR</"
"literal> (or Oracle <literal>VARCHAR2</literal>)."
msgstr ""
"<literal>java.lang.String</literal>으로부터 <literal>VARCHAR</literal> (또는 "
"Oracle <literal>VARCHAR2</literal>)로의 타입 매핑."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>date, time, timestamp</literal>"
msgstr "date, time, timestamp"

#. Tag: para
#, no-c-format
msgid ""
"Type mappings from <literal>java.util.Date</literal> and its subclasses to "
"SQL types <literal>DATE</literal>, <literal>TIME</literal> and "
"<literal>TIMESTAMP</literal> (or equivalent)."
msgstr ""
"<literal>java.util.Date</literal>와 그것의 서브클래스로부터 SQL 타입들인 "
"<literal>DATE</literal>, <literal>TIME</literal>, <literal>TIMESTAMP</"
"literal> (또는 등가물)로의 타입 매핑들."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>calendar, calendar_date</literal>"
msgstr "calendar, calendar_date"

#. Tag: para
#, no-c-format
msgid ""
"Type mappings from <literal>java.util.Calendar</literal> to SQL types "
"<literal>TIMESTAMP</literal> and <literal>DATE</literal> (or equivalent)."
msgstr ""
"<literal>java.util.Calendar</literal>로부터 SQL 타입들인 <literal>TIMESTAMP</"
"literal>, <literal>DATE</literal> (또는 등가물)로의 타입 매핑들."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>big_decimal, big_integer</literal>"
msgstr "big_decimal, big_integer"

#. Tag: para
#, no-c-format
msgid ""
"Type mappings from <literal>java.math.BigDecimal</literal> and <literal>java."
"math.BigInteger</literal> to <literal>NUMERIC</literal> (or Oracle "
"<literal>NUMBER</literal>)."
msgstr ""
"<literal>java.math.BigDecimal</literal>과 <literal>java.math.BigInteger</"
"literal>로부터 <literal>NUMERIC</literal> (또는 Oracle <literal>NUMBER</"
"literal>)로의 타입 매핑들."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>locale, timezone, currency</literal>"
msgstr "locale, timezone, currency"

#. Tag: para
#, no-c-format
msgid ""
"Type mappings from <literal>java.util.Locale</literal>, <literal>java.util."
"TimeZone</literal> and <literal>java.util.Currency</literal> to "
"<literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>). "
"Instances of <literal>Locale</literal> and <literal>Currency</literal> are "
"mapped to their ISO codes. Instances of <literal>TimeZone</literal> are "
"mapped to their <literal>ID</literal>."
msgstr ""
"<literal>java.util.Locale</literal>, <literal>java.util.TimeZone</literal>, "
"그리고 <literal>java.util.Currency</literal>로부터 <literal>VARCHAR</literal>"
"(또는 Oracle <literal>VARCHAR2</literal>)로의 타입 매핑. <literal>Locale</"
"literal>과 <literal>Currency</literal>의 인스턴스들은 그것들의 ISO 코드들로 "
"매핑된다. <literal>TimeZone</literal>의 인스턴스들은 그것들의 <literal>ID</"
"literal>로 매핑된다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>class</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, no-c-format
msgid ""
"A type mapping from <literal>java.lang.Class</literal> to <literal>VARCHAR</"
"literal> (or Oracle <literal>VARCHAR2</literal>). A <literal>Class</literal> "
"is mapped to its fully qualified name."
msgstr ""
"<literal>java.lang.Class</literal>로부터 <literal>VARCHAR</literal> (또는 "
"Oracle <literal>VARCHAR2</literal>)로의 타입 매핑. <literal>Class</literal>"
"는 그것의 전체 수식어가 붙은 이름으로 매핑된다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>binary</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, no-c-format
msgid "Maps byte arrays to an appropriate SQL binary type."
msgstr "byte 배열들을 적절한 SQL binary 타입으로 매핑시킨다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>text</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, no-c-format
msgid ""
"Maps long Java strings to a SQL <literal>CLOB</literal> or <literal>TEXT</"
"literal> type."
msgstr ""
"long Java 문자열을 SQL <literal>CLOB</literal> 또는 <literal>TEXT</literal> "
"타입으로 매핑시킨다"

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>serializable</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Maps serializable Java types to an appropriate SQL binary type. You can also "
"indicate the Hibernate type <literal>serializable</literal> with the name of "
"a serializable Java class or interface that does not default to a basic type."
msgstr ""
"serializable Java 타입들을 적절한 SQL binary 타입으로 매핑시킨다. 당신은 또"
"한 디폴트로 기본 타입이 아닌 serializable 자바 클래스 또는 인터페이스의 이름"
"을 가진 Hibernate 타입 <literal>serializable</literal>을 나타낼 수도 있다."

#. Tag: term
#, fuzzy, no-c-format
msgid "<literal>clob, blob</literal>"
msgstr "<literal>all</literal>은 모든 컬럼들을 체크한다"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Type mappings for the JDBC classes <literal>java.sql.Clob</literal> and "
"<literal>java.sql.Blob</literal>. These types can be inconvenient for some "
"applications, since the blob or clob object cannot be reused outside of a "
"transaction. Driver support is patchy and inconsistent."
msgstr ""
"<literal>java.sql.Clob</literal>와 <literal>java.sql.Blob</literal> JDBC 클래"
"스들에 대한 타입 매핑들. 이들 타입들은 몇몇 어플리케이션들에서는 불편하다. 왜"
"냐하면 blob 또는 clob 객체는 트랜잭션 외부에서 재사용될 수 없기 때문이다.(게"
"다가 드라이버 지원이 비일관적이고 페치되어야 한다)"

#. Tag: term
#, fuzzy, no-c-format
msgid ""
"<literal>imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, "
"imm_serializable, imm_binary</literal>"
msgstr ""
"imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, "
"imm_serializable, imm_binary"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Type mappings for what are considered mutable Java types. This is where "
"Hibernate makes certain optimizations appropriate only for immutable Java "
"types, and the application treats the object as immutable. For example, you "
"should not call <literal>Date.setTime()</literal> for an instance mapped as "
"<literal>imm_timestamp</literal>. To change the value of the property, and "
"have that change made persistent, the application must assign a new, "
"nonidentical, object to the property."
msgstr ""
"대개 가변적인 Java 타입들로 간주되는 것에 대한 타입 매핑들. 여기서 Hibernate"
"는 불변적인 Java 타입들에 대해서만 적절한 어떤 최적화를 행하고, 어플리케이션 "
"그 객체를 변할 수 없는 것으로 취급한다. 예를 들어, 당신은 "
"<literal>imm_timestamp</literal>로서 매핑된 인스턴스에 대해 <literal>Date."
"setTime()</literal>을 호출하지 않을 것이다. 프로퍼티의 값을 변경시키고, 그 변"
"경을 영속화 시키기 위해서, 어플리케이션은 하나의 새로운 (동일하지 않은) 객체"
"를 그 프로퍼티에 할당해야 한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Unique identifiers of entities and collections can be of any basic type "
"except <literal>binary</literal>, <literal>blob</literal> and <literal>clob</"
"literal>. Composite identifiers are also allowed. See below for more "
"information."
msgstr ""
"엔트리들과 콜렉션들의 유일 식별자들은 <literal>binary</literal>, "
"<literal>blob</literal> 그리고 <literal>clob</literal>를 제외한 기본 타입 중 "
"어느 것일 수 있다. (Composite 식별자들이 또한 허용된다. 아래를 보라.)"

#. Tag: para
#, no-c-format
msgid ""
"The basic value types have corresponding <literal>Type</literal> constants "
"defined on <literal>org.hibernate.Hibernate</literal>. For example, "
"<literal>Hibernate.STRING</literal> represents the <literal>string</literal> "
"type."
msgstr ""
"기본 value 타입들은 <literal>org.hibernate.Hibernate</literal>에 정의되어 있"
"는 대응하는 <literal>Type</literal> 상수들을 갖는다. 예를 들어, "
"<literal>Hibernate.STRING</literal>은 <literal>string</literal> 타입을 표현한"
"다."

#. Tag: title
#, no-c-format
msgid "Custom value types"
msgstr "맞춤형 value 타입들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is relatively easy for developers to create their own value types. For "
"example, you might want to persist properties of type <literal>java.lang."
"BigInteger</literal> to <literal>VARCHAR</literal> columns. Hibernate does "
"not provide a built-in type for this. Custom types are not limited to "
"mapping a property, or collection element, to a single table column. So, for "
"example, you might have a Java property <literal>getName()</literal>/"
"<literal>setName()</literal> of type <literal>java.lang.String</literal> "
"that is persisted to the columns <literal>FIRST_NAME</literal>, "
"<literal>INITIAL</literal>, <literal>SURNAME</literal>."
msgstr ""
"개발자들이 그들 자신들의 value 타입들을 생성시키는 것이 상대적으로 쉽다. 예"
"를 들어, 당신은 <literal>java.lang.BigInteger</literal> 타입의 프로퍼티들을 "
"<literal>VARCHAR</literal> 컬럼들로 영속화 시키고자 원할 수 있다. Hibernate"
"는 이것을 위한 미리 만들어진 타입을 제공하지 않는다. 그러나 맞춤형 타입들은 "
"프로퍼티(또는 콜렉션 요소)를 하나의 테이블 컬럼으로의 매핑하는 것에 제약되지 "
"않는다. 따라서 예를 들어, 당신은 <literal>FIRST_NAME</literal>, "
"<literal>INITIAL</literal>, <literal>SURNAME</literal> 컬럼들로 영속화 되는 "
"<literal>java.lang.String</literal> 타입의 자바 프로퍼티<literal>getName()</"
"literal>/ <literal>setName()</literal>를 가질 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"To implement a custom type, implement either <literal>org.hibernate."
"UserType</literal> or <literal>org.hibernate.CompositeUserType</literal> and "
"declare properties using the fully qualified classname of the type. View "
"<literal>org.hibernate.test.DoubleStringType</literal> to see the kind of "
"things that are possible."
msgstr ""
"맞춤형 타입을 구현하려면, <literal>org.hibernate.UserType</literal> 또는 "
"<literal>org.hibernate.CompositeUserType</literal>을 구현하고 그 타입의 전체 "
"수식어가 붙은 클래스명을 사용하여 프로퍼티들을 선언하라. 가능한 종류의 것들"
"을 보려면 <literal>org.hibernate.test.DoubleStringType</literal>을 체크하라."

#. Tag: para
#, no-c-format
msgid ""
"Notice the use of <literal>&lt;column&gt;</literal> tags to map a property "
"to multiple columns."
msgstr ""
"하나의 프로퍼티를 여러 개의 컬럼들로 매핑시키는 <literal>&lt;column&gt;</"
"literal> 태그의 사용을 주목하라."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>CompositeUserType</literal>, <literal>EnhancedUserType</"
"literal>, <literal>UserCollectionType</literal>, and "
"<literal>UserVersionType</literal> interfaces provide support for more "
"specialized uses."
msgstr ""
"<literal>CompositeUserType</literal>, <literal>EnhancedUserType</literal>, "
"<literal>UserCollectionType</literal>, 그리고 <literal>UserVersionType</"
"literal> 인터페이스들은 더 많은 특화된 사용들을 위한 지원을 제공한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can even supply parameters to a <literal>UserType</literal> in the "
"mapping file. To do this, your <literal>UserType</literal> must implement "
"the <literal>org.hibernate.usertype.ParameterizedType</literal> interface. "
"To supply parameters to your custom type, you can use the <literal>&lt;"
"type&gt;</literal> element in your mapping files."
msgstr ""
"당신은 매핑 파일 속에 <literal>UserType</literal>에 대한 파라미터들을 제공할 "
"수도 있다. 이것을 행하기 위해, 당신의 <literal>UserType</literal>은 "
"<literal>org.hibernate.usertype.ParameterizedType</literal> 인터페이스를 구현"
"해야 한다. 당신의 맞춤형 타입에 파라미터들을 제공하기 위해, 당신은 당신의 매"
"핑 파일들 속에 <literal>&lt;type&gt;</literal> 요소를 사용할 수 있다."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>UserType</literal> can now retrieve the value for the parameter "
"named <literal>default</literal> from the <literal>Properties</literal> "
"object passed to it."
msgstr ""
"<literal>UserType</literal>은 이제 그것에 전달된 <literal>Properties</"
"literal> 객체로부터 <literal>default</literal>로 명명된 파라미터에 대한 값을 "
"검색할 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you regularly use a certain <literal>UserType</literal>, it is useful to "
"define a shorter name for it. You can do this using the <literal>&lt;"
"typedef&gt;</literal> element. Typedefs assign a name to a custom type, and "
"can also contain a list of default parameter values if the type is "
"parameterized."
msgstr ""
"만일 당신이 매우 자주 어떤 UserType을 사용할 경우, 그것은 그것에 대한 더 짧"
"은 이름을 정의하는 것이 유용할 수 있다. <literal>&lt;typedef&gt;</literal> 요"
"소를 사용하여 이것을 행할 수 있다. Typedef들은 이름을 맞춤형 타입에 할당하"
"고, 또한 만일 그 타입이 파라미터화 된 경우에 디폴트 파라미터 값들의 리스트를 "
"포함할 수도 있다."

#. Tag: para
#, no-c-format
msgid ""
"It is also possible to override the parameters supplied in a typedef on a "
"case-by-case basis by using type parameters on the property mapping."
msgstr ""
"property 매핑 상에 type 파라미터들을 사용함으로써 경우에 맞게 typedef 내에 제"
"공된 파라미터들을 오버라이드 시키는 것이 가능하다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Even though Hibernate's rich range of built-in types and support for "
"components means you will rarely need to use a custom type, it is considered "
"good practice to use custom types for non-entity classes that occur "
"frequently in your application. For example, a <literal>MonetaryAmount</"
"literal> class is a good candidate for a <literal>CompositeUserType</"
"literal>, even though it could be mapped as a component. One reason for this "
"is abstraction. With a custom type, your mapping documents would be "
"protected against changes to the way monetary values are represented."
msgstr ""
"비록 Hibernate의 풍부한 범위의 미리 만들어진 타입들과 컴포넌트들에 대한 지원"
"이 당신이 가끔 맞춤형 타입을 사용할 <emphasis>필요가</emphasis> 거의 없을 것"
"임을 의미할 지라도, 그럼에도 불구하고 그것은 당신의 어플리케이션에서 자주 발"
"생하는 (엔티티가 아닌) 클래스들에 대해 맞춤형 타입들을 사용하는 좋은 형식으"
"로 간주된다. 예를 들어 <literal>MonetaryAmount</literal> 클래스는 비록 그것"
"이 컴포넌트로서 쉽게 매핑될 수 있을지라도, <literal>CompositeUserType</"
"literal>에 대한 좋은 후보이다. 이것에 대한 하나의 동기는 추상화이다. 맞춤형 "
"타입으로, 당신의 매핑 문서들은 화폐 값들을 표현하는 당신의 방법에서 가능한 변"
"경들에 대해 장차 검증될 것이다."

#. Tag: title
#, no-c-format
msgid "Mapping a class more than once"
msgstr "하나의 클래스를 한 번 이상 매핑하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is possible to provide more than one mapping for a particular persistent "
"class. In this case, you must specify an <emphasis>entity name</emphasis> to "
"disambiguate between instances of the two mapped entities. By default, the "
"entity name is the same as the class name. Hibernate lets you specify the "
"entity name when working with persistent objects, when writing queries, or "
"when mapping associations to the named entity."
msgstr ""
"하나의 특정한 영속 클래스에 대해 하나 이상의 매핑을 제공하는 것이 가능하다. "
"이 경우에 당신은 두 개의 매핑된 엔티티들의 인스턴스들 사이를 명확하게 하기 위"
"해 <emphasis>하나의 엔티티 이름</emphasis>을 지정해야 한다. (디폴트로, 엔티"
"티 이름은 클래스 이름과 동일한 것이다.) Hibernate는 영속 객체들에 대해 작업"
"할 때, 질의들을 작성할 때, 또는 명명된 엔티티에 대한 연관들을 매핑할 때 당신"
"으로 하여금 엔티티 이름을 지정하도록 한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Associations are now specified using <literal>entity-name</literal> instead "
"of <literal>class</literal>."
msgstr ""
"연관들은 이제 <literal>class</literal> 대신에 <literal>entity-name</literal>"
"을 사용하여 어떻게 지정되는지를 주목하라."

#. Tag: title
#, no-c-format
msgid "SQL quoted identifiers"
msgstr "SQL 인용부호 표시된 식별자들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can force Hibernate to quote an identifier in the generated SQL by "
"enclosing the table or column name in backticks in the mapping document. "
"Hibernate will use the correct quotation style for the SQL <literal>Dialect</"
"literal>. This is usually double quotes, but the SQL Server uses brackets "
"and MySQL uses backticks."
msgstr ""
"당신은 매핑 문서 내에서 테이블 또는 컬럼 이름을 역인용기호(`)들 속에 넣어서 "
"생성된 SQL에서 식별자를 인용부호 처리하도록 Hibernate에게 강제할 수도 있다. "
"Hibernate는 SQL <literal>Dialect</literal>에 대해 정확한 인용 스타일을 사용"
"할 것이다(대개 이중 인용부호 이지만, SQL Server의 경우에는 모난 괄호들이고 "
"MySQL의 경우에는 역인용부호(`))."

#. Tag: title
#, no-c-format
msgid "Metadata alternatives"
msgstr "Metadata 대안들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"XML does not suit all users so there are some alternative ways to define O/R "
"mapping metadata in Hibernate."
msgstr ""
"XML은 모든 사람들을 위한 것이 아니지만, Hibernate에서 O/R 매핑 메타데이터를 "
"정의하는 몇몇 대안적인 방법들이 존재한다."

#. Tag: title
#, no-c-format
msgid "Using XDoclet markup"
msgstr "XDoclet 마크업 사용하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Many Hibernate users prefer to embed mapping information directly in "
"sourcecode using XDoclet <literal>@hibernate.tags</literal>. We do not cover "
"this approach in this reference guide since it is considered part of "
"XDoclet. However, we include the following example of the <literal>Cat</"
"literal> class with XDoclet mappings:"
msgstr ""
"많은 Hibernate 사용자들은 XDoclet <literal>@hibernate.tags</literal>를 사용하"
"여 소스 코드 속에 직접 매핑 정보를 삽입시키는 것을 선호한다. 우리는 이 문서에"
"서 이 접근법을 다루지 않을 것이다. 왜냐하면 그것은 엄격하게는 XDoclet의 부분"
"으로 간주되기 때문이다. 하지만 우리는 XDoclet 매핑들을 가진 <literal>Cat</"
"literal> 클래스에 관한 다음 예제를 포함한다."

#. Tag: para
#, fuzzy, no-c-format
msgid "See the Hibernate website for more examples of XDoclet and Hibernate."
msgstr "XDoclet과 ibernate에 관한 추가 예제들은 Hibernate 웹 사이트를 보라."

#. Tag: title
#, no-c-format
msgid "Using JDK 5.0 Annotations"
msgstr "JDK 5.0 Annotations 사용하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"JDK 5.0 introduced XDoclet-style annotations at the language level that are "
"type-safe and checked at compile time. This mechanism is more powerful than "
"XDoclet annotations and better supported by tools and IDEs. IntelliJ IDEA, "
"for example, supports auto-completion and syntax highlighting of JDK 5.0 "
"annotations. The new revision of the EJB specification (JSR-220) uses JDK "
"5.0 annotations as the primary metadata mechanism for entity beans. "
"Hibernate3 implements the <literal>EntityManager</literal> of JSR-220 (the "
"persistence API). Support for mapping metadata is available via the "
"<emphasis>Hibernate Annotations</emphasis> package as a separate download. "
"Both EJB3 (JSR-220) and Hibernate3 metadata is supported."
msgstr ""
"JDK 5.0은 언어 레벨에서 XDoclet-스타일의 주석들, type-safe와 컴파일 시 체킹"
"을 도입했다. 이 메커니즘은 XDoclet 주석들 보다 더 강력하며 도구들과 IDE들에 "
"의해 더 좋게 지원된다. 예를 들어 IntelliJ IDEA는 JDK 5.0 주석들에 대한 자동-"
"완성 기능과 구문 강조를 지원한다. EJB 명세서의 새로운 개정판(JSR-220)은 엔티"
"티 빈즈에 대한 프라이머리 메타데이터 메커니즘으로서 JDK 5.0 Annotations을 사"
"용한다. Hibernate3는 JSR-220(영속 API)의 <literal>EntityManager</literal>를 "
"구현하고, 매핑 메타데이터에 대한 지원은 별도의 내려받기로서 "
"<emphasis>Hibernate Annotations</emphasis> 패키지를 통해 이용 가능하다. EJB3 "
"(JSR-220)과 Hibernate3 metadata 양자가 지원된다."

#. Tag: para
#, no-c-format
msgid "This is an example of a POJO class annotated as an EJB entity bean:"
msgstr "다음은 EJB 엔티티 빈으로서 주석이 붙은 POJO 클래스에 관한 예제이다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Support for JDK 5.0 Annotations (and JSR-220) is currently under "
"development. Please refer to the Hibernate Annotations module for more "
"details."
msgstr ""
"JDK 5.0 Annotations(그리고 JSR-220)에 대한 지원은 여전히 작업이 진행 중이고 "
"완성되지 않았음을 노트하라. 상세한 것은 Hibernate Anotations를 참조하라."

#. Tag: title
#, fuzzy, no-c-format
msgid "Generated properties"
msgstr "산출되는 프로퍼티들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Generated properties are properties that have their values generated by the "
"database. Typically, Hibernate applications needed to <literal>refresh</"
"literal> objects that contain any properties for which the database was "
"generating values. Marking properties as generated, however, lets the "
"application delegate this responsibility to Hibernate. When Hibernate issues "
"an SQL INSERT or UPDATE for an entity that has defined generated properties, "
"it immediately issues a select afterwards to retrieve the generated values."
msgstr ""
"산출되는 프로퍼티들은 데이터베이스에 의해 산출되는 그것들의 값들을 갖는 프로"
"퍼티들이다. 전형적으로, Hibernate 어플리케이션들은 데이터베이스가 값들을 생성"
"시켰던 임의의 프로퍼티들을 포함하는 객체들을 <literal>갱신</literal>시킬 필요"
"가 있었다.하지만 generated로 마크된 프로퍼티들은 어플리케이션으로 하여금 이 "
"책임을 Hibernate에게 위임시키도록 한다. 본질적으로 Hibernate가 산출되는 프로"
"퍼티들을 정의했던 엔티티에 대해 SQL INSERT 또는 UPDATE 명령을 내릴 때마다 바"
"로 직후에 산출되는 값들을 검색하기 위해 하나의 select 명령을 내린다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Properties marked as generated must additionally be non-insertable and non-"
"updateable. Only <link linkend=\"mapping-declaration-version\">versions</"
"link>, <link linkend=\"mapping-declaration-timestamp\">timestamps</link>, "
"and <link linkend=\"mapping-declaration-property\">simple properties</link>, "
"can be marked as generated."
msgstr ""
"generated로 마크된 프로퍼티들은 부가적으로 inser 가능하지 않아야 하고 update "
"불가능해야 한다. 오직 Properties marked as generated must additionally be "
"non-insertable and non-updateable. <xref linkend=\"mapping-declaration-"
"version\">versions</xref>, <xref linkend=\"mapping-declaration-timestamp"
"\">timestamps</xref>, 그리고 <xref linkend=\"mapping-declaration-property\">"
"단순 프로퍼티들</xref> 만이 generated로 마크될 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>never</literal> (the default): the given property value is not "
"generated within the database."
msgstr ""
"<literal>never</literal> (디폴트) - 는 주어진 프로퍼티 값이 데이터베이스 내"
"에 생성되지 않을 것임을 의미한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>insert</literal>: the given property value is generated on insert, "
"but is not regenerated on subsequent updates. Properties like created-date "
"fall into this category. Even though <link linkend=\"mapping-declaration-"
"version\">version</link> and <link linkend=\"mapping-declaration-timestamp"
"\">timestamp</link> properties can be marked as generated, this option is "
"not available."
msgstr ""
"<literal>insert</literal> - 는 주어진 프로퍼티 값이 insert 시에 생성되지만, "
"차후의 업데이트들에서 다시 생성되지 않을 것임을 기술한다. 생성-날짜와 같은 것"
"들이 이 카테고리 내로 포함될 것이다. 비록 <xref linkend=\"mapping-"
"declaration-version\">version</xref>과 <xref linkend=\"mapping-declaration-"
"timestamp\">timestamp</xref> 프로퍼티들이 생성되는 것으로서 마크될 수 있을 지"
"라도, 이 옵션은 거기서 이용 불가능함을 노트하라..."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>always</literal>: the property value is generated both on insert "
"and on update."
msgstr ""
"<literal>always</literal> - 는 프로퍼티 값이 insert 시와 update 시 모두에 생"
"성됨을 기술한다."

#. Tag: title
#, no-c-format
msgid "Column read and write expressions"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Hibernate allows you to customize the SQL it uses to read and write the "
"values of columns mapped to <link linkend=\"mapping-declaration-property"
"\">simple properties</link>. For example, if your database provides a set of "
"data encryption functions, you can invoke them for individual columns like "
"this: <programlisting role=\"XML\">&lt;property name=\"creditCardNumber"
"\"&gt; &lt;column name=\"credit_card_num\" read=\"decrypt(credit_card_num)\" "
"write=\"encrypt(?)\"/&gt; &lt;/property&gt;</programlisting>"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Hibernate applies the custom expressions automatically whenever the property "
"is referenced in a query. This functionality is similar to a derived-"
"property <literal>formula</literal> with two differences:"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"The property is backed by one or more columns that are exported as part of "
"automatic schema generation."
msgstr ""

#. Tag: para
#, no-c-format
msgid "The property is read-write, not read-only."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"The <literal>write</literal> expression, if specified, must contain exactly "
"one '?' placeholder for the value."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Auxiliary database objects"
msgstr "보조 데이터베이스 객체들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Auxiliary database objects allow for the CREATE and DROP of arbitrary "
"database objects. In conjunction with Hibernate's schema evolution tools, "
"they have the ability to fully define a user schema within the Hibernate "
"mapping files. Although designed specifically for creating and dropping "
"things like triggers or stored procedures, any SQL command that can be run "
"via a <literal>java.sql.Statement.execute()</literal> method is valid (for "
"example, ALTERs, INSERTS, etc.). There are essentially two modes for "
"defining auxiliary database objects:"
msgstr ""
"Hibernate 매핑 파일들 내에 사용자 스키마를 완전하게 정의하기 위한 능력을 제공"
"하기 위해서, Hibernate의 스키마 방출 도구들과 함께 임의적인 데이터베이스 객체"
"들에 대한 CREATE와 DROP을 허용해준다. 비록 트리거들 또는 내장 프로시저들과 같"
"은 것들을 생성시키고 드롭시키기 이해 특별히 고안되었을지라도 하나의 "
"<literal>java.sql.Statement.execute()</literal> 메소드를 통해 실행될 수 있는 "
"SQL 명령이 여기서 유효하다(ALTERs, INSERTS, 기타). 보조 데0이터베이스 객체들"
"을 정의하는 두 가지 모드들이 본질적으로 존재한다..."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The first mode is to explicitly list the CREATE and DROP commands in the "
"mapping file:"
msgstr ""
"첫 번째 모드는 매핑 파일 바깥에서 CREATE 및 DROP 명령들을 명시적으로 나열하"
"는 것이다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The second mode is to supply a custom class that constructs the CREATE and "
"DROP commands. This custom class must implement the <literal>org.hibernate."
"mapping.AuxiliaryDatabaseObject</literal> interface."
msgstr ""
"두번째 모드는 CREATE 및 DROP 명령들을 생성시키는 방법을 알고 있는 하나의 맞"
"춤 클래스를 제공하는 것이다. 이 맞춤 클래스는 <literal>org.hibernate.mapping."
"AuxiliaryDatabaseObject</literal> 인터페이스를 구현해야 한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Additionally, these database objects can be optionally scoped so that they "
"only apply when certain dialects are used."
msgstr ""
"덧붙여 이들 데이터베이스 객체들은 어떤 dialect들이 사용될 때 그것들이 단지 적"
"용될 수 있도록 선택적으로 변동될 수 있다."

#~ msgid "increment"
#~ msgstr "increment"

#~ msgid "identity"
#~ msgstr "identity"

#~ msgid "sequence"
#~ msgstr "sequence"

#~ msgid "hilo"
#~ msgstr "hilo"

#~ msgid "seqhilo"
#~ msgstr "seqhilo"

#~ msgid "uuid"
#~ msgstr "uuid"

#~ msgid "guid"
#~ msgstr "guid"

#~ msgid "native"
#~ msgstr "native"

#~ msgid "assigned"
#~ msgstr "assigned"

#~ msgid "select"
#~ msgstr "select"

#~ msgid "foreign"
#~ msgstr "foreign"

#~ msgid "sequence-identity"
#~ msgstr "sequence-identity"

#, fuzzy
#~ msgid ""
#~ "<literal>optimizer</literal> (optional - defaults to <literal>none</"
#~ "literal>): See"
#~ msgstr ""
#~ "<literal>cascade</literal> (optional- defaults to <literal>none</"
#~ "literal>): cascade 스타일."

#, fuzzy
#~ msgid ""
#~ "<literal>optimizer</literal> (optional - defaults to <literal></"
#~ "literal>): See"
#~ msgstr ""
#~ "<literal>cascade</literal> (optional- defaults to <literal>none</"
#~ "literal>): cascade 스타일."

#~ msgid "string"
#~ msgstr "string"

#~ msgid "class"
#~ msgstr "class"

#~ msgid "binary"
#~ msgstr "binary"

#~ msgid "text"
#~ msgstr "text"

#~ msgid "serializable"
#~ msgstr "serializable"

#~ msgid "clob, blob"
#~ msgstr "clob, blob"

#~ msgid ""
#~ "<literal>type</literal> (optional): A name that indicates the Hibernate "
#~ "type."
#~ msgstr "<literal>type</literal> (옵션): Hibernate 타입을 나타내는 이름."

#~ msgid ""
#~ "<literal>cascade</literal> (optional): Specifies which operations should "
#~ "be cascaded from the parent object to the associated object."
#~ msgstr ""
#~ "<literal>cascade</literal> (옵션): 어느 오퍼레이션들이 부모 객체로부터 연"
#~ "관된 객체로 케스케이드 될 것인지를 지정한다."

#~ msgid ""
#~ "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
#~ "literal>): Specifies that updates to this property do or do not require "
#~ "acquisition of the optimistic lock. In other words, dertermines if a "
#~ "version increment should occur when this property is dirty."
#~ msgstr ""
#~ "<literal>optimistic-lock</literal> (옵션 - 디폴트는 <literal>true</"
#~ "literal>): 이 프로퍼티에 대한 업데이트들이 optimistic lock의 획득을 필요"
#~ "로 하는지 아닌지 여부를 지정한다. 달리 말해 이 프로퍼티가 dirty일 때 "
#~ "version 증가가 발생해야 할 경우인지를 결정한다."

#~ msgid ""
#~ "To understand the behaviour of various Java language-level objects with "
#~ "respect to the persistence service, we need to classify them into two "
#~ "groups:"
#~ msgstr ""
#~ "영속 서비스에 관한 여러 Java 언어-레벨의 객체들을 이해하기 위해, 우리는 그"
#~ "것들을 다음 두 개의 그룹들로 분류할 필요가 있다:"

#~ msgid ""
#~ "<literal>optimizer</literal> (optional, defaults to <literal/>): See "
#~ "<xref linkend=\"mapping-declaration-id-enhanced-optimizers\"/>"
#~ msgstr ""
#~ "<literal>optimizer</literal> (optional, defaults to <literal/>): See "
#~ "<xref linkend=\"mapping-declaration-id-enhanced-optimizers\"/>"
