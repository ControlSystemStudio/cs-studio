# translation of persistent_classes.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2006.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# Michael H. Smith <mhideo@redhat.com>, 2007.
# Glaucia Cintra <gcintra@redhat.com>, 2007.
msgid ""
msgstr ""
"Project-Id-Version: persistent_classes\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:15\n"
"PO-Revision-Date: 2010-03-18 14:48+1000\n"
"Last-Translator: \n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Persistent Classes"
msgstr "Classes Persistentes"

#. Tag: para
#, no-c-format
msgid ""
"Persistent classes are classes in an application that implement the entities "
"of the business problem (e.g. Customer and Order in an E-commerce "
"application). Not all instances of a persistent class are considered to be "
"in the persistent state. For example, an instance can instead be transient "
"or detached."
msgstr ""
"As classes persistentes são classes dentro de um aplicativo que implementa "
"as entidades de problemas de negócios (ex.: Cliente e Pedido em um "
"aplicativo e-commerce). Nem todas as instâncias de uma classe persistente "
"estão em estado persistente, uma instância pode, ao invés disso, ser "
"transiente ou desanexada. "

#. Tag: para
#, no-c-format
msgid ""
"Hibernate works best if these classes follow some simple rules, also known "
"as the Plain Old Java Object (POJO) programming model. However, none of "
"these rules are hard requirements. Indeed, Hibernate3 assumes very little "
"about the nature of your persistent objects. You can express a domain model "
"in other ways (using trees of <literal>Map</literal> instances, for example)."
msgstr ""
"O Hibernate trabalha melhor se estas classes seguirem uma regra simples, "
"também conhecida como modelo de programação Objeto de Java Antigo Simples "
"(POJO). No entanto, nenhuma destas regras são difíceis solicitações. "
"Certamente, o Hibernate3 considera muito pouco da natureza de seus objetos "
"persistentes. Você pode expressar um modelo de domínio de outras formas (por "
"exemplo: utilizando árvores de instâncias <literal>Map</literal>)."

#. Tag: title
#, no-c-format
msgid "A simple POJO example"
msgstr "Um exemplo simples de POJO"

#. Tag: para
#, no-c-format
msgid ""
"Most Java applications require a persistent class representing felines. For "
"example:"
msgstr ""
"A maior parte dos aplicativos Java requerem uma classe persistente que "
"representa os felinos. Por exemplo:"

#. Tag: para
#, no-c-format
msgid ""
"The four main rules of persistent classes are explored in more detail in the "
"following sections."
msgstr ""
"As quatro regras principais das classes persistentes são descritas em "
"maiores detalhes nas seguintes seções."

#. Tag: title
#, no-c-format
msgid "Implement a no-argument constructor"
msgstr "Implemente um construtor de não argumento"

#. Tag: para
#, no-c-format
msgid ""
"<literal>Cat</literal> has a no-argument constructor. All persistent classes "
"must have a default constructor (which can be non-public) so that Hibernate "
"can instantiate them using <literal>Constructor.newInstance()</literal>. It "
"is recommended that you have a default constructor with at least "
"<emphasis>package</emphasis> visibility for runtime proxy generation in "
"Hibernate."
msgstr ""
"<literal>Cat</literal> possui um construtor de não argumento. Todas as "
"classes persistentes devem ter um construtor padrão (que não pode ser "
"público), para que o Hibernate possa instanciá-lo utilizando um "
"<literal>Constructor.newInstance()</literal>. Nós recomendamos enfaticamente "
"ter um construtor padrão com ao menos uma visibilidade <emphasis>package</"
"emphasis> para a geração de um proxy de tempo de espera no Hibernate. "

#. Tag: title
#, no-c-format
msgid "Provide an identifier property (optional)"
msgstr "Providencie uma propriedade de identificador (opcional)"

#. Tag: para
#, no-c-format
msgid ""
"<literal>Cat</literal> has a property called <literal>id</literal>. This "
"property maps to the primary key column of a database table. The property "
"might have been called anything, and its type might have been any primitive "
"type, any primitive \"wrapper\" type, <literal>java.lang.String</literal> or "
"<literal>java.util.Date</literal>. If your legacy database table has "
"composite keys, you can use a user-defined class with properties of these "
"types (see the section on composite identifiers later in the chapter.)"
msgstr ""
"<literal>Cat</literal> possui uma propriedade chamada <literal>id</literal>. "
"Esta propriedade mapeia para a coluna de chave primária de uma tabela de "
"banco de dados. A propriedade pode ter sido chamada por qualquer nome e seu "
"tipo pode ter sido qualquer um primitivo, ou qualquer tipo \"wrapper\", "
"<literal>java.lang.String</literal> ou <literal>java.util.Date</literal>. Se "
"sua tabela de banco de dados de legacia possuir chaves compostas, você "
"também poderá usar uma classe de usuário definido, com propriedades destes "
"tipos (veja a seção de identificadores compostos mais adiante.)"

#. Tag: para
#, no-c-format
msgid ""
"The identifier property is strictly optional. You can leave them off and let "
"Hibernate keep track of object identifiers internally. We do not recommend "
"this, however."
msgstr ""
"A propriedade de identificador é estritamente opcional. Você pode deixá-los "
"desligados e deixar que o Hibernate encontre os identificadores de objeto "
"internamente. No entanto, não recomendamos que faça isto."

#. Tag: para
#, no-c-format
msgid ""
"In fact, some functionality is available only to classes that declare an "
"identifier property:"
msgstr ""
"Na verdade, algumas funcionalidades estão disponíveis somente para classes "
"que declaram uma propriedade de identificador:"

#. Tag: para
#, no-c-format
msgid ""
"Transitive reattachment for detached objects (cascade update or cascade "
"merge) - see <xref linkend=\"objectstate-transitive\" />"
msgstr ""
"Reconexão transitiva para objetos desanexados (atualização de cascata ou "
"mesclagem de cascata) - veja <xref linkend=\"objectstate-transitive\" />"

#. Tag: para
#, no-c-format
msgid "<literal>Session.saveOrUpdate()</literal>"
msgstr "<literal>Session.saveOrUpdate()</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>Session.merge()</literal>"
msgstr "<literal>Session.merge()</literal>"

#. Tag: para
#, no-c-format
msgid ""
"We recommend that you declare consistently-named identifier properties on "
"persistent classes and that you use a nullable (i.e., non-primitive) type."
msgstr ""
"Recomendamos que você declare propriedades de identificador nomeados de "
"forma consistente nas classes persistentes e que você use um tipo anulável "
"(ou seja, não primitivo)."

#. Tag: title
#, no-c-format
msgid "Prefer non-final classes (optional)"
msgstr "Prefira classes não finais (opcional)"

#. Tag: para
#, no-c-format
msgid ""
"A central feature of Hibernate, <emphasis>proxies</emphasis>, depends upon "
"the persistent class being either non-final, or the implementation of an "
"interface that declares all public methods."
msgstr ""
"Um recurso central do Hibernate, <emphasis>proxies</emphasis>, depende da "
"classe persistente ser tanto não final como uma implementação de uma "
"interface que declare todos os métodos públicos."

#. Tag: para
#, no-c-format
msgid ""
"You can persist <literal>final</literal> classes that do not implement an "
"interface with Hibernate. You will not, however, be able to use proxies for "
"lazy association fetching which will ultimately limit your options for "
"performance tuning."
msgstr ""
"Você pode persistir as classes <literal>final</literal> que não implementam "
"uma interface com o Hibernate, mas não poderá usar os proxies para busca por "
"associação lazy, que irá limitar suas opções para ajuste de desempenho. "

#. Tag: para
#, no-c-format
msgid ""
"You should also avoid declaring <literal>public final</literal> methods on "
"the non-final classes. If you want to use a class with a <literal>public "
"final</literal> method, you must explicitly disable proxying by setting "
"<literal>lazy=\"false\"</literal>."
msgstr ""
"Você deve evitar declarar métodos <literal>public final</literal> em classes "
"não finais. Se você desejar usar uma classe com um método <literal>public "
"final</literal> você deve desabilitar o proxy explicitamente, ajustando "
"<literal>lazy=\"false\"</literal>. "

#. Tag: title
#, no-c-format
msgid "Declare accessors and mutators for persistent fields (optional)"
msgstr "Declare acessores e mutadores para campos persistentes (opcional)"

#. Tag: para
#, no-c-format
msgid ""
"<literal>Cat</literal> declares accessor methods for all its persistent "
"fields. Many other ORM tools directly persist instance variables. It is "
"better to provide an indirection between the relational schema and internal "
"data structures of the class. By default, Hibernate persists JavaBeans style "
"properties and recognizes method names of the form <literal>getFoo</"
"literal>, <literal>isFoo</literal> and <literal>setFoo</literal>. If "
"required, you can switch to direct field access for particular properties."
msgstr ""
"<literal>Cat</literal> declara os métodos assessores para todos os seus "
"campos persistentes. Muitas ferramentas ORM persistem diretamente variáveis "
"de instâncias. Acreditamos ser melhor prover uma indireção entre o esquema "
"relacional e as estruturas de dados internos da classe. Por padrão, o "
"Hibernate persiste as propriedades de estilo JavaBeans, e reconhece nomes de "
"métodos da forma <literal>getFoo</literal>, <literal>isFoo</literal> e "
"<literal>setFoo</literal>. Caso solicitado, você pode mudar para direcionar "
"acesso ao campo para certas propriedades, caso seja necessário. "

#. Tag: para
#, no-c-format
msgid ""
"Properties need <emphasis>not</emphasis> be declared public - Hibernate can "
"persist a property with a default, <literal>protected</literal> or "
"<literal>private</literal> get / set pair."
msgstr ""
"As propriedades precisam <emphasis>not</emphasis> ser declaradas como "
"públicas. O Hibernate pode persistir uma propriedade com um par get/set "
"padrão <literal>protegido</literal> ou <literal>privado</literal>."

#. Tag: title
#, no-c-format
msgid "Implementing inheritance"
msgstr "Implementando herança"

#. Tag: para
#, no-c-format
msgid ""
"A subclass must also observe the first and second rules. It inherits its "
"identifier property from the superclass, <literal>Cat</literal>. For example:"
msgstr ""
"Uma subclasse também deve observar as primeiras e segundas regras. Ela herda "
"sua propriedade de identificador a partir das superclasses, <literal>Cat</"
"literal>. Por exemplo:"

#. Tag: title
#, no-c-format
msgid "Implementing <literal>equals()</literal> and <literal>hashCode()</literal>"
msgstr "Implementando <literal>equals()</literal> e <literal>hashCode()</literal> "

#. Tag: para
#, no-c-format
msgid ""
"You have to override the <literal>equals()</literal> and <literal>hashCode()"
"</literal> methods if you:"
msgstr ""
"Você precisa substituir os métodos <literal>equals()</literal> e "
"<literal>hashCode()</literal> se você:"

#. Tag: para
#, no-c-format
msgid ""
"intend to put instances of persistent classes in a <literal>Set</literal> "
"(the recommended way to represent many-valued associations); <emphasis>and</"
"emphasis>"
msgstr ""
"pretender inserir instâncias de classes persistentes em um <literal>Set</"
"literal> (a forma mais recomendada é representar associações de muitos "
"valores), <emphasis>e</emphasis>"

#. Tag: para
#, no-c-format
msgid "intend to use reattachment of detached instances"
msgstr "pretender usar reconexão de instâncias desanexadas"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate guarantees equivalence of persistent identity (database row) and "
"Java identity only inside a particular session scope. When you mix instances "
"retrieved in different sessions, you must implement <literal>equals()</"
"literal> and <literal>hashCode()</literal> if you wish to have meaningful "
"semantics for <literal>Set</literal>s."
msgstr ""
"O Hibernate garante a equivalência de identidades persistentes (linha de "
"base de dados) e identidade Java somente dentro de um certo escopo de "
"sessão. Dessa forma, assim que misturarmos instâncias recuperadas em sessões "
"diferentes, devemos implementar <literal>equals()</literal> e "
"<literal>hashCode()</literal> se quisermos ter semânticas significativas "
"para os <literal>Set</literal>s.  "

#. Tag: para
#, no-c-format
msgid ""
"The most obvious way is to implement <literal>equals()</literal>/"
"<literal>hashCode()</literal> by comparing the identifier value of both "
"objects. If the value is the same, both must be the same database row, "
"because they are equal. If both are added to a <literal>Set</literal>, you "
"will only have one element in the <literal>Set</literal>). Unfortunately, "
"you cannot use that approach with generated identifiers. Hibernate will only "
"assign identifier values to objects that are persistent; a newly created "
"instance will not have any identifier value. Furthermore, if an instance is "
"unsaved and currently in a <literal>Set</literal>, saving it will assign an "
"identifier value to the object. If <literal>equals()</literal> and "
"<literal>hashCode()</literal> are based on the identifier value, the hash "
"code would change, breaking the contract of the <literal>Set</literal>. See "
"the Hibernate website for a full discussion of this problem. This is not a "
"Hibernate issue, but normal Java semantics of object identity and equality."
msgstr ""
"A forma mais óbvia é implementar <literal>equals()</literal>/"
"<literal>hashCode()</literal> comparando o valor do identificador de ambos "
"objetos. Caso o valor seja o mesmo, ambos devem ter a mesma linha de base de "
"dados, assim eles serão iguais (se ambos forem adicionados a um "
"<literal>Set</literal>, nós só teremos um elemento no <literal>Set</"
"literal>). Infelizmente, não podemos usar esta abordagem com os "
"identificadores gerados. O Hibernate atribuirá somente os valores de "
"identificadores aos objetos que forem persistentes, uma instância "
"recentemente criada não terá nenhum valor de identificador. Além disso, se "
"uma instância não for salva e estiver em um <literal>Set</literal>, salvá-la "
"atribuirá um valor de identificador ao objeto. Se <literal>equals()</"
"literal> e <literal>hashCode()</literal> fossem baseados em um valor "
"identificador, o código hash teria mudado, quebrando o contrato do "
"<literal>Set</literal>. Consulte o website do Hibernate para acessar uma "
"discussão completa sobre este problema. Note que esta não é uma edição do "
"Hibernate, e sim semânticas naturais do Java de igualdade e identidade."

#. Tag: para
#, no-c-format
msgid ""
"It is recommended that you implement <literal>equals()</literal> and "
"<literal>hashCode()</literal> using <emphasis>Business key equality</"
"emphasis>. Business key equality means that the <literal>equals()</literal> "
"method compares only the properties that form the business key. It is a key "
"that would identify our instance in the real world (a <emphasis>natural</"
"emphasis> candidate key):"
msgstr ""
"Recomendamos implementar <literal>equals()</literal> e <literal>hashCode()</"
"literal> usando <emphasis>Business key equality</emphasis>. A chave de "
"negócios significa que o método <literal>equals()</literal> compara somente "
"a propriedade que formar uma chave de negócios, uma chave que identificaria "
"nossa instância na realidade (uma chave de candidato <emphasis>natural</"
"emphasis>): "

#. Tag: para
#, no-c-format
msgid ""
"A business key does not have to be as solid as a database primary key "
"candidate (see <xref linkend=\"transactions-basics-identity\" />). Immutable "
"or unique properties are usually good candidates for a business key."
msgstr ""
"Note que uma chave de negócios não tem que ser tão sólida quanto um "
"candidato de chave primária de base de dados (veja <xref linkend=\"transactions-basics-identity\" />). Propriedades imutáveis ou únicas são "
"bons candidatos para uma chave de negócios. "

#. Tag: title
#, no-c-format
msgid "Dynamic models"
msgstr "Modelos dinâmicos"

#. Tag: title
#, no-c-format
msgid "Note"
msgstr "Nota"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>The following features are currently considered experimental and "
"may change in the near future.</emphasis>"
msgstr ""
"<emphasis>Os recursos seguintes são considerados experimentais no momento e "
"podem mudar no futuro.</emphasis> "

#. Tag: para
#, no-c-format
msgid ""
"Persistent entities do not necessarily have to be represented as POJO "
"classes or as JavaBean objects at runtime. Hibernate also supports dynamic "
"models (using <literal>Map</literal>s of <literal>Map</literal>s at runtime) "
"and the representation of entities as DOM4J trees. With this approach, you "
"do not write persistent classes, only mapping files."
msgstr ""
"Entidades persistentes não precisam ser representadas como classes POJO ou "
"como objetos JavaBeans em tempo de espera. O Hibernate também suporta "
"modelos dinâmicos (usando <literal>Map</literal>s de <literal>Map</literal>s "
"em tempo de execução) e a representação de entidades como árvores DOM4J. Com "
"esta abordagem, você não escreve classes persistes, somente arquivos de "
"mapeamentos. "

#. Tag: para
#, no-c-format
msgid ""
"By default, Hibernate works in normal POJO mode. You can set a default "
"entity representation mode for a particular <literal>SessionFactory</"
"literal> using the <literal>default_entity_mode</literal> configuration "
"option (see <xref linkend=\"configuration-optional-properties\" />)."
msgstr ""
"Por padrão, o Hibernate funciona em modo POJO normal. Você deve ajustar um "
"modo de representação de entidade por padrão para uma certa "
"<literal>SessionFactory</literal> usando a opção de configuração "
"<literal>default_entity_mode</literal> (veja <xref linkend=\"configuration-optional-properties\" />). "

#. Tag: para
#, no-c-format
msgid ""
"The following examples demonstrate the representation using <literal>Map</"
"literal>s. First, in the mapping file an <literal>entity-name</literal> has "
"to be declared instead of, or in addition to, a class name:"
msgstr ""
"Os seguintes exemplos demonstram a representação usando <literal>Map</"
"literal>s. Primeiro, no arquivo de mapeamento, um <literal>entity-name</"
"literal> precisa ser declarado ao invés de (ou além de) um nome de classe:"

#. Tag: para
#, no-c-format
msgid ""
"Even though associations are declared using target class names, the target "
"type of associations can also be a dynamic entity instead of a POJO."
msgstr ""
"Note que embora as associações sejam declaradas utilizando nomes de classe, "
"o tipo alvo de uma associação pode também ser uma entidade dinâmica, ao "
"invés de um POJO. "

#. Tag: para
#, no-c-format
msgid ""
"After setting the default entity mode to <literal>dynamic-map</literal> for "
"the <literal>SessionFactory</literal>, you can, at runtime, work with "
"<literal>Map</literal>s of <literal>Map</literal>s:"
msgstr ""
"Após ajustar o modo de entidade padrão para <literal>dynamic-map</literal> "
"para a <literal>SessionFactory</literal>, você poderá trabalhar com "
"<literal>Map</literal>s de <literal>Map</literal>s no período de execução: "

#. Tag: para
#, no-c-format
msgid ""
"One of the main advantages of dynamic mapping is quick turnaround time for "
"prototyping, without the need for entity class implementation. However, you "
"lose compile-time type checking and will likely deal with many exceptions at "
"runtime. As a result of the Hibernate mapping, the database schema can "
"easily be normalized and sound, allowing to add a proper domain model "
"implementation on top later on."
msgstr ""
"As vantagens de um mapeamento dinâmico são o tempo de retorno rápido para "
"realizar o protótipo sem a necessidade de implementar uma classe de "
"entidade. No entanto, você perde o tipo de tempo de compilação, verificando "
"e muito provavelmente terá que lidar com muitas exceções de tempo de espera. "
"Graças ao mapeamento do Hibernate, o esquema do banco de dados pode ser "
"facilmente normalizado e seguro, permitindo adicionar uma implementação "
"modelo de domínio apropriado na camada do topo num futuro próximo. "

#. Tag: para
#, no-c-format
msgid ""
"Entity representation modes can also be set on a per <literal>Session</"
"literal> basis:"
msgstr ""
"Modos de representação de entidade podem ser também ajustados para base por "
"<literal>Session</literal>:"

#. Tag: para
#, no-c-format
msgid ""
"Please note that the call to <literal>getSession()</literal> using an "
"<literal>EntityMode</literal> is on the <literal>Session</literal> API, not "
"the <literal>SessionFactory</literal>. That way, the new <literal>Session</"
"literal> shares the underlying JDBC connection, transaction, and other "
"context information. This means you do not have to call <literal>flush()</"
"literal> and <literal>close()</literal> on the secondary <literal>Session</"
"literal>, and also leave the transaction and connection handling to the "
"primary unit of work."
msgstr ""
"Por favor, note que a chamada para a <literal>getSession()</literal> usando "
"um <literal>EntityMode</literal> está na API de <literal>Session</literal> e "
"não na <literal>SessionFactory</literal>. Dessa forma, a nova "
"<literal>Session</literal> compartilha a conexão, transação e outra "
"informação de contexto JDBC adjacente. Isto significa que você não precisará "
"chamar <literal>flush()</literal> e <literal>close()</literal> na "
"<literal>Session</literal> secundária, e também deixar a transação e o "
"manuseio da conexão para a unidade primária do trabalho. "

#. Tag: para
#, no-c-format
msgid ""
"More information about the XML representation capabilities can be found in "
"<xref linkend=\"xml\" />."
msgstr ""
"Você poderá encontrar maiores informações sobre as atividades de "
"representação XML em <xref linkend=\"xml\" />. "

#. Tag: title
#, no-c-format
msgid "Tuplizers"
msgstr "Tuplizadores"

#. Tag: para
#, no-c-format
msgid ""
"<literal>org.hibernate.tuple.Tuplizer</literal>, and its sub-interfaces, are "
"responsible for managing a particular representation of a piece of data "
"given that representation's <literal>org.hibernate.EntityMode</literal>. If "
"a given piece of data is thought of as a data structure, then a tuplizer is "
"the thing that knows how to create such a data structure and how to extract "
"values from and inject values into such a data structure. For example, for "
"the POJO entity mode, the corresponding tuplizer knows how create the POJO "
"through its constructor. It also knows how to access the POJO properties "
"using the defined property accessors."
msgstr ""
"<literal>org.hibernate.tuple.Tuplizer</literal>, e suas sub-interfaces, são "
"responsáveis por gerenciar uma certa representação de uma parte de dado, "
"dada a <literal>org.hibernate.EntityMode</literal> da representação. Se uma "
"parte de dado é tida como uma estrutura de dado, então o tuplizador se "
"encarrega de criar tal estrutura de dado e como extrair e injetar valores de "
"e em tal estrutura de dados. Por exemplo, para um modo POJO, o tuplizador "
"correspondente sabe como criar um POJO através de seu construtor. Além "
"disso, ele sabe como acessar propriedades de POJO usando assessores de "
"propriedades definidas. "

#. Tag: para
#, no-c-format
msgid ""
"There are two high-level types of Tuplizers, represented by the <literal>org."
"hibernate.tuple.entity.EntityTuplizer</literal> and <literal>org.hibernate."
"tuple.component.ComponentTuplizer</literal> interfaces. "
"<literal>EntityTuplizer</literal>s are responsible for managing the above "
"mentioned contracts in regards to entities, while "
"<literal>ComponentTuplizer</literal>s do the same for components."
msgstr ""
"Existem dois tipos de alto nível de Tuplizadores, representados pelas "
"interfaces <literal>org.hibernate.tuple.entity.EntityTuplizer</literal> e "
"<literal>org.hibernate.tuple.component.ComponentTuplizer</literal>. Os "
"<literal>EntityTuplizer</literal>s são responsáveis pelo gerenciamento dos "
"contratos mencionados acima em relação às entidades, enquanto os "
"<literal>ComponentTuplizer</literal>s realizam o mesmo para os componentes."

#. Tag: para
#, no-c-format
msgid ""
"Users can also plug in their own tuplizers. Perhaps you require that a "
"<literal>java.util.Map</literal> implementation other than <literal>java."
"util.HashMap</literal> be used while in the dynamic-map entity-mode. Or "
"perhaps you need to define a different proxy generation strategy than the "
"one used by default. Both would be achieved by defining a custom tuplizer "
"implementation. Tuplizer definitions are attached to the entity or component "
"mapping they are meant to manage. Going back to the example of our customer "
"entity:"
msgstr ""
"Os usuários podem também plugar seu próprio tuplizador. Talvez você queira "
"usar uma implementação <literal>java.util.Map</literal> ao invés de uma "
"<literal>java.util.HashMap</literal> enquanto estiver no modo de entidade "
"mapa dinâmico, ou talvez você precise definir uma estratégia de geração de "
"proxy diferente, ao invés de uma utilizada por padrão. Ambas seriam "
"alcançadas definindo uma implementação de tuplizador personalizada. As "
"definições do tuplizador estão anexadas à entidade ou ao mapeamento de "
"componente que tiverem que gerenciar. Retornando ao exemplo da entidade do "
"nosso cliente:"

#. Tag: title
#, no-c-format
msgid "EntityNameResolvers"
msgstr "EntityNameResolvers"

#. Tag: para
#, no-c-format
msgid ""
"The <interfacename>org.hibernate.EntityNameResolver</interfacename> "
"interface is a contract for resolving the entity name of a given entity "
"instance. The interface defines a single method "
"<methodname>resolveEntityName</methodname> which is passed the entity "
"instance and is expected to return the appropriate entity name (null is "
"allowed and would indicate that the resolver does not know how to resolve "
"the entity name of the given entity instance). Generally speaking, an "
"<interfacename>org.hibernate.EntityNameResolver</interfacename> is going to "
"be most useful in the case of dynamic models. One example might be using "
"proxied interfaces as your domain model. The hibernate test suite has an "
"example of this exact style of usage under the <package>org.hibernate.test."
"dynamicentity.tuplizer2</package>. Here is some of the code from that "
"package for illustration."
msgstr ""
"A interface <interfacename>org.hibernate.EntityNameResolver</interfacename> "
"é um contrato para resolver o nome da entidade de uma instância de entidade "
"dada. A interface define um <methodname>resolveEntityName</methodname> de "
"método único que é passado à instância de entidade e é esperado a retornar "
"ao nome de entidade apropriado (nulo é permitido e indicaria que o "
"solucionador não saiba como resolver o nome de entidade da instância de "
"entidade dada). Normalmente, um <interfacename>org.hibernate."
"EntityNameResolver</interfacename> será mais útil no caso de modelos "
"dinâmicos. Um exemplo poderá ser usado nas interfaces com proxie no caso dos "
"modelos dinâmicos. O hibernate test suite possui um exemplo deste estilo "
"exato de uso sob o <package>org.hibernate.test.dynamicentity.tuplizer2</"
"package>. Segue abaixo parte do código a partir daquele pacote para "
"ilustração."

#. Tag: para
#, no-c-format
msgid ""
"In order to register an <interfacename>org.hibernate.EntityNameResolver</"
"interfacename> users must either:"
msgstr ""
"Com o objetivo de registrar um <interfacename>org.hibernate."
"EntityNameResolver</interfacename>, os usuários devem tanto:"

#. Tag: para
#, no-c-format
msgid ""
"Implement a custom <link linkend=\"persistent-classes-tuplizers\">Tuplizer</"
"link>, implementing the <methodname>getEntityNameResolvers</methodname> "
"method."
msgstr ""
"Implementar um <link linkend=\"persistent-classes-tuplizers\">Tuplizer</"
"link> personalizado, implementando o método <methodname>getEntityNameResolvers</methodname>."

#. Tag: para
#, no-c-format
msgid ""
"Register it with the <classname>org.hibernate.impl.SessionFactoryImpl</"
"classname> (which is the implementation class for <interfacename>org."
"hibernate.SessionFactory</interfacename>) using the "
"<methodname>registerEntityNameResolver</methodname> method."
msgstr ""
"Registrá-lo com o <classname>org.hibernate.impl.SessionFactoryImpl</"
"classname> (que é a classe de implementação para <interfacename>org."
"hibernate.SessionFactory</interfacename>) usando o método "
"<methodname>registerEntityNameResolver</methodname>."

