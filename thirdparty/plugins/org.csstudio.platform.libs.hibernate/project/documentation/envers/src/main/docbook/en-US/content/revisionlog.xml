<?xml version='1.0' encoding="UTF-8"?>
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~ Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  ~ indicated by the @author tags or express copyright attribution
  ~ statements applied by the authors.  All third-party contributions are
  ~ distributed under license by Red Hat Middleware LLC.
  ~
  ~ This copyrighted material is made available to anyone wishing to use, modify,
  ~ copy, or redistribute it subject to the terms and conditions of the GNU
  ~ Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../Hibernate_Envers_-_Easy_Entity_Auditing.ent">
%BOOK_ENTITIES;
]>

<chapter id="revisionlog">

    <title>Logging data for revisions</title>

    <para>
        Envers provides an easy way to log additional data for each revision. You simply need
        to annotate one entity with <literal>@RevisionEntity</literal>, and a new instance of
        this entity will be persisted when a new revision is created (that is, whenever an
        audited entity is modified). As revisions are global, you can have at most one revisions entity.
    </para>

    <para>
        This entity must have at least two properties:
    </para>

    <orderedlist>
        <listitem>
            <para>
                an integer- or long-valued property, annotated with <literal>@RevisionNumber</literal>. Most
                often, this will be an auto-generated primary key.
            </para>
        </listitem>
        <listitem>
            <para>
                a long- or j.u.Date- valued property, annotated with <literal>@RevisionTimestamp</literal>. Value of
                this property will be automatically set by Envers.
            </para>
        </listitem>
    </orderedlist>

    <para>
        You can either add these properties to your entity, or extend
        <literal>org.hibernate.envers.DefaultRevisionEntity</literal>, which already has those two properties.
    </para>

    <para>
        When using a <literal>Date</literal>, instead of a <literal>long/Long</literal> for the revision timestamp,
        take care not to use a mapping of the property which will loose precision (for example, using
        <literal>@Temporal(DATE)</literal> is wrong, as it doesn't store the time information, so many of your
        revisions will appear to happen at exactly the same time). A good choice is a
        <literal>@Temporal(TIMESTAMP)</literal>.
    </para>

    <para>
        To fill the entity with additional data, you'll need to implement the
        <literal>org.jboss.envers.RevisionListener</literal> interface. Its newRevision method will
        be called when a new revision is created, before persisting the revision entity.
        The implementation should be stateless and thread-safe. The listener then has to be
        attached to the revisions entity by specifying it as a parameter to the
        <literal>@RevisionEntity</literal> annotation.
    </para>

    <para>
        Alternatively, you can use the <literal>getCurrentRevision</literal> method of the 
        <literal>AuditReader</literal> interface to obtain the current revision, and fill it with desired information.
        The method has a <literal>persist</literal> parameter specifying, if the revision entity should be persisted
        before returning. If set to <literal>true</literal>, the revision number will be available in the returned
        revision entity (as it is normally generated by the database), but the revision entity will be persisted
        regardless of wheter there are any audited entities changed. If set to <literal>false</literal>, the revision
        number will be <literal>null</literal>, but the revision entity will be persisted only if some audited entities
        have changed.
    </para>

    <para>
        A simplest example of a revisions entity, which with each revision associates the
        username of the user making the change is:
    </para>

    <programlisting>package org.jboss.envers.example;

import org.hibernate.envers.RevisionEntity;
import org.hibernate.envers.DefaultRevisionEntity;

import javax.persistence.Entity;

@Entity
@RevisionEntity(ExampleListener.class)
public class ExampleRevEntity extends DefaultRevisionEntity {
	private String username;

	public String getUsername() { return username; }
	public void setUsername(String username) { this.username = username; }
}</programlisting>

    <para>
        Or, if you don't want to extend any class:
    </para>

    <programlisting>package org.hibernate.envers.example;

import org.hibernate.envers.RevisionNumber;
import org.hibernate.envers.RevisionTimestamp;
import org.hibernate.envers.RevisionEntity;

import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.Entity;

@Entity
@RevisionEntity(ExampleListener.class)
public class ExampleRevEntity {
    @Id
    @GeneratedValue
    @RevisionNumber
    private int id;

    @RevisionTimestamp
    private long timestamp;

    private String username;

    // Getters, setters, equals, hashCode ...
}</programlisting>

    <para>
        An example listener, which, if used in a JBoss Seam application, stores the
        currently logged in user username:
    </para>

    <programlisting>package org.hibernate.envers.example;

import org.hibernate.envers.RevisionListener;
import org.jboss.seam.security.Identity;
import org.jboss.seam.Component;

public class ExampleListener implements RevisionListener {
    public void newRevision(Object revisionEntity) {
        ExampleRevEntity exampleRevEntity = (ExampleRevEntity) revisionEntity;
        Identity identity = (Identity) Component.getInstance("org.jboss.seam.security.identity");

        exampleRevEntity.setUsername(identity.getUsername());
    }
}</programlisting>

    <para>
        Having an "empty" revision entity - that is, with no additional properties except the
        two mandatory ones - is also an easy way to change the names of the table and of the
        properties in the revisions table automatically generated by Envers.
    </para>

    <para>
        In case there is no entity annotated with <literal>@RevisionEntity</literal>, a default
        table will be generated, with the name <literal>REVINFO</literal>.
    </para>

</chapter>
