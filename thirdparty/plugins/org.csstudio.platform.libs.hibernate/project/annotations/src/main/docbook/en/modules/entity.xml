<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~ Copyright (c) 2008, Red Hat Inc. or third-party contributors as
  ~ indicated by the @author tags or express copyright attribution
  ~ statements applied by the authors.  All third-party contributions are
  ~ distributed under license by Red Hat Middleware LLC.
  ~
  ~ This copyrighted material is made available to anyone wishing to use, modify,
  ~ copy, or redistribute it subject to the terms and conditions of the GNU
  ~ Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="entity">
  <title>Mapping Entities</title>

  <section id="entity-overview">
    <title>Intro</title>

    <para>This section explains how to describe persistence mappings using
    Java Persistence 2.0 annotations as well as Hibernate-specific annotation
    extensions.</para>
  </section>

  <section id="entity-mapping">
    <title>Mapping with JPA (Java Persistence Annotations)</title>

    <para>JPA entities are plain POJOs. Actually, they are Hibernate
    persistent entities. Their mappings are defined through JDK 5.0
    annotations instead of hbm.xml files. A JPA 2 XML descriptor syntax for
    overriding is defined as well). Annotations can be split in two
    categories, the logical mapping annotations (describing the object model,
    the association between two entities etc.) and the physical mapping
    annotations (describing the physical schema, tables, columns, indexes,
    etc). We will mix annotations from both categories in the following code
    examples.</para>

    <para>JPA annotations are in the <literal>javax.persistence.*</literal>
    package. You favorite IDE can auto-complete annotations and their
    attributes for you (even without a specific "JPA" module, since JPA
    annotations are plain JDK 5 annotations).</para>

    <para>A good an complete set of working examples can be found in the
    Hibernate Annotations test suite itself: most of the unit tests have been
    designed to represent a concrete example and be a source of inspiration
    for you. You can get the test suite sources in the distribution.</para>

    <section id="entity-mapping-entity">
      <title>Marking a POJO as persistent entity</title>

      <para>Every persistent POJO class is an entity and is declared using the
      <literal>@Entity</literal> annotation (at the class level):</para>

      <programlisting language="JAVA" role="JAVA">@Entity
public class Flight implements Serializable {
    Long id;

    @Id
    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }
}         </programlisting>

      <para><literal>@Entity</literal> declares the class as an entity (i.e. a
      persistent POJO class), <literal>@Id</literal> declares the identifier
      property of this entity. The other mapping declarations are implicit.
      The class Flight is mapped to the Flight table, using the column id as
      its primary key column.</para>

      <note>
        <para>The concept of configuration by exception is central to the JPA
        specification.</para>
      </note>

      <para>Depending on whether you annotate fields or methods, the access
      type used by Hibernate will be <literal>field</literal> or
      <literal>property</literal>. The EJB3 spec requires that you declare
      annotations on the element type that will be accessed, i.e. the getter
      method if you use <literal>property</literal> access, the field if you
      use <literal>field</literal> access. Mixing annotations in both fields
      and methods should be avoided. Hibernate will guess the access type from
      the position of <literal>@Id</literal> or
      <literal>@EmbeddedId</literal>.</para>

      <section>
        <title>Defining the table</title>

        <para><literal>@Table</literal> is set at the class level; it allows
        you to define the table, catalog, and schema names for your entity
        mapping. If no <literal>@Table</literal> is defined the default values
        are used: the unqualified class name of the entity.</para>

        <programlisting language="JAVA" role="JAVA">@Entity
@Table(name="tbl_sky")
public class Sky implements Serializable {
   ...
}            </programlisting>

        <para>The <literal>@Table</literal> element contains a
        <literal>schema</literal> and <literal>catalog</literal> attributes,
        if they need to be defined. You can also define unique constraints to
        the table using the <literal>@UniqueConstraint</literal> annotation in
        conjunction with <literal>@Table</literal> (for a unique constraint
        bound to a single column, it is recommended to use the
        <code>@Column.unique</code> approach (refer to
        <literal>@Column</literal> for more information).</para>

        <programlisting language="JAVA" role="JAVA">@Table(name="tbl_sky",
    uniqueConstraints = {@UniqueConstraint(columnNames={"month", "day"})}
)</programlisting>

        <para>A unique constraint is applied to the tuple month, day. Note
        that the <literal>columnNames</literal> array refers to the logical
        column names.</para>

        <remark>The logical column name is defined by the Hibernate
        <classname>NamingStrategy</classname> implementation. The default JPA
        naming strategy uses the physical column name as the logical column
        name but it could be different if for example you append fld_ to all
        your columns using a custom <classname>NamingStrategy</classname>
        implementation. Note that the logical column name is not necessarily
        equals to the property name esp when the column name is explicitly
        set. Unless you override the <classname>NamingStrategy</classname>,
        you shouldn't worry about that.</remark>
      </section>

      <section id="entity-mapping-entity-version">
        <title>Versioning for optimistic locking</title>

        <para>You can add optimistic locking capability to an entity using the
        <literal>@Version</literal> annotation:</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Flight implements Serializable {
...
    @Version
    @Column(name="OPTLOCK")
    public Integer getVersion() { ... }
}           </programlisting>

        <para>The version property will be mapped to the
        <literal>OPTLOCK</literal> column, and the entity manager will use it
        to detect conflicting updates (preventing lost updates you might
        otherwise see with the last-commit-wins strategy).</para>

        <para>The version column may be a numeric (the recommended solution)
        or a timestamp. Hibernate supports any kind of type provided that you
        define and implement the appropriate
        <classname>UserVersionType</classname>.</para>

        <para>The application must not alter the version number set up by
        Hibernate in any way. To artificially increase the version number,
        check in Hibernate Entity Manager's reference documentation
        <literal>LockModeType.OPTIMISTIC_FORCE_INCREMENT</literal> or
        <literal>LockModeType.PESSIMISTIC_FORCE_INCREMENT</literal>.</para>
      </section>
    </section>

    <section id="entity-mapping-property">
      <title>Mapping simple properties</title>

      <section>
        <title>Declaring basic property mappings</title>

        <para>Every non static non transient property (field or method
        depending on the access type) of an entity is considered persistent,
        unless you annotate it as <literal>@Transient</literal>. Not having an
        annotation for your property is equivalent to the appropriate
        <literal>@Basic</literal> annotation. The <literal>@Basic</literal>
        annotation allows you to declare the fetching strategy for a
        property:</para>

        <programlisting language="JAVA" role="JAVA">public transient int counter; //transient property

private String firstname; //persistent property

@Transient
String getLengthInMeter() { ... } //transient property

String getName() {... } // persistent property

@Basic
int getLength() { ... } // persistent property

@Basic(fetch = FetchType.LAZY)
String getDetailedComment() { ... } // persistent property

@Temporal(TemporalType.TIME)
java.util.Date getDepartureTime() { ... } // persistent property           

@Enumerated(EnumType.STRING)
Starred getNote() { ... } //enum persisted as String in database</programlisting>

        <para><literal>counter</literal>, a transient field, and
        <literal>lengthInMeter</literal>, a method annotated as
        <literal>@Transient</literal>, and will be ignored by the entity
        manager. <literal>name</literal>, <literal>length</literal>, and
        <literal>firstname</literal> properties are mapped persistent and
        eagerly fetched (the default for simple properties). The
        <literal>detailedComment</literal> property value will be lazily
        fetched from the database once a lazy property of the entity is
        accessed for the first time. Usually you don't need to lazy simple
        properties (not to be confused with lazy association fetching).</para>

        <note>
          <para>To enable property level lazy fetching, your classes have to
          be instrumented: bytecode is added to the original class to enable
          such feature, please refer to the Hibernate reference documentation.
          If your classes are not instrumented, property level lazy loading is
          silently ignored.</para>
        </note>

        <para>The recommended alternative is to use the projection capability
        of JP-QL (Java Persistence Query Language) or Criteria queries.</para>

        <para>JPA support property mapping of all basic types supported by
        Hibernate (all basic Java types , their respective wrappers and
        serializable classes). Hibernate Annotations support out of the box
        enum type mapping either into a ordinal column (saving the enum
        ordinal) or a string based column (saving the enum string
        representation): the persistence representation, defaulted to ordinal,
        can be overridden through the <literal>@Enumerated</literal>
        annotation as shown in the <literal>note</literal> property
        example.</para>

        <para>In plain Java APIs, the temporal precision of time is not
        defined. When dealing with temporal data you might want to describe
        the expected precision in database. Temporal data can have
        <literal>DATE</literal>, <literal>TIME</literal>, or
        <literal>TIMESTAMP</literal> precision (ie the actual date, only the
        time, or both). Use the <literal>@Temporal</literal> annotation to
        fine tune that.</para>

        <para><literal>@Lob</literal> indicates that the property should be
        persisted in a Blob or a Clob depending on the property type:
        <classname>java.sql.Clob</classname>,
        <classname>Character[]</classname>, <classname>char[]</classname> and
        java.lang.<classname>String</classname> will be persisted in a Clob.
        <classname>java.sql.Blob</classname>, <classname>Byte[]</classname>,
        <classname>byte[] </classname>and serializable type will be persisted
        in a Blob.</para>

        <programlisting language="JAVA" role="JAVA">
@Lob
public String getFullText() {
    return fullText;
}

@Lob 
public byte[] getFullCode() {
    return fullCode;
}
 </programlisting>

        <para>If the property type implements
        <classname>java.io.Serializable</classname> and is not a basic type,
        and if the property is not annotated with <literal>@Lob</literal>,
        then the Hibernate <literal>serializable</literal> type is
        used.</para>
      </section>

      <section>
        <title>Access type</title>

        <para>By default the access type of a class hierarchy is defined by
        the position of the <classname>@Id</classname> or
        <classname>@EmbeddedId</classname> annotations. If these annotations
        are on a field, then only fields are considered for persistence and
        the state is accessed via the field. If there annotations are on a
        getter, then only the getters are considered for persistence and the
        state is accessed via the getter/setter. That works well in practice
        and is the recommended approach.<note>
            <para>The placement of annotations within a class hierarchy has to
            be consistent (either field or on property) to be able to
            determine the default access type. It is recommended to stick to
            one single annotation placement strategy throughout your whole
            application.</para>
          </note></para>

        <para>However in some situations, you need to:</para>

        <itemizedlist>
          <listitem>
            <para>force the access type of the entity hierarchy</para>
          </listitem>

          <listitem>
            <para>override the access type of a specific entity in the class
            hierarchy</para>
          </listitem>

          <listitem>
            <para>override the access type of an embeddable type</para>
          </listitem>
        </itemizedlist>

        <para>The best use case is an embeddable class used by several
        entities that might not use the same access type. In this case it is
        better to force the access type at the embeddable class level.</para>

        <para>To force the access type on a given class, use the
        <classname>@Access</classname> annotation as showed below:</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Order {
   @Id private Long id;
   public Long getId() { return id; }
   public void setId(Long id) { this.id = id; }

   @Embedded private Address address;
   public Address getAddress() { return address; }
   public void setAddress() { this.address = address; }
}

@Entity
public class User {
   private Long id;
   @Id public Long getId() { return id; }
   public void setId(Long id) { this.id = id; }

   private Address address;
   @Embedded public Address getAddress() { return address; }
   public void setAddress() { this.address = address; }
}

@Embeddable
@Access(AcessType.PROPERTY)
public class Address {
   private String street1;
   public String getStreet1() { return street1; }
   public void setStreet1() { this.street1 = street1; }

   private hashCode; //not persistent
}</programlisting>

        <para>You can also override the access type of a single property while
        keeping the other properties standard.</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Order {
   @Id private Long id;
   public Long getId() { return id; }
   public void setId(Long id) { this.id = id; }
   @Transient private String userId;
   @Transient private String orderId;

   @Access(AccessType.PROPERTY)
   public String getOrderNumber() { return userId + ":" + orderId; }
   public void setOrderNumber() { this.userId = ...; this.orderId = ...; }
}</programlisting>

        <para>In this example, the default access type is
        <classname>FIELD</classname> except for the
        <literal>orderNumber</literal> property. Note that the corresponding
        field, if any must be marked as <classname>@Transient</classname> or
        <code>transient</code>.</para>

        <note>
          <title>@org.hibernate.annotations.AccessType</title>

          <para>The annotation
          <classname>@org.hibernate.annotations.AccessType</classname> should
          be considered deprecated for FIELD and PROPERTY access. It is still
          useful however if you need to use a custom access type.</para>
        </note>
      </section>

      <section id="entity-mapping-property-column">
        <title>Declaring column attributes</title>

        <para>The column(s) used for a property mapping can be defined using
        the <literal>@Column</literal> annotation. Use it to override default
        values (see the EJB3 specification for more information on the
        defaults). You can use this annotation at the property level for
        properties that are:</para>

        <itemizedlist>
          <listitem>
            <para>not annotated at all</para>
          </listitem>

          <listitem>
            <para>annotated with <literal>@Basic</literal></para>
          </listitem>

          <listitem>
            <para>annotated with <literal>@Version</literal></para>
          </listitem>

          <listitem>
            <para>annotated with <literal>@Lob</literal></para>
          </listitem>

          <listitem>
            <para>annotated with <literal>@Temporal</literal></para>
          </listitem>
        </itemizedlist>

        <programlisting language="JAVA" role="JAVA">
@Entity
public class Flight implements Serializable {
...
@Column(updatable = false, name = "flight_name", nullable = false, length=50)
public String getName() { ... }
            </programlisting>

        <para>The <literal>name</literal> property is mapped to the
        <literal>flight_name</literal> column, which is not nullable, has a
        length of 50 and is not updatable (making the property
        immutable).</para>

        <para>This annotation can be applied to regular properties as well as
        <literal>@Id</literal> or <literal>@Version</literal>
        properties.</para>

        <programlistingco>
          <areaspec>
            <area coords="2" id="hm1" />

            <area coords="3" id="hm2" />

            <area coords="4" id="hm3" />

            <area coords="5" id="hm4" />

            <area coords="6" id="hm5" />

            <area coords="7" id="hm6" />

            <area coords="8" id="hm7" />

            <area coords="9" id="hm8" />

            <area coords="10" id="hm9" />

            <area coords="11" id="hm10" />
          </areaspec>

          <programlisting>@Column(
    name="columnName";
    boolean unique() default false;
    boolean nullable() default true;
    boolean insertable() default true;
    boolean updatable() default true;
    String columnDefinition() default "";
    String table() default "";
    int length() default 255;
    int precision() default 0; // decimal precision
    int scale() default 0; // decimal scale</programlisting>

          <calloutlist>
            <callout arearefs="hm1">
              <para><literal>name</literal> (optional): the column name
              (default to the property name)</para>
            </callout>

            <callout arearefs="hm2">
              <para><literal>unique</literal> (optional): set a unique
              constraint on this column or not (default false)</para>
            </callout>

            <callout arearefs="hm3">
              <para><literal>nullable</literal> (optional): set the column as
              nullable (default true).</para>
            </callout>

            <callout arearefs="hm4">
              <para><literal>insertable</literal> (optional): whether or not
              the column will be part of the insert statement (default
              true)</para>
            </callout>

            <callout arearefs="hm5">
              <para><literal>updatable</literal> (optional): whether or not
              the column will be part of the update statement (default
              true)</para>
            </callout>

            <callout arearefs="hm6">
              <para><literal>columnDefinition</literal> (optional): override
              the sql DDL fragment for this particular column (non
              portable)</para>
            </callout>

            <callout arearefs="hm7">
              <para><literal>table</literal> (optional): define the targeted
              table (default primary table)</para>
            </callout>

            <callout arearefs="hm8">
              <para><literal><literal>length</literal></literal> (optional):
              column length (default 255)</para>
            </callout>

            <callout arearefs="hm8">
              <para><literal><literal>precision</literal></literal>
              (optional): column decimal precision (default 0)</para>
            </callout>

            <callout arearefs="hm10">
              <para><literal><literal>scale</literal></literal> (optional):
              column decimal scale if useful (default 0)</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </section>

      <section>
        <title>Embedded objects (aka components)</title>

        <para>It is possible to declare an embedded component inside an entity
        and even override its column mapping. Component classes have to be
        annotated at the class level with the <literal>@Embeddable</literal>
        annotation. It is possible to override the column mapping of an
        embedded object for a particular entity using the
        <literal>@Embedded</literal> and <literal>@AttributeOverride</literal>
        annotation in the associated property:</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Person implements Serializable {

    // Persistent component using defaults
    Address homeAddress;

    @Embedded
    @AttributeOverrides( {
            @AttributeOverride(name="iso2", column = @Column(name="bornIso2") ),
            @AttributeOverride(name="name", column = @Column(name="bornCountryName") )
    } )
    Country bornIn;
    ...
}          </programlisting>

        <programlisting language="JAVA" role="JAVA">@Embeddable
public class Address implements Serializable {
    String city;
    Country nationality; //no overriding here
}            </programlisting>

        <programlisting language="JAVA" role="JAVA">@Embeddable
public class Country implements Serializable {
    private String iso2;
    @Column(name="countryName") private String name;

    public String getIso2() { return iso2; }
    public void setIso2(String iso2) { this.iso2 = iso2; }

    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    ...
}            </programlisting>

        <para>An embeddable object inherits the access type of its owning
        entity (note that you can override that using the
        <literal>@Access</literal> annotation).</para>

        <para>The <literal>Person</literal> entity has two component
        properties, <literal>homeAddress</literal> and
        <literal>bornIn</literal>. <literal>homeAddress</literal> property has
        not been annotated, but Hibernate will guess that it is a persistent
        component by looking for the <literal>@Embeddable</literal> annotation
        in the Address class. We also override the mapping of a column name
        (to <literal>bornCountryName</literal>) with the
        <literal>@Embedded</literal> and <literal>@AttributeOverride
        </literal>annotations for each mapped attribute of
        <literal>Country</literal>. As you can see, <literal>Country
        </literal>is also a nested component of <literal>Address</literal>,
        again using auto-detection by Hibernate and JPA defaults. Overriding
        columns of embedded objects of embedded objects is through dotted
        expressions.</para>

        <programlisting language="JAVA" role="JAVA">    @Embedded
    @AttributeOverrides( {
            @AttributeOverride(name="city", column = @Column(name="fld_city") ),
            @AttributeOverride(name="nationality.iso2", column = @Column(name="nat_Iso2") ),
            @AttributeOverride(name="nationality.name", column = @Column(name="nat_CountryName") )
            //nationality columns in homeAddress are overridden
    } )
    Address homeAddress;</programlisting>

        <para>Hibernate Annotations supports something that is not explicitly
        supported by the JPA specification. You can annotate a embedded object
        with the <literal>@MappedSuperclass</literal> annotation to make the
        superclass properties persistent (see
        <literal>@MappedSuperclass</literal> for more informations).</para>

        <para>You can also use association annotations in an embeddable object
        (ie <literal>@OneToOne</literal>, <classname>@ManyToOne</classname>,
        <classname>@OneToMany</classname> or <literal>@ManyToMany</literal>).
        To override the association columns you can use
        <literal>@AssociationOverride</literal>.</para>

        <para>If you want to have the same embeddable object type twice in the
        same entity, the column name defaulting will not work as several
        embedded objects would share the same set of columns. In plain JPA,
        you need to override at least one set of columns. Hibernate, however,
        allows you to enhance the default naming mechanism through the
        <classname>NamingStrategy</classname> interface. You can write a
        strategy that prevent name clashing in such a situation.
        <classname>DefaultComponentSafeNamingStrategy</classname> is an
        example of this.</para>
      </section>

      <section>
        <title>Non-annotated property defaults</title>

        <para>If a property is not annotated, the following rules
        apply:<itemizedlist>
            <listitem>
              <para>If the property is of a single type, it is mapped as
              @Basic</para>
            </listitem>

            <listitem>
              <para>Otherwise, if the type of the property is annotated as
              @Embeddable, it is mapped as @Embedded</para>
            </listitem>

            <listitem>
              <para>Otherwise, if the type of the property is
              <classname>Serializable</classname>, it is mapped as
              <classname>@Basic</classname> in a column holding the object in
              its serialized version</para>
            </listitem>

            <listitem>
              <para>Otherwise, if the type of the property is
              <classname>java.sql.Clob</classname> or
              <classname>java.sql.Blob</classname>, it is mapped as
              <classname>@Lob</classname> with the appropriate
              <classname>LobType</classname></para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>

    <section id="entity-mapping-identifier">
      <title>Mapping identifier properties</title>

      <para>The <literal>@Id</literal> annotation lets you define which
      property is the identifier of your entity. This property can be set by
      the application itself or be generated by Hibernate (preferred). You can
      define the identifier generation strategy thanks to the
      <literal>@GeneratedValue</literal> annotation.</para>

      <section>
        <title>Generating the identifier property</title>

        <para>JPA defines five types of identifier generation
        strategies:</para>

        <itemizedlist>
          <listitem>
            <para>AUTO - either identity column, sequence or table depending
            on the underlying DB</para>
          </listitem>

          <listitem>
            <para>TABLE - table holding the id</para>
          </listitem>

          <listitem>
            <para>IDENTITY - identity column</para>
          </listitem>

          <listitem>
            <para>SEQUENCE - sequence</para>
          </listitem>

          <listitem>
            <para>identity copy - the identity is copied from another
            entity</para>
          </listitem>
        </itemizedlist>

        <para>Hibernate provides more id generators than the basic JPA ones.
        Check <xref linkend="entity-hibspec" /> for more informations.</para>

        <para>The following example shows a sequence generator using the
        SEQ_STORE configuration (see below)</para>

        <programlisting language="JAVA" role="JAVA">@Id @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="SEQ_STORE")
public Integer getId() { ... }         </programlisting>

        <para>The next example uses the identity generator:</para>

        <programlisting language="JAVA" role="JAVA">@Id @GeneratedValue(strategy=GenerationType.IDENTITY)
public Long getId() { ... }         </programlisting>

        <para>The <literal>AUTO</literal> generator is the preferred type for
        portable applications (across several DB vendors). The identifier
        generation configuration can be shared for several
        <literal>@Id</literal> mappings with the generator attribute. There
        are several configurations available through
        <literal>@SequenceGenerator</literal> and
        <literal>@TableGenerator</literal>. The scope of a generator can be
        the application or the class. Class-defined generators are not visible
        outside the class and can override application level generators.
        Application level generators are defined at XML level (see <xref
        linkend="xml-overriding" />):</para>

        <programlisting language="JAVA" role="JAVA">&lt;table-generator name="EMP_GEN"
            table="GENERATOR_TABLE"
            pk-column-name="key"
            value-column-name="hi"
            pk-column-value="EMP"
            allocation-size="20"/&gt;

//and the annotation equivalent

@javax.persistence.TableGenerator(
    name="EMP_GEN",
    table="GENERATOR_TABLE",
    pkColumnName = "key",
    valueColumnName = "hi"
    pkColumnValue="EMP",
    allocationSize=20
)

&lt;sequence-generator name="SEQ_GEN" 
    sequence-name="my_sequence"
    allocation-size="20"/&gt;

//and the annotation equivalent

@javax.persistence.SequenceGenerator(
    name="SEQ_GEN",
    sequenceName="my_sequence",
    allocationSize=20
)
         </programlisting>

        <para>If JPA XML (like <filename>META-INF/orm.xml</filename>) is used
        to define the generators, <literal>EMP_GEN</literal> and
        <literal>SEQ_GEN</literal> are application level generators.
        <literal>EMP_GEN</literal> defines a table based id generator using
        the hilo algorithm with a <literal>max_lo</literal> of 20. The hi
        value is kept in a <literal>table</literal>
        "<literal>GENERATOR_TABLE</literal>". The information is kept in a row
        where <literal>pkColumnName</literal> "key" is equals to
        <literal>pkColumnValue</literal> "<literal>EMP</literal>" and column
        <literal>valueColumnName</literal> "<literal>hi</literal>" contains
        the the next high value used.</para>

        <para><literal>SEQ_GEN</literal> defines a sequence generator using a
        sequence named <literal>my_sequence</literal>. The allocation size
        used for this sequence based hilo algorithm is 20. Note that this
        version of Hibernate Annotations does not handle
        <literal>initialValue</literal> in the sequence generator. The default
        allocation size is 50, so if you want to use a sequence and pickup the
        value each time, you must set the allocation size to 1.</para>

        <important>
          <para>We recommend all new projects to use
          <code>hibernate.id.new_generator_mappings=true</code> as the new
          generators are more efficient and closer to the JPA 2 specification
          semantic. However they are not backward compatible with existing
          databases (if a sequence or a table is used for id generation). See
          <xref linkend="ann-setup-properties" /> for more information on how
          to activate them.</para>
        </important>

        <note>
          <para>Package level definition is not supported by the JPA
          specification. However, you can use the
          <literal>@GenericGenerator</literal> at the package level (see <xref
          linkend="entity-hibspec-identifier" />).</para>
        </note>

        <para>The next example shows the definition of a sequence generator in
        a class scope:</para>

        <programlisting language="JAVA" role="JAVA">@Entity
@javax.persistence.SequenceGenerator(
    name="SEQ_STORE",
    sequenceName="my_sequence"
)
public class Store implements Serializable {
    private Long id;

    @Id @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="SEQ_STORE")
    public Long getId() { return id; }
}         </programlisting>

        <para>This class will use a sequence named my_sequence and the
        SEQ_STORE generator is not visible in other classes. Note that you can
        check the Hibernate Annotations tests in the
        <package>org.hibernate.test.annotations.id</package> package for more
        examples.</para>

        <para>Finally, you can ask Hibernate to copy the identifier from
        another associated entity. In the Hibernate jargon, it is known as a
        foreign generator but the JPA mapping reads better and is
        encouraged.</para>

        <programlisting language="JAVA" role="JAVA">@Entity
class MedicalHistory implements Serializable {
  @Id @OneToOne
  @JoinColumn(name = "person_id")
  Person patient;
}

@Entity
public class Person implements Serializable {
  @Id @GeneratedValue Integer id;
}</programlisting>

        <para>Or alternatively</para>

        <programlisting language="JAVA" role="JAVA">@Entity
class MedicalHistory implements Serializable {
  @Id Integer id;

  @MapsId @OneToOne
  @JoinColumn(name = "patient_id")
  Person patient;
}

@Entity
class Person {
  @Id @GeneratedValue Integer id;
}</programlisting>

        <para>If you are interested in more examples of "derived identities",
        the JPA 2 specification has a great set of them in chapter
        2.4.1.3.</para>

        <para>But an identifier does not have to be a single property, it can
        be composed of several properties.</para>
      </section>

      <section>
        <title>Composite identifier</title>

        <para>You can define a composite primary key through several
        syntaxes:</para>

        <itemizedlist>
          <listitem>
            <para>use a component type to represent the identifier and map it
            as a property in the entity: you then annotated the property as
            <classname>@EmbeddedId</classname>. The component type has to be
            <classname>Serializable</classname>.</para>
          </listitem>

          <listitem>
            <para>map multiple properties as <classname>@Id</classname>
            properties: the identifier type is then the entity class itself
            and needs to be <classname>Serializable</classname>. This approach
            is unfortunately not standard and only supported by
            Hibernate.</para>
          </listitem>

          <listitem>
            <para>map multiple properties as <classname>@Id</classname>
            properties and declare an external class to be the identifier
            type. This class, which needs to be
            <classname>Serializable</classname>, is declared on the entity via
            the <classname>@IdClass</classname> annotation. The identifier
            type must contain the same properties as the identifier properties
            of the entity: each property name must be the same, its type must
            be the same as well if the entity property is of a basic type, its
            type must be the type of the primary key of the associated entity
            if the entity property is an association (either a
            <classname>@OneToOne</classname> or a
            <classname>@ManyToOne</classname>).</para>
          </listitem>
        </itemizedlist>

        <para>As you can see the last case is far from obvious. It has been
        inherited from the dark ages of EJB 2 for backward compatibilities and
        we recommend you not to use it (for simplicity sake).</para>

        <para>Let's explore all three cases using examples.</para>

        <section>
          <title>@EmbeddedId property</title>

          <para>Here is a simple example of
          <classname>@EmbeddedId</classname>.</para>

          <programlisting language="JAVA" role="JAVA">@Entity
class User {
  @EmbeddedId
  @AttributeOverride(name="firstName", column=@Column(name="fld_firstname")
  UserId id;

  Integer age;
}

@Embeddable
class UserId implements Serializable {
  String firstName;
  String lastName;
}</programlisting>

          <para>You can notice that the <classname>UserId</classname> class is
          serializable. To override the column mapping, use
          <classname>@AttributeOverride</classname>.</para>

          <para>An embedded id can itself contains the primary key of an
          associated entity.</para>

          <programlisting language="JAVA" role="JAVA">@Entity
class Customer {
  @EmbeddedId CustomerId id;
  boolean preferredCustomer;

  @MapsId("userId")
  @JoinColumns({
    @JoinColumn(name="userfirstname_fk", referencedColumnName="firstName"),
    @JoinColumn(name="userlastname_fk", referencedColumnName="lastName")
  })
  @OneToOne User user;
}

@Embeddable
class CustomerId implements Serializable {
  UserId userId;
  String customerNumber;
}

@Entity 
class User {
  @EmbeddedId UserId id;
  Integer age;
}

@Embeddable
class UserId implements Serializable {
  String firstName;
  String lastName;
}</programlisting>

          <para>In the embedded id object, the association is represented as
          the identifier of the associated entity. But you can link its value
          to a regular association in the entity via the
          <classname>@MapsId</classname> annotation. The
          <classname>@MapsId</classname> value correspond to the property name
          of the embedded id object containing the associated entity's
          identifier. In the database, it means that the
          <literal>Customer.user</literal> and the
          <literal>CustomerId.userId</literal> properties share the same
          underlying column (<literal>user_fk</literal> in this case).</para>

          <para>In practice, your code only sets the
          <literal>Customer.user</literal> property and the user id value is
          copied by Hibernate into the <literal>CustomerId.userId</literal>
          property.</para>

          <warning>
            <para>The id value can be copied as late as flush time, don't rely
            on it until after flush time.</para>
          </warning>

          <para>While not supported in JPA, Hibernate lets you place your
          association directly in the embedded id component (instead of having
          to use the <classname>@MapsId</classname> annotation).</para>

          <programlisting language="JAVA" role="JAVA">@Entity
class Customer {
  @EmbeddedId CustomerId id;
  boolean preferredCustomer;
}

@Embeddable
class CustomerId implements Serializable {
  @OneToOne
  @JoinColumns({
    @JoinColumn(name="userfirstname_fk", referencedColumnName="firstName"),
    @JoinColumn(name="userlastname_fk", referencedColumnName="lastName")
  }) 
  User user;
  String customerNumber;
}

@Entity 
class User {
  @EmbeddedId UserId id;
  Integer age;
}

@Embeddable
class UserId implements Serializable {
  String firstName;
  String lastName;
}</programlisting>
        </section>

        <section>
          <title>Multiple @Id properties</title>

          <para>Another, arguably more natural, approach is to place
          <classname>@Id</classname> on multiple properties of my entity. This
          approach is only supported by Hibernate but does not require an
          extra embeddable component.</para>

          <programlisting language="JAVA" role="JAVA">@Entity
class Customer implements Serializable {
  @Id @OneToOne
  @JoinColumns({
    @JoinColumn(name="userfirstname_fk", referencedColumnName="firstName"),
    @JoinColumn(name="userlastname_fk", referencedColumnName="lastName")
  })
  User user;
  
  @Id String customerNumber;

  boolean preferredCustomer;
}

@Entity 
class User {
  @EmbeddedId UserId id;
  Integer age;
}

@Embeddable
class UserId implements Serializable {
  String firstName;
  String lastName;
}</programlisting>

          <para>In this case <classname>Customer</classname> being it's own
          identifier representation, it must implement
          <classname>Serializable</classname>.</para>
        </section>

        <section>
          <title>@IdClass</title>

          <para><classname>@IdClass</classname> on an entity points to the
          class (component) representing the identifier of the class. The
          properties marked <classname>@Id</classname> on the entity must have
          their corresponding property on the <classname>@IdClass</classname>.
          The return type of search twin property must be either identical for
          basic properties or must correspond to the identifier class of the
          associated entity for an association.</para>

          <warning>
            <para>This approach is inherited from the EJB 2 days and we
            recommend against its use. But, after all it's your application
            and Hibernate supports it.</para>
          </warning>

          <programlisting language="JAVA" role="JAVA">@Entity
class Customer {
  @Id @OneToOne
  @JoinColumns({
    @JoinColumn(name="userfirstname_fk", referencedColumnName="firstName"),
    @JoinColumn(name="userlastname_fk", referencedColumnName="lastName")
  }) 
  User user;
  
  @Id String customerNumber;

  boolean preferredCustomer;
}

class CustomerId implements Serializable {
  UserId user;
  String customerNumber;
}

@Entity 
class User {
  @EmbeddedId UserId id;
  Integer age;
}

@Embeddable
class UserId implements Serializable {
  String firstName;
  String lastName;
}</programlisting>

          <para><classname>Customer</classname> and
          <classname>CustomerId</classname> do have the same properties
          <literal>customerNumber</literal> as well as
          <literal>user</literal>.</para>

          <para>While not JPA standard, Hibernate let's you declare the
          vanilla associated property in the
          <classname>@IdClass</classname>.</para>

          <programlisting language="JAVA" role="JAVA">@Entity
class Customer {
  @Id @OneToOne
  @JoinColumns({
    @JoinColumn(name="userfirstname_fk", referencedColumnName="firstName"),
    @JoinColumn(name="userlastname_fk", referencedColumnName="lastName")
  }) 
  User user;
  
  @Id String customerNumber;

  boolean preferredCustomer;
}

class CustomerId implements Serializable {
  @OneToOne User user;
  String customerNumber;
}

@Entity 
class User {
  @EmbeddedId UserId id;
  Integer age;
}

@Embeddable
class UserId implements Serializable {
  String firstName;
  String lastName;
}</programlisting>
        </section>

        <section>
          <title>Partial identifier generation</title>

          <para>Hibernate supports the automatic generation of some of the
          identifier properties. Simply use the
          <classname>@GeneratedValue</classname> annotation on one or several
          id properties.</para>

          <warning>
            <para>The Hibernate team has always felt such a construct as
            fundamentally wrong. Try hard to fix your data model before using
            this feature.</para>
          </warning>

          <programlisting language="JAVA" role="JAVA">@Entity
public class CustomerInventory implements Serializable {
  @Id
  @TableGenerator(name = "inventory",
    table = "U_SEQUENCES",
    pkColumnName = "S_ID",
    valueColumnName = "S_NEXTNUM",
    pkColumnValue = "inventory",
    allocationSize = 1000)
  @GeneratedValue(strategy = GenerationType.TABLE, generator = "inventory")
  Integer id;


  @Id @ManyToOne(cascade = CascadeType.MERGE)
  Customer customer;
}

@Entity
public class Customer implements Serializable {
   @Id
   private int id;
}</programlisting>

          <para>You can also generate properties inside an
          <classname>@EmbeddedId</classname> class.</para>
        </section>
      </section>
    </section>

    <section>
      <title>Mapping inheritance</title>

      <para>EJB3 supports the three types of inheritance:</para>

      <itemizedlist>
        <listitem>
          <para>Table per Class Strategy: the &lt;union-class&gt; element in
          Hibernate</para>
        </listitem>

        <listitem>
          <para>Single Table per Class Hierarchy Strategy: the
          &lt;subclass&gt; element in Hibernate</para>
        </listitem>

        <listitem>
          <para>Joined Subclass Strategy: the &lt;joined-subclass&gt; element
          in Hibernate</para>
        </listitem>
      </itemizedlist>

      <para>The chosen strategy is declared at the class level of the top
      level entity in the hierarchy using the <literal>@Inheritance</literal>
      annotation.</para>

      <note>
        <para>Annotating interfaces is currently not supported.</para>
      </note>

      <section>
        <title>Table per class</title>

        <para>This strategy has many drawbacks (esp. with polymorphic queries
        and associations) explained in the JPA spec, the Hibernate reference
        documentation, Hibernate in Action, and many other places. Hibernate
        work around most of them implementing this strategy using <literal>SQL
        UNION</literal> queries. It is commonly used for the top level of an
        inheritance hierarchy:</para>

        <programlisting language="JAVA" role="JAVA">@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public class Flight implements Serializable { ... }            </programlisting>

        <para>This strategy supports one-to-many associations provided that
        they are bidirectional. This strategy does not support the
        <literal>IDENTITY</literal> generator strategy: the id has to be
        shared across several tables. Consequently, when using this strategy,
        you should not use <literal>AUTO </literal>nor
        <literal>IDENTITY</literal>.</para>
      </section>

      <section>
        <title>Single table per class hierarchy</title>

        <para>All properties of all super- and subclasses are mapped into the
        same table, instances are distinguished by a special discriminator
        column:</para>

        <programlisting language="JAVA" role="JAVA">@Entity
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(
    name="planetype",
    discriminatorType=DiscriminatorType.STRING
)
@DiscriminatorValue("Plane")
public class Plane { ... }

@Entity
@DiscriminatorValue("A320")
public class A320 extends Plane { ... }          </programlisting>

        <para><classname>Plane</classname> is the superclass, it defines the
        inheritance strategy <literal>InheritanceType.SINGLE_TABLE</literal>.
        It also defines the discriminator column through the
        <literal>@DiscriminatorColumn</literal> annotation, a discriminator
        column can also define the discriminator type. Finally, the
        <literal>@DiscriminatorValue</literal> annotation defines the value
        used to differentiate a class in the hierarchy. All of these
        attributes have sensible default values. The default name of the
        discriminator column is <literal>DTYPE</literal>. The default
        discriminator value is the entity name (as defined in
        <literal>@Entity.name</literal>) for DiscriminatorType.STRING.
        <classname>A320</classname> is a subclass; you only have to define
        discriminator value if you don't want to use the default value. The
        strategy and the discriminator type are implicit.</para>

        <para><literal>@Inheritance</literal> and
        <literal>@DiscriminatorColumn</literal> should only be defined at the
        top of the entity hierarchy.</para>
      </section>

      <section>
        <title>Joined subclasses</title>

        <para>The<literal> @PrimaryKeyJoinColumn</literal> and
        <literal>@PrimaryKeyJoinColumns</literal> annotations define the
        primary key(s) of the joined subclass table:</para>

        <programlisting language="JAVA" role="JAVA">@Entity
@Inheritance(strategy=InheritanceType.JOINED)
public class Boat implements Serializable { ... }

@Entity
public class Ferry extends Boat { ... }

@Entity
@PrimaryKeyJoinColumn(name="BOAT_ID")
public class AmericaCupClass  extends Boat { ... }            </programlisting>

        <para>All of the above entities use the <literal>JOINED</literal>
        strategy, the <literal>Ferry</literal> table is joined with the
        <literal>Boat</literal> table using the same primary key names. The
        <literal>AmericaCupClass</literal> table is joined with
        <literal>Boat</literal> using the join condition <code>Boat.id =
        AmericaCupClass.BOAT_ID</code>.</para>
      </section>

      <section>
        <title>Inherit properties from superclasses</title>

        <para>This is sometimes useful to share common properties through a
        technical or a business superclass without including it as a regular
        mapped entity (ie no specific table for this entity). For that purpose
        you can map them as <literal>@MappedSuperclass</literal>.</para>

        <programlisting language="JAVA" role="JAVA">@MappedSuperclass
public class BaseEntity {
    @Basic
    @Temporal(TemporalType.TIMESTAMP)
    public Date getLastUpdate() { ... }
    public String getLastUpdater() { ... }
    ...
}

@Entity class Order extends BaseEntity {
    @Id public Integer getId() { ... }
    ...
}</programlisting>

        <para>In database, this hierarchy will be represented as an
        <literal>Order</literal> table having the <literal>id</literal>,
        <literal>lastUpdate</literal> and <literal>lastUpdater</literal>
        columns. The embedded superclass property mappings are copied into
        their entity subclasses. Remember that the embeddable superclass is
        not the root of the hierarchy though.</para>

        <note>
          <para>Properties from superclasses not mapped as
          <literal>@MappedSuperclass</literal> are ignored.</para>
        </note>

        <note>
          <para>The default access type (field or methods) is used, unless you
          use the <literal>@Access</literal> annotation.</para>
        </note>

        <note>
          <para>The same notion can be applied to
          <literal>@Embeddable</literal> objects to persist properties from
          their superclasses. You also need to use
          <literal>@MappedSuperclass</literal> to do that (this should not be
          considered as a standard EJB3 feature though)</para>
        </note>

        <note>
          <para>It is allowed to mark a class as
          <literal>@MappedSuperclass</literal> in the middle of the mapped
          inheritance hierarchy.</para>
        </note>

        <note>
          <para>Any class in the hierarchy non annotated with
          <literal>@MappedSuperclass</literal> nor <literal>@Entity</literal>
          will be ignored.</para>
        </note>

        <para>You can override columns defined in entity superclasses at the
        root entity level using the <literal>@AttributeOverride</literal>
        annotation.</para>

        <programlisting language="JAVA" role="JAVA">@MappedSuperclass
public class FlyingObject implements Serializable {

    public int getAltitude() {
        return altitude;
    }

    @Transient
    public int getMetricAltitude() {
        return metricAltitude;
    }

    @ManyToOne
    public PropulsionType getPropulsion() {
        return metricAltitude;
    }
    ...
}

@Entity
@AttributeOverride( name="altitude", column = @Column(name="fld_altitude") )
@AssociationOverride( 
   name="propulsion", 
   joinColumns = @JoinColumn(name="fld_propulsion_fk") 
)
public class Plane extends FlyingObject {
    ...
}</programlisting>

        <para>The <literal>altitude</literal> property will be persisted in an
        <literal>fld_altitude</literal> column of table
        <literal>Plane</literal> and the propulsion association will be
        materialized in a <literal>fld_propulsion_fk</literal> foreign key
        column.</para>

        <para>You can define <literal>@AttributeOverride</literal>(s) and
        <literal>@AssociationOverride</literal>(s) on
        <literal>@Entity</literal> classes,
        <literal>@MappedSuperclass</literal> classes and properties pointing
        to an <literal>@Embeddable</literal> object.</para>
      </section>
    </section>

    <section id="entity-mapping-association">
      <title>Mapping entity associations/relationships</title>

      <section>
        <title>One-to-one</title>

        <para>You can associate entities through a one-to-one relationship
        using <literal>@OneToOne</literal>. There are three cases for
        one-to-one associations: either the associated entities share the same
        primary keys values, a foreign key is held by one of the entities
        (note that this FK column in the database should be constrained unique
        to simulate one-to-one multiplicity), or a association table is used
        to store the link between the 2 entities (a unique constraint has to
        be defined on each fk to ensure the one to one multiplicity).</para>

        <para>First, we map a real one-to-one association using shared primary
        keys:</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Body {
    @Id
    public Long getId() { return id; }

    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    public Heart getHeart() {
        return heart;
    }
    ...
}            </programlisting>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Heart {
    @Id
    public Long getId() { ...}
}            </programlisting>

        <para>The <literal>@PrimaryKeyJoinColumn</literal> annotation does say
        that the primary key of the entity is used as the foreign key value to
        the associated entity.</para>

        <para>In the following example, the associated entities are linked
        through an explicit foreign key column:</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Customer implements Serializable {
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name="passport_fk")
    public Passport getPassport() {
        ...
    }

@Entity
public class Passport implements Serializable {
    @OneToOne(mappedBy = "passport")
    public Customer getOwner() {
    ...
}            </programlisting>

        <para>A <classname>Customer</classname> is linked to a
        <classname>Passport</classname>, with a foreign key column named
        <literal>passport_fk</literal> in the <literal>Customer</literal>
        table. The join column is declared with the
        <literal>@JoinColumn</literal> annotation which looks like the
        <literal>@Column</literal> annotation. It has one more parameters
        named <literal>referencedColumnName</literal>. This parameter declares
        the column in the targeted entity that will be used to the join. Note
        that when using
        <literal><literal>referencedColumnName</literal></literal> to a non
        primary key column, the associated class has to be
        <classname>Serializable</classname>. Also note that the
        <literal><literal>referencedColumnName</literal></literal> to a non
        primary key column has to be mapped to a property having a single
        column (other cases might not work).</para>

        <para>The association may be bidirectional. In a bidirectional
        relationship, one of the sides (and only one) has to be the owner: the
        owner is responsible for the association column(s) update. To declare
        a side as <emphasis>not</emphasis> responsible for the relationship,
        the attribute <literal>mappedBy</literal> is used.
        <literal>mappedBy</literal> refers to the property name of the
        association on the owner side. In our case, this is
        <literal>passport</literal>. As you can see, you don't have to (must
        not) declare the join column since it has already been declared on the
        owners side.</para>

        <para>If no <literal>@JoinColumn</literal> is declared on the owner
        side, the defaults apply. A join column(s) will be created in the
        owner table and its name will be the concatenation of the name of the
        relationship in the owner side, <keycap>_</keycap> (underscore), and
        the name of the primary key column(s) in the owned side. In this
        example <literal>passport_id</literal> because the property name is
        <literal>passport</literal> and the column id of <literal>Passport
        </literal>is <literal>id</literal>.</para>

        <para>The third possibility (using an association table) is quite
        exotic.</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Customer implements Serializable {
    @OneToOne(cascade = CascadeType.ALL)
    @JoinTable(name = "CustomerPassports",
        joinColumns = @JoinColumn(name="customer_fk"),
        inverseJoinColumns = @JoinColumn(name="passport_fk")
    )
    public Passport getPassport() {
        ...
    }

@Entity
public class Passport implements Serializable {
    @OneToOne(mappedBy = "passport")
    public Customer getOwner() {
    ...
}          </programlisting>

        <para>A <classname>Customer</classname> is linked to a
        <classname>Passport</classname> through a association table named
        <literal>CustomerPassports</literal> ; this association table has a
        foreign key column named <literal>passport_fk</literal> pointing to
        the <literal>Passport</literal> table (materialized by the
        <literal>inverseJoinColumn</literal>, and a foreign key column named
        <literal>customer_fk</literal> pointing to the
        <literal>Customer</literal> table materialized by the
        <literal>joinColumns</literal> attribute.</para>

        <para>You must declare the join table name and the join columns
        explicitly in such a mapping.</para>
      </section>

      <section>
        <title>Many-to-one</title>

        <para>Many-to-one associations are declared at the property level with
        the annotation <literal>@ManyToOne</literal>:</para>

        <programlisting language="JAVA" role="JAVA">@Entity()
public class Flight implements Serializable {
    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )
    @JoinColumn(name="COMP_ID")
    public Company getCompany() {
        return company;
    }
    ...
}            </programlisting>

        <para>The <literal>@JoinColumn</literal> attribute is optional, the
        default value(s) is like in one to one, the concatenation of the name
        of the relationship in the owner side, <keycap>_</keycap>
        (underscore), and the name of the primary key column in the owned
        side. In this example <literal>company_id</literal> because the
        property name is <literal>company</literal> and the column id of
        Company is <literal>id</literal>.</para>

        <para><literal>@ManyToOne</literal> has a parameter named
        <literal>targetEntity</literal> which describes the target entity
        name. You usually don't need this parameter since the default value
        (the type of the property that stores the association) is good in
        almost all cases. However this is useful when you want to use
        interfaces as the return type instead of the regular entity.</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Flight implements Serializable {
    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE}, targetEntity=CompanyImpl.class )
    @JoinColumn(name="COMP_ID")
    public Company getCompany() {
        return company;
    }
    ...
}

public interface Company {
    ...
}</programlisting>

        <para>You can also map a many-to-one association through an
        association table. This association table described by the
        <literal>@JoinTable</literal> annotation will contains a foreign key
        referencing back the entity table (through
        <literal>@JoinTable.joinColumns</literal>) and a a foreign key
        referencing the target entity table (through
        <literal>@JoinTable.inverseJoinColumns</literal>).</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Flight implements Serializable {
    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )
    @JoinTable(name="Flight_Company",
        joinColumns = @JoinColumn(name="FLIGHT_ID"),
        inverseJoinColumns = @JoinColumn(name="COMP_ID")
    )
    public Company getCompany() {
        return company;
    }
    ...
}       </programlisting>
      </section>

      <section id="entity-mapping-association-collections">
        <title>Collections</title>

        <para>You can map <classname>Collection</classname>,
        <classname>List</classname>, <classname>Map</classname> and
        <classname>Set</classname> pointing to associated entities as
        one-to-many or many-to-many associations using the
        <classname>@OneToMany</classname> or
        <classname>@ManyToMany</classname> annotation respectively. If the
        collection is of a basic type or of an embeddable type, use
        <classname>@ElementCollection</classname>. We will describe that in
        more detail in the following subsections.</para>

        <section id="entity-mapping-association-collection-onetomany">
          <title>One-to-many</title>

          <para>One-to-many associations are declared at the property level
          with the annotation <literal>@OneToMany</literal>. One to many
          associations may be bidirectional.</para>

          <section>
            <title>Bidirectional</title>

            <para>Since many to one are (almost) always the owner side of a
            bidirectional relationship in the JPA spec, the one to many
            association is annotated by
            <literal>@OneToMany(mappedBy=...)</literal></para>

            <programlisting language="JAVA" role="JAVA">@Entity
public class Troop {
    @OneToMany(mappedBy="troop")
    public Set&lt;Soldier&gt; getSoldiers() {
    ...
}

@Entity
public class Soldier {
    @ManyToOne
    @JoinColumn(name="troop_fk")
    public Troop getTroop() {
    ...
}              </programlisting>

            <para><classname>Troop</classname> has a bidirectional one to many
            relationship with <literal>Soldier</literal> through the
            <literal>troop</literal> property. You don't have to (must not)
            define any physical mapping in the <literal>mappedBy</literal>
            side.</para>

            <para>To map a bidirectional one to many, with the one-to-many
            side as the owning side, you have to remove the
            <literal>mappedBy</literal> element and set the many to one
            <literal>@JoinColumn</literal> as insertable and updatable to
            false. This solution is not optimized and will produce some
            additional UPDATE statements.</para>

            <programlisting language="JAVA" role="JAVA">@Entity
public class Troop {
    @OneToMany
    @JoinColumn(name="troop_fk") //we need to duplicate the physical information
    public Set&lt;Soldier&gt; getSoldiers() {
    ...
}

@Entity
public class Soldier {
    @ManyToOne
    @JoinColumn(name="troop_fk", insertable=false, updatable=false)
    public Troop getTroop() {
    ...
}</programlisting>
          </section>

          <section>
            <title>Unidirectional</title>

            <para>A unidirectional one to many using a foreign key column in
            the owned entity is not that common and not really recommended. We
            strongly advise you to use a join table for this kind of
            association (as explained in the next section). This kind of
            association is described through a
            <literal>@JoinColumn</literal></para>

            <programlisting language="JAVA" role="JAVA">@Entity
public class Customer implements Serializable {
    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @JoinColumn(name="CUST_ID")
    public Set&lt;Ticket&gt; getTickets() {
    ...
}

@Entity
public class Ticket implements Serializable {
    ... //no bidir
}              </programlisting>

            <para><literal>Customer</literal> describes a unidirectional
            relationship with <literal>Ticket</literal> using the join column
            <literal>CUST_ID</literal>.</para>
          </section>

          <section>
            <title>Unidirectional with join table</title>

            <para>A unidirectional one to many with join table is much
            preferred. This association is described through an
            <literal>@JoinTable</literal>.</para>

            <programlisting language="JAVA" role="JAVA">@Entity
public class Trainer {
    @OneToMany
    @JoinTable(
            name="TrainedMonkeys",
            joinColumns = @JoinColumn( name="trainer_id"),
            inverseJoinColumns = @JoinColumn( name="monkey_id")
    )
    public Set&lt;Monkey&gt; getTrainedMonkeys() {
    ...
}

@Entity
public class Monkey {
    ... //no bidir
}         </programlisting>

            <para><literal>Trainer</literal> describes a unidirectional
            relationship with <classname>Monkey</classname> using the join
            table <classname>TrainedMonkeys</classname>, with a foreign key
            <literal>trainer_id</literal> to <literal>Trainer</literal>
            (<literal>joinColumns</literal>) and a foreign key
            <literal>monkey_id</literal> to <literal>Monkey</literal>
            (<literal>inversejoinColumns</literal>).</para>
          </section>

          <section id="entity-mapping-association-collection-manytomany-default">
            <title>Defaults</title>

            <para>Without describing any physical mapping, a unidirectional
            one to many with join table is used. The table name is the
            concatenation of the owner table name, <keycap>_</keycap>, and the
            other side table name. The foreign key name(s) referencing the
            owner table is the concatenation of the owner table,
            <keycap>_</keycap>, and the owner primary key column(s) name. The
            foreign key name(s) referencing the other side is the
            concatenation of the owner property name, <keycap>_</keycap>, and
            the other side primary key column(s) name. A unique constraint is
            added to the foreign key referencing the other side table to
            reflect the one to many.</para>

            <programlisting language="JAVA" role="JAVA">@Entity
public class Trainer {
    @OneToMany
    public Set&lt;Tiger&gt; getTrainedTigers() {
    ...
}

@Entity
public class Tiger {
    ... //no bidir
}               </programlisting>

            <para><classname>Trainer</classname> describes a unidirectional
            relationship with <classname>Tiger</classname> using the join
            table <literal>Trainer_Tiger</literal>, with a foreign key
            <literal>trainer_id</literal> to <literal>Trainer</literal> (table
            name, <keycap>_</keycap>, trainer id) and a foreign key
            <literal>trainedTigers_id</literal> to <literal>Monkey</literal>
            (property name, <keycap>_</keycap>, Tiger primary column).</para>
          </section>
        </section>

        <section id="eentity-mapping-association-collection-manytomany">
          <title>Many-to-many</title>

          <section>
            <title>Definition</title>

            <para>A many-to-many association is defined logically using the
            <literal>@ManyToMany</literal> annotation. You also have to
            describe the association table and the join conditions using the
            <literal>@JoinTable</literal> annotation. If the association is
            bidirectional, one side has to be the owner and one side has to be
            the inverse end (ie. it will be ignored when updating the
            relationship values in the association table):</para>

            <programlisting language="JAVA" role="JAVA">@Entity
public class Employer implements Serializable {
    @ManyToMany(
        targetEntity=org.hibernate.test.metadata.manytomany.Employee.class,
        cascade={CascadeType.PERSIST, CascadeType.MERGE}
    )
    @JoinTable(
        name="EMPLOYER_EMPLOYEE",
        joinColumns=@JoinColumn(name="EMPER_ID"),
        inverseJoinColumns=@JoinColumn(name="EMPEE_ID")
    )
    public Collection getEmployees() {
        return employees;
    }
    ...
}               </programlisting>

            <programlisting language="JAVA" role="JAVA">@Entity
public class Employee implements Serializable {
    @ManyToMany(
        cascade = {CascadeType.PERSIST, CascadeType.MERGE},
        mappedBy = "employees",
        targetEntity = Employer.class
    )
    public Collection getEmployers() {
        return employers;
    }
}               </programlisting>

            <para>We've already shown the many declarations and the detailed
            attributes for associations. We'll go deeper in the
            <literal>@JoinTable</literal> description, it defines a
            <literal>name</literal>, an array of join columns (an array in
            annotation is defined using { A, B, C }), and an array of inverse
            join columns. The latter ones are the columns of the association
            table which refer to the <classname>Employee</classname> primary
            key (the "other side").</para>

            <para>As seen previously, the other side don't have to (must not)
            describe the physical mapping: a simple
            <literal>mappedBy</literal> argument containing the owner side
            property name bind the two.</para>
          </section>

          <section>
            <title>Default values</title>

            <para>As any other annotations, most values are guessed in a many
            to many relationship. Without describing any physical mapping in a
            unidirectional many to many the following rules applied. The table
            name is the concatenation of the owner table name,
            <keycap>_</keycap> and the other side table name. The foreign key
            name(s) referencing the owner table is the concatenation of the
            owner table name, <keycap>_</keycap> and the owner primary key
            column(s). The foreign key name(s) referencing the other side is
            the concatenation of the owner property name, <keycap>_</keycap>,
            and the other side primary key column(s). These are the same rules
            used for a unidirectional one to many relationship.</para>

            <programlisting language="JAVA" role="JAVA">
@Entity
public class Store {
    @ManyToMany(cascade = CascadeType.PERSIST)
    public Set&lt;City&gt; getImplantedIn() {
        ...
    }
}

@Entity
public class City {
    ... //no bidirectional relationship
}
               </programlisting>

            <para>A <literal>Store_City</literal> is used as the join table.
            The <literal>Store_id</literal> column is a foreign key to the
            <literal>Store</literal> table. The
            <literal>implantedIn_id</literal> column is a foreign key to the
            <literal>City</literal> table.</para>

            <para>Without describing any physical mapping in a bidirectional
            many to many the following rules applied. The table name is the
            concatenation of the owner table name, <keycap>_</keycap> and the
            other side table name. The foreign key name(s) referencing the
            owner table is the concatenation of the other side property name,
            <keycap>_</keycap>, and the owner primary key column(s). The
            foreign key name(s) referencing the other side is the
            concatenation of the owner property name, <keycap>_</keycap>, and
            the other side primary key column(s). These are the same rules
            used for a unidirectional one to many relationship.</para>

            <programlisting language="JAVA" role="JAVA">@Entity
public class Store {
    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    public Set&lt;Customer&gt; getCustomers() {
        ...
    }
}

@Entity
public class Customer {
    @ManyToMany(mappedBy="customers")
    public Set&lt;Store&gt; getStores() {
        ...
    }
}               </programlisting>

            <para>A <literal>Store_Customer</literal> is used as the join
            table. The <literal>stores_id</literal> column is a foreign key to
            the <literal>Store</literal> table. The
            <literal>customers_id</literal> column is a foreign key to the
            <literal>Customer</literal> table.</para>
          </section>
        </section>

        <section>
          <title>Collection of basic types or embeddable objects</title>

          <para>In some simple situation, do don't need to associate two
          entities but simply create a collection of basic types or embeddable
          objects. Use the <classname>@ElementCollection</classname> in this
          case.</para>

          <programlisting language="JAVA" role="JAVA">@Entity
public class User {
   [...]
   public String getLastname() { ...}

   @ElementCollection
   @CollectionTable(name="Nicknames", joinColumns=@JoinColumn(name="user_id"))
   @Column(name="nickname")
   public Set&lt;String&gt; getNicknames() { ... } 
}</programlisting>

          <para>The collection table holding the collection data is set using
          the <classname>@CollectionTable</classname> annotation. If omitted
          the collection table name default to the concatenation of the name
          of the containing entity and the name of the collection attribute,
          separated by an underscore: in our example, it would be
          <literal>User_nicknames</literal>.</para>

          <para>The column holding the basic type is set using the
          <classname>@Column</classname> annotation. If omitted, the column
          name defaults to the property name: in our example, it would be
          <literal>nicknames</literal>.</para>

          <para>But you are not limited to basic types, the collection type
          can be any embeddable object. To override the columns of the
          embeddable object in the collection table, use the
          <classname>@AttributeOverride</classname> annotation.</para>

          <programlisting language="JAVA" role="JAVA">@Entity
public class User {
   [...]
   public String getLastname() { ...}

   @ElementCollection
   @CollectionTable(name="Addresses", joinColumns=@JoinColumn(name="user_id"))
   @AttributeOverrides({
      @AttributeOverride(name="street1", column=@Column(name="fld_street"))
   })
   public Set&lt;Address&gt; getAddresses() { ... } 
}

@Embeddable
public class Address {
   public String getStreet1() {...}
   [...]
}</programlisting>

          <para>Such an embeddable object cannot contains a collection
          itself.</para>

          <note>
            <para>in <classname>@AttributeOverride</classname>, you must use
            the <literal>value.</literal> prefix to override properties of the
            embeddable object used in the map value and the
            <literal>key.</literal> prefix to override properties of the
            embeddable object used in the map key.</para>

            <programlisting language="JAVA" role="JAVA">@Entity
public class User {
   @ElementCollection
   @AttributeOverrides({
      @AttributeOverride(name="key.street1", column=@Column(name="fld_street")),
      @AttributeOverride(name="value.stars", column=@Column(name="fld_note"))
   })
   public Map&lt;Address,Rating&gt; getFavHomes() { ... } </programlisting>
          </note>

          <note>
            <para>We recommend you to migrate from
            <classname>@org.hibernate.annotations.CollectionOfElements</classname>
            to the new <classname>@ElementCollection</classname>
            annotation.</para>
          </note>
        </section>

        <section id="entity-mapping-association-collections-overview">
          <title>Indexed collections (List, Map)</title>

          <para>Lists can be mapped in two different ways:</para>

          <itemizedlist>
            <listitem>
              <para>as ordered lists, the order is not materialized in the
              database</para>
            </listitem>

            <listitem>
              <para>as indexed lists, the order is materialized in the
              database</para>
            </listitem>
          </itemizedlist>

          <para>To order lists in memory, add
          <literal>@javax.persistence.OrderBy</literal> to your property. This
          annotation takes into parameter a list of comma separated properties
          (of the target entity) and order the collection accordingly (eg
          <code>firstname asc, age desc</code>), if the string is empty, the
          collection will be ordered by the primary key of the target
          entity.</para>

          <programlisting language="JAVA" role="JAVA">@Entity
public class Customer {
   @Id @GeneratedValue public Integer getId() { return id; }
   public void setId(Integer id) { this.id = id; }
   private Integer id;

   @OneToMany(mappedBy="customer")
   @OrderBy("number")
   public List&lt;Order&gt; getOrders() { return orders; }
   public void setOrders(List&lt;Order&gt; orders) { this.orders = orders; }
   private List&lt;Order&gt; orders;
}

@Entity
public class Order {
   @Id @GeneratedValue public Integer getId() { return id; }
   public void setId(Integer id) { this.id = id; }
   private Integer id;

   public String getNumber() { return number; }
   public void setNumber(String number) { this.number = number; }
   private String number;

   @ManyToOne
   public Customer getCustomer() { return customer; }
   public void setCustomer(Customer customer) { this.customer = customer; }
   private Customer number;
}

-- Table schema
|-------------| |----------|
| Order       | | Customer |
|-------------| |----------|
| id          | | id       |
| number      | |----------| 
| customer_id |
|-------------|</programlisting>

          <para>To store the index value in a dedicated column, use the
          <classname>@javax.persistence.OrderColumn</classname> annotation on
          your property. This annotations describes the column name and
          attributes of the column keeping the index value. This column is
          hosted on the table containing the association foreign key. If the
          column name is not specified, the default is the name of the
          referencing property, followed by underscore, followed by
          <literal>ORDER</literal> (in the following example, it would be
          <literal>orders_ORDER</literal>).</para>

          <programlisting language="JAVA" role="JAVA">@Entity
public class Customer {
   @Id @GeneratedValue public Integer getId() { return id; }
   public void setId(Integer id) { this.id = id; }
   private Integer id;

   @OneToMany(mappedBy="customer")
   @OrderColumn(name"orders_index")
   public List&lt;Order&gt; getOrders() { return orders; }
   public void setOrders(List&lt;Order&gt; orders) { this.orders = orders; }
   private List&lt;Order&gt; orders;
}

@Entity
public class Order {
   @Id @GeneratedValue public Integer getId() { return id; }
   public void setId(Integer id) { this.id = id; }
   private Integer id;

   public String getNumber() { return number; }
   public void setNumber(String number) { this.number = number; }
   private String number;

   @ManyToOne
   public Customer getCustomer() { return customer; }
   public void setCustomer(Customer customer) { this.customer = customer; }
   private Customer number;
}

-- Table schema
|--------------| |----------|
| Order        | | Customer |
|--------------| |----------|
| id           | | id       |
| number       | |----------| 
| customer_id  |
| orders_index |
|--------------|</programlisting>

          <note>
            <para>We recommend you to convert
            <classname>@org.hibernate.annotations.IndexColumn</classname>
            usages to <classname>@OrderColumn</classname> unless you are
            making use of the base property. The <literal>base</literal>
            property lets you define the index value of the first element (aka
            as base index). The usual value is <literal>0</literal> or
            <literal>1</literal>. The default is 0 like in Java.</para>
          </note>

          <para>Likewise, maps can borrow their keys from one of the
          associated entity properties or have dedicated columns to store an
          explicit key.</para>

          <para>To use one of the target entity property as a key of the map,
          use <literal>@MapKey(name="myProperty")</literal>
          (<literal>myProperty</literal> is a property name in the target
          entity). When using <literal>@MapKey</literal> (without property
          name), the target entity primary key is used. The map key uses the
          same column as the property pointed out: there is no additional
          column defined to hold the map key, and it does make sense since the
          map key actually represent a target property. Be aware that once
          loaded, the key is no longer kept in sync with the property, in
          other words, if you change the property value, the key will not
          change automatically in your Java model.</para>

          <programlisting language="JAVA" role="JAVA">@Entity
public class Customer {
   @Id @GeneratedValue public Integer getId() { return id; }
   public void setId(Integer id) { this.id = id; }
   private Integer id;

   @OneToMany(mappedBy="customer")
   @MapKey(name"number")
   public Map&lt;String,Order&gt; getOrders() { return orders; }
   public void setOrders(Map&lt;String,Order&gt; order) { this.orders = orders; }
   private Map&lt;String,Order&gt; orders;
}

@Entity
public class Order {
   @Id @GeneratedValue public Integer getId() { return id; }
   public void setId(Integer id) { this.id = id; }
   private Integer id;

   public String getNumber() { return number; }
   public void setNumber(String number) { this.number = number; }
   private String number;

   @ManyToOne
   public Customer getCustomer() { return customer; }
   public void setCustomer(Customer customer) { this.customer = customer; }
   private Customer number;
}

-- Table schema
|-------------| |----------|
| Order       | | Customer |
|-------------| |----------|
| id          | | id       |
| number      | |----------| 
| customer_id |
|-------------|</programlisting>

          <para>Otherwise, the map key is mapped to a dedicated column or
          columns. To customize things, use one of the following
          annotations:</para>

          <itemizedlist>
            <listitem>
              <para>@<classname>MapKeyColumn</classname> if the map key is a
              basic type, if you don't specify the column name, the name of
              the property followed by underscore followed by
              <literal>KEY</literal> is used (for example
              <literal>orders_KEY</literal>).</para>
            </listitem>

            <listitem>
              <para><classname>@MapKeyEnumerated</classname> /
              <classname>@MapKeyTemporal</classname> if the map key type is
              respectively an enum or a <classname>Date</classname>.</para>
            </listitem>

            <listitem>
              <para><classname>@MapKeyJoinColumn</classname>/<classname>@MapKeyJoinColumns</classname>
              if the map key type is another entity.</para>
            </listitem>

            <listitem>
              <para><classname>@AttributeOverride</classname>/<classname>@AttributeOverrides</classname>
              when the map key is a embeddable object. Use
              <literal>key.</literal> as a prefix for your embeddable object
              property names.</para>
            </listitem>
          </itemizedlist>

          <para>You can also use <classname>@MapKeyClass</classname> to define
          the type of the key if you don't use generics (at this stage, you
          should wonder why at this day and age you don't use
          generics).</para>

          <programlisting language="JAVA" role="JAVA">@Entity
public class Customer {
   @Id @GeneratedValue public Integer getId() { return id; }
   public void setId(Integer id) { this.id = id; }
   private Integer id;

   @OneToMany @JoinTable(name="Cust_Order")
   @MapKeyColumn(name"orders_number")
   public Map&lt;String,Order&gt; getOrders() { return orders; }
   public void setOrders(Map&lt;String,Order&gt; orders) { this.orders = orders; }
   private Map&lt;String,Order&gt; orders;
}

@Entity
public class Order {
   @Id @GeneratedValue public Integer getId() { return id; }
   public void setId(Integer id) { this.id = id; }
   private Integer id;

   public String getNumber() { return number; }
   public void setNumber(String number) { this.number = number; }
   private String number;

   @ManyToOne
   public Customer getCustomer() { return customer; }
   public void setCustomer(Customer customer) { this.customer = customer; }
   private Customer number;
}

-- Table schema
|-------------| |----------| |---------------|
| Order       | | Customer | | Cust_Order    |
|-------------| |----------| |---------------|
| id          | | id       | | customer_id   |
| number      | |----------| | order_id      |
| customer_id |              | orders_number |
|-------------|              |---------------|</programlisting>

          <note>
            <para>We recommend you to migrate from
            <classname>@org.hibernate.annotations.MapKey</classname> /
            <classname>@org.hibernate.annotation.MapKeyManyToMany</classname>
            to the new standard approach described above.</para>
          </note>

          <para>Let's now explore the various collection semantics based on
          the mapping you are choosing.</para>

          <table>
            <title>Collections semantics</title>

            <tgroup cols="3">
              <colspec colname="c1" />

              <colspec colname="c2" />

              <colspec colname="c3" colnum="2" />

              <thead>
                <row>
                  <entry>Semantic</entry>

                  <entry>java representation</entry>

                  <entry>annotations</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>Bag semantic</entry>

                  <entry>java.util.List, java.util.Collection</entry>

                  <entry>@ElementCollection or @OneToMany or
                  @ManyToMany</entry>
                </row>

                <row>
                  <entry>Bag semantic with primary key (without the
                  limitations of Bag semantic)</entry>

                  <entry>java.util.List, java.util.Collection</entry>

                  <entry>(@ElementCollection or @OneToMany or @ManyToMany) and
                  @CollectionId</entry>
                </row>

                <row>
                  <entry>List semantic</entry>

                  <entry>java.util.List</entry>

                  <entry>(@ElementCollection or @OneToMany or @ManyToMany) and
                  (@OrderColumn or
                  @org.hibernate.annotations.IndexColumn)</entry>
                </row>

                <row>
                  <entry>Set semantic</entry>

                  <entry>java.util.Set</entry>

                  <entry>@ElementCollection or @OneToMany or
                  @ManyToMany</entry>
                </row>

                <row>
                  <entry>Map semantic</entry>

                  <entry>java.util.Map</entry>

                  <entry>(@ElementCollection or @OneToMany or @ManyToMany) and
                  ((nothing or @MapKeyJoinColumn/@MapKeyColumn for true map
                  support) OR @javax.persistence.MapKey)</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <remark>Specifically, java.util.List collections without
          @OrderColumn or @IndexColumn are going to be considered as
          bags.</remark>

          <para>More support for collections are available via Hibernate
          specific extensions (see <xref linkend="entity-hibspec" />).</para>
        </section>
      </section>

      <section id="entity-mapping-association-cascade">
        <title>Transitive persistence with cascading</title>

        <para>You probably have noticed the <literal>cascade</literal>
        attribute taking an array of <classname>CascadeType</classname> as a
        value. The cascade concept in JPA is very is similar to the transitive
        persistence and cascading of operations in Hibernate, but with
        slightly different semantics and cascading types:</para>

        <itemizedlist>
          <listitem>
            <para><literal>CascadeType.PERSIST</literal>: cascades the persist
            (create) operation to associated entities persist() is called or
            if the entity is managed</para>
          </listitem>

          <listitem>
            <para><literal>CascadeType.MERGE</literal>: cascades the merge
            operation to associated entities if merge() is called or if the
            entity is managed</para>
          </listitem>

          <listitem>
            <para><literal>CascadeType.REMOVE</literal>: cascades the remove
            operation to associated entities if delete() is called</para>
          </listitem>

          <listitem>
            <para><literal>CascadeType.REFRESH:</literal> cascades the refresh
            operation to associated entities if refresh() is called</para>
          </listitem>

          <listitem>
            <para><literal>CascadeType.DETACH:</literal> cascades the detach
            operation to associated entities if detach() is called</para>
          </listitem>

          <listitem>
            <para><literal>CascadeType.ALL</literal>: all of the above</para>
          </listitem>
        </itemizedlist>

        <note>
          <para>CascadeType.ALL also covers Hibernate specific operations like
          save-update, lock etc... Check <xref
          linkend="entity-hibspec-cascade" /> for more information</para>
        </note>

        <para>Please refer to the chapter 6.3 of the JPA specification for
        more information on cascading and create/merge semantics.</para>

        <para>You can also enable the orphan removal semantic. If an entity is
        removed from a <classname>@OneToMany</classname> collection or an
        associated entity is dereferenced from a
        <classname>@OneToOne</classname> association, this associated entity
        can be marked for deletion if <literal>orphanRemoval</literal> is set
        to true. In a way, it means that the associated entity's lifecycle is
        bound to the owning entity just like an embeddable object is.</para>

        <programlisting language="JAVA" role="JAVA">@Entity class Customer {
   @OneToMany(orphanRemoval=true) public Set&lt;Order&gt; getOrders() { return orders; }
   public void setOrders(Set&lt;Order&gt; orders) { this.orders = orders; }
   private Set&lt;Order&gt; orders;

   [...]
}

@Entity class Order { ... }

Customer customer = em.find(Customer.class, 1l);
Order order = em.find(Order.class, 1l);
customer.getOrders().remove(order); //order will be deleted by cascade</programlisting>
      </section>

      <section id="entity-mapping-association-fetching">
        <title>Association fetching</title>

        <para>You have the ability to either eagerly or lazily fetch
        associated entities. The <literal>fetch</literal> parameter can be set
        to <literal>FetchType.LAZY</literal> or
        <literal>FetchType.EAGER</literal>. <literal>EAGER</literal> will try
        to use an outer join select to retrieve the associated object, while
        <literal>LAZY</literal> will only trigger a select when the associated
        object is accessed for the first time. <literal>@OneToMany</literal>
        and <literal>@ManyToMany</literal> associations are defaulted to
        <literal>LAZY</literal> and <literal>@OneToOne</literal> and
        <literal>@ManyToOne</literal> are defaulted to
        <literal>EAGER</literal>. For more information about static fetching,
        check <xref linkend="entity-hibspec-singleassoc-fetching" />.</para>

        <para>The recommanded approach is to use <literal>LAZY</literal> on
        all static fetching definitions and override this choice dynamically
        through JP-QL. JP-QL has a <literal>fetch</literal> keyword that
        allows you to override laziness when doing a particular query. This is
        very useful to improve performance and is decided on a use case to use
        case basis.</para>
      </section>
    </section>

    <section>
      <title>Mapping composite primary keys and foreign keys to composite
      primary keys</title>

      <para>Composite primary keys use a embedded class as the primary key
      representation, so you'd use the <literal>@Id</literal> and
      <literal>@Embeddable</literal> annotations. Alternatively, you can use
      the <literal>@EmbeddedId</literal> annotation. Note that the dependent
      class has to be serializable and implements
      <methodname>equals()</methodname>/<methodname>hashCode()</methodname>.
      You can also use <literal>@IdClass</literal>. These are more detailed in
      <xref linkend="entity-mapping-identifier" />.</para>

      <programlisting language="JAVA" role="JAVA">@Entity
public class RegionalArticle implements Serializable {

    @Id
    public RegionalArticlePk getPk() { ... }
}

@Embeddable
public class RegionalArticlePk implements Serializable { ... }       </programlisting>

      <para>or alternatively</para>

      <programlisting language="JAVA" role="JAVA">@Entity
public class RegionalArticle implements Serializable {

    @EmbeddedId
    public RegionalArticlePk getPk() { ... }
}

public class RegionalArticlePk implements Serializable { ... }         </programlisting>

      <para><literal>@Embeddable</literal> inherit the access type of its
      owning entity unless <literal>@Access</literal> is used. Composite
      foreign keys (if not using the default sensitive values) are defined on
      associations using the <literal>@JoinColumns</literal> element, which is
      basically an array of <literal>@JoinColumn</literal>. It is considered a
      good practice to express <literal>referencedColumnNames</literal>
      explicitly. Otherwise, Hibernate will suppose that you use the same
      order of columns as in the primary key declaration.</para>

      <programlisting language="JAVA" role="JAVA">@Entity
public class Parent implements Serializable {
    @Id
    public ParentPk id;
    public int age;

    @OneToMany(cascade=CascadeType.ALL)
    @JoinColumns ({
        @JoinColumn(name="parentCivility", referencedColumnName = "isMale"),
        @JoinColumn(name="parentLastName", referencedColumnName = "lastName"),
        @JoinColumn(name="parentFirstName", referencedColumnName = "firstName")
    })
    public Set&lt;Child&gt; children; //unidirectional
    ...
} </programlisting>

      <programlisting language="JAVA" role="JAVA">@Entity
public class Child implements Serializable {
    @Id @GeneratedValue
    public Integer id;

    @ManyToOne
    @JoinColumns ({
        @JoinColumn(name="parentCivility", referencedColumnName = "isMale"),
        @JoinColumn(name="parentLastName", referencedColumnName = "lastName"),
        @JoinColumn(name="parentFirstName", referencedColumnName = "firstName")
    })
    public Parent parent; //unidirectional
}       </programlisting>

      <programlisting language="JAVA" role="JAVA">@Embeddable
public class ParentPk implements Serializable {
    String firstName;
    String lastName;
    ...
}        </programlisting>

      <para>Note the explicit usage of the
      <literal>referencedColumnName</literal>.</para>
    </section>

    <section>
      <title>Mapping secondary tables</title>

      <para>You can map a single entity to several tables using the
      <literal>@SecondaryTable</literal> or
      <literal>@SecondaryTables</literal> class level annotations. To express
      that a column is in a particular table, use the <literal>table</literal>
      parameter of <literal>@Column</literal> or
      <literal>@JoinColumn</literal>.</para>

      <programlisting language="JAVA" role="JAVA">@Entity
@Table(name="MainCat")
@SecondaryTables({
    @SecondaryTable(name="Cat1", pkJoinColumns={
        @PrimaryKeyJoinColumn(name="cat_id", referencedColumnName="id")
    ),
    @SecondaryTable(name="Cat2", uniqueConstraints={@UniqueConstraint(columnNames={"storyPart2"})})
})
public class Cat implements Serializable {

    private Integer id;
    private String name;
    private String storyPart1;
    private String storyPart2;

    @Id @GeneratedValue
    public Integer getId() {
        return id;
    }

    public String getName() {
        return name;
    }
    
    @Column(table="Cat1")
    public String getStoryPart1() {
        return storyPart1;
    }

    @Column(table="Cat2")
    public String getStoryPart2() {
        return storyPart2;
    }
}</programlisting>

      <para>In this example, <literal>name</literal> will be in
      <literal>MainCat</literal>. <literal>storyPart1</literal> will be in
      <literal>Cat1</literal> and <literal>storyPart2</literal> will be in
      <literal>Cat2</literal>. <literal>Cat1</literal> will be joined to
      <literal>MainCat</literal> using the <literal>cat_id</literal> as a
      foreign key, and <literal>Cat2</literal> using <literal>id</literal> (ie
      the same column name, the <literal>MainCat</literal> id column has).
      Plus a unique constraint on <literal>storyPart2</literal> has been
      set.</para>
    </section>

    <section>
      <title>Caching entities</title>

      <para>Hibernate offers naturally a first level cache for entities called
      a persistence context via the notion of <classname>Session</classname>.
      This cache is contextual to the use case at hand. Some entities however
      are shared by many different use cases and are barely changed. You can
      cache these in what is called the second level cache.</para>

      <para>By default, entities are not part of the second level cache. While
      we do not recommend that, you can override this by setting the
      <literal>shared-cache-mode</literal> element in your persistence.xml
      file or by using the <literal>javax.persistence.sharedCache.mode
      property</literal>. The following values are possible:</para>

      <itemizedlist>
        <listitem>
          <para><literal>ENABLE_SELECTIVE</literal> (Default and recommended
          value): entities are not cached unless explicitly marked as
          cacheable.</para>
        </listitem>

        <listitem>
          <para><literal>DISABLE_SELECTIVE</literal>: entities are cached
          unless explicitly marked as not cacheable.</para>
        </listitem>

        <listitem>
          <para><literal>ALL</literal>: all entities are always cached even if
          marked as non cacheable.</para>
        </listitem>

        <listitem>
          <para><literal>NONE</literal>: no entity are cached even if marked
          as cacheable. This option can make sense to disable second-level
          cache altogether.</para>
        </listitem>
      </itemizedlist>

      <para>The cache concurrency strategy used by default can be set with the
      <literal>hibernate.cache.default_cache_concurrency_strategy</literal>
      property:</para>

      <itemizedlist>
        <listitem>
          <para><literal>read-only</literal></para>
        </listitem>

        <listitem>
          <para><literal>read-write</literal></para>
        </listitem>

        <listitem>
          <para><literal>nonstrict-read-write</literal></para>
        </listitem>

        <listitem>
          <para><literal>transactional</literal></para>
        </listitem>
      </itemizedlist>

      <note>
        <para>It is recommended to define the cache concurrency strategy per
        entity rather than using a global one. Use the
        <classname>@org.hibernate.annotations.Cache</classname> annotation for
        that.</para>
      </note>

      <programlisting language="JAVA" role="JAVA">@Entity @Cacheable
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public class Forest { ... }</programlisting>

      <para>Hibernate also let's you cache the content of a collection or the
      identifiers if the collection contains other entities. Use the
      <classname>@Cache</classname> annotation on the collection
      property.</para>

      <programlisting language="JAVA" role="JAVA">@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
@JoinColumn(name="CUST_ID")
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public SortedSet&lt;Ticket&gt; getTickets() {
    return tickets;
}</programlisting>

      <para><literal>@org.hibernate.annotations.Cache</literal> defines the
      caching strategy and region of a given second level cache.</para>

      <programlistingco>
        <areaspec>
          <area coords="2" id="cache-hm1" />

          <area coords="3" id="cache-hm2" />

          <area coords="4" id="cache-hm3" />
        </areaspec>

        <programlisting>@Cache(
    CacheConcurrencyStrategy usage();
    String region() default "";
    String include() default "all";
)</programlisting>

        <calloutlist>
          <callout arearefs="cache-hm1">
            <para>usage: the given cache concurrency strategy (NONE,
            READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL)</para>
          </callout>

          <callout arearefs="cache-hm2">
            <para>region (optional): the cache region (default to the fqcn of
            the class or the fq role name of the collection)</para>
          </callout>

          <callout arearefs="cache-hm3">
            <para><literal>include</literal> (optional): all to include all
            properties, non-lazy to only include non lazy properties (default
            all).</para>
          </callout>
        </calloutlist>
      </programlistingco>
    </section>
  </section>

  <section id="entity-mapping-query">
    <title>Mapping Queries</title>

    <para>While you can write queries in your code, it is considered a good
    practice to externalize them:</para>

    <itemizedlist>
      <listitem>
        <para>it make developer/DBA communications easier</para>
      </listitem>

      <listitem>
        <para>named queries are pre-compiled by Hibernate at startup
        time</para>
      </listitem>
    </itemizedlist>

    <para>Unfortunately, you lose the type-safety of queries written using the
    Criteria API.</para>

    <section id="entity-mapping-query-hql">
      <title>Mapping JP-QL/HQL queries</title>

      <para>You can map JP-QL/HQL queries using annotations.
      <literal>@NamedQuery</literal> and <literal>@NamedQueries</literal> can
      be defined at the class level or in a JPA XML deployment descriptor.
      However their definitions are global to the session factory/entity
      manager factory scope. A named query is defined by its name and the
      actual query string.</para>

      <programlisting language="JAVA" role="JAVA">&lt;entity-mappings&gt;
    &lt;named-query name="plane.getAll"&gt;
        &lt;query&gt;select p from Plane p&lt;/query&gt;
    &lt;/named-query&gt;
    ...
&lt;/entity-mappings&gt;
...

@Entity
@NamedQuery(name="night.moreRecentThan", query="select n from Night n where n.date &gt;= :date")
public class Night {
    ...
}

public class MyDao {
    doStuff() {
        Query q = s.getNamedQuery("night.moreRecentThan");
        q.setDate( "date", aMonthAgo );
        List results = q.list();
        ...
    }
    ...
}      </programlisting>

      <para>You can also provide some hints to a query through an array of
      <literal>QueryHint</literal> through a <literal>hints</literal>
      attribute.</para>

      <para>The available Hibernate hints are</para>

      <table>
        <title>Query hints</title>

        <tgroup cols="2">
          <thead>
            <colspec colname="c1" />

            <colspec colname="c2" colnum="2" />

            <row>
              <entry>hint</entry>

              <entry colname="c2">description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>org.hibernate.cacheable</entry>

              <entry>Whether the query should interact with the second level
              cache (defualt to false)</entry>
            </row>

            <row>
              <entry>org.hibernate.cacheRegion</entry>

              <entry>Cache region name (default used otherwise)</entry>
            </row>

            <row>
              <entry>org.hibernate.timeout</entry>

              <entry>Query timeout</entry>
            </row>

            <row>
              <entry>org.hibernate.fetchSize</entry>

              <entry>resultset fetch size</entry>
            </row>

            <row>
              <entry>org.hibernate.flushMode</entry>

              <entry>Flush mode used for this query</entry>
            </row>

            <row>
              <entry>org.hibernate.cacheMode</entry>

              <entry>Cache mode used for this query</entry>
            </row>

            <row>
              <entry>org.hibernate.readOnly</entry>

              <entry>Entities loaded by this query should be in read only mode
              or not (default to false)</entry>
            </row>

            <row>
              <entry>org.hibernate.comment</entry>

              <entry>Query comment added to the generated SQL</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>You can also define the lock mode by which the returned entities
      should be locked using the <literal>lockMode</literal> property. This is
      equivalent to the optional lock mode of the entitymanager lookup
      operations.</para>
    </section>

    <section id="entity-mapping-query-native">
      <title>Mapping native queries</title>

      <para>You can also map a native query (ie a plain SQL query). To achieve
      that, you need to describe the SQL resultset structure using
      <literal>@SqlResultSetMapping</literal> (or
      <literal>@SqlResultSetMappings</literal> if you plan to define several
      resulset mappings). Like <literal>@NamedQuery</literal>, a
      <literal>@SqlResultSetMapping</literal> can be defined at class level or
      in a JPA XML file. However its scope is global to the
      application.</para>

      <para>As we will see, a <literal>resultSetMapping</literal> parameter is
      defined in <literal>@NamedNativeQuery</literal>, it represents the name
      of a defined <literal>@SqlResultSetMapping</literal>. The resultset
      mapping declares the entities retrieved by this native query. Each field
      of the entity is bound to an SQL alias (or column name). All fields of
      the entity including the ones of subclasses and the foreign key columns
      of related entities have to be present in the SQL query. Field
      definitions are optional provided that they map to the same column name
      as the one declared on the class property.</para>

      <programlisting language="JAVA" role="JAVA">@NamedNativeQuery(name="night&amp;area", query="select night.id nid, night.night_duration, "
    + " night.night_date, area.id aid, night.area_id, area.name "
    + "from Night night, Area area where night.area_id = area.id", 
                  resultSetMapping="joinMapping")
@SqlResultSetMapping(name="joinMapping", entities={
    @EntityResult(entityClass=Night.class, fields = {
        @FieldResult(name="id", column="nid"),
        @FieldResult(name="duration", column="night_duration"),
        @FieldResult(name="date", column="night_date"),
        @FieldResult(name="area", column="area_id"),
        discriminatorColumn="disc"
    }),
    @EntityResult(entityClass=org.hibernate.test.annotations.query.Area.class, fields = {
        @FieldResult(name="id", column="aid"),
        @FieldResult(name="name", column="name")
    })
    }
)</programlisting>

      <para>In the above example, the <literal>night&amp;area</literal> named
      query use the <literal>joinMapping</literal> result set mapping. This
      mapping returns 2 entities, <literal>Night</literal> and
      <literal>Area</literal>, each property is declared and associated to a
      column name, actually the column name retrieved by the query. Let's now
      see an implicit declaration of the property / column.</para>

      <programlisting language="JAVA" role="JAVA">@Entity
@SqlResultSetMapping(name="implicit",
                     entities=@EntityResult(entityClass=SpaceShip.class))
@NamedNativeQuery(name="implicitSample", 
                  query="select * from SpaceShip", 
                  resultSetMapping="implicit")
public class SpaceShip {
    private String name;
    private String model;
    private double speed;

    @Id
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Column(name="model_txt")
    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }
}</programlisting>

      <para>In this example, we only describe the entity member of the result
      set mapping. The property / column mappings is done using the entity
      mapping values. In this case the <literal>model</literal> property is
      bound to the <literal>model_txt </literal>column. If the association to
      a related entity involve a composite primary key, a
      <literal>@FieldResult</literal> element should be used for each foreign
      key column. The <literal>@FieldResult</literal> name is composed of the
      property name for the relationship, followed by a dot ("."), followed by
      the name or the field or property of the primary key.</para>

      <programlisting language="JAVA" role="JAVA">@Entity
@SqlResultSetMapping(name="compositekey",
        entities=@EntityResult(entityClass=SpaceShip.class,
            fields = {
                    @FieldResult(name="name", column = "name"),
                    @FieldResult(name="model", column = "model"),
                    @FieldResult(name="speed", column = "speed"),
                    @FieldResult(name="captain.firstname", column = "firstn"),
                    @FieldResult(name="captain.lastname", column = "lastn"),
                    @FieldResult(name="dimensions.length", column = "length"),
                    @FieldResult(name="dimensions.width", column = "width")
                    }),
        columns = { @ColumnResult(name = "surface"),
                    @ColumnResult(name = "volume") } )

@NamedNativeQuery(name="compositekey",
    query="select name, model, speed, lname as lastn, fname as firstn, length, width, length * width as surface from SpaceShip", 
    resultSetMapping="compositekey")
} )
public class SpaceShip {
    private String name;
    private String model;
    private double speed;
    private Captain captain;
    private Dimensions dimensions;

    @Id
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @ManyToOne(fetch= FetchType.LAZY)
    @JoinColumns( {
            @JoinColumn(name="fname", referencedColumnName = "firstname"),
            @JoinColumn(name="lname", referencedColumnName = "lastname")
            } )
    public Captain getCaptain() {
        return captain;
    }

    public void setCaptain(Captain captain) {
        this.captain = captain;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }

    public Dimensions getDimensions() {
        return dimensions;
    }

    public void setDimensions(Dimensions dimensions) {
        this.dimensions = dimensions;
    }
}

@Entity
@IdClass(Identity.class)
public class Captain implements Serializable {
    private String firstname;
    private String lastname;

    @Id
    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    @Id
    public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }
}
</programlisting>

      <para>If you retrieve a single entity and if you use the default
      mapping, you can use the <literal>resultClass</literal> attribute
      instead of <literal>resultSetMapping</literal>:</para>

      <programlisting language="JAVA" role="JAVA">@NamedNativeQuery(name="implicitSample", query="select * from SpaceShip",
    resultClass=SpaceShip.class)
public class SpaceShip {</programlisting>

      <para>In some of your native queries, you'll have to return scalar
      values, for example when building report queries. You can map them in
      the <literal>@SqlResultsetMapping</literal> through
      <literal>@ColumnResult</literal>. You actually can even mix, entities
      and scalar returns in the same native query (this is probably not that
      common though).</para>

      <programlisting language="JAVA" role="JAVA">@SqlResultSetMapping(name="scalar", columns=@ColumnResult(name="dimension"))
@NamedNativeQuery(name="scalar", query="select length*width as dimension from SpaceShip", resultSetMapping="scalar")</programlisting>

      <para>An other query hint specific to native queries has been
      introduced: <literal>org.hibernate.callable</literal> which can be true
      or false depending on whether the query is a stored procedure or
      not.</para>
    </section>
  </section>

  <section id="entity-hibspec">
    <title>Hibernate Annotation Extensions</title>

    <para>Hibernate 3.1 offers a variety of additional annotations that you
    can mix/match with your EJB 3 entities. They have been designed as a
    natural extension of EJB3 annotations.</para>

    <para>To empower the EJB3 capabilities, hibernate provides specific
    annotations that match hibernate features. The
    <classname>org.hibernate.annotations</classname> package contains all
    these annotations extensions.</para>

    <section id="entity-hibspec-entity">
      <title>Entity</title>

      <para>You can fine tune some of the actions done by Hibernate on
      entities beyond what the EJB3 spec offers.</para>

      <para><classname>@org.hibernate.annotations.Entity</classname> adds
      additional metadata that may be needed beyond what is defined in the
      standard <literal>@Entity</literal> <itemizedlist>
          <listitem>
            <para>mutable: whether this entity is mutable or not</para>
          </listitem>

          <listitem>
            <para>dynamicInsert: allow dynamic SQL for inserts</para>
          </listitem>

          <listitem>
            <para>dynamicUpdate: allow dynamic SQL for updates</para>
          </listitem>

          <listitem>
            <para>selectBeforeUpdate: Specifies that Hibernate should never
            perform an SQL UPDATE unless it is certain that an object is
            actually modified.</para>
          </listitem>

          <listitem>
            <para>polymorphism: whether the entity polymorphism is of
            PolymorphismType.IMPLICIT (default) or
            PolymorphismType.EXPLICIT</para>
          </listitem>

          <listitem>
            <para>optimisticLock: optimistic locking strategy
            (OptimisticLockType.VERSION, OptimisticLockType.NONE,
            OptimisticLockType.DIRTY or OptimisticLockType.ALL)</para>
          </listitem>
        </itemizedlist></para>

      <para><note>
          <para>@javax.persistence.Entity is still mandatory,
          @org.hibernate.annotations.Entity is not a replacement.</para>
        </note></para>

      <para>Here are some additional Hibernate annotation extensions</para>

      <para><literal>@org.hibernate.annotations.BatchSize</literal> allows you
      to define the batch size when fetching instances of this entity ( eg.
      <literal>@BatchSize(size=4)</literal> ). When loading a given entity,
      Hibernate will then load all the uninitialized entities of the same type
      in the persistence context up to the batch size.</para>

      <para><literal>@org.hibernate.annotations.Proxy</literal> defines the
      laziness attributes of the entity. lazy (default to true) define whether
      the class is lazy or not. proxyClassName is the interface used to
      generate the proxy (default is the class itself).</para>

      <para><literal>@org.hibernate.annotations.Where</literal> defines an
      optional SQL WHERE clause used when instances of this class is
      retrieved.</para>

      <para><literal>@org.hibernate.annotations.Check</literal> defines an
      optional check constraints defined in the DDL statetement.</para>

      <para><literal>@OnDelete(action=OnDeleteAction.CASCADE)</literal> on
      joined subclasses: use a SQL cascade delete on deletion instead of the
      regular Hibernate mechanism.</para>

      <para><literal>@Table(appliesTo="tableName", indexes = {
      @Index(name="index1", columnNames={"column1", "column2"} ) } )</literal>
      creates the defined indexes on the columns of table
      <literal>tableName</literal>. This can be applied on the primary table
      or any secondary table. The <literal>@Tables</literal> annotation allows
      your to apply indexes on different tables. This annotation is expected
      where <literal>@javax.persistence.Table</literal> or
      <literal>@javax.persistence.SecondaryTable</literal>(s) occurs.</para>

      <note>
        <para><literal>@org.hibernate.annotations.Table</literal> is a
        complement, not a replacement to
        <literal>@javax.persistence.Table</literal>. Especially, if you want
        to change the default name of a table, you must use
        <literal>@javax.persistence.Table</literal>, not
        <literal>@org.hibernate.annotations.Table</literal>.</para>
      </note>

      <para><literal>@org.hibernate.annotations.Table</literal> can also be
      used to define the following elements of secondary tables:</para>

      <itemizedlist>
        <listitem>
          <para><literal>fetch</literal>: If set to JOIN, the default,
          Hibernate will use an inner join to retrieve a secondary table
          defined by a class or its superclasses and an outer join for a
          secondary table defined by a subclass. If set to select then
          Hibernate will use a sequential select for a secondary table defined
          on a subclass, which will be issued only if a row turns out to
          represent an instance of the subclass. Inner joins will still be
          used to retrieve a secondary defined by the class and its
          superclasses.</para>
        </listitem>

        <listitem>
          <para><literal>inverse</literal>: If true, Hibernate will not try to
          insert or update the properties defined by this join. Default to
          false.</para>
        </listitem>

        <listitem>
          <para><literal>optional</literal>: If enabled (the default),
          Hibernate will insert a row only if the properties defined by this
          join are non-null and will always use an outer join to retrieve the
          properties.</para>
        </listitem>

        <listitem>
          <para><literal>foreignKey</literal>: defines the Foreign Key name of
          a secondary table pointing back to the primary table.</para>
        </listitem>
      </itemizedlist>

      <para><literal>@Immutable</literal> marks an entity or collection as
      immutable. An immutable entity may not be updated by the application.
      This allows Hibernate to make some minor performance optimizations.
      Updates to an immutable entity will be ignored, but no exception is
      thrown. <literal>@Immutable</literal> must be used on root entities
      only. <literal>@Immutable</literal> placed on a collection makes the
      collection immutable, meaning additions and deletions to and from the
      collection are not allowed. A <literal>HibernateException</literal> is
      thrown in this case.</para>

      <para><literal>@Persister</literal> lets you define your own custom
      persistence strategy. You may, for example, specify your own subclass of
      <classname>org.hibernate.persister.EntityPersister</classname> or you
      might even provide a completely new implementation of the interface
      <literal>org.hibernate.persister.ClassPersister</literal> that
      implements persistence via, for example, stored procedure calls,
      serialization to flat files or LDAP.</para>

      <programlisting language="JAVA" role="JAVA">@Entity
@BatchSize(size=5)
@org.hibernate.annotations.Entity(
        selectBeforeUpdate = true,
        dynamicInsert = true, dynamicUpdate = true,
        optimisticLock = OptimisticLockType.ALL,
        polymorphism = PolymorphismType.EXPLICIT)
@Where(clause="1=1")
@org.hibernate.annotations.Table(name="Forest", indexes = { @Index(name="idx", columnNames = { "name", "length" } ) } )
@Persister(impl=MyEntityPersister.class)
public class Forest { ... }</programlisting>

      <programlisting language="JAVA" role="JAVA">@Entity
@Inheritance(
    strategy=InheritanceType.JOINED
)
public class Vegetable { ... }

@Entity
@OnDelete(action=OnDeleteAction.CASCADE)
public class Carrot extends Vegetable { ... }</programlisting>
    </section>

    <section id="entity-hibspec-identifier">
      <title>Identifier</title>

      <para>Hibernate Annotations goes beyond the Java Persistence
      specification when defining identifiers.</para>

      <section>
        <title>Generators</title>

        <para><literal><literal>@org.hibernate.annotations.GenericGenerator</literal>
        and <literal>@org.hibernate.annotations.GenericGenerators</literal>
        allows you to define an Hibernate specific id
        generator.</literal></para>

        <programlisting language="JAVA" role="JAVA">@Id @GeneratedValue(generator="system-uuid")
@GenericGenerator(name="system-uuid", strategy = "uuid")
public String getId() {

@Id @GeneratedValue(generator="hibseq")
@GenericGenerator(name="hibseq", strategy = "seqhilo",
    parameters = {
        @Parameter(name="max_lo", value = "5"),
        @Parameter(name="sequence", value="heybabyhey")
    }
)
public Integer getId() {</programlisting>

        <para><literal>strategy</literal> is the short name of an Hibernate3
        generator strategy or the fully qualified class name of an
        <classname>IdentifierGenerator</classname> implementation. You can add
        some parameters through the <literal>parameters</literal>
        attribute.</para>

        <para>Contrary to their standard counterpart,
        <literal>@GenericGenerator</literal> and
        <literal>@GenericGenerators</literal> can be used in package level
        annotations, making them application level generators (just like if
        they were in a JPA XML file).</para>

        <programlisting language="JAVA" role="JAVA">@GenericGenerators(
    {
    @GenericGenerator(
        name="hibseq",
        strategy = "seqhilo",
        parameters = {
            @Parameter(name="max_lo", value = "5"),
            @Parameter(name="sequence", value="heybabyhey")
        }
     ),
     @GenericGenerator(...)
     }
)
package org.hibernate.test.model</programlisting>
      </section>

      <section>
        <title>@NaturalId</title>

        <para>While not used as identifier property, some (group of)
        properties represent natural identifier of an entity. This is
        especially true when the schema uses the recommended approach of using
        surrogate primary key even if a natural business key exists. Hibernate
        allows to map such natural properties and reuse them in a
        <classname>Criteria</classname> query. The natural identifier is
        composed of all the properties marked
        <classname>@NaturalId</classname>.</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Citizen {
    @Id
    @GeneratedValue
    private Integer id;
    private String firstname;
    private String lastname;
    
    @NaturalId
    @ManyToOne
    private State state;

    @NaturalId
    private String ssn;
    ...
}



//and later on query
List results = s.createCriteria( Citizen.class )
                .add( Restrictions.naturalId().set( "ssn", "1234" ).set( "state", ste ) )
                .list();</programlisting>

        <para>Note that the group of properties representing the natural
        identifier have to be unique (Hibernate will generate a unique
        constraint if the database schema is generated).</para>
      </section>
    </section>

    <section id="entity-hibspec-property">
      <title>Property</title>

      <section>
        <title>Formula</title>

        <para>Sometimes, you want the Database to do some computation for you
        rather than in the JVM, you might also create some kind of virtual
        column. You can use a SQL fragment (aka formula) instead of mapping a
        property into a column. This kind of property is read only (its value
        is calculated by your formula fragment).</para>

        <programlisting language="JAVA" role="JAVA">@Formula("obj_length * obj_height * obj_width")
public long getObjectVolume()</programlisting>

        <para>The SQL fragment can be as complex as you want and even include
        subselects.</para>
      </section>

      <section>
        <title>Type</title>

        <para><literal>@org.hibernate.annotations.Type</literal> overrides the
        default hibernate type used: this is generally not necessary since the
        type is correctly inferred by Hibernate. Please refer to the Hibernate
        reference guide for more informations on the Hibernate types.</para>

        <para><literal>@org.hibernate.annotations.TypeDef</literal> and
        <literal>@org.hibernate.annotations.TypeDefs</literal> allows you to
        declare type definitions. These annotations can be placed at the class
        or package level. Note that these definitions are global for the
        session factory (even when defined at the class level). If the type is
        used on a single entity, you can place the definition on the entity
        itself. Otherwise, it is recommended to place the definition at the
        package level. In the example below, when Hibernate encounters a
        property of class <literal>PhoneNumer</literal>, it delegates the
        persistence strategy to the custom mapping type
        <literal>PhoneNumberType</literal>. However, properties belonging to
        other classes, too, can delegate their persistence strategy to
        <literal>PhoneNumberType</literal>, by explicitly using the
        <literal>@Type</literal> annotation.</para>

        <note>
          <para>Package level annotations are placed in a file named
          <filename>package-info.java</filename> in the appropriate package.
          Place your annotations before the package declaration.</para>
        </note>

        <programlisting language="JAVA" role="JAVA">@TypeDef(
   name = "phoneNumber",
   defaultForType = PhoneNumber.class,
   typeClass = PhoneNumberType.class
)

@Entity
public class ContactDetails {
   [...]
   private PhoneNumber localPhoneNumber;
   @Type(type="phoneNumber")
   private OverseasPhoneNumber overseasPhoneNumber;
   [...]
}</programlisting>

        <para>The following example shows the usage of the
        <literal>parameters</literal> attribute to customize the
        TypeDef.</para>

        <programlisting language="JAVA" role="JAVA">//in org/hibernate/test/annotations/entity/package-info.java
@TypeDefs(
    {
    @TypeDef(
        name="caster",
        typeClass = CasterStringType.class,
        parameters = {
            @Parameter(name="cast", value="lower")
        }
    )
    }
)
package org.hibernate.test.annotations.entity;

//in org/hibernate/test/annotations/entity/Forest.java
public class Forest {
    @Type(type="caster")
    public String getSmallText() {
    ...
}      </programlisting>

        <para>When using composite user type, you will have to express column
        definitions. The <literal>@Columns</literal> has been introduced for
        that purpose.</para>

        <programlisting language="JAVA" role="JAVA">@Type(type="org.hibernate.test.annotations.entity.MonetaryAmountUserType")
@Columns(columns = {
    @Column(name="r_amount"),
    @Column(name="r_currency")
})
public MonetaryAmount getAmount() {
    return amount;
}


public class MonetaryAmount implements Serializable {
    private BigDecimal amount;
    private Currency currency;
    ...
}</programlisting>
      </section>

      <section>
        <title>Index</title>

        <para>You can define an index on a particular column using the
        <literal>@Index</literal> annotation on a one column property, the
        columnNames attribute will then be ignored</para>

        <programlisting language="JAVA" role="JAVA">@Column(secondaryTable="Cat1")
@Index(name="story1index")
public String getStoryPart1() {
    return storyPart1;
}</programlisting>
      </section>

      <section>
        <title>@Parent</title>

        <para>When inside an embeddable object, you can define one of the
        properties as a pointer back to the owner element.</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Person {
    @Embeddable public Address address;
    ...
}

@Embeddable
public class Address {
    @Parent public Person owner;
    ...
}


person == person.address.owner</programlisting>
      </section>

      <section>
        <title>Generated properties</title>

        <para>Some properties are generated at insert or update time by your
        database. Hibernate can deal with such properties and triggers a
        subsequent select to read these properties.</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Antenna {
    @Id public Integer id;
    @Generated(GenerationTime.ALWAYS) 
    @Column(insertable = false, updatable = false)
    public String longitude;

    @Generated(GenerationTime.INSERT) @Column(insertable = false)
    public String latitude;
}</programlisting>

        <para>Annotate your property as <literal>@Generated</literal> You have
        to make sure your insertability or updatability does not conflict with
        the generation strategy you have chosen. When
        <literal>GenerationTime.INSERT</literal> is chosen, the property must
        not contains insertable columns, when
        <literal>GenerationTime.ALWAYS</literal> is chosen, the property must
        not contains insertable nor updatable columns.</para>

        <para><literal>@Version</literal> properties cannot be
        <literal>@Generated(INSERT)</literal> by design, it has to be either
        <literal>NEVER</literal> or <literal>ALWAYS</literal>.</para>
      </section>

      <section>
        <title>@Target</title>

        <para>Sometimes, the type guessed by reflection is not the one you
        want Hibernate to use. This is especially true on components when an
        interface is used. You can use <literal>@Target</literal> to by pass
        the reflection guessing mechanism (very much like the
        <literal>targetEntity</literal> attribute available on
        associations.</para>

        <programlisting language="JAVA" role="JAVA">    @Embedded
    @Target(OwnerImpl.class)
    public Owner getOwner() {
        return owner;
    }</programlisting>
      </section>

      <section>
        <title>Optimistic lock</title>

        <para>It is sometimes useful to avoid increasing the version number
        even if a given property is dirty (particularly collections). You can
        do that by annotating the property (or collection) with
        <literal>@OptimisticLock(excluded=true)</literal>.</para>

        <para>More formally, specifies that updates to this property do not
        require acquisition of the optimistic lock.</para>
      </section>
    </section>

    <section id="entity-hibspec-inheritance">
      <title>Inheritance</title>

      <para>SINGLE_TABLE is a very powerful strategy but sometimes, and
      especially for legacy systems, you cannot add an additional
      discriminator column. For that purpose Hibernate has introduced the
      notion of discriminator formula:
      <literal>@DiscriminatorFormula</literal> is a replacement of
      <literal>@DiscriminatorColumn</literal> and use a SQL fragment as a
      formula for discriminator resolution (no need to have a dedicated
      column).</para>

      <programlisting language="JAVA" role="JAVA">@Entity
@DiscriminatorFormula("case when forest_type is null then 0 else forest_type end")
public class Forest { ... }</programlisting>

      <para>By default, when querying the top entities, Hibernate does not put
      a restriction clause on the discriminator column. This can be
      inconvenient if this column contains values not mapped in your hierarchy
      (through <literal>@DiscriminatorValue</literal>). To work around that
      you can use <literal>@ForceDiscriminator</literal> (at the class level,
      next to <literal>@DiscriminatorColumn</literal>). Hibernate will then
      list the available values when loading the entities.</para>

      <para>You can define the foreign key name generated by Hibernate for
      subclass tables in the JOINED inheritance strategy.</para>

      <programlisting language="JAVA" role="JAVA">@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class File { ... }

@Entity
@ForeignKey(name = "FK_DOCU_FILE")
public class Document extends File {</programlisting>

      <para>The foreign key from the <literal>Document</literal> table to the
      <literal>File</literal> table will be named
      <literal>FK_DOCU_FILE</literal>.</para>
    </section>

    <section id="entity-hibspec-singleassoc">
      <title>Single Association related annotations</title>

      <para>By default, when Hibernate cannot resolve the association because
      the expected associated element is not in database (wrong id on the
      association column), an exception is raised by Hibernate. This might be
      inconvenient for legacy and badly maintained schemas. You can ask
      Hibernate to ignore such elements instead of raising an exception using
      the <literal>@NotFound</literal> annotation. This annotation can be used
      on a <literal>@OneToOne</literal> (with FK),
      <literal>@ManyToOne</literal>, <literal>@OneToMany</literal> or
      <literal>@ManyToMany</literal> association.</para>

      <programlisting language="JAVA" role="JAVA">@Entity
public class Child {
    ...
    @ManyToOne
    @NotFound(action=NotFoundAction.IGNORE)
    public Parent getParent() { ... }
    ...
}</programlisting>

      <para>Sometimes you want to delegate to your database the deletion of
      cascade when a given entity is deleted.</para>

      <programlisting language="JAVA" role="JAVA">@Entity
public class Child {
    ...
    @ManyToOne
    @OnDelete(action=OnDeleteAction.CASCADE)
    public Parent getParent() { ... }
    ...
}</programlisting>

      <para>In this case Hibernate generates a cascade delete constraint at
      the database level.</para>

      <para>Foreign key constraints, while generated by Hibernate, have a
      fairly unreadable name. You can override the constraint name by use
      <literal>@ForeignKey</literal>.</para>

      <programlisting language="JAVA" role="JAVA">@Entity
public class Child {
    ...
    @ManyToOne
    @ForeignKey(name="FK_PARENT")
    public Parent getParent() { ... }
    ...
}

alter table Child add constraint FK_PARENT foreign key (parent_id) references Parent</programlisting>

      <section id="entity-hibspec-singleassoc-fetching">
        <title id="section-lazy-options-fetching-modes">Lazy options and
        fetching modes</title>

        <para>JPA comes with the <literal>fetch</literal> option to define
        lazy loading and fetching modes, however Hibernate has a much more
        option set in this area. To fine tune the lazy loading and fetching
        strategies, some additional annotations have been introduced:</para>

        <itemizedlist>
          <listitem>
            <para><literal>@LazyToOne</literal>: defines the lazyness option
            on <literal>@ManyToOne</literal> and <literal>@OneToOne</literal>
            associations. <literal>LazyToOneOption</literal> can be
            <literal>PROXY</literal> (ie use a proxy based lazy loading),
            <literal>NO_PROXY</literal> (use a bytecode enhancement based lazy
            loading - note that build time bytecode processing is necessary)
            and <literal>FALSE</literal> (association not lazy)</para>
          </listitem>

          <listitem>
            <para><literal>@LazyCollection</literal>: defines the lazyness
            option on <literal>@ManyTo</literal>Many and
            <literal>@OneToMany</literal> associations. LazyCollectionOption
            can be <literal>TRUE</literal> (the collection is lazy and will be
            loaded when its state is accessed), <literal>EXTRA</literal> (the
            collection is lazy and all operations will try to avoid the
            collection loading, this is especially useful for huge collections
            when loading all the elements is not necessary) and FALSE
            (association not lazy)</para>
          </listitem>

          <listitem>
            <para><literal>@Fetch</literal>: defines the fetching strategy
            used to load the association. <literal>FetchMode</literal> can be
            <literal>SELECT</literal> (a select is triggered when the
            association needs to be loaded), <literal>SUBSELECT</literal>
            (only available for collections, use a subselect strategy - please
            refers to the Hibernate Reference Documentation for more
            information) or <literal>JOIN</literal> (use a SQL JOIN to load
            the association while loading the owner entity).
            <literal>JOIN</literal> overrides any lazy attribute (an
            association loaded through a <literal>JOIN</literal> strategy
            cannot be lazy).</para>
          </listitem>
        </itemizedlist>

        <para>The Hibernate annotations overrides the EJB3 fetching
        options.</para>

        <table>
          <title>Lazy and fetch options equivalent</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry>Annotations</entry>

                <entry>Lazy</entry>

                <entry>Fetch</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>@[One|Many]ToOne](fetch=FetchType.LAZY)</entry>

                <entry>@LazyToOne(PROXY)</entry>

                <entry>@Fetch(SELECT)</entry>
              </row>

              <row>
                <entry>@[One|Many]ToOne](fetch=FetchType.EAGER)</entry>

                <entry>@LazyToOne(FALSE)</entry>

                <entry>@Fetch(JOIN)</entry>
              </row>

              <row>
                <entry>@ManyTo[One|Many](fetch=FetchType.LAZY)</entry>

                <entry>@LazyCollection(TRUE)</entry>

                <entry>@Fetch(SELECT)</entry>
              </row>

              <row>
                <entry>@ManyTo[One|Many](fetch=FetchType.EAGER)</entry>

                <entry>@LazyCollection(FALSE)</entry>

                <entry>@Fetch(JOIN)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section id="entity-hibspec-singleassoc-any">
        <title>@Any</title>

        <para>The <classname>@Any</classname> annotation defines a polymorphic
        association to classes from multiple tables. This type of mapping
        always requires more than one column. The first column holds the type
        of the associated entity. The remaining columns hold the identifier.
        It is impossible to specify a foreign key constraint for this kind of
        association, so this is most certainly not meant as the usual way of
        mapping (polymorphic) associations. You should use this only in very
        special cases (eg. audit logs, user session data, etc).</para>

        <para>The <classname>@Any</classname> annotation describes the column
        holding the metadata information. To link the value of the metadata
        information and an actual entity type, The
        <classname>@AnyDef</classname> and <classname>@AnyDefs</classname>
        annotations are used.</para>

        <programlisting language="JAVA" role="JAVA">    @Any( metaColumn = @Column( name = "property_type" ), fetch=FetchType.EAGER )
    @AnyMetaDef( 
        idType = "integer", 
        metaType = "string", 
        metaValues = {
            @MetaValue( value = "S", targetEntity = StringProperty.class ),
            @MetaValue( value = "I", targetEntity = IntegerProperty.class )
        } )
    @JoinColumn( name = "property_id" )
    public Property getMainProperty() {
        return mainProperty;
    }</programlisting>

        <para><methodname>idType</methodname> represents the target entities
        identifier property type and <methodname>metaType</methodname> the
        metadata type (usually String).</para>

        <para>Note that <classname>@AnyDef</classname> can be mutualized and
        reused. It is recommended to place it as a package metadata in this
        case.</para>

        <programlisting language="JAVA" role="JAVA">//on a package
@AnyMetaDef( name="property" 
    idType = "integer", 
    metaType = "string", 
    metaValues = {
        @MetaValue( value = "S", targetEntity = StringProperty.class ),
        @MetaValue( value = "I", targetEntity = IntegerProperty.class )
    } )
package org.hibernate.test.annotations.any;


//in a class
    @Any( metaDef="property", metaColumn = @Column( name = "property_type" ), fetch=FetchType.EAGER )
    @JoinColumn( name = "property_id" )
    public Property getMainProperty() {
        return mainProperty;
    }</programlisting>
      </section>
    </section>

    <section id="entity-hibspec-collection">
      <title>Collection related annotations</title>

      <section id="entity-hibspec-collection-enhance">
        <title>Enhance collection settings</title>

        <para>It is possible to set <itemizedlist>
            <listitem>
              <para>the batch size for collections using @BatchSize</para>
            </listitem>

            <listitem>
              <para>the where clause, using @Where (applied on the target
              entity) or @WhereJoinTable (applied on the association
              table)</para>
            </listitem>

            <listitem>
              <para>the check clause, using @Check</para>
            </listitem>

            <listitem>
              <para>the SQL order by clause, using @OrderBy</para>
            </listitem>

            <listitem>
              <para>the delete cascade strategy through
              @OnDelete(action=OnDeleteAction.CASCADE)</para>
            </listitem>

            <listitem>
              <para>the collection immutability using @Immutable: if set
              specifies that the elements of the collection never change (a
              minor performance optimization in some cases)</para>
            </listitem>

            <listitem>
              <para>a custom collection persister (ie the persistence strategy
              used) using <literal>@Persister</literal>: the class must
              implement
              <classname>org.hibernate.persister.collectionCollectionPersister</classname></para>
            </listitem>
          </itemizedlist></para>

        <para>You can also declare a sort comparator. Use the
        <literal>@Sort</literal> annotation. Expressing the comparator type
        you want between unsorted, natural or custom comparator. If you want
        to use your own comparator implementation, you'll also have to express
        the implementation class using the <literal>comparator</literal>
        attribute. Note that you need to use either a
        <classname>SortedSet</classname> or a <classname>SortedMap</classname>
        interface.</para>

        <programlisting language="JAVA" role="JAVA">    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @JoinColumn(name="CUST_ID")
    @Sort(type = SortType.COMPARATOR, comparator = TicketComparator.class)
    @Where(clause="1=1")
    @OnDelete(action=OnDeleteAction.CASCADE)
    public SortedSet&lt;Ticket&gt; getTickets() {
        return tickets;
    }</programlisting>

        <para>Please refer to the previous descriptions of these annotations
        for more informations.</para>

        <para>Foreign key constraints, while generated by Hibernate, have a
        fairly unreadable name. You can override the constraint name by use
        <literal>@ForeignKey</literal>. Note that this annotation has to be
        placed on the owning side of the relationship,
        <literal>inverseName</literal> referencing to the other side
        constraint.</para>

        <programlisting language="JAVA" role="JAVA">@Entity
public class Woman {
    ...
    @ManyToMany(cascade = {CascadeType.ALL})
    @ForeignKey(name = "TO_WOMAN_FK", inverseName = "TO_MAN_FK")
    public Set&lt;Man&gt; getMens() {
        return mens;
    }
}

alter table Man_Woman add constraint TO_WOMAN_FK foreign key (woman_id) references Woman
alter table Man_Woman add constraint TO_MAN_FK foreign key (man_id) references Man</programlisting>
      </section>

      <section id="entity-hibspec-collection-extratype">
        <title>Extra collection types</title>

        <section id="entity-hibspec-collection-extratype-indexbidir">
          <title>Bidirectional association with indexed collections</title>

          <para>A bidirectional association where one end is an indexed
          collection (ie. represented as a <literal>@OrderColumn</literal>, or
          as a Map) requires special consideration. If a property on the
          associated class explicitly maps the indexed value, the use of
          <methodname>mappedBy</methodname> is permitted:</para>

          <programlisting language="JAVA" role="JAVA">@Entity
public class Parent {
    @OneToMany(mappedBy="parent")
    @OrderColumn(name="order")
    private List&lt;Child&gt; children;
    ...
}

@Entity
public class Child {
    ...
    //the index column is mapped as a property in the associated entity
    @Column(name="order")
    private int order;

    @ManyToOne
    @JoinColumn(name="parent_id", nullable=false)
    private Parent parent;
    ...
}</programlisting>

          <para>But, if there is no such property on the child class, we can't
          think of the association as truly bidirectional (there is
          information available at one end of the association that is not
          available at the other end: the index). In this case, we can't map
          the collection as <literal>mappedBy</literal>. Instead, we could use
          the following mapping:</para>

          <programlisting language="JAVA" role="JAVA">@Entity
public class Parent {
    @OneToMany
    @OrderColumn(name="order")
    @JoinColumn(name="parent_id", nullable=false)
    private List&lt;Child&gt; children;
    ...
}

@Entity
public class Child {
    ...
    @ManyToOne
    @JoinColumn(name="parent_id", insertable=false, updatable=false, nullable=false)
    private Parent parent;
    ...
}</programlisting>

          <para>Note that in this mapping, the collection-valued end of the
          association is responsible for updating the foreign key.</para>
        </section>

        <section>
          <title>Bag with primary key</title>

          <para>Another interesting feature is the ability to define a
          surrogate primary key to a bag collection. This remove pretty much
          all of the drawbacks of bags: update and removal are efficient, more
          than one <literal>EAGER</literal> bag per query or per entity. This
          primary key will be contained in a additional column of your
          collection table but will not be visible to the Java application.
          @CollectionId is used to mark a collection as id bag, it also allow
          to override the primary key column(s), the primary key type and the
          generator strategy. The strategy can be <literal>identity</literal>,
          or any defined generator name of your application.</para>

          <programlisting language="JAVA" role="JAVA">@Entity
@TableGenerator(name="ids_generator", table="IDS")
public class Passport {
    ...

    @ManyToMany(cascade = CascadeType.ALL)
    @JoinTable(name="PASSPORT_VISASTAMP")
    @CollectionId(
        columns = @Column(name="COLLECTION_ID"), 
        type=@Type(type="long"), 
        generator = "ids_generator"
    )
    private Collection&lt;Stamp&gt; visaStamp = new ArrayList();
    ...
}</programlisting>
        </section>

        <section>
          <title>@ManyToAny</title>

          <para><classname>@ManyToAny</classname> allows polymorphic
          associations to classes from multiple tables. This type of mapping
          always requires more than one column. The first column holds the
          type of the associated entity. The remaining columns hold the
          identifier. It is impossible to specify a foreign key constraint for
          this kind of association, so this is most certainly not meant as the
          usual way of mapping (polymorphic) associations. You should use this
          only in very special cases (eg. audit logs, user session data,
          etc).</para>

          <programlisting language="JAVA" role="JAVA">    @ManyToAny(
            metaColumn = @Column( name = "property_type" ) )
    @AnyMetaDef( 
        idType = "integer", 
        metaType = "string",
        metaValues = {
            @MetaValue( value = "S", targetEntity = StringProperty.class ),
            @MetaValue( value = "I", targetEntity = IntegerProperty.class ) } )
    @Cascade( { org.hibernate.annotations.CascadeType.ALL } )
    @JoinTable( name = "obj_properties", joinColumns = @JoinColumn( name = "obj_id" ),
            inverseJoinColumns = @JoinColumn( name = "property_id" ) )
    public List&lt;Property&gt; getGeneralProperties() {</programlisting>

          <para>Like <classname>@Any</classname>,
          <classname>@ManyToAny</classname> can use named
          <classname>@AnyDef</classname>s, see <xref
          linkend="entity-hibspec-singleassoc-any" /> for more info.</para>
        </section>
      </section>
    </section>

    <section id="entity-hibspec-cascade">
      <title>Cascade</title>

      <para>Hibernate offers more operations than the Java Persistence
      specification. You can use the <literal>@Cascade</literal> annotation to
      cascade the following operations:</para>

      <itemizedlist>
        <listitem>
          <para>PERSIST</para>
        </listitem>

        <listitem>
          <para>MERGE</para>
        </listitem>

        <listitem>
          <para>REMOVE</para>
        </listitem>

        <listitem>
          <para>REFRESH</para>
        </listitem>

        <listitem>
          <para>DELETE</para>
        </listitem>

        <listitem>
          <para>SAVE_UPDATE</para>
        </listitem>

        <listitem>
          <para>REPLICATE</para>
        </listitem>

        <listitem>
          <para>DELETE_ORPHAN (alternatively, use the
          <methodname>@OneToOne.orphanRemoval</methodname> or
          <methodname>@OneToMany.orphanRemoval</methodname> flag)</para>
        </listitem>

        <listitem>
          <para>LOCK</para>
        </listitem>

        <listitem>
          <para>EVICT (alternatively, use the standard DETACH flag).</para>
        </listitem>
      </itemizedlist>

      <para>This is especially useful for <literal>SAVE_UPDATE</literal>
      (which is the operation cascaded at flush time if you use plain
      Hibernate Annotations - Hibernate EntityManager cascade
      <literal>PERSIST</literal> at flush time as per the
      specification).</para>

      <programlisting language="JAVA" role="JAVA">@OneToMany( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )
@Cascade(org.hibernate.annotations.CascadeType.REPLICATE)
public Collection&lt;Employer&gt; getEmployers()</programlisting>

      <para>It is recommended to use <classname>@Cascade</classname> to
      compliment <classname>@*To*(cascade=...)</classname> as shown in the
      previous example.</para>
    </section>

    <section id="entity-hibspec-filters">
      <title>Filters</title>

      <para>Hibernate has the ability to apply arbitrary filters on top of
      your data. Those filters are applied at runtime on a given session.
      First, you need to define them.</para>

      <para><literal>@org.hibernate.annotations.FilterDef</literal> or
      <literal>@FilterDefs</literal> define filter definition(s) used by
      filter(s) using the same name. A filter definition has a name() and an
      array of parameters(). A parameter will allow you to adjust the behavior
      of the filter at runtime. Each parameter is defined by a
      <literal>@ParamDef</literal> which has a name and a type. You can also
      define a defaultCondition() parameter for a given
      <literal>@FilterDef</literal> to set the default condition to use when
      none are defined in each individual <literal>@Filter</literal>. A
      <literal>@FilterDef</literal>(s) can be defined at the class or package
      level.</para>

      <para>We now need to define the SQL filter clause applied to either the
      entity load or the collection load. <literal>@Filter</literal> is used
      and placed either on the entity or the collection element</para>

      <programlisting language="JAVA" role="JAVA">@Entity
@FilterDef(name="minLength", parameters=@ParamDef( name="minLength", type="integer" ) )
@Filters( {
    @Filter(name="betweenLength", condition=":minLength &lt;= length and :maxLength &gt;= length"),
    @Filter(name="minLength", condition=":minLength &lt;= length")
} )
public class Forest { ... }</programlisting>

      <para>When the collection use an association table as a relational
      representation, you might want to apply the filter condition to the
      association table itself or to the target entity table. To apply the
      constraint on the target entity, use the regular
      <literal>@Filter</literal> annotation. However, if you wan to target the
      association table, use the <literal>@FilterJoinTable</literal>
      annotation.</para>

      <programlisting language="JAVA" role="JAVA">    @OneToMany
    @JoinTable
    //filter on the target entity table
    @Filter(name="betweenLength", condition=":minLength &lt;= length and :maxLength &gt;= length")
    //filter on the association table
    @FilterJoinTable(name="security", condition=":userlevel &gt;= requredLevel")
    public Set&lt;Forest&gt; getForests() { ... }</programlisting>
    </section>

    <section id="entity-hibspec-query">
      <title>Queries</title>

      <para>Since Hibernate has more features on named queries than the one
      defined in the JPA specification,
      <literal>@org.hibernate.annotations.NamedQuery</literal>,
      <literal>@org.hibernate.annotations.NamedQueries</literal>,
      <literal>@org.hibernate.annotations.NamedNativeQuery</literal> and
      <literal>@org.hibernate.annotations.NamedNativeQueries</literal> have
      been introduced. They add some attributes to the standard version and
      can be used as a replacement:</para>

      <itemizedlist>
        <listitem>
          <para>flushMode: define the query flush mode (Always, Auto, Commit
          or Manual)</para>
        </listitem>

        <listitem>
          <para>cacheable: whether the query should be cached or not</para>
        </listitem>

        <listitem>
          <para>cacheRegion: cache region used if the query is cached</para>
        </listitem>

        <listitem>
          <para>fetchSize: JDBC statement fetch size for this query</para>
        </listitem>

        <listitem>
          <para>timeout: query time out</para>
        </listitem>

        <listitem>
          <para>callable: for native queries only, to be set to true for
          stored procedures</para>
        </listitem>

        <listitem>
          <para>comment: if comments are activated, the comment seen when the
          query is sent to the database.</para>
        </listitem>

        <listitem>
          <para>cacheMode: Cache interaction mode (get, ignore, normal, put or
          refresh)</para>
        </listitem>

        <listitem>
          <para>readOnly: whether or not the elements retrievent from the
          query are in read only mode.</para>
        </listitem>
      </itemizedlist>

      <para>Those hints can be set in a standard
      <literal>@javax.persistence.NamedQuery</literal> annotations through the
      detyped <literal>@QueryHint</literal>. Another key advantage is the
      ability to set those annotations at a package level.</para>
    </section>

    <section id="entity-hibspec-customsql">
      <title>Custom SQL for CRUD operations</title>

      <para>Hibernate gives you the ability to override every single SQL
      statement generated. We have seen native SQL query usage already, but
      you can also override the SQL statement used to load or change the state
      of entities.</para>

      <programlisting language="JAVA" role="JAVA">@Entity
@Table(name="CHAOS")
@SQLInsert( sql="INSERT INTO CHAOS(size, name, nickname, id) VALUES(?,upper(?),?,?)")
@SQLUpdate( sql="UPDATE CHAOS SET size = ?, name = upper(?), nickname = ? WHERE id = ?")
@SQLDelete( sql="DELETE CHAOS WHERE id = ?")
@SQLDeleteAll( sql="DELETE CHAOS")
@Loader(namedQuery = "chaos")
@NamedNativeQuery(name="chaos", query="select id, size, name, lower( nickname ) as nickname from CHAOS where id= ?", resultClass = Chaos.class)
public class Chaos {
    @Id
    private Long id;
    private Long size;
    private String name;
    private String nickname;</programlisting>

      <para><literal>@SQLInsert</literal>, <literal>@SQLUpdate</literal>,
      <literal>@SQLDelete</literal>, <literal>@SQLDeleteAll</literal>
      respectively override the INSERT statement, UPDATE statement, DELETE
      statement, DELETE statement to remove all entities.</para>

      <para>If you expect to call a store procedure, be sure to set the
      <literal>callable</literal> attribute to true
      (<literal>@SQLInsert(callable=true, ...)</literal>).</para>

      <para>To check that the execution happens correctly, Hibernate allows
      you to define one of those three strategies:</para>

      <itemizedlist>
        <listitem>
          <para>NONE: no check is performed: the store procedure is expected
          to fail upon issues</para>
        </listitem>

        <listitem>
          <para>COUNT: use of rowcount to check that the update is
          successful</para>
        </listitem>

        <listitem>
          <para>PARAM: like COUNT but using an output parameter rather that
          the standard mechanism</para>
        </listitem>
      </itemizedlist>

      <para>To define the result check style, use the <literal>check</literal>
      parameter (<literal>@SQLUpdate(check=ResultCheckStyle.COUNT,
      ...)</literal>).</para>

      <para>You can also override the SQL load statement by a native SQL query
      or a HQL query. You just have to refer to a named query with the
      <literal><literal>@Loader</literal></literal> annotation.</para>

      <para>You can use the exact same set of annotations to override the
      collection related statements.</para>

      <programlisting language="JAVA" role="JAVA">@OneToMany
@JoinColumn(name="chaos_fk")
@SQLInsert( sql="UPDATE CASIMIR_PARTICULE SET chaos_fk = ? where id = ?")
@SQLDelete( sql="UPDATE CASIMIR_PARTICULE SET chaos_fk = null where id = ?")
private Set&lt;CasimirParticle&gt; particles = new HashSet&lt;CasimirParticle&gt;();</programlisting>

      <para>The parameters order is important and is defined by the order
      Hibernate handle properties. You can see the expected order by enabling
      debug logging for the <literal>org.hibernate.persister.entity</literal>
      level. With this level enabled Hibernate will print out the static SQL
      that is used to create, update, delete etc. entities. (To see the
      expected sequence, remember to not include your custom SQL through
      annotations as that will override the Hibernate generated static
      sql.)</para>

      <para>Overriding SQL statements for secondary tables is also possible
      using <literal>@org.hibernate.annotations.Table</literal> and either (or
      all) attributes <literal>sqlInsert</literal>,
      <literal>sqlUpdate</literal>, <literal>sqlDelete</literal>:</para>

      <programlisting language="JAVA" role="JAVA">@Entity
@SecondaryTables({
    @SecondaryTable(name = "`Cat nbr1`"),
    @SecondaryTable(name = "Cat2"})
@org.hibernate.annotations.Tables( {
    @Table(appliesTo = "Cat", comment = "My cat table" ),
    @Table(appliesTo = "Cat2", foreignKey = @ForeignKey(name="FK_CAT2_CAT"), fetch = FetchMode.SELECT,
        sqlInsert=@SQLInsert(sql="insert into Cat2(storyPart2, id) values(upper(?), ?)") )
} )
public class Cat implements Serializable {</programlisting>

      <para>The previous example also show that you can give a comment to a
      given table (promary or secondary): This comment will be used for DDL
      generation.</para>
    </section>

    <section>
      <title>Tuplizer</title>

      <para><classname>org.hibernate.tuple.Tuplizer</classname>, and its
      sub-interfaces, are responsible for managing a particular representation
      of a piece of data, given that representation's
      <literal>org.hibernate.EntityMode</literal>. If a given piece of data is
      thought of as a data structure, then a tuplizer is the thing which knows
      how to create such a data structure and how to extract values from and
      inject values into such a data structure. For example, for the POJO
      entity mode, the correpsonding tuplizer knows how create the POJO
      through its constructor and how to access the POJO properties using the
      defined property accessors. There are two high-level types of Tuplizers,
      represented by the
      <classname>org.hibernate.tuple.EntityTuplizer</classname> and
      <classname>org.hibernate.tuple.ComponentTuplizer</classname> interfaces.
      EntityTuplizers are responsible for managing the above mentioned
      contracts in regards to entities, while
      <classname>ComponentTuplizers</classname> do the same for components.
      Check the Hibernate reference documentation for more information.</para>

      <para>To define tuplixer in annotations, simply use the
      <literal>@Tuplizer</literal> annotation on the according element</para>

      <programlisting language="JAVA" role="JAVA">@Entity
@Tuplizer(impl = DynamicEntityTuplizer.class)
public interface Cuisine {
    @Id
    @GeneratedValue
    public Long getId();
    public void setId(Long id);

    public String getName();
    public void setName(String name);

    @Tuplizer(impl = DynamicComponentTuplizer.class)
    public Country getCountry();
    public void setCountry(Country country);
}</programlisting>
    </section>

    <section>
      <title>Fetch profiles</title>

      <para>In <xref linkend="section-lazy-options-fetching-modes" /> we have
      seen how to affect the fetching strategy for associated objects using
      the <classname>@Fetch</classname> annotation. An alternative approach is
      a so called fetch profile. A fetch profile is a named configuration
      associated with the <classname>org.hibernate.SessionFactory</classname>
      which gets enabled on the <classname>org.hibernate.Session.</classname>
      Once enabled on a <classname>org.hibernate.Session</classname>, the
      fetch profile will be in affect for that session until it is explicitly
      disabled. Lets look at an example:</para>

      <programlisting language="JAVA" role="JAVA">@Entity
@FetchProfile(name = "customer-with-orders", fetchOverrides = {
   @FetchProfile.FetchOverride(entity = Customer.class, association = "orders", mode = FetchMode.JOIN)
})
public class Customer {
   @Id
   @GeneratedValue
   private long id;

   private String name;

   private long customerNumber;

   @OneToMany
   private Set&lt;Order&gt; orders;

   // standard getter/setter
   ...
}</programlisting>

      <para>In the normal case the orders association would be lazy loaded by
      Hibernate, but in a usecase where it is more efficient to load the
      customer and their orders together you could do something like
      this:</para>

      <programlisting language="JAVA" role="JAVA">Session session = ...;
session.enableFetchProfile( "customer-with-orders" );  // name matches @FetchProfile name
Customer customer = (Customer) session.get( Customer.class, customerId );
session.disableFetchProfile( "customer-with-orders" ); // or just close the session
...</programlisting>

      <note>
        <para>Fetch profile definitions are global and it does not matter on
        which class you place them. You can place the
        <classname>@FetchProfile</classname> annotation either onto a class or
        package (package-info.java). In order to define multiple fetch
        profiles for the same class or package
        <classname>@FetchProfiles</classname> can be used.</para>
      </note>

      <para>Currently only join style fetch profiles are supported, but they
      plan is to support additional styles. See <ulink
      url="http://opensource.atlassian.com/projects/hibernate/browse/HHH-3414">HHH-3414</ulink>
      for details. Refer also to the discussion about fetch profiles in the
      Hibernate Core documentation.</para>
    </section>
  </section>
</chapter>
