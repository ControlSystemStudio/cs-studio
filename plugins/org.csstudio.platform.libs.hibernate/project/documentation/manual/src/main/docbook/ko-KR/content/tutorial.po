msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-04T04:51:22\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, no-c-format
msgid "Tutorial"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Intended for new users, this chapter provides an step-by-step introduction "
"to Hibernate, starting with a simple application using an in-memory "
"database. The tutorial is based on an earlier tutorial developed by Michael "
"Gloegl. All code is contained in the <filename>tutorials/web</filename> "
"directory of the project source."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"This tutorial expects the user have knowledge of both Java and SQL. If you "
"have a limited knowledge of JAVA or SQL, it is advised that you start with a "
"good introduction to that technology prior to attempting to learn Hibernate."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"The distribution contains another example application under the "
"<filename>tutorial/eg</filename> project source directory."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Part 1 - The first Hibernate Application"
msgstr "파트 1 - 첫 번째 Hibernate 어플리케이션"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For this example, we will set up a small database application that can store "
"events we want to attend and information about the host(s) of these events."
msgstr ""
"우리가 우리가 수반하고자 원하는 이벤트들을 저장할 수 있는 작은 데이터베이스 "
"어플리케이션과 이들 이벤트들의 호스트들에 대한 정보를 필요로 한다고 가정하자."

#. Tag: para
#, no-c-format
msgid ""
"Although you can use whatever database you feel comfortable using, we will "
"use <ulink url=\"http://hsqldb.org/\">HSQLDB</ulink> (an in-memory, Java "
"database) to avoid describing installation/setup of any particular database "
"servers."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Setup"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"The first thing we need to do is to set up the development environment. We "
"will be using the \"standard layout\" advocated by alot of build tools such "
"as <ulink url=\"http://maven.org\">Maven</ulink>. Maven, in particular, has "
"a good resource describing this <ulink url=\"http://maven.apache.org/guides/"
"introduction/introduction-to-the-standard-directory-layout.html\">layout</"
"ulink>. As this tutorial is to be a web application, we will be creating and "
"making use of <filename>src/main/java</filename>, <filename>src/main/"
"resources</filename> and <filename>src/main/webapp</filename> directories."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"We will be using Maven in this tutorial, taking advantage of its transitive "
"dependency management capabilities as well as the ability of many IDEs to "
"automatically set up a project for us based on the maven descriptor."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"It is not a requirement to use Maven. If you wish to use something else to "
"build this tutoial (such as Ant), the layout will remain the same. The only "
"change is that you will need to manually account for all the needed "
"dependencies. If you use something like <ulink url=\"http://ant.apache.org/"
"ivy/\">Ivy</ulink> providing transitive dependency management you would "
"still use the dependencies mentioned below. Otherwise, you'd need to grab "
"<emphasis>all</emphasis> dependencies, both explicit and transitive, and add "
"them to the project's classpath. If working from the Hibernate distribution "
"bundle, this would mean <filename>hibernate3.jar</filename>, all artifacts "
"in the <filename>lib/required</filename> directory and all files from either "
"the <filename>lib/bytecode/cglib</filename> or <filename>lib/bytecode/"
"javassist</filename> directory; additionally you will need both the servlet-"
"api jar and one of the slf4j logging backends."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Save this file as <filename>pom.xml</filename> in the project root directory."
msgstr ""

#. Tag: title
#, no-c-format
msgid "The first class"
msgstr "첫 번째 클래스"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Next, we create a class that represents the event we want to store in the "
"database; it is a simple JavaBean class with some properties:"
msgstr ""
"다음으로 우리는 우리가 데이터베이스 속에 저장시키고자 원하는 이벤트를 표현하"
"는 한 개의 클래스를 생성시킨다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This class uses standard JavaBean naming conventions for property getter and "
"setter methods, as well as private visibility for the fields. Although this "
"is the recommended design, it is not required. Hibernate can also access "
"fields directly, the benefit of accessor methods is robustness for "
"refactoring."
msgstr ""
"당신은 이 클래스가 프로퍼티 getter와 setter 메소드들에 대한 표준 자바빈즈 명"
"명법들 뿐만 아니라 필드들에 대한 private 가시성을 사용하고 있음을 알 수 있"
"다. 이것은 권장되는 설계이지만, 필수적이지는 않다. Hibernate는 또한 필드들에 "
"직접 접근할 수 있으며, accessor 메소드들의 이점은 강건한 리팩토링이다. 아규먼"
"트 없는 생성자는 reflection을 통해 이 클래스의 객체를 초기화 시킬 필요가 있"
"다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>id</literal> property holds a unique identifier value for a "
"particular event. All persistent entity classes (there are less important "
"dependent classes as well) will need such an identifier property if we want "
"to use the full feature set of Hibernate. In fact, most applications, "
"especially web applications, need to distinguish objects by identifier, so "
"you should consider this a feature rather than a limitation. However, we "
"usually do not manipulate the identity of an object, hence the setter method "
"should be private. Only Hibernate will assign identifiers when an object is "
"saved. Hibernate can access public, private, and protected accessor methods, "
"as well as public, private and protected fields directly. The choice is up "
"to you and you can match it to fit your application design."
msgstr ""
"<literal>id</literal> 프로퍼티는 특별한 이벤트를 위한 유일 식별자를 소유한"
"다. 모든 영속 엔티티 클래스들 (보다 덜 중요한 종속 클래스들도 존재한다)은 우"
"리가 Hibernate의 전체 특징 집합을 사용하고자 원할 경우에 그런 식별자 프로퍼티"
"를 필요로 할 것이다. 사실 대부분의 어플리케이션들(특히 웹 어플리케이션들)은 "
"식별자에 의해 객체들을 구분지을 필요가 있어서, 당신은 이것을 어떤 제약점이라"
"기 보다는 하나의 특징으로 간주할 것이다. 하지만 우리는 대개 객체의 항등"
"(identity)를 처리하지 않으므로, setter 메소드는 private이어야 한다. 객체가 저"
"장될 때, Hibernate는 단지 식별자들을 할당할 것이다. 당신은 Hibernate가 "
"public, private, protected 접근자 메소드들 뿐만 아니라 (public, private, "
"protected) 필드들에도 직접 접근할 수 있음을 알 수 있다. 선택은 당신에게 달려 "
"있으며, 당신은 당신의 어플리케이션 설계에 적합하도록 그것을 부합시킬 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The no-argument constructor is a requirement for all persistent classes; "
"Hibernate has to create objects for you, using Java Reflection. The "
"constructor can be private, however package or public visibility is required "
"for runtime proxy generation and efficient data retrieval without bytecode "
"instrumentation."
msgstr ""
"아규먼트 없는 생성자는 모든 영속 클래스들에 대한 필요조건이다; Hibernate는 당"
"신을 위해 Java Reflection을 사용하여 객체들을 생성시켜야 한다. 하지만 생성자"
"는 private 일 수 있고, 패키지 가시성은 런타임 프락시 생성과 바이트코드 방편 "
"없는 효율적인 데이터 검색에 필요하다."

#. Tag: para
#, no-c-format
msgid ""
"Save this file to the <filename>src/main/java/org/hibernate/tutorial/domain</"
"filename> directory."
msgstr ""

#. Tag: title
#, no-c-format
msgid "The mapping file"
msgstr "The mapping file"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate needs to know how to load and store objects of the persistent "
"class. This is where the Hibernate mapping file comes into play. The mapping "
"file tells Hibernate what table in the database it has to access, and what "
"columns in that table it should use."
msgstr ""
"Hibernate는 영속 크래스들에 대한 객체들을 로드시키고 저장시키는 방법을 알 필"
"요가 있다. 이곳은 Hibernate 매핑 파일이 역할을 행하는 곳이다. 매핑 파일은 "
"Hibernate가 접근해야 하는 데이터베이스 내의 테이블이 무엇인지, 그리고 그것이 "
"사용해야 하는 그 테이블 내의 컬럼들이 무엇인지를 Hibernate에게 알려준다."

#. Tag: para
#, no-c-format
msgid "The basic structure of a mapping file looks like this:"
msgstr "매핑 파일의 기본 구조는 다음과 같다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate DTD is sophisticated. You can use it for auto-completion of XML "
"mapping elements and attributes in your editor or IDE. Opening up the DTD "
"file in your text editor is the easiest way to get an overview of all "
"elements and attributes, and to view the defaults, as well as some comments. "
"Hibernate will not load the DTD file from the web, but first look it up from "
"the classpath of the application. The DTD file is included in "
"<filename>hibernate-core.jar</filename> (it is also included in the "
"<filename>hibernate3.jar</filename>, if using the distribution bundle)."
msgstr ""
"Hibernate DTD는 매우 정교하다. 당신은 당신의 편집기 또는 IDE 내에서 XML 매핑 "
"요소들과 속성들에 대한 자동 완성 기능을 위해 그것을 사용할 수 있다. 당신은 또"
"한 당신의 텍스트 편집기 내에 DTD 파일을 열 수 있을 것이다 - 그것은 모든 요소"
"들과 속성들에 대한 전체상을 얻고 디폴트들 뿐만 아니라 몇몇 주석들을 보는 가"
"장 손쉬운 방법이다. Hibernate는 웹으로부터 DTD 파일을 로드시키지 않지만, 먼"
"저 어플리케이션의 classpath 경로로부터 그것을 먼저 룩업할 것임을 노트하라. "
"DTD 파일은 <literal>hibernate3.jar</literal> 속에 포함되어 있을 뿐만 아니라 "
"Hibernate 배포본의 <literal>src/</literal> 디렉토리 속에 포함되어 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"We will omit the DTD declaration in future examples to shorten the code. It "
"is, of course, not optional."
msgstr ""
"우리는 코드를 간략화 시키기 위해 장래의 예제에서 DTD 선언을 생략할 것이다. 그"
"것은 물론 옵션이 아니다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Between the two <literal>hibernate-mapping</literal> tags, include a "
"<literal>class</literal> element. All persistent entity classes (again, "
"there might be dependent classes later on, which are not first-class "
"entities) need a mapping to a table in the SQL database:"
msgstr ""
"두 개의 <literal>hibernate-mapping</literal> 태그들 사이에 <literal>class</"
"literal> 요소를 포함시켜라. 모든 영속 엔티티 클래스들(다시금 종속 클래스들일 "
"수 있고, 그것은 첫번째-급의 엔티티들이 아니다)은 SQL 데이터베이스 내의 테이블"
"에 대한 그런 매핑을 필요로 한다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"So far we have told Hibernate how to persist and load object of class "
"<literal>Event</literal> to the table <literal>EVENTS</literal>. Each "
"instance is now represented by a row in that table. Now we can continue by "
"mapping the unique identifier property to the tables primary key. As we do "
"not want to care about handling this identifier, we configure Hibernate's "
"identifier generation strategy for a surrogate primary key column:"
msgstr ""
"지금까지 우리는 그 테이블 내에 있는 한 행에 의해 표현된 각각의 인스턴스인, 클"
"래스의 객체를 영속화 시키고 로드시키는 방법을 Hibernate에게 알려주었다. 이제 "
"우린느 테이블 프라이머리 키에 대한 유일 식별자 프로퍼티 매핑을 계속 행한다. "
"게다가 우리는 이 식별자를 처리하는 것에 주의를 기울이고자 원하지 않으므로, 우"
"리는 대용 키 프라이머리 키 컬럼에 대한 Hibernate의 식별자 생성 방도를 구성한"
"다:"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>id</literal> element is the declaration of the identifier "
"property. The <literal>name=\"id\"</literal> mapping attribute declares the "
"name of the JavaBean property and tells Hibernate to use the <literal>getId()"
"</literal> and <literal>setId()</literal> methods to access the property. "
"The column attribute tells Hibernate which column of the <literal>EVENTS</"
"literal> table holds the primary key value."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"The nested <literal>generator</literal> element specifies the identifier "
"generation strategy (aka how are identifier values generated?). In this case "
"we choose <literal>native</literal>, which offers a level of portability "
"depending on the configured database dialect. Hibernate supports database "
"generated, globally unique, as well as application assigned, identifiers. "
"Identifier value generation is also one of Hibernate's many extension points "
"and you can plugin in your own strategy."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"<literal>native</literal> is no longer consider the best strategy in terms "
"of portability. for further discussion, see <xref linkend=\"portability-idgen"
"\" />"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Lastly, we need to tell Hibernate about the remaining entity class "
"properties. By default, no properties of the class are considered persistent:"
msgstr ""
"마지막으로 우리는 매핑 파일 속에서 클래스의 영속 프로퍼티들에 대한 선언들을 "
"포함한다. 디폴트로, 클래스의 프로퍼티들은 영속적인 것으로 간주되지 않는다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Similar to the <literal>id</literal> element, the <literal>name</literal> "
"attribute of the <literal>property</literal> element tells Hibernate which "
"getter and setter methods to use. In this case, Hibernate will search for "
"<literal>getDate()</literal>, <literal>setDate()</literal>, <literal>getTitle"
"()</literal> and <literal>setTitle()</literal> methods."
msgstr ""
"<literal>id</literal> 요소의 경우처럼, <literal>property</literal> 요소의 "
"<literal>name</literal> 속성은 사용할 getter 및 setter 메소드들이 어느 것인지"
"를 Hibernate에게 알려준다. 따라서 이 경우에 Hibernate는 <literal>getDate()/"
"setDate()</literal> 뿐만 아니라 <literal>getTitle()/setTitle()</literal>을 찾"
"게 될 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Why does the <literal>date</literal> property mapping include the "
"<literal>column</literal> attribute, but the <literal>title</literal> does "
"not? Without the <literal>column</literal> attribute, Hibernate by default "
"uses the property name as the column name. This works for <literal>title</"
"literal>, however, <literal>date</literal> is a reserved keyword in most "
"databases so you will need to map it to a different name."
msgstr ""
"<literal>date</literal> 프로퍼티 매핑은 <literal>column</literal> 속성을 포함"
"하는데, 왜 <literal>title</literal>은 <literal>column</literal> 속성을 포함하"
"지 않는가? <literal>column</literal> 속성이 없을 경우 Hibernate는 디폴트로 컬"
"럼 이름으로서 프로퍼티 이름을 사용한다. 이것은 에 대해 잘 동작한다. 하지만 "
"<literal>date</literal>는 대부분의 데이터베이스에서 예약된 키워드이어서, 우리"
"는 그것을 다른 이름으로 더 좋게 매핑 시킨다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>title</literal> mapping also lacks a <literal>type</literal> "
"attribute. The types declared and used in the mapping files are not Java "
"data types; they are not SQL database types either. These types are called "
"<emphasis>Hibernate mapping types</emphasis>, converters which can translate "
"from Java to SQL data types and vice versa. Again, Hibernate will try to "
"determine the correct conversion and mapping type itself if the "
"<literal>type</literal> attribute is not present in the mapping. In some "
"cases this automatic detection using Reflection on the Java class might not "
"have the default you expect or need. This is the case with the "
"<literal>date</literal> property. Hibernate cannot know if the property, "
"which is of <literal>java.util.Date</literal>, should map to a SQL "
"<literal>date</literal>, <literal>timestamp</literal>, or <literal>time</"
"literal> column. Full date and time information is preserved by mapping the "
"property with a <literal>timestamp</literal> converter."
msgstr ""
"다음 흥미로운 점은 <literal>title</literal> 매핑 또한 <literal>type</"
"literal> 속성을 갖지 않는다. 우리가 매핑파일들 속에서 선언하고 사용하는 타입"
"들은 당신이 예상하는 Java 데이터 타입들이 아니다. 그것들은 또한 SQL 데이터베"
"이스 타입들도 아니다. 이들 타입들은 이른바 <emphasis>Hibernate 매핑 타입들</"
"emphasis>, 즉 Java 타입들로부터 SQL 타입들로 변환될 수 있고 반대로 SQL 타입들"
"로부터 Java 타입들로 매핑될 수 있는 컨버터들이다. 다시말해, <literal>type</"
"literal> 속성이 매핑 속에 존재하지 않을 경우 Hibernate는 정확환 변환 및 매핑 "
"타입 그 자체를 결정하려고 시도할 것이다. 몇몇 경우들에서 (Java 클래스에 대한 "
"Reflection을 사용하는) 이 자동적인 검출은 당신이 예상하거나 필요로 하는 디폴"
"트를 갖지 않을 수도 있다. 이것은 <literal>date</literal> 프로퍼티를 가진 경우"
"이다. Hibernate는 그 프로퍼티가 SQL <literal>date</literal> 컬럼, "
"<literal>timestamp</literal> 컬럼 또는 <literal>time</literal> 컬럼 중 어느 "
"것으로 매핑되어야 하는지를 알 수가 없다. 우리는 <literal>timestamp</literal> "
"컨버터를 가진 프로퍼티를 매핑함으로써 전체 날짜와 시간 정보를 보존하고 싶다"
"고 선언한다."

#. Tag: para
#, no-c-format
msgid ""
"Hibernate makes this mapping type determination using reflection when the "
"mapping files are processed. This can take time and resources, so if startup "
"performance is important you should consider explicitly defining the type to "
"use."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Save this mapping file as <filename>src/main/resources/org/hibernate/"
"tutorial/domain/Event.hbm.xml</filename>."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Hibernate configuration"
msgstr "Hibernate 구성"

#. Tag: para
#, no-c-format
msgid ""
"At this point, you should have the persistent class and its mapping file in "
"place. It is now time to configure Hibernate. First let's set up HSQLDB to "
"run in \"server mode\""
msgstr ""

#. Tag: para
#, no-c-format
msgid "We do this do that the data remains between runs."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"We will utilize the Maven exec plugin to launch the HSQLDB server by "
"running: <command> mvn exec:java -Dexec.mainClass=\"org.hsqldb.Server\" -"
"Dexec.args=\"-database.0 file:target/data/tutorial\"</command> You will see "
"it start up and bind to a TCP/IP socket; this is where our application will "
"connect later. If you want to start with a fresh database during this "
"tutorial, shutdown HSQLDB, delete all files in the <filename>target/data</"
"filename> directory, and start HSQLDB again."
msgstr ""
"개발 디렉토리의 루트에 <literal>data</literal>로 명명된 디렉토리를 생성시켜"
"라 - 이 디렉토리는 HSQL DB가 그것의 데이터 파일들을 저장하게 될 장소이다. 이"
"제 이 데이터 디렉토리에서 <literal>java -classpath ../lib/hsqldb.jar org."
"hsqldb.Server</literal>를 실행시켜서 데이터베이스를 시작시켜라. 당신은 그것"
"이 시작되고 이것은 우리의 어플리케이션이 나중에 연결하게 될 장소인, 하나의 "
"TCP/IP 소켓에 바인드 되는 것을 볼 수 있다. 만일 이 튜토리얼 동안에 당신이 새 "
"데이터베이스로 시작하고자 원할 경우, HSQL DB를 셧다운시키고(왼도우에서 "
"<literal>CTRL + C</literal>를 눌러라), <literal>data/</literal> 디렉토리 내"
"에 있는 모든 파일들을 삭제하고 다시 HSQL DB를 시작하라."

#. Tag: para
#, no-c-format
msgid ""
"Hibernate will be connecting to the database on behalf of your application, "
"so it needs to know how to obtain connections. For this tutorial we will be "
"using a standalone connection pool (as opposed to a <interfacename>javax.sql."
"DataSource</interfacename>). Hibernate comes with support for two third-"
"party open source JDBC connection pools: <ulink url=\"https://sourceforge."
"net/projects/c3p0\">c3p0</ulink> and <ulink url=\"http://proxool.sourceforge."
"net/\">proxool</ulink>. However, we will be using the Hibernate built-in "
"connection pool for this tutorial."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"The built-in Hibernate connection pool is in no way intended for production "
"use. It lacks several features found on any decent connection pool."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For Hibernate's configuration, we can use a simple <literal>hibernate."
"properties</literal> file, a more sophisticated <literal>hibernate.cfg.xml</"
"literal> file, or even complete programmatic setup. Most users prefer the "
"XML configuration file:"
msgstr ""
"Hibernate의 구성을 위해, 우리는 한 개의 간단한 <literal>hibernate."
"properties</literal> 파일, 한 개의 약간 더 세련된 <literal>hibernate.cfg."
"xml</literal> 파일, 또는 심지어 완전한 프로그램 상의 설정을 사용할 수 있다. "
"대부분의 사용자들은 XMl 구성 파일을 선호한다:"

#. Tag: para
#, no-c-format
msgid "Notice that this configuration file specifies a different DTD"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You configure Hibernate's <literal>SessionFactory</literal>. SessionFactory "
"is a global factory responsible for a particular database. If you have "
"several databases, for easier startup you should use several <literal>&lt;"
"session-factory&gt;</literal> configurations in several configuration files."
msgstr ""
"이 XML 구성이 다른 DTD를 사용함을 노트하라. 우리는 Hibernate의 "
"<literal>SessionFactory</literal> -특정 데이터베이스에 대해 책임이 있는 전역 "
"팩토리-를 구성한다. 만일 당신이 여러 데이터베이스들을 갖고 있다면, (보다 쉬"
"운 시작을 위해) 몇 개의 구성 파일들 속에 여러 개의 <literal>&lt;session-"
"factory&gt;</literal> 구성들을 사용하라."

#. Tag: para
#, no-c-format
msgid ""
"The first four <literal>property</literal> elements contain the necessary "
"configuration for the JDBC connection. The dialect <literal>property</"
"literal> element specifies the particular SQL variant Hibernate generates."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"In most cases, Hibernate is able to properly determine which dialect to use. "
"See <xref linkend=\"portability-dialectresolver\" /> for more information."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate's automatic session management for persistence contexts is "
"particularly useful in this context. The <literal>hbm2ddl.auto</literal> "
"option turns on automatic generation of database schemas directly into the "
"database. This can also be turned off by removing the configuration option, "
"or redirected to a file with the help of the <literal>SchemaExport</literal> "
"Ant task. Finally, add the mapping file(s) for persistent classes to the "
"configuration."
msgstr ""
"처음 네 개의 <literal>property</literal> 요소들은 JDBC 커넥션을 위한 필수 구"
"성을 포함한다. dialect <literal>property</literal> 요소는 Hibernate가 발생시"
"키는 특별한 SQL 이형(異形)을 지정한다. <literal>hbm2ddl.auto</literal> 옵션"
"은 -직접 데이터베이스 속으로- 데이터베이스 스키마의 자동적인 생성을 활성화 시"
"킨다. 물론 이것은 (config 옵션을 제거함으로써) 비활성화 시킬 수 있거나 "
"<literal>SchemaExport</literal> Ant 태스크의 도움으로 파일로 리다이렉트 될 "
"수 있다. 마지막으로 우리는 영속 클래스들을 위한 매핑 파일(들)을 추가시킨다."

#. Tag: para
#, no-c-format
msgid ""
"Save this file as <filename>hibernate.cfg.xml</filename> into the "
"<filename>src/main/resources</filename> directory."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Building with Maven"
msgstr "Ant로 빌드하기"

#. Tag: para
#, no-c-format
msgid ""
"We will now build the tutorial with Maven. You will need to have Maven "
"installed; it is available from the <ulink url=\"http://maven.apache.org/"
"download.html\">Maven download page</ulink>. Maven will read the <filename>/"
"pom.xml</filename> file we created earlier and know how to perform some "
"basic project tasks. First, lets run the <literal>compile</literal> goal to "
"make sure we can compile everything so far:"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Startup and helpers"
msgstr "시작과 helper들"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is time to load and store some <literal>Event</literal> objects, but "
"first you have to complete the setup with some infrastructure code. You have "
"to startup Hibernate by building a global <interfacename>org.hibernate."
"SessionFactory</interfacename> object and storing it somewhere for easy "
"access in application code. A <interfacename>org.hibernate.SessionFactory</"
"interfacename> is used to obtain <interfacename>org.hibernate.Session</"
"interfacename> instances. A <interfacename>org.hibernate.Session</"
"interfacename> represents a single-threaded unit of work. The "
"<interfacename>org.hibernate.SessionFactory</interfacename> is a thread-safe "
"global object that is instantiated once."
msgstr ""
"몇몇 <literal>Event</literal> 객체들을 로드시키고 저장할 차례이지만, 먼저 우"
"리는 어떤 인프라스트럭처 코드로 설정을 완료해야 한다. 우리는 Hibernate를 시작"
"해야 한다. 이 시작은 전역 <literal>SessionFactory</literal> 객체를 빌드하고 "
"어플리케이션 내에서 용이한 접근을 위해 그것을 어떤 곳에 저장하는 것을 포함한"
"다. <literal>SessionFactory</literal>는 새로운 <literal>Session</literal>들"
"을 열 수 있다. <literal>Session</literal>은 작업의 단일-쓰레드 단위를 표현하"
"며, <literal>SessionFactory</literal>는 한번 초기화 되는 하나의 thread-safe "
"전역 객체이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"We will create a <literal>HibernateUtil</literal> helper class that takes "
"care of startup and makes accessing the <interfacename>org.hibernate."
"SessionFactory</interfacename> more convenient."
msgstr ""
"우리는 시작을 처리하고 <literal>Session</literal> 처리를 편리하게 해주는 "
"<literal>HibernateUtil</literal> helper 클래스를 생성시킬 것이다. 이른바 "
"<emphasis>ThreadLocal Session</emphasis> 패턴이 여기서 유용하며, 우리는 현재"
"의 작업 단위를 현재의 쓰레드와 연관지워 유지한다. 구현을 살펴보자:"

#. Tag: para
#, no-c-format
msgid ""
"Save this code as <filename>src/main/java/org/hibernate/tutorial/util/"
"HibernateUtil.java</filename>"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This class not only produces the global <interfacename>org.hibernate."
"SessionFactory</interfacename> reference in its static initializer; it also "
"hides the fact that it uses a static singleton. We might just as well have "
"looked up the <interfacename>org.hibernate.SessionFactory</interfacename> "
"reference from JNDI in an application server or any other location for that "
"matter."
msgstr ""
"이 클래스는 (클래스가 로드될 때 JVM에 의해 한번 호출되는) 그것의 static 초기"
"자 내에 전역 <literal>SessionFactory</literal>를 산출할 뿐만 아니라 또한 현"
"재 쓰레드에 대한 <literal>Session</literal>을 소유하는 <literal>ThreadLocal</"
"literal> 변수를 갖는다. 당신이 <literal>HibernateUtil.getCurrentSession()</"
"literal>을 호출하는 시점에는 문제가 없으며, 그것은 항상 동일 쓰레드 내에 동일"
"한 Hibernate 작업 단위를 반환할 것이다. <literal>HibernateUtil.closeSession()"
"</literal>에 대한 호출은 쓰레드와 현재 연관되어 있는 작업 단위를 종료시킨다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you give the <interfacename>org.hibernate.SessionFactory</interfacename> "
"a name in your configuration, Hibernate will try to bind it to JNDI under "
"that name after it has been built. Another, better option is to use a JMX "
"deployment and let the JMX-capable container instantiate and bind a "
"<literal>HibernateService</literal> to JNDI. Such advanced options are "
"discussed later."
msgstr ""
"당신이 이 helper를 사용하기 전에 thread-local 변수들에 대한 Java 개념을 확실"
"히 이해하도록 하라. 보다 강력한 <literal>HibernateUtil</literal> helper는 "
"http://caveatemptor.hibernate.org/에 있는 <literal>CaveatEmptor</literal> 뿐"
"만 아니라 \"Java Persistence with Hibernate\" 책에서 찾을 수 있다. 당신이 "
"J2EE 어플리케이션 서버 내에 Hibernate를 배치할 경우에 이 클래스는 필수적이지 "
"않다: 하나의 <literal>Session</literal>은 현재의 JTA 트랜잭션에 자동적으로 바"
"인드 될 것이고 당신은 JNDI를 통해 <literal>SessionFactory</literal>를 룩업할 "
"수 있다. 만일 당신이 JBoss AS를 사용할 경우, Hibernate는 관리되는 시스템 서비"
"스로서 배치될 수 있고 <literal>SessionFactory</literal>를 JNDI 이름에 자동적"
"으로 바인드시킬 수 있을 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You now need to configure a logging system. Hibernate uses commons logging "
"and provides two choices: Log4j and JDK 1.4 logging. Most developers prefer "
"Log4j: copy <literal>log4j.properties</literal> from the Hibernate "
"distribution in the <literal>etc/</literal> directory to your <literal>src</"
"literal> directory, next to <literal>hibernate.cfg.xml</literal>. If you "
"prefer to have more verbose output than that provided in the example "
"configuration, you can change the settings. By default, only the Hibernate "
"startup message is shown on stdout."
msgstr ""
"이것은 문제 없이 다시 컴파일 될 것이다. 우리는 마지막으로 로깅 시스템을 구성"
"할 필요가 있다 - Hibernate는 commons logging를 사용하고 Log4j와 JDK 1.4 사이"
"의 선택은 당신의 몫으로 남겨둔다. 대부분의 개발자들은 Log4j를 선호한다: "
"Hibernate 배포본에 있는 <literal>log4j.properties</literal>(이것은 디렉토리 "
"<literal>etc/</literal> 내에 있다)를 <literal>src</literal> 디렉토리로 복사하"
"고, 다음으로 <literal>hibernate.cfg.xml</literal>을 복사하라. 예제 구성을 살"
"펴보고 당신이 더 많은 verbose 출력을 원할 경우에 설정들을 변경하라. 디폴트로 "
"Hibernate 시작 메시지는 stdout 상에 보여진다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The tutorial infrastructure is complete and you are now ready to do some "
"real work with Hibernate."
msgstr ""
"튜토리얼 인프라스트럭처는 완전하다 - 그리고 우리는 Hibernate로 어떤 실제 작업"
"을 행할 준비가 되어 있다."

#. Tag: title
#, no-c-format
msgid "Loading and storing objects"
msgstr "객체 로딩과 객체 저장"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"We are now ready to start doing some real worjk with Hibernate. Let's start "
"by writing an <literal>EventManager</literal> class with a <literal>main()</"
"literal> method:"
msgstr ""
"마지막으로 우리는 객체들을 로드시키고 저장하는데 Hibernate를 사용할 수 있다. "
"우리는 한 개의 <literal>main()</literal> 메소드를 가진 한 개의 "
"<literal>EventManager</literal> 클래스를 작성한다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"In <literal>createAndStoreEvent()</literal> we created a new <literal>Event</"
"literal> object and handed it over to Hibernate. At that point, Hibernate "
"takes care of the SQL and executes an <literal>INSERT</literal> on the "
"database."
msgstr ""
"우리는 한 개의 새로운 <literal>Event</literal> 객체를 생성시키고, 그것을 "
"Hibernate에게 건네준다. Hibernate는 이제 SQL을 처리하고 데이터베이스 상에서 "
"<literal>INSERT</literal>들을 실행시킨다. -우리가 이것을 실행하기 전에 코드"
"를 처리하는- <literal>Session</literal>과 <literal>Transaction</literal>을 살"
"펴보자."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A <interface>org.hibernate.Session</interface> is designed to represent a "
"single unit of work (a single atmoic piece of work to be performed). For now "
"we will keep things simple and assume a one-to-one granularity between a "
"Hibernate <interface>org.hibernate.Session</interface> and a database "
"transaction. To shield our code from the actual underlying transaction "
"system we use the Hibernate <interfacename>org.hibernate.Transaction</"
"interfacename> API. In this particular case we are using JDBC-based "
"transactional semantics, but it could also run with JTA."
msgstr ""
"<literal>Session</literal>은 한 개의 작업 단위이다. 지금부터 우리는 단숨함을 "
"유지할 것이고 Hibernate <literal>Session</literal>과 데이터베이스 트랜잭션 사"
"이의 일-대-일 과립형(granularity)을 가정할 것이다. 실제 기반 트랜잭션 시스템"
"으로부터 우리의 소스를 은폐시키기 위해(이 경우 통상의 JDBC이지만, 그것은 또"
"한 JTA에도 실행된다) 우리는 Hibernate <literal>Session</literal> 상에서 이용 "
"가능한 <literal>Transaction</literal> API를 사용한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"What does <literal>sessionFactory.getCurrentSession()</literal> do? First, "
"you can call it as many times and anywhere you like once you get hold of "
"your <interfacename>org.hibernate.SessionFactory</interfacename>. The "
"<literal>getCurrentSession()</literal> method always returns the \"current\" "
"unit of work. Remember that we switched the configuration option for this "
"mechanism to \"thread\" in our <filename>src/main/resources/hibernate.cfg."
"xml</filename>? Due to that setting, the context of a current unit of work "
"is bound to the current Java thread that executes the application."
msgstr ""
"<literal>sessionFactory.getCurrentSession()</literal>은 무엇을 행하는가? 먼"
"저 당신은 당신이 (<literal>HibernateUtil</literal> 덕분에 쉽게) "
"<literal>SessionFactory</literal>을 당신이 소유하고 있다면, 원하는 만큼 어디"
"서든 여러번 그것을 호출할 수 있다. <literal>getCurrentSession()</literal> 메"
"소드는 항상 \"현재의\" 작업 단위를 반환한다. 우리가 <literal>hibernate.cfg."
"xml</literal> 내에서 이 매커니즘에 대한 구성 옵션을 \"thread\"로 전환시켰음"
"을 기억하는가? 그러므로 작업의 현재 단위는 우리의 어플리케이션을 실행시키는 "
"현재 자바 쓰레드에 묶여 있다. 하지만 이것은 전체 그림이 아니며, 당신은 또한 "
"scope(영역), 작업 단위가 시작될 때와 작업 단위가 종료될 때를 고려해야 한다."

#. Tag: para
#, no-c-format
msgid ""
"Hibernate offers three methods of current session tracking. The \"thread\" "
"based method is not intended for production use; it is merely useful for "
"prototyping and tutorials such as this one. Current session tracking is "
"discussed in more detail later on."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A <interface>org.hibernate.Session</interface> begins when the first call to "
"<literal>getCurrentSession()</literal> is made for the current thread. It is "
"then bound by Hibernate to the current thread. When the transaction ends, "
"either through commit or rollback, Hibernate automatically unbinds the "
"<interface>org.hibernate.Session</interface> from the thread and closes it "
"for you. If you call <literal>getCurrentSession()</literal> again, you get a "
"new <interface>org.hibernate.Session</interface> and can start a new unit of "
"work."
msgstr ""
"<literal>Session</literal>은 그것이 처음으로 필요로 되고 "
"<literal>getCurrentSession()</literal>에 대한 첫 번째 호출이 이루어질 때 시작"
"된다. 그때 그것은 Hibernate에 의해 현재의 쓰레드에 바인드 된다. 커밋되든 롤백"
"되든 간에 트랜잭션이 종료되고, Hibernate가 자동적으로 그 쓰레드로부터 "
"<literal>Session</literal>을 바인드 해제시키고 당신을 위해 세션을 닫는다. 만"
"일 당신이 <literal>getCurrentSession()</literal>을 다시 호출한다면, 당신은 새"
"로운 <literal>Session</literal>을 얻고 새로운 작업단위를 시작할 수 있다. 이 "
"<emphasis>thread-bound</emphasis> 프로그래밍 모형은 Hibernate를 사용하는 가"
"장 대중적인 방법이다. 왜냐하면 그것은 당신의 코드를 유연하게 계층화시키는 것"
"을 허용해주기 때문이다(트랜잭션 경계 분할 코드는 데이트 접근 코드와 구별지워"
"질 수 있는데, 우리는 이 튜토리얼의 뒷부분에서 이것을 다룰 것이다.)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Related to the unit of work scope, should the Hibernate <interface>org."
"hibernate.Session</interface> be used to execute one or several database "
"operations? The above example uses one <interface>org.hibernate.Session</"
"interface> for one operation. However this is pure coincidence; the example "
"is just not complex enough to show any other approach. The scope of a "
"Hibernate <interface>org.hibernate.Session</interface> is flexible but you "
"should never design your application to use a new Hibernate <interface>org."
"hibernate.Session</interface> for <emphasis>every</emphasis> database "
"operation. Even though it is used in the following examples, consider "
"<emphasis>session-per-operation</emphasis> an anti-pattern. A real web "
"application is shown later in the tutorial which will help illustrate this."
msgstr ""
"작업 영역의 단위와 관련하여, Hibernate <literal>Session</literal>은 하나 또"
"는 여러 개의 데이터베이스 오퍼레이션들을 실행시키는데 사용될 수 있는가? 위의 "
"예제는 하나의 오퍼레이션에 한 개의 <literal>Session</literal>을 사용하고 있"
"다. 이것은 순진한 일치이며, 예제는 어떤 다른 접근법을 보여주기에는 충분히 복"
"잡하지 않다. Hibernate <literal>Session</literal>의 scope(영역)은 유연하지만 "
"당신은 결코 <emphasis>모든</emphasis> 데이터베이스 오퍼레이션 각각에 대해 새"
"로운 Hibernate <literal>Session</literal>을 사용하도록 당신의 어플리케이션을 "
"설계할 수 없다. 따라서 심지어 당신이 다음의 (매우 사소한) 예제들에서 여러 번 "
"그것을 볼 수 있을지라도 <emphasis>session-per-operation</emphasis>을 하나의 "
"안티-패턴으로 간주하라. 실제 (웹) 어플리케이션은 이 튜토리얼의 뒷부분에 보여"
"진다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"See <xref linkend=\"transactions\" /> for more information about transaction "
"handling and demarcation. The previous example also skipped any error "
"handling and rollback."
msgstr ""
"트랜잭션 핸들링과 경계구분에 대한 추가 정보는 <xref linkend=\"transactions\"/"
">을 살펴보라. 우리는 또한 앞의 예제에서 임의의 오류 처리와 롤백을 생략했다."

#. Tag: para
#, no-c-format
msgid ""
"To run this, we will make use of the Maven exec plugin to call our class "
"with the necessary classpath setup: <command>mvn exec:java -Dexec.mainClass="
"\"org.hibernate.tutorial.EventManager\" -Dexec.args=\"store\"</command>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "You may need to perform <command>mvn compile</command> first."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You should see Hibernate starting up and, depending on your configuration, "
"lots of log output. Towards the end, the following line will be displayed:"
msgstr ""
"컴파일, 구성에 따른 Hibernate 시작 후에, 당신은 많은 로그 출력을 보게 될 것이"
"다. 끝에서 당신은 다음 라인을 발견할 것이다:"

#. Tag: para
#, no-c-format
msgid "This is the <literal>INSERT</literal> executed by Hibernate."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "To list stored events an option is added to the main method:"
msgstr ""
"이제 우리는 마찬가지로 저장된 이벤트들을 열거하고자 원하며, 우리는 main 메소"
"드에 한 개의 옵션을 추가한다:"

#. Tag: para
#, fuzzy, no-c-format
msgid "A new <literal>listEvents() method is also added</literal>:"
msgstr ""
"우리는 또한 새로운 <literal>listEvents() method</literal> 메소드를 추가 시킨"
"다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Here, we are using a Hibernate Query Language (HQL) query to load all "
"existing <literal>Event</literal> objects from the database. Hibernate will "
"generate the appropriate SQL, send it to the database and populate "
"<literal>Event</literal> objects with the data. You can create more complex "
"queries with HQL. See <xref linkend=\"queryhql\" /> for more information."
msgstr ""
"여기서 우리가 행할 것은 데이터베이스로부터 모든 존재하는 <literal>Event</"
"literal> 객체들을 로드시키기 위해 HQL (Hibernate Query Language) 질의를 사용"
"하는 것이다. Hibernate는 적절한 SQL을 생성시킬 것이고, 그것을 데이터베이스로 "
"전송하고 데이터를 <literal>Event</literal> 객체들에 거주시킬 것이다. 당신은 "
"물론 HQL로서 보다 복잡한 질의들을 생성시킬 수 있다."

#. Tag: para
#, no-c-format
msgid ""
"Now we can call our new functionality, again using the Maven exec plugin: "
"<command>mvn exec:java -Dexec.mainClass=\"org.hibernate.tutorial.EventManager"
"\" -Dexec.args=\"list\"</command>"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Part 2 - Mapping associations"
msgstr "파트 2 - 연관들을 매핑하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"So far we have mapped a single persistent entity class to a table in "
"isolation. Let's expand on that a bit and add some class associations. We "
"will add people to the application and store a list of events in which they "
"participate."
msgstr ""
"우리는 한 개의 영속 엔티티 클래스를 한 개의 테이블로 매핑했다. 이것 위에서 빌"
"드하고 몇몇 클래스 연관들을 추가시키자. 먼저 우리는 우리의 어플리케이션에 사"
"람들을 추가하고 그들이 참여하는 이벤트들의 목록을 저장할 것이다."

#. Tag: title
#, no-c-format
msgid "Mapping the Person class"
msgstr "Person 클래스 매핑하기"

#. Tag: para
#, fuzzy, no-c-format
msgid "The first cut of the <literal>Person</literal> class looks like this:"
msgstr "클래스의 첫 번째 장면은 간단하다:"

#. Tag: para
#, no-c-format
msgid ""
"Save this to a file named <filename>src/main/java/org/hibernate/tutorial/"
"domain/Person.java</filename>"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Next, create the new mapping file as <filename>src/main/resources/org/"
"hibernate/tutorial/domain/Person.hbm.xml</filename>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Finally, add the new mapping to Hibernate's configuration:"
msgstr "마지막으로 새로운 매핑을 Hibernate의 구성에 추가하라:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Create an association between these two entities. Persons can participate in "
"events, and events have participants. The design questions you have to deal "
"with are: directionality, multiplicity, and collection behavior."
msgstr ""
"이제 우리는 이들 두 개의 엔티티들 사이에 한 개의 연관을 생성시킬 것이다. 명백"
"하게, 개인들은 이벤트들에 참여할 수 있고, 이벤트들은 참여자들을 갖는다. 우리"
"가 다루어야 하는 설계 질문들은 다음과 같다 : 방향성(directionality), 다중성"
"(multiplicity), 그리고 콜렉션 특징."

#. Tag: title
#, no-c-format
msgid "A unidirectional Set-based association"
msgstr "단방향 Set-기반의 연관"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"By adding a collection of events to the <literal>Person</literal> class, you "
"can easily navigate to the events for a particular person, without executing "
"an explicit query - by calling <literal>Person#getEvents</literal>. Multi-"
"valued associations are represented in Hibernate by one of the Java "
"Collection Framework contracts; here we choose a <interfacename>java.util."
"Set</interfacename> because the collection will not contain duplicate "
"elements and the ordering is not relevant to our examples:"
msgstr ""
"우리는 <literal>Person</literal> 클래스에 이벤트들을 가진 한 개의 콜렉션을 추"
"가할 것이다. 그 방법으로 우리는 명시적인 질의-<literal>aPerson.getEvents()</"
"literal>를 호출함으로써-를 실행시키지 않고서 특정 개인에 대한 이벤트들을 쉽"
"게 네비게이트할 수 있다. 우리는 하나의 Java 콜렉션, 하나의 <literal>Set</"
"literal>를 사용한다. 왜냐하면 그 콜렉션은 중복 요소들을 포함하기 않을 것이고 "
"그 순서가 우리와 관련되어 있지 않기 때문이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Before mapping this association, let's consider the other side. We could "
"just keep this unidirectional or create another collection on the "
"<literal>Event</literal>, if we wanted to be able to navigate it from both "
"directions. This is not necessary, from a functional perspective. You can "
"always execute an explicit query to retrieve the participants for a "
"particular event. This is a design choice left to you, but what is clear "
"from this discussion is the multiplicity of the association: \"many\" valued "
"on both sides is called a <emphasis>many-to-many</emphasis> association. "
"Hence, we use Hibernate's many-to-many mapping:"
msgstr ""
"우리가 이 연관을 매핑하기 전에, 다른 측에 대해 생각하라. 명백하게 우리는 이것"
"을 단지 단방향으로 유지시킬 수 있다. 또는 우리가 그것을 양방향으로 네비게이트"
"하는 것-예를 들어 <literal>anEvent.getParticipants()</literal>-이 가능하도록 "
"원할 경우에, <literal>Event</literal>측 상에 또 다른 콜렉션을 생성시킬 수 있"
"다. 이것은 당신에게 남겨진 설계 선택이지만, 이 논의에서 명료한 점은 연관의 다"
"중성이다: 양 측 상에서 \"다중\" 값을 갖는 경우, 우리는 이것을 <emphasis>many-"
"to-many</emphasis> 연관이라고 명명한다. 그러므로 우리는 Hibernate의 many-to-"
"many 매핑을 사용한다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate supports a broad range of collection mappings, a <literal>set</"
"literal> being most common. For a many-to-many association, or <emphasis>n:"
"m</emphasis> entity relationship, an association table is required. Each row "
"in this table represents a link between a person and an event. The table "
"name is decalred using the <literal>table</literal> attribute of the "
"<literal>set</literal> element. The identifier column name in the "
"association, for the person side, is defined with the <literal>key</literal> "
"element, the column name for the event's side with the <literal>column</"
"literal> attribute of the <literal>many-to-many</literal>. You also have to "
"tell Hibernate the class of the objects in your collection (the class on the "
"other side of the collection of references)."
msgstr ""
"Hibernate는 모든 종류의 콜렉션 매핑들, 가장 공통적인 <literal>&lt;set&gt;</"
"literal>을 지원한다. many-to-many 연관 (또는 <emphasis>n:m</emphasis> 엔티티 "
"관계)의 경우, 한 개의 연관 테이블이 필요하다. 이 테이블 내에 있는 각각의 행"
"은 한 명의 개인과 한 개의 이벤트 사이의 링크를 표현한다. 테이블 이름은 "
"<literal>set</literal> 요소의 <literal>table</literal> 속성으로 구성된다. 연"
"관 내의 식별자 컬럼 이름은 개인 측에 대해 <literal>&lt;key&gt;</literal> 요소"
"로 정의되고 이벤트 측에 대한 컬럼 이름은 <literal>&lt;many-to-many&gt;</"
"literal>의 <literal>column</literal> 속성으로 정의된다. 당신은 또한 당신의 콜"
"렉션 내에 있는 객체들의 클래스(정확하게 : 참조들을 가진 콜렉션의 다른 측 상"
"에 있는 클래스)를 Hibernate에게 알려주어야 한다."

#. Tag: para
#, no-c-format
msgid "The database schema for this mapping is therefore:"
msgstr "따라서 이 매핑을 위한 데이터베이스 스키마는 다음과 같다:"

#. Tag: title
#, no-c-format
msgid "Working the association"
msgstr "연관들에 작업하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Now we will bring some people and events together in a new method in "
"<literal>EventManager</literal>:"
msgstr ""
"<literal>EventManager</literal> 속에 있는 한 개의 새로운 메소드 내에 몇몇 사"
"람들과 이벤트들을 함께 가져오자:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"After loading a <literal>Person</literal> and an <literal>Event</literal>, "
"simply modify the collection using the normal collection methods. There is "
"no explicit call to <literal>update()</literal> or <literal>save()</"
"literal>; Hibernate automatically detects that the collection has been "
"modified and needs to be updated. This is called <emphasis>automatic dirty "
"checking</emphasis>. You can also try it by modifying the name or the date "
"property of any of your objects. As long as they are in "
"<emphasis>persistent</emphasis> state, that is, bound to a particular "
"Hibernate <interfacename>org.hibernate.Session</interfacename>, Hibernate "
"monitors any changes and executes SQL in a write-behind fashion. The process "
"of synchronizing the memory state with the database, usually only at the end "
"of a unit of work, is called <emphasis>flushing</emphasis>. In our code, the "
"unit of work ends with a commit, or rollback, of the database transaction."
msgstr ""
"<literal>Person</literal>과 <literal>Event</literal>를 로드시킨 후에, 정규 콜"
"렉션 메소드들을 사용하여 콜렉션을 간단하게 변경하라. 당신이 알 수 있듯이, "
"<literal>update()</literal> 또는 <literal>save()</literal>에 대한 명시적인 호"
"출이 존재하지 않고, 변경되었고 저장할 필요가 있는 콜렉션을 Hibernate가 자동적"
"으로 검출해낸다. 이것은 <emphasis>자동적인 dirty 체킹</emphasis>이라 불려지"
"며, 당신은 또한 당신의 임의의 객체들에 대한 name 또는 date 프로퍼티를 변경함"
"으로써 그것을 시도할 수 있다. 그것들이 <emphasis>영속(persistent)</emphasis> "
"상태에 있는 동안, 즉 특정 Hibernate <literal>Session</literal>에 바인드되어 "
"있는 동안(예를 들면. 그것들은 작업 단위 속에 방금 로드되었거나 저장되었다), "
"Hibernate는 임의의 변경들을 모니터링하고 쓰기 이면의 형태로 SQL을 실행시킨"
"다. 메모리 상태를 데이터베이스와 동기화 시키는 과정은 대개 오직 작업 단위의 "
"끝에서이고, <emphasis>flushing</emphasis>이라 명명된다. 우리의 코드에서, 작"
"업 단위는 <literal>CurrentSessionContext</literal> 클래스에 대한 "
"<literal>thread</literal> 구성 옵션에 의해 정의된 대로 - 데이터베이스 트랜잭"
"션의 커밋(또는 롤백)으로 끝이난다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can load person and event in different units of work. Or you can modify "
"an object outside of a <interfacename>org.hibernate.Session</interfacename>, "
"when it is not in persistent state (if it was persistent before, this state "
"is called <emphasis>detached</emphasis>). You can even modify a collection "
"when it is detached:"
msgstr ""
"물론 당신은 다른 작업 단위 속에 개인과 이벤트를 로드시킬 수 도 있다. 또는 당"
"신은 하나의 객체그 영속 상태에 있지 않을 때 <literal>Session</literal>의 외부"
"에서 객체를 변경시킬 수도 있다(만일 객체가 이전에 영속화 되었다면, 우리는 이 "
"상태를 <emphasis>detached</emphasis>라고 부른다). (매우 사실적이지 않은) 코"
"드 내에서 이것은 다음과 같을 수 있다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The call to <literal>update</literal> makes a detached object persistent "
"again by binding it to a new unit of work, so any modifications you made to "
"it while detached can be saved to the database. This includes any "
"modifications (additions/deletions) you made to a collection of that entity "
"object."
msgstr ""
"<literal>update</literal>에 대한 호출은 한 개의 detached 객체를 다시 영속화 "
"시키고, 당신은 그것이 새로운 작업 단위에 바인드된다고 말할 수 있고, 따라서 "
"detached 동안에 당신이 그것에 대해 행한 임의의 변경들이 데이터베이스에 저장"
"될 수 있다. 이것은 당신이 그 엔티티 객체의 콜렉션에 대해 행했던 임의의 변경들"
"(추가/삭제)를 포함한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This is not much use in our example, but it is an important concept you can "
"incorporate into your own application. Complete this exercise by adding a "
"new action to the main method of the <literal>EventManager</literal> and "
"call it from the command line. If you need the identifiers of a person and "
"an event - the <literal>save()</literal> method returns it (you might have "
"to modify some of the previous methods to return that identifier):"
msgstr ""
"물론, 우리의 현재 상황에서 이것은 많이 사용되지 않지만, 그것은 당신이 당신 자"
"신의 어플리케이션 내로 설계할 수 있는 중요한 개념이다. 지금 "
"<literal>EventManager</literal>의 main 메소드에 한 개의 새로운 액션을 추가하"
"고 명령 라인에서 그것을 호출하여 이 연습을 완료하라. 만일 당신이 한명의 개인"
"과 한 개의 이벤트에 대한 식별자들을 필요로 할 경우 - <literal>save()</"
"literal> 메소드가 그것을 반환시킨다(당신은 그 식별자를 반환시키는 앞의 메소드"
"들 중 몇몇을 변경시켜야 할 것이다):"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This is an example of an association between two equally important classes : "
"two entities. As mentioned earlier, there are other classes and types in a "
"typical model, usually \"less important\". Some you have already seen, like "
"an <literal>int</literal> or a <classname>java.lang.String</classname>. We "
"call these classes <emphasis>value types</emphasis>, and their instances "
"<emphasis>depend</emphasis> on a particular entity. Instances of these types "
"do not have their own identity, nor are they shared between entities. Two "
"persons do not reference the same <literal>firstname</literal> object, even "
"if they have the same first name. Value types cannot only be found in the "
"JDK , but you can also write dependent classes yourself such as an "
"<literal>Address</literal> or <literal>MonetaryAmount</literal> class. In "
"fact, in a Hibernate application all JDK classes are considered value types."
msgstr ""
"이것은 두 개의 동등하게 중요한 클래스들, 두 개의 엔티티들 사이에서 한 개의 연"
"관에 관한 예제였다. 앞서 언급했듯이, 전형적인 모형 내에는 다른 클래스들과 타"
"이들이 존재하는데, 대개 \"덜 중요하다\". 당신은 이미 <literal>int</literal> "
"또는 <literal>String</literal>과 같은 어떤 것을 이미 보았다. 우리는 이들 클래"
"스들을 <emphasis>값 타입들(value types)</emphasis>이라 명명하고, 그들 인스턴"
"스들은 특정 엔티티에 <emphasis>의존한다(depend)</emphasis>. 이들 타입들을 가"
"진 인스턴스들은 그것들 자신의 식별성(identity)를 갖지 않거나, 그것들은 엔티티"
"들 사이에서 공유되지도 않는다(두개의 person들은 심지어 그것들이 같은 첫 번째 "
"이름을 갖는 경우에도 동일한 <literal>firstname</literal>을 참조하지 않는"
"다 ). 물론 값 타입들은 JDK 내에서 발견될 뿐만 아니라(사실, Hibernate 어플리케"
"이션에서 모든 JDK 클래스들은 값 타입들로 간주된다), 당신은 또한 당신 스스로 "
"종속 클래스들, 예를 들면 <literal>Address</literal> 또는 "
"<literal>MonetaryAmount</literal>을 작성할 수 있다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can also design a collection of value types. This is conceptually "
"different from a collection of references to other entities, but looks "
"almost the same in Java."
msgstr ""
"당신은 또한 값 타입들을 설계할 수 있다. 이것은 다른 엔티티들에 대한 참조들을 "
"가진 콜렉션과는 개념적으로 매우 다르지만, Java에서는 대개 동일한 것으로 보여"
"진다."

#. Tag: title
#, no-c-format
msgid "Collection of values"
msgstr "값들을 가진 콜렉션"

#. Tag: para
#, no-c-format
msgid ""
"Let's add a collection of email addresses to the <literal>Person</literal> "
"entity. This will be represented as a <interfacename>java.util.Set</"
"interfacename> of <classname>java.lang.String</classname> instances:"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "The mapping of this <literal>Set</literal> is as follows:"
msgstr "이 <literal>Set</literal>에 대한 매핑은 다음과 같다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The difference compared with the earlier mapping is the use of the "
"<literal>element</literal> part which tells Hibernate that the collection "
"does not contain references to another entity, but is rather a collection "
"whose elements are values types, here specifically of type <literal>string</"
"literal>. The lowercase name tells you it is a Hibernate mapping type/"
"converter. Again the <literal>table</literal> attribute of the <literal>set</"
"literal> element determines the table name for the collection. The "
"<literal>key</literal> element defines the foreign-key column name in the "
"collection table. The <literal>column</literal> attribute in the "
"<literal>element</literal> element defines the column name where the email "
"address values will actually be stored."
msgstr ""
"앞의 매핑과 비교한 차이점은 <literal>element</literal> 부분인데, 그것은 그 콜"
"렉션이 또 다른 엔티티에 대한 참조들을 포함하지 않을 것이지만 "
"<literal>String</literal>(소문자 이름은 그것이 Hibernate 매핑 타입/변환자임"
"을 당신에게 말해준다) 타입의 요소들을 가진 한 개의 콜렉션을 포함할 것임을 "
"Hibernate에게 알려준다. 일단 다시 <literal>set</literal> 요소의 "
"<literal>table</literal> 속성은 그 콜렉션에 대한 테이블 이름을 결정한다. "
"<literal>key</literal> 요소는 콜렉션 테이블 내에서 foreign-key 컬럼 이름을 정"
"의한다. <literal>element</literal> 요소 내에 있는 <literal>column</literal> "
"속성은 <literal>String</literal> 값들이 실제로 저장될 컬럼 이름을 정의한다."

#. Tag: para
#, fuzzy, no-c-format
msgid "Here is the updated schema:"
msgstr "업데이트된 스키마를 살펴보라:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can see that the primary key of the collection table is in fact a "
"composite key that uses both columns. This also implies that there cannot be "
"duplicate email addresses per person, which is exactly the semantics we need "
"for a set in Java."
msgstr ""
"당신은 콜렉션 테이블의 프라이머리 키가 사실은 두 컬럼들을 사용하는 한 개의 합"
"성 키(composite key)임을 알 수 있다. 이것은 또한 개인에 대해 email 주소가 중"
"복될 수 없음을 의미하며, 그것은 정확하게 우리가 Java에서 set을 필요로 하는 의"
"미론이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can now try to add elements to this collection, just like we did before "
"by linking persons and events. It is the same code in Java:"
msgstr ""
"마치 개인들과 이벤트들을 링크시켜서 이전에 우리가 행했던 것처럼 이제 당신은 "
"요소들을 시도하고 이 콜렉션에 추가할 수 있다. 그것은 Java에서 동일한 코드이"
"다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This time we did not use a <emphasis>fetch</emphasis> query to initialize "
"the collection. Monitor the SQL log and try to optimize this with an eager "
"fetch."
msgstr ""
"지금 우리는 콜렉션을 초기화 시키는데 <emphasis>fetch</emphasis> 질의를 사용하"
"지 않았다. 그러므로 콜렉션의 getter 메소드에 대한 호출은 콜렉션을 초기화 시키"
"기 위해 추가적인 select를 트리거 시킬 것이어서, 우리는 그것에 요소를 추가시"
"킬 수 있다. SQL 로그를 관찰하고 이것을 eager fetch로 최적화 시키려고 시도하"
"라."

#. Tag: title
#, no-c-format
msgid "Bi-directional associations"
msgstr "Bi-directional associations"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Next you will map a bi-directional association. You will make the "
"association between person and event work from both sides in Java. The "
"database schema does not change, so you will still have many-to-many "
"multiplicity."
msgstr ""
"다음으로 우리는 양방향 연관을 매핑시킬 예정이다-개인과 이벤트 사이에 연관을 "
"만드는 것은 Java에서 양 측들에서 동작한다. 물론 데이터베이스 스키마는 변경되"
"지 않고, 우리는 여전히 many-to-many 다중성을 갖는다. 관계형 데이터베이스는 네"
"트웍 프로그래밍 언어 보다 훨씬 더 유연하여서, 그것은 네비게이션 방향과 같은 "
"어떤 것을 필요로 하지 않는다 - 데이터는 어떤 가능한 바업ㅂ으로 보여질 수 있"
"고 검색될 수 있다."

#. Tag: para
#, no-c-format
msgid ""
"A relational database is more flexible than a network programming language, "
"in that it does not need a navigation direction; data can be viewed and "
"retrieved in any possible way."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"First, add a collection of participants to the <literal>Event</literal> "
"class:"
msgstr ""
"먼저, 참여자들을 가진 한 개의 콜렉션을 <literal>Event</literal> Event 클래스"
"에 추가시켜라:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Now map this side of the association in <literal>Event.hbm.xml</literal>."
msgstr "이제 <literal>Event.hbm.xml</literal> 내에 연관의 이 쪽도 매핑하라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"These are normal <literal>set</literal> mappings in both mapping documents. "
"Notice that the column names in <literal>key</literal> and <literal>many-to-"
"many</literal> swap in both mapping documents. The most important addition "
"here is the <literal>inverse=\"true\"</literal> attribute in the "
"<literal>set</literal> element of the <literal>Event</literal>'s collection "
"mapping."
msgstr ""
"당신이 볼 수 있듯이, 이것들은 두 매핑 문서들 내에서 정규 <literal>set</"
"literal> 매핑들이다. <literal>key</literal>와 <literal>many-to-many</literal>"
"에서 컬럼 이름들은 두 매핑 문서들에서 바뀌어진다. 여기서 가장 중요한 부가물"
"은 <literal>Event</literal>의 콜렉션 매핑에 관한 <literal>set</literal> 요소 "
"내에 있는 <literal>inverse=\"true\"</literal> 속성이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"What this means is that Hibernate should take the other side, the "
"<literal>Person</literal> class, when it needs to find out information about "
"the link between the two. This will be a lot easier to understand once you "
"see how the bi-directional link between our two entities is created."
msgstr ""
"이것이 의미하는 바는 Hibernate가 둘 사이의 링크에 대한 정보를 알 필요가 있을 "
"때 다른 측-<literal>Person</literal> 클래스-를 취할 것이라는 점이다. 일단 당"
"신이 우리의 두 엔티티들 사이에 양방향 링크가 생성되는 방법을 안다면 이것은 이"
"해하기가 훨씬 더 쉬울 것이다."

#. Tag: title
#, no-c-format
msgid "Working bi-directional links"
msgstr "양방향 링크들에 작업하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"First, keep in mind that Hibernate does not affect normal Java semantics. "
"How did we create a link between a <literal>Person</literal> and an "
"<literal>Event</literal> in the unidirectional example? You add an instance "
"of <literal>Event</literal> to the collection of event references, of an "
"instance of <literal>Person</literal>. If you want to make this link bi-"
"directional, you have to do the same on the other side by adding a "
"<literal>Person</literal> reference to the collection in an <literal>Event</"
"literal>. This process of \"setting the link on both sides\" is absolutely "
"necessary with bi-directional links."
msgstr ""
"첫 번째로 Hibernate가 정규 Java 의미론에 영향을 주지 않음을 염두에 두라. 우리"
"는 단방향 예제에서 <literal>Person</literal>과 <literal>Event</literal> 사이"
"에 어떻게 한 개의 링크를 생성시켰는가? 우리는 <literal>Event</literal> 타입"
"의 인스턴스를 <literal>Person</literal> 타입의 이벤트 참조들을 가진 콜렉션에 "
"추가시켰다. 따라서 명백하게 우리가 이 링크를 양방향으로 동작하도록 만들고자 "
"원한다면, 우리는 다른 측 상에서 -하나의 <literal>Person</literal> 참조를 하나"
"의 <literal>Event</literal> 내에 있는 콜렉션에 추가시킴으로써- 동일한 것을 행"
"해야 한다. 이 \"양 측 상에 링크 설정하기\"는 절대적으로 필수적이고 당신은 그"
"것을 행하는 것을 결코 잊지 말아야 한다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Many developers program defensively and create link management methods to "
"correctly set both sides (for example, in <literal>Person</literal>):"
msgstr ""
"많은 개발자들은 방비책을 프로그램하고 양 측들을 정확하게 설정하기 위한 하나"
"의 링크 관리 메소드들을 생성시킨다. 예를 들면 <literal>Person</literal>에서 :"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The get and set methods for the collection are now protected. This allows "
"classes in the same package and subclasses to still access the methods, but "
"prevents everybody else from altering the collections directly. Repeat the "
"steps for the collection on the other side."
msgstr ""
"콜렉션에 대한 get 및 set 메소드드은 이제 protected임을 인지하라 - 이것은 동일"
"한 패키지 내에 있는 클래스들과 서브클래스들이 그 메소드들에 접근하는 것을 허"
"용해주지만, 그 밖의 모든 것들이 그 콜렉션들을 (물론, 대개) 직접 만지는 것을 "
"금지시킨다. 당신은 다른 측 상에 있는 콜렉션에 대해 동일한 것을 행할 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"What about the <literal>inverse</literal> mapping attribute? For you, and "
"for Java, a bi-directional link is simply a matter of setting the references "
"on both sides correctly. Hibernate, however, does not have enough "
"information to correctly arrange SQL <literal>INSERT</literal> and "
"<literal>UPDATE</literal> statements (to avoid constraint violations). "
"Making one side of the association <literal>inverse</literal> tells "
"Hibernate to consider it a <emphasis>mirror</emphasis> of the other side. "
"That is all that is necessary for Hibernate to resolve any issues that arise "
"when transforming a directional navigation model to a SQL database schema. "
"The rules are straightforward: all bi-directional associations need one side "
"as <literal>inverse</literal>. In a one-to-many association it has to be the "
"many-side, and in many-to-many association you can select either side."
msgstr ""
"<literal>inverse</literal> 매핑 속성은 무엇인가? 당신의 경우, 그리고 Java의 "
"경우, 한 개의 양방향 링크는 단순히 양 측들에 대한 참조들을 정확하게 설정하는 "
"문제이다. 하지만 Hibernate는 (컨스트레인트 위배를 피하기 위해서) SQL "
"<literal>INSERT</literal> 문장과 <literal>UPDATE</literal> 문장을 정확하게 마"
"련하기에 충분한 정보를 갖고 있지 않으며, 양방향 연관들을 올바르게 처리하기 위"
"해 어떤 도움을 필요로 한다. 연관의 한 측을 <literal>inverse</literal>로 만드"
"는 것은 기본적으로 그것을 무시하고 그것을 다른 측의 <emphasis>거울(mirror)</"
"emphasis>로 간주하도록 Hibernate에게 알려준다. 그것은 Hibernate가 하나의 방향"
"성 네비게이션 모형을 한 개의 SQL 스키마로 변환시킬 때 모든 쟁점들을 잘 해결하"
"는데 필수적인 모든 것이다. 당신이 염두에 두어야 하는 규칙들은 간단하다 : 모"
"든 양방향 연관들은 한 쪽이 <literal>inverse</literal>일 필요가 있다. one-to-"
"many 연관에서 그것은 many-측이어야 하고, many-to-many 연관에서 당신은 어느 측"
"이든 선택할 수 있으며 차이점은 없다."

#. Tag: title
#, no-c-format
msgid "Part 3 - The EventManager web application"
msgstr "파트 3 - EventManager 웹 어플리케이션"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A Hibernate web application uses <literal>Session</literal> and "
"<literal>Transaction</literal> almost like a standalone application. "
"However, some common patterns are useful. You can now write an "
"<literal>EventManagerServlet</literal>. This servlet can list all events "
"stored in the database, and it provides an HTML form to enter new events."
msgstr ""
"Hibernate 웹 어플리케이션은 대부분의 스탠드얼론 어플리케이션과 같이 "
"<literal>Session</literal>과 <literal>Transaction</literal>을 사용한다. 하지"
"만 몇몇 공통 패턴들이 유용하다. 우리는 이제 <literal>EventManagerServlet</"
"literal>를 작성한다. 이 서블릿은 데이터베이스 내에 저장된 모든 이벤트들을 나"
"열할 수 있고, 그것은 새로운 이벤트들을 입력하기 위한 HTML form을 제공한다."

#. Tag: title
#, no-c-format
msgid "Writing the basic servlet"
msgstr "기본 서블릿 작성하기"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"First we need create our basic processing servlet. Since our servlet only "
"handles HTTP <literal>GET</literal> requests, we will only implement the "
"<literal>doGet()</literal> method:"
msgstr ""
"서블릿은 HTTP <literal>GET</literal> 요청들 만을 처리하므로, 우리가 구현하는 "
"메소드는 <literal>doGet()</literal>이다:"

#. Tag: para
#, no-c-format
msgid ""
"Save this servlet as <filename>src/main/java/org/hibernate/tutorial/web/"
"EventManagerServlet.java</filename>"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The pattern applied here is called <emphasis>session-per-request</emphasis>. "
"When a request hits the servlet, a new Hibernate <literal>Session</literal> "
"is opened through the first call to <literal>getCurrentSession()</literal> "
"on the <literal>SessionFactory</literal>. A database transaction is then "
"started. All data access occurs inside a transaction irrespective of whether "
"the data is read or written. Do not use the auto-commit mode in applications."
msgstr ""
"우리가 여기서 적용하는 패턴은 <emphasis>session-per-request</emphasis>이다. "
"하나의 요청이 서블릿에 도달할 때, 하나의 새로운 Hibernate <literal>Session</"
"literal>이 <literal>SessionFactory</literal> 상의 <literal>getCurrentSession"
"()</literal>에 대한 첫번째 호출을 통해 열린다. 그때 하나의 데이터베이스 트랜"
"잭션이 시작되고, 모든 데이터 접근이 하나의 트랜잭션 내에서 발생하는 한, 데이"
"터가 읽혀지거나 기록되는데 문제가 없다(우리는 어플리케이션들 내에서 auto-"
"commit 모드를 사용하지 않는다)."

#. Tag: para
#, no-c-format
msgid ""
"Do <emphasis>not</emphasis> use a new Hibernate <literal>Session</literal> "
"for every database operation. Use one Hibernate <literal>Session</literal> "
"that is scoped to the whole request. Use <literal>getCurrentSession()</"
"literal>, so that it is automatically bound to the current Java thread."
msgstr ""
"모든 데이터베이스 오퍼레이션 각각에 대해 새로운 Hibernate <literal>Session</"
"literal>을 사용하지 <emphasis>말라</emphasis>. 전체 요청에 대해 영역지워진 "
"한 개의 Hibernate <literal>Session</literal>을 사용하라. 그것이 자동적으로 현"
"재의 자바 쓰레드에 바인드되도록 <literal>getCurrentSession()</literal>을 사용"
"하라."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Next, the possible actions of the request are processed and the response "
"HTML is rendered. We will get to that part soon."
msgstr ""
"다음으로, 요청의 가능한 액션들이 처리되고 응답 HTML이 렌더링된다. 우리는 곧"
"장 그부분으로 갈 것이다."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Finally, the unit of work ends when processing and rendering are complete. "
"If any problems occurred during processing or rendering, an exception will "
"be thrown and the database transaction rolled back. This completes the "
"<literal>session-per-request</literal> pattern. Instead of the transaction "
"demarcation code in every servlet, you could also write a servlet filter. "
"See the Hibernate website and Wiki for more information about this pattern "
"called <emphasis>Open Session in View</emphasis>. You will need it as soon "
"as you consider rendering your view in JSP, not in a servlet."
msgstr ""
"마지막으로, 프로세싱과 렌더링이 완료될 때 작업 단위가 종료된다. 만일 어떤 문"
"제가 프로세싱과 렌더링 동안에 발생될 경우, 하나의 예외상황이 던져질 것이고 데"
"이터베이스 트랜잭션은 롤백될 것이다. 이것은 <literal>session-per-request</"
"literal>을 완료시킨다. 모든 서블릿 내에 있는 트랜잭션 구획 코드 대신에 당신"
"은 또한 서블릿 필터를 사용할 수 있다. <emphasis>Open Session in View</"
"emphasis>로 명명되는 이 패턴에 대한 추가 정보는 Hibernate 웹 사이트와 위키를 "
"보라. 당신은 서블릿 내에서가 아닌 JSP 내에 당신의 뷰를 렌더링하는 것을 고려"
"할 때 그것을 필요로 할 것이다."

#. Tag: title
#, no-c-format
msgid "Processing and rendering"
msgstr "프로세싱과 렌더링"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Now you can implement the processing of the request and the rendering of the "
"page."
msgstr "요청의 처리와 페이지의 렌더링을 구현하자."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This coding style, with a mix of Java and HTML, would not scale in a more "
"complex application&mdash;keep in mind that we are only illustrating basic "
"Hibernate concepts in this tutorial. The code prints an HTML header and a "
"footer. Inside this page, an HTML form for event entry and a list of all "
"events in the database are printed. The first method is trivial and only "
"outputs HTML:"
msgstr ""
"Java와 HTML이 혼합된 이 코딩이 보다 복잡한 어플리케이션에서 기준이 될 수 없"
"다 할지라도, 우리는 단지 이 튜토리얼 내에서 기본 Hibernate 개념들을 설명하고 "
"있음을 염두에 두라. 코드는 하나의 HTML 헤더와 하나의 footer를 프린트한다. 이 "
"페이지 내에 이벤트 엔트리를 위한 하나의 HTML form과 데이터베이스 내에 있는 모"
"든 이벤트들의 목록이 프린트된다. 첫 번째 메소드는 시행적이고 오직 HTML을 출력"
"한다:"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>listEvents()</literal> method uses the Hibernate "
"<literal>Session</literal> bound to the current thread to execute a query:"
msgstr ""
"<literal>listEvents()</literal> 메소드는 하나의 질의를 실행하기 위해서 현재"
"의 쓰레드에 결합된 Hibernate <literal>Session</literal>을 사용한다:"

#. Tag: para
#, no-c-format
msgid ""
"Finally, the <literal>store</literal> action is dispatched to the "
"<literal>createAndStoreEvent()</literal> method, which also uses the "
"<literal>Session</literal> of the current thread:"
msgstr ""
"마지막으로, <literal>store</literal> 액션은 <literal>createAndStoreEvent()</"
"literal> 메소드로 디스패치된다. 그것은 현재 쓰레드의 <literal>Session</"
"literal>을 사용한다:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The servlet is now complete. A request to the servlet will be processed in a "
"single <literal>Session</literal> and <literal>Transaction</literal>. As "
"earlier in the standalone application, Hibernate can automatically bind "
"these objects to the current thread of execution. This gives you the freedom "
"to layer your code and access the <literal>SessionFactory</literal> in any "
"way you like. Usually you would use a more sophisticated design and move the "
"data access code into data access objects (the DAO pattern). See the "
"Hibernate Wiki for more examples."
msgstr ""
"즉 서블릿이 완성된다. 서블릿에 대한 요청은 하나의 단일 <literal>Session</"
"literal>과 <literal>Transaction</literal> 내에서 처리될 것이다. 이전처럼 스탠"
"드얼론 어플리케이션에서, Hibernate는 이들 객체들을 실행 중인 현재 쓰레드에 자"
"동적으로 바인드시킬 수 있다. 이것은 당신의 코드를 계층화 시키고 당신이 좋아하"
"는 임의의 방법으로 <literal>SessionFactory</literal>에 접근하는 자유를 당신에"
"게 부여한다. 대개 당신은 보다 세련된 설계를 사용할 것이고 데이터 접근 코드를 "
"데이터 접근 객체들 내로 이동시킬 것이다(DAO 패턴). 추가 예제들은 Hibernate 위"
"키를 보라."

#. Tag: title
#, no-c-format
msgid "Deploying and testing"
msgstr "배치하기 그리고 테스트하기"

#. Tag: para
#, no-c-format
msgid ""
"To deploy this application for testing we must create a Web ARchive (WAR). "
"First we must define the WAR descriptor as <filename>src/main/webapp/WEB-INF/"
"web.xml</filename>"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"To build and deploy call <literal>mvn package</literal> in your project "
"directory and copy the <filename>hibernate-tutorial.war</filename> file into "
"your Tomcat <filename>webapps</filename> directory."
msgstr ""
"빌드하고 배치하기 위해 당신의 프로젝트 디렉토리 내에서 <literal>ant war</"
"literal>를 호출하고 <literal>hibernate-tutorial.war</literal> 파일을 당신의 "
"Tomcat <literal>webapp</literal> 디렉토리로 복사하라. 만일 당신이 Tomcat을 설"
"치하지 않았다면, 그것을 내려받아 설치 지침들을 따르라. 당신은 이 어플리케이션"
"을 배치하기 위해 임의의 Tomcat 구성을 변경하지 않아야 한다."

#. Tag: para
#, no-c-format
msgid ""
"If you do not have Tomcat installed, download it from <ulink url=\"http://"
"tomcat.apache.org/\" /> and follow the installation instructions. Our "
"application requires no changes to the standard Tomcat configuration."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Once deployed and Tomcat is running, access the application at "
"<literal>http://localhost:8080/hibernate-tutorial/eventmanager</literal>. "
"Make sure you watch the Tomcat log to see Hibernate initialize when the "
"first request hits your servlet (the static initializer in "
"<literal>HibernateUtil</literal> is called) and to get the detailed output "
"if any exceptions occurs."
msgstr ""
"일단 배치했고 Tomcat이 실행중이면, <literal>http://localhost:8080/hibernate-"
"tutorial/eventmanager</literal>로 어플리케이션에 접근하라. 첫 번째 요청이 당"
"신의 서블릿에 도달할 때 Hibernate가 초기화(<literal>HibernateUtil</literal> "
"내에 있는 static initializer가 호출된다) 되는 것을 보기 위해 그리고 만일 어"
"떤 예외상황들이 발생할 경우 상세한 출력을 얻기 위해서 Tomcat 로그를 지켜보도"
"록 하라."

#. Tag: title
#, no-c-format
msgid "Summary"
msgstr "요약"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This tutorial covered the basics of writing a simple standalone Hibernate "
"application and a small web application. More tutorials are available from "
"the Hibernate <ulink url=\"http://hibernate.org\">website</ulink>."
msgstr ""
"이 튜토리얼은 간단한 스탠드얼론 Hibernate 어플리케이션과 하나의 작은 웹 어플"
"리케이션을 작성하는 기초를 다루었다."

#~ msgid "Introduction to Hibernate"
#~ msgstr "Hibernate 개요"

#~ msgid "Preface"
#~ msgstr "머리말"

#~ msgid ""
#~ "This chapter is an introductory tutorial for new users of Hibernate. We "
#~ "start with a simple command line application using an in-memory database "
#~ "and develop it in easy to understand steps."
#~ msgstr ""
#~ "이 장은 Hibernate 초심자를 위한 개론적인 튜토리얼이다. 우리는 메모리-내 데"
#~ "이터베이스를 사용하는 간단한 명령 라인 어플리케이션으로 시작하고 단계들을 "
#~ "이해하도록 쉽게 그것을 개발한다."

#~ msgid ""
#~ "This tutorial is intended for new users of Hibernate but requires Java "
#~ "and SQL knowledge. It is based on a tutorial by Michael Gloegl, the third-"
#~ "party libraries we name are for JDK 1.4 and 5.0. You might need others "
#~ "for JDK 1.3."
#~ msgstr ""
#~ "이 튜토리얼은 Hibernate 신규 사용자들을 의도하고 있지만 Java와 SQL 지식을 "
#~ "필요로 한다. 그것은 Michael Gloegl이 작성한 튜토리얼에 기초하며, 우리가 명"
#~ "명하는 제 3의 라이브러리들은 JDK 1.4와 5.0 버전용이다. 당신은 JDK1.3에 대"
#~ "해 다른 라이브러리들을 필요로 할 수도 있다."

#~ msgid ""
#~ "The source code for the tutorial is included in the distribution in the "
#~ "<literal>doc/reference/tutorial/</literal> directory."
#~ msgstr ""
#~ "튜토리얼용 소스는 <literal>doc/reference/tutorial/</literal> 디렉토리 내"
#~ "에 있는 배포본 내에 포함되어 있다."

#~ msgid ""
#~ "First, we'll create a simple console-based Hibernate application. We use "
#~ "an Java database (HSQL DB), so we do not have to install any database "
#~ "server."
#~ msgstr ""
#~ "먼저, 우리는 한 개의 간단한 콘솔-기반 Hibernate 어플리케이션을 생성시킬 것"
#~ "이다. 우리는 메모리-내 데이터베이스(HSQL DB)를 사용하므로, 우리는 어떤 데"
#~ "이터베이스 서버를 설치하지 않아도 된다."

#~ msgid ""
#~ "The first thing we do, is set up our development directory and put all "
#~ "the Java libraries we need into it. Download the Hibernate distribution "
#~ "from the Hibernate website. Extract the package and place all required "
#~ "libraries found in <literal>/lib</literal> into into the <literal>/lib</"
#~ "literal> directory of your new development working directory. It should "
#~ "look like this:"
#~ msgstr ""
#~ "우리가 행할 첫 번째 것은 우리의 개발 디렉토리를 설정하고, 우리가 필요로 하"
#~ "는 모든 Java 라이브러리들을 그것 속에 집어 넣는 것이다. Hibernate 웹 사이"
#~ "트로부터 Hibernate 배포본을 내려 받아라. 패키지를 추출해내고 <literal>/"
#~ "lib</literal> 속에서 발견되는 모든 필요한 라이브러리들을 당신의 새로운 개"
#~ "발 작업 디렉토리의 <literal>/lib</literal> 디렉토리 속에 위치지워라. 그것"
#~ "은 다음과 같을 것이다:"

#~ msgid ""
#~ "This is the minimum set of required libraries (note that we also copied "
#~ "hibernate3.jar, the main archive) for Hibernate <emphasis>at the time of "
#~ "writing</emphasis>. The Hibernate release you are using might require "
#~ "more or less libraries. See the <literal>README.txt</literal> file in the "
#~ "<literal>lib/</literal> directory of the Hibernate distribution for more "
#~ "information about required and optional third-party libraries. (Actually, "
#~ "Log4j is not required but preferred by many developers.)"
#~ msgstr ""
#~ "이것은 <emphasis>글의 작성 시점에서</emphasis> Hibernate에 필수적인 최소한"
#~ "의 세트이다(우리는 또한 메인 아카이브인 hibernate3.jar를 복사했음을 노트하"
#~ "라). 당신이 사용 중인 Hibernate 배포본이 더 많거나 보다 적은 라이브러리들"
#~ "을 필요로 할 수도 있다. 필수 라이브러리들과 선택적인 제3의 라이브러리들에 "
#~ "대한 추가 정보는 Hibernate 배포본의 <literal>lib/</literal> 디렉토리 내에 "
#~ "있는 <literal>README.txt</literal> 파일을 보라. (실제로, Log4j는 필수는 아"
#~ "니지만 많은 개발자들에 의해 선호된다.)"

#~ msgid ""
#~ "Our first persistent class is a simple JavaBean class with some "
#~ "properties:"
#~ msgstr ""
#~ "우리의 첫 번째 영속 클래스는 몇몇 프로퍼티들을 가진 간단한 자바빈즈 클래스"
#~ "이다:"

#~ msgid ""
#~ "Place this Java source file in a directory called <literal>src</literal> "
#~ "in the development folder, and in its correct package. The directory "
#~ "should now look like this:"
#~ msgstr ""
#~ "이 Java 소스 파일을 개발 폴더 내의 <literal>src</literal>로 명명된 디렉토"
#~ "리 속에 있는 위치지워라. 이제 그 디렉토리는 다음과 같을 것이다:"

#~ msgid "In the next step, we tell Hibernate about this persistent class."
#~ msgstr ""
#~ "다음 단계에서, 우리는 Hiberante에게 이 영속 클래스에 대해 알려 준다."

#~ msgid ""
#~ "The <literal>id</literal> element is the declaration of the identifer "
#~ "property, <literal>name=\"id\"</literal> declares the name of the Java "
#~ "property - Hibernate will use the getter and setter methods to access the "
#~ "property. The column attribute tells Hibernate which column of the "
#~ "<literal>EVENTS</literal> table we use for this primary key. The nested "
#~ "<literal>generator</literal> element specifies the identifier generation "
#~ "strategy, in this case we used <literal>native</literal>, which picks the "
#~ "best strategy depending on the configured database (dialect). Hibernate "
#~ "supports database generated, globally unique, as well as application "
#~ "assigned identifiers (or any strategy you have written an extension for)."
#~ msgstr ""
#~ "<literal>id</literal> 요소는 식별자 프로퍼티의 선언이고, <literal>name="
#~ "\"id\"</literal>는 Java 프로퍼티의 이름을 선언한다 - Hibernate는 그 프로퍼"
#~ "티에 접근하는데 getter 및 setter 메소드들을 사용할 것이다. column 속성은 "
#~ "우리가 <literal>EVENTS</literal> 테이블의 어느 컬럼을 이 프라이머리 키로 "
#~ "사용하는지를 Hibernate에게 알려준다. 내포된 <literal>generator</literal> "
#~ "요소는 식별자 생성 방도를 지정하며, 이 경우에 우리는 <literal>increment</"
#~ "literal>를 사용했고, 그것은 대개 테스팅(과 튜토리얼들)에 유용한 매우 간단"
#~ "한 메모리-내 숫자 증가 방법이다. Hibernate는 또한 전역적으로 유일한 데이터"
#~ "베이스에 의해 생성된 식별자 뿐만 아니라 어플리케이션에 의해 할당된 식별자"
#~ "(또는 당신이 확장으로 작성한 어떤 방도)를 지원한다."

#~ msgid ""
#~ "This mapping file should be saved as <literal>Event.hbm.xml</literal>, "
#~ "right in the directory next to the <literal>Event</literal> Java class "
#~ "source file. The naming of mapping files can be arbitrary, however the "
#~ "<literal>hbm.xml</literal> suffix is a convention in the Hibernate "
#~ "developer community. The directory structure should now look like this:"
#~ msgstr ""
#~ "다음 매핑 파일은 <literal>Event</literal> Java 클래스 소스 파일과 같은 디"
#~ "렉토리 속에 <literal>Event.hbm.xml</literal>로서 저장될 것이다. 매핑 파일"
#~ "들에 대한 네이밍은 임의적일 수 있지만, 접미사 <literal>hbm.xml</literal>"
#~ "은 Hibernate 개발자 공동체 내에서 컨벤션이 되었다. 디렉토리 구조는 이제 다"
#~ "음과 같을 것이다:"

#~ msgid "We continue with the main configuration of Hibernate."
#~ msgstr "우리는 Hibernate의 메인 구성을 계속 행한다."

#~ msgid ""
#~ "We now have a persistent class and its mapping file in place. It is time "
#~ "to configure Hibernate. Before we do this, we will need a database. HSQL "
#~ "DB, a java-based SQL DBMS, can be downloaded from the HSQL DB website"
#~ "(http://hsqldb.org/). Actually, you only need the <literal>hsqldb.jar</"
#~ "literal> from this download. Place this file in the <literal>lib/</"
#~ "literal> directory of the development folder."
#~ msgstr ""
#~ "우리는 이제 적절한 곳에 한 개의 영속 클래스와 그것의 매핑 파일을 갖고 있"
#~ "다. Hibernate를 구성할 차례이다. 우리가 이것을 행하기 전에, 우리는 데이터"
#~ "베이스를 필요로 할 것이다. 자바 기반의 메모리-내 SQL DBMS인 HSQL DB는 "
#~ "HSQL DB 웹 사이트에서 내려받을 수 있다. 실제로, 당신은 이 다운로드에서 오"
#~ "직 <literal>hsqldb.jar</literal> 만을 필요로 한다. 개발 폴더의 "
#~ "<literal>lib/</literal> 디렉토리 속에 이 파일을 위치지워라."

#~ msgid ""
#~ "Hibernate is the layer in your application which connects to this "
#~ "database, so it needs connection information. The connections are made "
#~ "through a JDBC connection pool, which we also have to configure. The "
#~ "Hibernate distribution contains several open source JDBC connection "
#~ "pooling tools, but will use the Hibernate built-in connection pool for "
#~ "this tutorial. Note that you have to copy the required library into your "
#~ "classpath and use different connection pooling settings if you want to "
#~ "use a production-quality third party JDBC pooling software."
#~ msgstr ""
#~ "Hibernate는 당신의 어플리케이션 내에서 이 데이터베이스에 연결하는 계층이"
#~ "고, 따라서 그것은 커넥션 정보를 필요로 한다. 커넥션들은 마찬가지로 구성되"
#~ "어야 하는 하나의 JDBC 커넥션 풀을 통해 행해진다. Hibernate 배포본은 몇몇 "
#~ "오픈 소스 JDBC 커넥션 풀링 도구들을 포함하고 있지만, 이 튜토리얼에서는 "
#~ "Hibernate에 의해 미리 빌드된 커넥션 풀링을 사용할 것이다. 당신이 필수 라이"
#~ "브러리를 당신의 classpath 속에 복사해야 하고 만일 당신이 제품-특징의 제3"
#~ "의 JDBC 풀링 소프트웨어를 사용하고자 원할 경우에는 다른 커넥션 풀링 설정들"
#~ "을 사용해야 함을 노트하라."

#~ msgid ""
#~ "Copy this file into the source directory, so it will end up in the root "
#~ "of the classpath. Hibernate automatically looks for a file called "
#~ "<literal>hibernate.cfg.xml</literal> in the root of the classpath, on "
#~ "startup."
#~ msgstr ""
#~ "이 파일을 소스 디렉토리 속으로 복사하고, 따라서 그것은 classpath의 루트에"
#~ "서 끝날 것이다. Hibernate는 시작 시에 classpath의 루트에서 "
#~ "<literal>hibernate.cfg.xml</literal>로 명명된 파일을 자동적으로 찾는다."

#~ msgid ""
#~ "We'll now build the tutorial with Ant. You will need to have Ant "
#~ "installed - get it from the <ulink url=\"http://ant.apache.org/"
#~ "bindownload.cgi\">Ant download page</ulink>. How to install Ant will not "
#~ "be covered here. Please refer to the <ulink url=\"http://ant.apache.org/"
#~ "manual/index.html\">Ant manual</ulink>. After you have installed Ant, we "
#~ "can start to create the buildfile. It will be called <literal>build.xml</"
#~ "literal> and placed directly in the development directory."
#~ msgstr ""
#~ "우리는 이제 Ant로 튜토리얼을 빌드할 것이다. 당신은 Ant를 설치할 필요가 있"
#~ "을 것이다 - <ulink url=\"http://ant.apache.org/bindownload.cgi\">Ant 내려"
#~ "받기 페이지</ulink>에서 Ant를 얻어라. Ant를 설치하는 방법은 여기서 다루지 "
#~ "않을 것이다. <ulink url=\"http://ant.apache.org/manual/index.html\">Ant 매"
#~ "뉴얼</ulink>을 참조하길 바란다. 당신이 Ant를 설치한 후에, 우리는 빌드파일 "
#~ "생성을 시작할 수 있다. 그것은 <literal>build.xml</literal>로 명명되고 개"
#~ "발 디렉토리 속에 직접 위치될 것이다."

#~ msgid "A basic build file looks like this:"
#~ msgstr "기본 빌드 파일은 다음과 같다:"

#~ msgid ""
#~ "This will tell Ant to add all files in the lib directory ending with "
#~ "<literal>.jar</literal> to the classpath used for compilation. It will "
#~ "also copy all non-Java source files to the target directory, e.g. "
#~ "configuration and Hibernate mapping files. If you now run Ant, you should "
#~ "get this output:"
#~ msgstr ""
#~ "이것은 <literal>.jar</literal>로 끝나는 lib 디렉토리 내에 있는 모든 파일들"
#~ "을 컴파일에 사용되는 classpath에 추가하도록 Ant에게 알려줄 것이다. 그것은 "
#~ "또한 모든 비-Java 소스 파일들을 대상 디렉토리로 복사할 것이다. 예를 들면, "
#~ "구성 및 Hibernate 매핑 파일들. 만일 당신이 Ant를 이제 실행할 경우, 당신은 "
#~ "다음 출력을 얻게 될 것이다:"

#~ msgid ""
#~ "Place <literal>HibernateUtil.java</literal> in the development source "
#~ "directory, in a package next to <literal>events</literal>:"
#~ msgstr ""
#~ "개발 소스 디렉토리 속에 <literal>HibernateUtil.java</literal> 를 위치지우"
#~ "고, 다음으로 <literal>Event.java</literal>를 위치지워라:"

#~ msgid ""
#~ "To run this first routine we have to add a callable target to the Ant "
#~ "build file:"
#~ msgstr ""
#~ "이 첫 번째 루틴을 실행하기 위해서 우리는 호출 가능한 대상을 Ant 빌드 파일"
#~ "에 추가해야 한다:"

#~ msgid ""
#~ "The value of the <literal>action</literal> argument is set on the command "
#~ "line when calling the target:"
#~ msgstr ""
#~ "<literal>action</literal> 아규먼트의 값은 대상을 호출할 때 명령 라인 상에"
#~ "서 설정된다:"

#~ msgid ""
#~ "This is the <literal>INSERT</literal> executed by Hibernate, the question "
#~ "marks represent JDBC bind parameters. To see the values bound as "
#~ "arguments, or to reduce the verbosity of the log, check your "
#~ "<literal>log4j.properties</literal>."
#~ msgstr ""
#~ "이것은 Hibernate에 의해 실행된 <literal>INSERT</literal>이고, 물음표 기호"
#~ "는 JDBC 바인드 파라미터들을 나타낸다. 아규먼트로서 바인드 된 값들을 보거"
#~ "나 장황한 로그를 줄이려면 당신의 <literal>log4j.properties</literal>를 체"
#~ "크하라."

#~ msgid "Now, to execute and test all of this, follow these steps:"
#~ msgstr "이제 이 모든 것을 실행하고 테스트하기 위해, 다음 단계들을 따르라:"

#~ msgid ""
#~ "Run <literal>ant run -Daction=store</literal> to store something into the "
#~ "database and, of course, to generate the database schema before through "
#~ "hbm2ddl."
#~ msgstr ""
#~ "데이터베이스 속으로 어떤 것을 저장하고 물론 앞서 hbm2ddl을 통해 데이터베이"
#~ "스 스키마를 산출시키기 위해 <literal>ant run -Daction=store</literal>를 실"
#~ "행하라."

#~ msgid ""
#~ "Now disable hbm2ddl by commenting out the property in your "
#~ "<literal>hibernate.cfg.xml</literal> file. Usually you only leave it "
#~ "turned on in continous unit testing, but another run of hbm2ddl would "
#~ "<emphasis>drop</emphasis> everything you have stored - the "
#~ "<literal>create</literal> configuration setting actually translates into "
#~ "\"drop all tables from the schema, then re-create all tables, when the "
#~ "SessionFactory is build\"."
#~ msgstr ""
#~ "이제 당신의 <literal>hibernate.cfg.xml</literal> 파일 속에서 그 프로퍼티"
#~ "를 주석처리함으로써 hbm2ddl을 사용불가능하게 하라. 대개 당신은 지속되는 단"
#~ "위 테스팅에서는 그것을 사용 가능하게 내버려두어도 되지만, 또 다른 hbm2ddl"
#~ "의 실행은 당신이 저장했던 모든 것을 <emphasis>drop</emphasis>시킬 것이다 "
#~ "- <literal>create</literal> 구성 설정은 실제로 \"스키마로부터 모든 테이블"
#~ "들을 드롭시키고 나서, SessionFactory가 빌드될 때 모든 테이블들을 다시 생성"
#~ "시키는 것\"으로 변환된다."

#~ msgid ""
#~ "If you now call Ant with <literal>-Daction=list</literal>, you should see "
#~ "the events you have stored so far. You can of course also call the "
#~ "<literal>store</literal> action a few times more."
#~ msgstr ""
#~ "만일 당신이 지금 <literal>-Daction=list</literal>로 Ant를 호출할 경우, 당"
#~ "신은 당신이 지금까지 저장했던 이벤트들을 보게 될 것이다. 물론 당신은 또한 "
#~ "여러 번 <literal>store</literal> 액션을 호출할 수 있다."

#~ msgid ""
#~ "Note: Most new Hibernate users fail at this point and we see questions "
#~ "about <emphasis>Table not found</emphasis> error messages regularly. "
#~ "However, if you follow the steps outlined above you will not have this "
#~ "problem, as hbm2ddl creates the database schema on the first run, and "
#~ "subsequent application restarts will use this schema. If you change the "
#~ "mapping and/or database schema, you have to re-enable hbm2ddl once again."
#~ msgstr ""
#~ "노트 : 대부분의 Hibernate 사용자들은 이 지점에서 실패하고 우리는 정기적으"
#~ "로 <emphasis>Table not found</emphasis> 오류 메시지들에 관한 질문을 받는"
#~ "다. 하지만 만일 당신이 위에 조명된 단게들을 따를 경우 당신은 이 문제를 겪"
#~ "지 않을 것이고, hbm2ddl이 처음 실행 시에 데이터베이스 스키마를 생성시키므"
#~ "로, 차후의 어플리케이션 재시작은 이 스키마를 사용할 것이다. 만일 당신이 매"
#~ "핑 그리고/또는 데이터베이스 스키마를 변경할 경우에, 당신은 다시 한번 더 "
#~ "hbm2ddl을 이용 가능하도록 해야 한다."

#~ msgid ""
#~ "Create a new mapping file called <literal>Person.hbm.xml</literal> (don't "
#~ "forget the DTD reference at the top):"
#~ msgstr ""
#~ "<literal>Person.hbm.xml</literal>로 명명되는 새로운 매핑 파일을 생성시켜"
#~ "라 (맨위에 DTD 참조를 잊지말라):"

#~ msgid ""
#~ "We need a unidirectional, many-valued associations, implemented with a "
#~ "<literal>Set</literal>. Let's write the code for this in the Java classes "
#~ "and then map it:"
#~ msgstr ""
#~ "우리는 하나의 <literal>Set</literal>으로 구현된, 하나의 단방향, 다중값 연"
#~ "관들을 필요로 한다. Java 클래스들 내에 이를 위한 코드를 작성하고 그런 다"
#~ "음 그것을 매핑시키자:"

#~ msgid ""
#~ "We add a collection of value typed objects to the <literal>Person</"
#~ "literal> entity. We want to store email addresses, so the type we use is "
#~ "<literal>String</literal>, and the collection is again a <literal>Set</"
#~ "literal>:"
#~ msgstr ""
#~ "우리는 값 타입의 객체들을 가진 한 개의 콜렉션을 <literal>Person</literal> "
#~ "엔티티에 추가시킨다. 우리는 email 주소를 저장하고자 원하므로, 우리가 사용"
#~ "하는 타입은 <literal>String</literal>이고, 그 콜렉션은 다시 한 개의 "
#~ "<literal>Set</literal>이다:"

#~ msgid "Let's turn this into a small web application."
#~ msgstr "Let's turn this into a small web application."

#~ msgid ""
#~ "Create a new class in your source directory, in the <literal>events</"
#~ "literal> package:"
#~ msgstr ""
#~ "다음 장에서 우리는 Hibernate를 Tomcat 및 WebWork와 통합시킨다. "
#~ "<literal>EventManager</literal>는 우리의 성장하는 어플리케이션을 더이상 감"
#~ "당하지 못한다. 당신의 소스 디렉토리에서 <literal>events</literal> 패키지 "
#~ "내에 새로운 클래스를 생성시켜라:"

#~ msgid ""
#~ "To deploy this application you have to create a web archive, a WAR. Add "
#~ "the following Ant target to your <literal>build.xml</literal>:"
#~ msgstr ""
#~ "이 어플리케이션을 배치하기 위해서 당신은 하나의 웹 아카이브, WAR를 생성시"
#~ "켜야 한다. 다음 Ant target을 당신의 <literal>build.xml</literal> 내에 추가"
#~ "하라:"

#~ msgid ""
#~ "This target creates a file called <literal>hibernate-tutorial.war</"
#~ "literal> in your project directory. It packages all libraries and the "
#~ "<literal>web.xml</literal> descriptor, which is expected in the base "
#~ "directory of your project:"
#~ msgstr ""
#~ "이 target은 당신의 프로젝트 디렉토리 내에 <literal>hibernate-tutorial."
#~ "war</literal>로 명명된 하나의 파일을 생성시킨다. 그것은 당신의 프로젝트의 "
#~ "기본 디렉토리 내에 기대되는 모든 라이브러리들과 <literal>web.xml</"
#~ "literal> 디스크립터를 패키징한다:"

#~ msgid ""
#~ "Before you compile and deploy the web application, note that an "
#~ "additional library is required: <literal>jsdk.jar</literal>. This is the "
#~ "Java servlet development kit, if you don't have this library already, get "
#~ "it from the Sun website and copy it to your library directory. However, "
#~ "it will be only used for compliation and excluded from the WAR package."
#~ msgstr ""
#~ "당신이 웹 어플리케이션을 컴파일하고 배치하기 전에, 하나의 부가적인 라이브"
#~ "러리가 필요함을 노트하라: <literal>jsdk.jar</literal>. 당신이 이미 이 라이"
#~ "브러리를 갖고 있지 않을 경우, 이것은 Java servlet development kit이며, "
#~ "Sun 웹 사이트로부터 그것을 얻어서 그것을 당신의 라이브러리 디렉토리에 복사"
#~ "하라. 하지만 그것은 오직 컴파일 시에만 사용될 것이고 WAR 패키지에서는 제외"
#~ "된다."

#~ msgid ""
#~ "If you already feel confident with Hibernate, continue browsing through "
#~ "the reference documentation table of contents for topics you find "
#~ "interesting - most asked are transactional processing (<xref linkend="
#~ "\"transactions\"/>), fetch performance (<xref linkend=\"performance\"/>), "
#~ "or the usage of the API (<xref linkend=\"objectstate\"/>) and the query "
#~ "features (<xref linkend=\"objectstate-querying\"/>)."
#~ msgstr ""
#~ "만일 당신이 이미 Hibernate에 자신이 있다고 느낀다면, 당신이 흥미를 찾는 주"
#~ "제들에 대한 참조 문서 목차를 계속 브라우징하라 - 가장 많이 요청되는 것은 "
#~ "트랜잭션 처리(<xref linkend=\"transactions\"/>), 페치 퍼포먼스(<xref "
#~ "linkend=\"performance\"/>), 또는 API 사용법(<xref linkend=\"objectstate\"/"
#~ ">), 그리고 질의 특징들(<xref linkend=\"objectstate-querying\"/>)이다."

#~ msgid ""
#~ "Don't forget to check the Hibernate website for more (specialized) "
#~ "tutorials."
#~ msgstr ""
#~ "더 많은(특화된) 튜토리얼들에 대해서는 Hibernate 웹 사이트를 체크하는 것을 "
#~ "잊지 말라."
