# translation of Collection_Mapping.po to
# Xi HUANG <xhuang@redhat.com>, 2007, 2010.
msgid ""
msgstr ""
"Project-Id-Version: Collection_Mapping\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-03-12T00:03:48\n"
"PO-Revision-Date: 2010-01-07 14:56+1000\n"
"Last-Translator: Xi HUANG <xhuang@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Working with objects"
msgstr "オブジェクトを扱う"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate is a full object/relational mapping solution that not only shields "
"the developer from the details of the underlying database management system, "
"but also offers <emphasis>state management</emphasis> of objects. This is, "
"contrary to the management of SQL <literal>statements</literal> in common "
"JDBC/SQL persistence layers, a natural object-oriented view of persistence "
"in Java applications."
msgstr ""
"Hibernate は完全なオブジェクト/リレーショナルマッピングソリューションであり、"
"データベース管理システムの詳細を開発者から隠蔽するだけでなく、オブジェクトの "
"<emphasis>状態管理</emphasis> も行います。これは、 JDBC/SQL 永続層と同じよう"
"な SQL <literal>statements</literal> の管理とは異なり、 Java アプリケーション"
"における永続化に対する、とても自然なオブジェクト指向の考え方を提供します。"

#. Tag: para
#, no-c-format
msgid ""
"In other words, Hibernate application developers should always think about "
"the <emphasis>state</emphasis> of their objects, and not necessarily about "
"the execution of SQL statements. This part is taken care of by Hibernate and "
"is only relevant for the application developer when tuning the performance "
"of the system."
msgstr ""
"言いかえれば、 Hibernate を用いるアプリケーション開発者は、オブジェクトの "
"<emphasis>状態</emphasis> については常に意識すべきであり、 SQL 文の実行につい"
"ては必ずしもそうではありません。この部分は、通常、 Hibernate が処理し、システ"
"ムのパフォーマンスをチューニングするときにだけ、問題になってきます。"

#. Tag: title
#, no-c-format
msgid "Hibernate object states"
msgstr "Hibernate におけるオブジェクトの状態"

#. Tag: para
#, no-c-format
msgid "Hibernate defines and supports the following object states:"
msgstr "Hibernate は次のようなオブジェクトの状態を定義し、サポートしています:"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Transient</emphasis> - an object is transient if it has just been "
"instantiated using the <literal>new</literal> operator, and it is not "
"associated with a Hibernate <literal>Session</literal>. It has no persistent "
"representation in the database and no identifier value has been assigned. "
"Transient instances will be destroyed by the garbage collector if the "
"application does not hold a reference anymore. Use the Hibernate "
"<literal>Session</literal> to make an object persistent (and let Hibernate "
"take care of the SQL statements that need to be executed for this "
"transition)."
msgstr ""
"<emphasis>Transient</emphasis> - <literal>new</literal> 演算子を使ってインス"
"タンス化されただけで、 Hibernate の <literal>Session</literal> に関連付けられ"
"ていないオブジェクトは、 transient です。それは、データベースに永続的な表現を"
"持たず、識別子となる値は割り当てられていません。 Transient インスタンスは、ア"
"プリケーションがその参照をどこにも保持しない場合に、ガベージコレクタによって"
"破棄されます。オブジェクトを永続的 (persistent) な状態にするためには、 "
"Hibernate の <literal>Session</literal> を使いましょう（この状態遷移に必要と"
"なる SQL 文の発行は、 Hibernate に任せましょう）。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Persistent</emphasis> - a persistent instance has a representation "
"in the database and an identifier value. It might just have been saved or "
"loaded, however, it is by definition in the scope of a <literal>Session</"
"literal>. Hibernate will detect any changes made to an object in persistent "
"state and synchronize the state with the database when the unit of work "
"completes. Developers do not execute manual <literal>UPDATE</literal> "
"statements, or <literal>DELETE</literal> statements when an object should be "
"made transient."
msgstr ""
"<emphasis>永続的 (Persistent)</emphasis> - 永続的なインスタンスはデータベース"
"に永続的な表現を持ち、識別子となる値を持っています。それは、セーブされたり、"
"ロードされたりするかもしれませんが、定義上は、 <literal>Session</literal> の"
"スコープの中に存在しています。 Hibernate は、作業単位（Unit of Work）が完了し"
"たときに、永続状態のオブジェクトに加えられた変更を検出し、オブジェクトの状態"
"とデータベースを同期します。オブジェクトを transient にするときは、開発者は、"
"手作業で <literal>UPDATE</literal> 文や <literal>DELETE</literal> 文を実行し"
"ません。"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Detached</emphasis> - a detached instance is an object that has "
"been persistent, but its <literal>Session</literal> has been closed. The "
"reference to the object is still valid, of course, and the detached instance "
"might even be modified in this state. A detached instance can be reattached "
"to a new <literal>Session</literal> at a later point in time, making it (and "
"all the modifications) persistent again. This feature enables a programming "
"model for long running units of work that require user think-time. We call "
"them <emphasis>application transactions</emphasis>, i.e., a unit of work "
"from the point of view of the user."
msgstr ""
"<emphasis>Detached</emphasis> - detached インスタンスとは、永続化されている"
"が、それと関連付いていた <literal>Session</literal> がクローズされているオブ"
"ジェクトのことです。そのオブジェクトへの参照は、依然として有効です。そして、"
"もちろん、detached インスタンスはこの状態に修正することさえできます。 "
"detached インスタンスは、もう一度永続化したい（そして、すべての変更を永続化し"
"たい）ときに、新しい <literal>Session</literal> に再追加できます。この機能"
"は、ユーザーが考える時間を必要とするような、長期間に及ぶ作業単位に対するプロ"
"グラミングモデルを可能にします。我々は、これを <emphasis>アプリケーションのト"
"ランザクション（application transactions）</emphasis> と呼んでいます。すなわ"
"ち、ユーザーから見た作業単位だということです。"

#. Tag: para
#, no-c-format
msgid ""
"We will now discuss the states and state transitions (and the Hibernate "
"methods that trigger a transition) in more detail."
msgstr ""
"これから、状態と状態遷移（そして、遷移のきっかけとなる Hibernate のメソッド）"
"について、詳細に述べます。"

#. Tag: title
#, no-c-format
msgid "Making objects persistent"
msgstr "オブジェクトを永続状態にする"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Newly instantiated instances of a persistent class are considered "
"<emphasis>transient</emphasis> by Hibernate. We can make a transient "
"instance <emphasis>persistent</emphasis> by associating it with a session:"
msgstr ""
"新しくインスタンス化された永続クラスのインスタンスは、 Hibernate では "
"<emphasis>transient</emphasis> と見なされます。以下のように、セッションと関連"
"づけることで、 transient インスタンスを <emphasis>永続状態 (persistent)</"
"emphasis> にできます。"

#. Tag: para
#, no-c-format
msgid ""
"If <literal>Cat</literal> has a generated identifier, the identifier is "
"generated and assigned to the <literal>cat</literal> when <literal>save()</"
"literal> is called. If <literal>Cat</literal> has an <literal>assigned</"
"literal> identifier, or a composite key, the identifier should be assigned "
"to the <literal>cat</literal> instance before calling <literal>save()</"
"literal>. You can also use <literal>persist()</literal> instead of "
"<literal>save()</literal>, with the semantics defined in the EJB3 early "
"draft."
msgstr ""
"<literal>Cat</literal> クラスの識別子が自動生成されるのであれば、 "
"<literal>save()</literal> が呼ばれるときに、識別子が生成され、 <literal>cat</"
"literal> インスタンスに割り当てられます。 <literal>Cat</literal> の識別子が "
"<literal>assigned</literal> 識別子を持つか、複合キーであるなら、 "
"<literal>save()</literal> を呼び出す前に、識別子を <literal>cat</literal> イ"
"ンスタンスを割り当てなければなりません。 <literal>save()</literal> の代わり"
"に、 EJB3 の初期ドラフトで定義された <literal>persist()</literal> を使うこと"
"も可能です。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>persist()</literal> makes a transient instance persistent. However, "
"it does not guarantee that the identifier value will be assigned to the "
"persistent instance immediately, the assignment might happen at flush time. "
"<literal>persist()</literal> also guarantees that it will not execute an "
"<literal>INSERT</literal> statement if it is called outside of transaction "
"boundaries. This is useful in long-running conversations with an extended "
"Session/persistence context."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"<literal>save()</literal> does guarantee to return an identifier. If an "
"INSERT has to be executed to get the identifier ( e.g. \"identity\" "
"generator, not \"sequence\"), this INSERT happens immediately, no matter if "
"you are inside or outside of a transaction. This is problematic in a long-"
"running conversation with an extended Session/persistence context."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Alternatively, you can assign the identifier using an overloaded version of "
"<literal>save()</literal>."
msgstr ""
"代わりに、識別子を引数にとる <literal>save()</literal> メソッドを使って、識別"
"子を割り当てることもできます。"

#. Tag: para
#, no-c-format
msgid ""
"If the object you make persistent has associated objects (e.g. the "
"<literal>kittens</literal> collection in the previous example), these "
"objects can be made persistent in any order you like unless you have a "
"<literal>NOT NULL</literal> constraint upon a foreign key column. There is "
"never a risk of violating foreign key constraints. However, you might "
"violate a <literal>NOT NULL</literal> constraint if you <literal>save()</"
"literal> the objects in the wrong order."
msgstr ""
"永続化するオブジェクトが関連オブジェクトを持っている場合 （例えば、前の例にお"
"ける <literal>kittens</literal> コレクションのように）、外部キーカラムに、 "
"<literal>NOT NULL</literal> 制約をつけない限りは、これらの一連のオブジェクト"
"をどんな順番で永続化してもかまいません。外部キー制約を違反する恐れはありませ"
"ん。しかし、 <literal>NOT NULL</literal> 制約がある場合、間違った順番でオブ"
"ジェクトを <literal>save()</literal> してしまうと、制約に違反するかもしれませ"
"ん。"

#. Tag: para
#, no-c-format
msgid ""
"Usually you do not bother with this detail, as you will normally use "
"Hibernate's <emphasis>transitive persistence</emphasis> feature to save the "
"associated objects automatically. Then, even <literal>NOT NULL</literal> "
"constraint violations do not occur - Hibernate will take care of everything. "
"Transitive persistence is discussed later in this chapter."
msgstr ""
"関連するオブジェクトを自動的に保存する、 Hibernate の <emphasis>遷移的な永続"
"化 (transitive persistence)</emphasis> 機能を使うつもりならば、そのような詳細"
"を気にする必要はありません。そして、 <literal>NOT NULL</literal> 制約の違反す"
"ら起こりません。 Hibernate がすべて面倒をみてくれます。遷移的な永続化は、この"
"章の後半に書かれています。"

#. Tag: title
#, no-c-format
msgid "Loading an object"
msgstr "オブジェクトのロード"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>load()</literal> methods of <literal>Session</literal> provide "
"a way of retrieving a persistent instance if you know its identifier. "
"<literal>load()</literal> takes a class object and loads the state into a "
"newly instantiated instance of that class in a persistent state."
msgstr ""
"永続化されたインスタンスの識別子があらかじめ分かっているなら、 "
"<literal>Session</literal> の <literal>load()</literal> メソッドを使って、復"
"元できます。 <literal>load()</literal> は、 Class オブジェクトを引数にとり、"
"そのクラスのインスタンスを新たに生成し、状態をロードします。そのインスタンス"
"の状態は、永続 (persistent) 状態です。"

#. Tag: para
#, no-c-format
msgid "Alternatively, you can load state into a given instance:"
msgstr ""
"あるいは、以下のように、既存のインスタンスに状態をロードすることもできます:"

#. Tag: para
#, no-c-format
msgid ""
"Be aware that <literal>load()</literal> will throw an unrecoverable "
"exception if there is no matching database row. If the class is mapped with "
"a proxy, <literal>load()</literal> just returns an uninitialized proxy and "
"does not actually hit the database until you invoke a method of the proxy. "
"This is useful if you wish to create an association to an object without "
"actually loading it from the database. It also allows multiple instances to "
"be loaded as a batch if <literal>batch-size</literal> is defined for the "
"class mapping."
msgstr ""
"DB に該当する行が無い場合、 <literal>load()</literal> は回復不可能な例外を投"
"げることに注意しましょう。そのクラスがプロキシを使ってマッピングされている場"
"合、 <literal>load()</literal> は初期化されていないプロキシを返し、プロキシの"
"メソッドが呼ばれるまで実際にはデータベースにアクセスしません。もし、実際に"
"データベースからロードせずに、オブジェクトに対する関連を作りたい場合、この振"
"る舞いはとても役立ちます。 <literal>batch-size</literal> がクラスマッピングに"
"定義されているならば、複数のインスタンスを一括でロードすることが可能です。"

#. Tag: para
#, no-c-format
msgid ""
"If you are not certain that a matching row exists, you should use the "
"<literal>get()</literal> method which hits the database immediately and "
"returns null if there is no matching row."
msgstr ""
"該当する行が存在することを確信できない場合は、 <literal>get()</literal> メ"
"ソッドを使うべきです。それは、データベースにすぐにアクセスし、該当する行が無"
"い場合は null を返します。"

#. Tag: para
#, no-c-format
msgid ""
"You can even load an object using an SQL <literal>SELECT ... FOR UPDATE</"
"literal>, using a <literal>LockMode</literal>. See the API documentation for "
"more information."
msgstr ""
"<literal>LockMode</literal> を使えば、 <literal>SELECT ... FOR UPDATE</"
"literal> という SQL を使ってオブジェクトをロードすることができます。詳細な情"
"報は、 API ドキュメントを参照してください。"

#. Tag: para
#, no-c-format
msgid ""
"Any associated instances or contained collections will <emphasis>not</"
"emphasis> be selected <literal>FOR UPDATE</literal>, unless you decide to "
"specify <literal>lock</literal> or <literal>all</literal> as a cascade style "
"for the association."
msgstr ""
"関連に対するカスケード方法として <literal>lock</literal> や <literal>all</"
"literal> を指定しない限り、関連するインスタンスや含まれるコレクションは "
"<literal>FOR UPDATE</literal> で復元 <emphasis>されない</emphasis> ことに注意"
"しましょう。"

#. Tag: para
#, no-c-format
msgid ""
"It is possible to re-load an object and all its collections at any time, "
"using the <literal>refresh()</literal> method. This is useful when database "
"triggers are used to initialize some of the properties of the object."
msgstr ""
"<literal>refresh()</literal> メソッドを使うことで、どんなときでも、オブジェク"
"トやそのコレクションをリロードすることができます。データベースのトリガがテー"
"ブルを更新した際に、そのテーブルに対応するオブジェクトのプロパティを同期する"
"場合、このメソッドが役に立ちます。"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"How much does Hibernate load from the database and how many SQL "
"<literal>SELECT</literal>s will it use? This depends on the "
"<emphasis>fetching strategy</emphasis>. This is explained in <xref linkend="
"\"performance-fetching\" />."
msgstr ""
"大切な問題は、いつも次の点に関するものです。それは、 Hibernate がデータベース"
"から、どのくらいの量を復元するのかと、どのくらいの数の SQL の "
"<literal>SELECT</literal> 文が使われるのかです。これは、 <emphasis>フェッチの"
"戦略</emphasis> によります。これについては、 <xref linkend=\"performance-"
"fetching\"/> で説明しています。"

#. Tag: title
#, no-c-format
msgid "Querying"
msgstr "クエリ"

#. Tag: para
#, no-c-format
msgid ""
"If you do not know the identifiers of the objects you are looking for, you "
"need a query. Hibernate supports an easy-to-use but powerful object oriented "
"query language (HQL). For programmatic query creation, Hibernate supports a "
"sophisticated Criteria and Example query feature (QBC and QBE). You can also "
"express your query in the native SQL of your database, with optional support "
"from Hibernate for result set conversion into objects."
msgstr ""
"探したいオブジェクトの識別子が分からない場合は、クエリが必要になります。 "
"Hibernate は使いやすくて強力なオブジェクト指向のクエリ言語 (HQL) をサポートし"
"ています。プログラムによってクエリが作成できるように、 Hibernate は洗練され"
"た Criteria と Example クエリ機能 (QBC と QBE） をサポートしています。 "
"ResultSet をオブジェクトに変換する Hibernate のオプション機能を使うことで、"
"データベースのネイティブな SQL でクエリを表現することもできます。"

#. Tag: title
#, no-c-format
msgid "Executing queries"
msgstr "クエリの実行"

#. Tag: para
#, no-c-format
msgid ""
"HQL and native SQL queries are represented with an instance of <literal>org."
"hibernate.Query</literal>. This interface offers methods for parameter "
"binding, result set handling, and for the execution of the actual query. You "
"always obtain a <literal>Query</literal> using the current <literal>Session</"
"literal>:"
msgstr ""
"HQL やネイティブな SQL クエリは、 <literal>org.hibernate.Query</literal> のイ"
"ンスタンスとして表現されます。このインタフェースは、パラメータバインディング"
"や ResultSet のハンドリングやクエリの実行を行うメソッドを用意しています。通"
"常、 <literal>Query</literal> は、以下に示すように、その時点の "
"<literal>Session</literal> を使って取得します。"

#. Tag: para
#, no-c-format
msgid ""
"A query is usually executed by invoking <literal>list()</literal>. The "
"result of the query will be loaded completely into a collection in memory. "
"Entity instances retrieved by a query are in a persistent state. The "
"<literal>uniqueResult()</literal> method offers a shortcut if you know your "
"query will only return a single object. Queries that make use of eager "
"fetching of collections usually return duplicates of the root objects, but "
"with their collections initialized. You can filter these duplicates through "
"a <literal>Set</literal>."
msgstr ""
"クエリは、普通、 <literal>list()</literal> を呼び出すことによって実行されま"
"す。クエリの結果は、メモリ上にあるコレクションにすべてロードされます。クエリ"
"によって復元されたエンティティのインスタンスは、永続状態です。もし、クエリが"
"たった1個のインスタンスを返すと分かっているなら、 <literal>uniqueResult()</"
"literal> メソッドが手っ取り早い方法です。即時フェッチを利用したクエリの場合、"
"ふつう、得られたコレクションには、ルートのオブジェクトが重複して含まれていま"
"す（しかし、ルートが持つコレクションは初期化 (ロード）されています）。この重"
"複は <literal>Set</literal> を使って取り除くことができます。"

#. Tag: title
#, no-c-format
msgid "Iterating results"
msgstr "結果をイテレートする"

#. Tag: para
#, no-c-format
msgid ""
"Occasionally, you might be able to achieve better performance by executing "
"the query using the <literal>iterate()</literal> method. This will usually "
"be the case if you expect that the actual entity instances returned by the "
"query will already be in the session or second-level cache. If they are not "
"already cached, <literal>iterate()</literal> will be slower than "
"<literal>list()</literal> and might require many database hits for a simple "
"query, usually <emphasis>1</emphasis> for the initial select which only "
"returns identifiers, and <emphasis>n</emphasis> additional selects to "
"initialize the actual instances."
msgstr ""
"時々、 <literal>iterate()</literal> メソッドを使ってクエリを実行することで、"
"より良いパフォーマンスを得ることができます。これは、通常、クエリによって得ら"
"れた実際のエンティティのインスタンスが、すでにセッションまたは二次キャッシュ"
"に存在することが期待できる場合だけです。それらが、まだキャッシュされていない"
"なら、 <literal>iterate()</literal> は、 <literal>list()</literal> よりも遅"
"く、簡単なクエリに対しても多くのデータベースアクセスを必要とします。そのアク"
"セスとは、識別子だけを取得するための最初の select <emphasis>１回</emphasis> "
"と、実際のインスタンスを初期化するために後から行う <emphasis>n回</emphasis> "
"の select のことです。"

#. Tag: title
#, no-c-format
msgid "Queries that return tuples"
msgstr "オブジェクトの組（tuple）を返すクエリ"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate queries sometimes return tuples of objects. Each tuple is returned "
"as an array:"
msgstr ""
"Hibernate のクエリでは、時々、オブジェクトの組を返すことがあります。その場合"
"は、各タプルは配列として返されます:"

#. Tag: title
#, no-c-format
msgid "Scalar results"
msgstr "スカラーの結果"

#. Tag: para
#, no-c-format
msgid ""
"Queries can specify a property of a class in the <literal>select</literal> "
"clause. They can even call SQL aggregate functions. Properties or aggregates "
"are considered \"scalar\" results and not entities in persistent state."
msgstr ""
"クエリでは、 <literal>select</literal> 節でクラスのプロパティを指定できま"
"す。 SQL の集合関数を呼ぶこともできます。プロパティや集合関数は、（永続状態の"
"エンティティではなく）「スカラー値」であると見なされます。"

#. Tag: title
#, no-c-format
msgid "Bind parameters"
msgstr "パラメータのバインド"

#. Tag: para
#, no-c-format
msgid ""
"Methods on <literal>Query</literal> are provided for binding values to named "
"parameters or JDBC-style <literal>?</literal> parameters. <emphasis>Contrary "
"to JDBC, Hibernate numbers parameters from zero.</emphasis> Named parameters "
"are identifiers of the form <literal>:name</literal> in the query string. "
"The advantages of named parameters are as follows:"
msgstr ""
"<literal>Query</literal> は、名前付きのパラメータや JDBC スタイルの "
"<literal>?</literal> パラメータに値をバインドするためのメソッドを持っていま"
"す。 <emphasis> JDBC とは違い、 Hibernate はパラメータにゼロから番号を振って"
"いきます。</emphasis>名前付きのパラメータとは、クエリ文字列のなかにある "
"<literal>:name</literal> 形式の識別子です。名前付きパラメータの利点は次の通り"
"です。"

#. Tag: para
#, no-c-format
msgid ""
"named parameters are insensitive to the order they occur in the query string"
msgstr "名前付きパラメータは、クエリ文字列に登場する順番と無関係です"

#. Tag: para
#, no-c-format
msgid "they can occur multiple times in the same query"
msgstr "同じクエリ内に複数回登場することができます"

#. Tag: para
#, no-c-format
msgid "they are self-documenting"
msgstr "自分自身を説明します"

#. Tag: title
#, no-c-format
msgid "Pagination"
msgstr "ページ分け"

#. Tag: para
#, no-c-format
msgid ""
"If you need to specify bounds upon your result set, that is, the maximum "
"number of rows you want to retrieve and/or the first row you want to "
"retrieve, you can use methods of the <literal>Query</literal> interface:"
msgstr ""
"ResultSet に制限（復元したい最大行数や復元したい最初の行）を加える必要があれ"
"ば、以下のように、 <literal>Query</literal> インターフェースのメソッドを使い"
"ます。"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate knows how to translate this limit query into the native SQL of "
"your DBMS."
msgstr ""
"制限付きのクエリを DBMS のネイティブな SQL に変換する方法を、 Hibernate は"
"知っています。"

#. Tag: title
#, no-c-format
msgid "Scrollable iteration"
msgstr "スクロール可能なイテレーション"

#. Tag: para
#, no-c-format
msgid ""
"If your JDBC driver supports scrollable <literal>ResultSet</literal>s, the "
"<literal>Query</literal> interface can be used to obtain a "
"<literal>ScrollableResults</literal> object that allows flexible navigation "
"of the query results."
msgstr ""
"JDBC ドライバがスクロール可能な <literal>ResultSet</literal> をサポートしてい"
"れば、 <literal>Query</literal> インターフェースを使って、 "
"<literal>ScrollableResults</literal> オブジェクトを取得できます。それを使う"
"と、クエリの結果に対して柔軟にナビゲーションできます。"

#. Tag: para
#, no-c-format
msgid ""
"Note that an open database connection and cursor is required for this "
"functionality. Use <literal>setMaxResult()</literal>/<literal>setFirstResult"
"()</literal> if you need offline pagination functionality."
msgstr ""
"この機能にはオープン状態のデータベースコネクションが必要であることに注意して"
"ください。もし、オフラインのページ分け機能が必要であれば、 "
"<literal>setMaxResult()</literal> / <literal>setFirstResult()</literal> を使"
"いましょう。"

#. Tag: title
#, no-c-format
msgid "Externalizing named queries"
msgstr "名前付きクエリの外出し"

#. Tag: para
#, no-c-format
msgid ""
"You can also define named queries in the mapping document. Remember to use a "
"<literal>CDATA</literal> section if your query contains characters that "
"could be interpreted as markup."
msgstr ""
"マッピングドキュメントに名前付きのクエリを定義することができます。（マーク"
"アップと解釈される文字がクエリに含まれるなら、 <literal>CDATA</literal> セク"
"ションを使うことを忘れないようにしましょう。）"

#. Tag: para
#, no-c-format
msgid "Parameter binding and executing is done programatically:"
msgstr ""
"パラメータのバインディングと実行は、以下のようなプログラムで行われます:"

#. Tag: para
#, no-c-format
msgid ""
"The actual program code is independent of the query language that is used. "
"You can also define native SQL queries in metadata, or migrate existing "
"queries to Hibernate by placing them in mapping files."
msgstr ""
"実際のプログラムコードは、使われるクエリ言語に依存していないことに注意しま"
"しょう。メタデータには、ネイティブ SQL クエリを定義することもできます。また、"
"既存のクエリをマッピングファイルに移すことで、 Hibernate に移行することもでき"
"ます。"

#. Tag: para
#, no-c-format
msgid ""
"Also note that a query declaration inside a <literal>&lt;hibernate-"
"mapping&gt;</literal> element requires a global unique name for the query, "
"while a query declaration inside a <literal>&lt;class&gt;</literal> element "
"is made unique automatically by prepending the fully qualified name of the "
"class. For example <literal>eg.Cat.ByNameAndMaximumWeight</literal>."
msgstr ""
"<literal>&lt;hibernate-mapping&gt;</literal> 要素の中のクエリ定義は、クエリに"
"対するユニークな名前が必要なことにも注意してください。それに対して、 "
"<literal>&lt;class&gt;</literal> 要素の中のクエリ定義は、クラスの完全限定名が"
"前に付けられるので、自動的にユニークな名前になります。例： <literal>eg.Cat."
"ByNameAndMaximumWeight</literal>"

#. Tag: title
#, no-c-format
msgid "Filtering collections"
msgstr "フィルタリングコレクション"

#. Tag: para
#, no-c-format
msgid ""
"A collection <emphasis>filter</emphasis> is a special type of query that can "
"be applied to a persistent collection or array. The query string can refer "
"to <literal>this</literal>, meaning the current collection element."
msgstr ""
"コレクション <emphasis>フィルタ</emphasis> は、永続化されているコレクションや"
"配列に適用される特殊なタイプのクエリです。そのクエリ文字列では、コレクション"
"のその時点での要素を意味する <literal>this</literal> を使います。"

#. Tag: para
#, no-c-format
msgid ""
"The returned collection is considered a bag that is a copy of the given "
"collection. The original collection is not modified. This is contrary to the "
"implication of the name \"filter\", but consistent with expected behavior."
msgstr ""
"返されるコレクションは Bag とみなされます。そして、それはもとのコレクションの"
"コピーになります。元のコレクションは修正されません（これは、 \"filter\" とい"
"う名前の意味とは異なりますが、期待される動きとは一致しています）。"

#. Tag: para
#, no-c-format
msgid ""
"Observe that filters do not require a <literal>from</literal> clause, "
"although they can have one if required. Filters are not limited to returning "
"the collection elements themselves."
msgstr ""
"フィルタには <literal>from</literal> 節が不要であることに気づくでしょう（必要"
"なら、持つことも可能ですが）。フィルタは、コレクションの要素自体を返して構い"
"ません。"

#. Tag: para
#, no-c-format
msgid ""
"Even an empty filter query is useful, e.g. to load a subset of elements in a "
"large collection:"
msgstr ""
"クエリを含まないフィルタも役に立ちます。例えば、非常に大きなコレクションの部"
"分集合をロードするために使えます。"

#. Tag: title
#, no-c-format
msgid "Criteria queries"
msgstr "クライテリアのクエリ"

#. Tag: para
#, no-c-format
msgid ""
"HQL is extremely powerful, but some developers prefer to build queries "
"dynamically using an object-oriented API, rather than building query "
"strings. Hibernate provides an intuitive <literal>Criteria</literal> query "
"API for these cases:"
msgstr ""
"HQL は非常に強力ですが、クエリ文字列を作るよりも、オブジェクト指向の API を"
"使って動的にクエリを作る方を好む開発者もいます。こういった場合のために、 "
"Hibernate は直感的な <literal>Criteria</literal> クエリ API を提供していま"
"す。"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>Criteria</literal> and the associated <literal>Example</"
"literal> API are discussed in more detail in <xref linkend=\"querycriteria"
"\" />."
msgstr ""
"<literal>Criteria</literal> と <literal>Example</literal> API の詳細は、 "
"<xref linkend=\"querycriteria\"/> に述べられています。"

#. Tag: title
#, no-c-format
msgid "Queries in native SQL"
msgstr "ネイティブ SQL のクエリ"

#. Tag: para
#, no-c-format
msgid ""
"You can express a query in SQL, using <literal>createSQLQuery()</literal> "
"and let Hibernate manage the mapping from result sets to objects. You can at "
"any time call <literal>session.connection()</literal> and use the JDBC "
"<literal>Connection</literal> directly. If you choose to use the Hibernate "
"API, you must enclose SQL aliases in braces:"
msgstr ""
"<literal>createSQLQuery()</literal> を使って、 SQL でクエリを表現することもで"
"きます。そして、 Hibernate に、 ResultSet からオブジェクトへのマッピングをま"
"かせます。 <literal>session.connection()</literal> を呼べばどんなときでも、直"
"接、 JDBC <literal>Connection</literal> を使用できることを覚えておきましょ"
"う。もし、 Hibernate API を使うのであれば、下記のように SQL の別名を括弧でく"
"くらなければなりません。"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"SQL queries can contain named and positional parameters, just like Hibernate "
"queries. More information about native SQL queries in Hibernate can be found "
"in <xref linkend=\"querysql\" />."
msgstr ""
"SQL クエリは、 Hibernate クエリと同じように、名前付きのパラメータと位置パラ"
"メータを持つことができます。 Hibernate におけるネイティブな SQL クエリの詳細"
"については、 <xref linkend=\"querysql\"/> を参照してください。"

#. Tag: title
#, no-c-format
msgid "Modifying persistent objects"
msgstr "永続オブジェクトの修正"

#. Tag: para
#, no-c-format
msgid ""
"<emphasis>Transactional persistent instances</emphasis> (i.e. objects "
"loaded, saved, created or queried by the <literal>Session</literal>) can be "
"manipulated by the application, and any changes to persistent state will be "
"persisted when the <literal>Session</literal> is <emphasis>flushed</"
"emphasis>. This is discussed later in this chapter. There is no need to call "
"a particular method (like <literal>update()</literal>, which has a different "
"purpose) to make your modifications persistent. The most straightforward way "
"to update the state of an object is to <literal>load()</literal> it and then "
"manipulate it directly while the <literal>Session</literal> is open:"
msgstr ""
"<emphasis>処理中の永続インスタンス</emphasis> （例： <literal>Session</"
"literal> によって、ロード、セーブ、作成、クエリされたオブジェクト）は、アプリ"
"ケーションに操作されます。その際に変更された永続状態は、 <literal>Session</"
"literal> が <emphasis>フラッシュ</emphasis> されるときに、永続化されます（こ"
"れは、この章の後半で述べています）。変更を永続化するために、特殊なメソッド"
"（ <literal>update()</literal> のようなもの。これは、別の目的で使用します）を"
"呼ぶ必要はありません。オブジェクトの状態を更新する一番簡単な方法は、オブジェ"
"クトを <literal>load()</literal> し、 <literal>Session</literal> をオープンに"
"している間に、直接操作することです。"

#. Tag: para
#, no-c-format
msgid ""
"Sometimes this programming model is inefficient, as it requires in the same "
"session both an SQL <literal>SELECT</literal> to load an object and an SQL "
"<literal>UPDATE</literal> to persist its updated state. Hibernate offers an "
"alternate approach by using detached instances."
msgstr ""
"（オブジェクトをロードするための） SQL の <literal>SELECT</literal> と（更新"
"された状態を永続化するための） SQL の <literal>UPDATE</literal> が同じセッ"
"ションで必要となるので、このプログラミングモデルは、効率が悪くなる場合があり"
"ます。そのため、 Hibernate は別の方法を用意しています。それは、 detached イン"
"スタンスを使用する方法です。"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate does not offer its own API for direct execution of "
"<literal>UPDATE</literal> or <literal>DELETE</literal> statements. Hibernate "
"is a <emphasis>state management</emphasis> service, you do not have to think "
"in <emphasis>statements</emphasis> to use it. JDBC is a perfect API for "
"executing SQL statements, you can get a JDBC <literal>Connection</literal> "
"at any time by calling <literal>session.connection()</literal>. Furthermore, "
"the notion of mass operations conflicts with object/relational mapping for "
"online transaction processing-oriented applications. Future versions of "
"Hibernate can, however, provide special mass operation functions. See <xref "
"linkend=\"batch\" /> for some possible batch operation tricks."
msgstr ""
"Hibernate は、 <literal>UPDATE</literal> 文や <literal>DELETE</literal> 文を"
"直接実行する API を用意していません。 Hibernate は、 <emphasis>ステートマネー"
"ジメント</emphasis> サービスであり、それを使うのに <emphasis>ステートメント</"
"emphasis> のことを開発者が考える必要はありません。 JDBC は SQL 文を実行する完"
"璧な API であり、 <literal>session.connection()</literal> を呼ぶことでいつで"
"も、 JDBC <literal>Connection</literal> を開発者は取得できます。さらに、大量"
"のデータ操作の考え方は、オンライントランザクション処理向きアプリケーションの"
"オブジェクト/リレーショナルマッピングと衝突します。しかし、 Hibernate の今後"
"のバージョンでは、大量データを処理する特別な機能を提供するかもしれません。"
"バッチ操作に利用できるいくつかの工夫については、 <xref linkend=\"batch\"/> を"
"参照してください。"

#. Tag: title
#, no-c-format
msgid "Modifying detached objects"
msgstr "detached オブジェクトの修正"

#. Tag: para
#, no-c-format
msgid ""
"Many applications need to retrieve an object in one transaction, send it to "
"the UI layer for manipulation, then save the changes in a new transaction. "
"Applications that use this kind of approach in a high-concurrency "
"environment usually use versioned data to ensure isolation for the \"long\" "
"unit of work."
msgstr ""
"多くのアプリケーションでは次のことが必要になります。それは、あるトランザク"
"ションでオブジェクトを復元し、操作するためにそれを UI 層に送り、その後に、新"
"しいトランザクションで変更をセーブするといったことです。並行性の高い環境で、"
"このタイプのアプローチを使うアプリケーションでは、「期間の長い」作業単位の隔"
"離性を保証するために、バージョンデータが通常使われます。"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate supports this model by providing for reattachment of detached "
"instances using the <literal>Session.update()</literal> or <literal>Session."
"merge()</literal> methods:"
msgstr ""
"Hibernate は、 <literal>Session.update()</literal> や <literal>Session.merge"
"()</literal> メソッドを使って、 detached インスタンスを再追加することで、この"
"モデルに対応します。"

#. Tag: para
#, no-c-format
msgid ""
"If the <literal>Cat</literal> with identifier <literal>catId</literal> had "
"already been loaded by <literal>secondSession</literal> when the application "
"tried to reattach it, an exception would have been thrown."
msgstr ""
"識別子 <literal>catId</literal> を持つ <literal>Cat</literal> が、既に "
"<literal>secondSession</literal> でロードされていた場合は、再追加しようとした"
"ときに、例外が投げられます。"

#. Tag: para
#, no-c-format
msgid ""
"Use <literal>update()</literal> if you are certain that the session does not "
"contain an already persistent instance with the same identifier. Use "
"<literal>merge()</literal> if you want to merge your modifications at any "
"time without consideration of the state of the session. In other words, "
"<literal>update()</literal> is usually the first method you would call in a "
"fresh session, ensuring that the reattachment of your detached instances is "
"the first operation that is executed."
msgstr ""
"同じ識別子を持つ永続インスタンスをセッションが既に保持していないことを確信で"
"きるなら <literal>update()</literal> を使います。そして、セッションの状態を考"
"えずに、どんな場合でも変更をマージしたい場合は、 <literal>merge()</literal> "
"を使います。すなわち、 detached インスタンスの再追加操作が、最初に実行される"
"ことを確実にするために、通常は <literal>update()</literal> が新しいセッション"
"のなかで最初に呼ばれるメソッドになります。"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The application should individually <literal>update()</literal> detached "
"instances that are reachable from the given detached instance "
"<emphasis>only</emphasis> if it wants their state to be updated. This can be "
"automated using <emphasis>transitive persistence</emphasis>. See <xref "
"linkend=\"objectstate-transitive\" /> for more information."
msgstr ""
"detached インスタンスから到達可能な、 detached インスタンスをアプリケーション"
"は個別に <literal>update()</literal> すべきです。それは、その状態を更新したい"
"場合に <emphasis>限ります。</emphasis>  <emphasis>遷移的な永続化</emphasis> "
"を使えば、もちろん自動化できます。<xref linkend=\"objectstate-transitive\"/> "
"を参照してください。"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>lock()</literal> method also allows an application to "
"reassociate an object with a new session. However, the detached instance has "
"to be unmodified."
msgstr ""
"<literal>lock()</literal> メソッドでもまた、新しいセッションにオブジェクトを"
"再関連付けできます。しかし、 detached インスタンスは無修正でなければなりませ"
"ん。"

#. Tag: para
#, no-c-format
msgid ""
"Note that <literal>lock()</literal> can be used with various "
"<literal>LockMode</literal>s. See the API documentation and the chapter on "
"transaction handling for more information. Reattachment is not the only "
"usecase for <literal>lock()</literal>."
msgstr ""
"<literal>lock()</literal> は、さまざまな <literal>LockMode</literal> とともに"
"使うことができます。詳細は、 API ドキュメントとトランザクション処理の章を参照"
"してください。再追加のときにだけ、 <literal>lock()</literal> が使われるわけで"
"はありません。"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Other models for long units of work are discussed in <xref linkend="
"\"transactions-optimistic\" />."
msgstr ""
"期間の長い作業単位の、その他のモデルは、 <xref linkend=\"transactions-"
"optimistic\"/> で述べています。"

#. Tag: title
#, no-c-format
msgid "Automatic state detection"
msgstr "自動的な状態検出"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate users have requested a general purpose method that either saves a "
"transient instance by generating a new identifier or updates/reattaches the "
"detached instances associated with its current identifier. The "
"<literal>saveOrUpdate()</literal> method implements this functionality."
msgstr ""
"Hibernate のユーザーは次の2つのケースのどちらにも使える汎用的なメソッドを要求"
"していました。それは、新しい識別子を生成して transient インスタンスをセーブす"
"ることと、その時点の識別子と関連づいている detached インスタンスを更新/再追加"
"することのできるメソッドです。 <literal>saveOrUpdate()</literal> はこのような"
"機能を実現したメソッドです。"

#. Tag: para
#, no-c-format
msgid ""
"The usage and semantics of <literal>saveOrUpdate()</literal> seems to be "
"confusing for new users. Firstly, so long as you are not trying to use "
"instances from one session in another new session, you should not need to "
"use <literal>update()</literal>, <literal>saveOrUpdate()</literal>, or "
"<literal>merge()</literal>. Some whole applications will never use either of "
"these methods."
msgstr ""
"<literal>saveOrUpdate()</literal> の使用方法と意味は、新しいユーザーにとって"
"混乱を招くかもしれません。まず第一に、あるセッションで使用したインスタンスを"
"別の新しいセッションで使おうとしない限り、 <literal>update()</literal> や "
"<literal>saveOrUpdate()</literal> や <literal>merge()</literal> を使う必要は"
"ありません。アプリケーション全体を通じて、これらのメソッドを全く使わないこと"
"もあります。"

#. Tag: para
#, no-c-format
msgid ""
"Usually <literal>update()</literal> or <literal>saveOrUpdate()</literal> are "
"used in the following scenario:"
msgstr ""
"通常、 <literal>update()</literal> や <literal>saveOrUpdate()</literal> は次"
"のシナリオで使われます:"

#. Tag: para
#, no-c-format
msgid "the application loads an object in the first session"
msgstr "アプリケーションが最初のセッションでオブジェクトをロードします。"

#. Tag: para
#, no-c-format
msgid "the object is passed up to the UI tier"
msgstr "オブジェクトが UI 層に送られます。"

#. Tag: para
#, no-c-format
msgid "some modifications are made to the object"
msgstr "オブジェクトに対して変更が加えられます。"

#. Tag: para
#, no-c-format
msgid "the object is passed back down to the business logic tier"
msgstr "オブジェクトがビジネスロジック層に送られます。"

#. Tag: para
#, no-c-format
msgid ""
"the application persists these modifications by calling <literal>update()</"
"literal> in a second session"
msgstr ""
"アプリケーションは、2番目のセッションで <literal>update()</literal> を呼ぶこ"
"とで、これらの変更を永続化します。"

#. Tag: para
#, no-c-format
msgid "<literal>saveOrUpdate()</literal> does the following:"
msgstr "<literal>saveOrUpdate()</literal> は以下のことを行います:"

#. Tag: para
#, no-c-format
msgid "if the object is already persistent in this session, do nothing"
msgstr ""
"オブジェクトがこのセッションで、すでに永続化されていれば、何もしません。"

#. Tag: para
#, no-c-format
msgid ""
"if another object associated with the session has the same identifier, throw "
"an exception"
msgstr ""
"そのセッションに関連づいている別のオブジェクトが同じ識別子を持っているなら、"
"例外を投げます。"

#. Tag: para
#, no-c-format
msgid "if the object has no identifier property, <literal>save()</literal> it"
msgstr ""
"オブジェクトの識別子が値を持たないならば、 <literal>save()</literal> します。"

#. Tag: para
#, no-c-format
msgid ""
"if the object's identifier has the value assigned to a newly instantiated "
"object, <literal>save()</literal> it"
msgstr ""
"オブジェクトの識別子が値を持ち、その値が新たにインスタンス化されたオブジェク"
"トのための値である場合、そのオブジェクトを <literal>save()</literal> します。"

#. Tag: para
#, no-c-format
msgid ""
"if the object is versioned by a <literal>&lt;version&gt;</literal> or "
"<literal>&lt;timestamp&gt;</literal>, and the version property value is the "
"same value assigned to a newly instantiated object, <literal>save()</"
"literal> it"
msgstr ""
"オブジェクトが（ <literal>&lt;version&gt;</literal> や <literal>&lt;"
"timestamp&gt;</literal> によって）バージョンづけされていて、バージョンのプロ"
"パティが値を持ち、その値が新しくインスタンス化されたオブジェクトのための値で"
"ある場合、そのオブジェクトを <literal>save()</literal> します。"

#. Tag: para
#, no-c-format
msgid "otherwise <literal>update()</literal> the object"
msgstr ""
"そうでない場合は、そのオブジェクトを <literal>update()</literal> します。"

#. Tag: para
#, no-c-format
msgid "and <literal>merge()</literal> is very different:"
msgstr "そして、 <literal>merge()</literal> は以下のように非常に異なります:"

#. Tag: para
#, no-c-format
msgid ""
"if there is a persistent instance with the same identifier currently "
"associated with the session, copy the state of the given object onto the "
"persistent instance"
msgstr ""
"同じ識別子を持つ永続化インスタンスがその時点でセッションと関連付いているなら"
"ば、引数で受け取ったオブジェクトの状態を永続化インスタンスにコピーします。"

#. Tag: para
#, no-c-format
msgid ""
"if there is no persistent instance currently associated with the session, "
"try to load it from the database, or create a new persistent instance"
msgstr ""
"永続化インスタンスがその時点でセッションに関連付いていないなら、データベース"
"からそれをロードするか、あるいは、新しい永続化インスタンスを作成します。"

#. Tag: para
#, no-c-format
msgid "the persistent instance is returned"
msgstr "永続化インスタンスが返されます。"

#. Tag: para
#, no-c-format
msgid ""
"the given instance does not become associated with the session, it remains "
"detached"
msgstr ""
"引数として与えたインスタンスはセッションと関連を持ちません。それは、分離状態"
"のままです。"

#. Tag: title
#, no-c-format
msgid "Deleting persistent objects"
msgstr "永続オブジェクトの削除"

#. Tag: para
#, no-c-format
msgid ""
"<literal>Session.delete()</literal> will remove an object's state from the "
"database. Your application, however, can still hold a reference to a deleted "
"object. It is best to think of <literal>delete()</literal> as making a "
"persistent instance, transient."
msgstr ""
"<literal>Session.delete()</literal> はオブジェクトの状態をデータベースから削"
"除します。もちろん、削除したオブジェクトをアプリケーションが保持したままでも"
"よいです。そのため、 <literal>delete()</literal> は永続インスタンスを "
"transient にするものと考えるのが一番です。"

#. Tag: para
#, no-c-format
msgid ""
"You can delete objects in any order, without risk of foreign key constraint "
"violations. It is still possible to violate a <literal>NOT NULL</literal> "
"constraint on a foreign key column by deleting objects in the wrong order, e."
"g. if you delete the parent, but forget to delete the children."
msgstr ""
"外部キー制約に違反するリスクもなく、好きな順番でオブジェクトを削除することが"
"できます。ただし、間違った順番でオブジェクトを削除すると、外部キーカラムの "
"<literal>NOT NULL</literal> 制約に違反する可能性があります。例えば、親オブ"
"ジェクトを削除したときに、子供オブジェクトを削除し忘れた場合です。"

#. Tag: title
#, no-c-format
msgid "Replicating object between two different datastores"
msgstr "異なる二つのデータストア間でのオブジェクトのレプリケーション"

#. Tag: para
#, no-c-format
msgid ""
"It is sometimes useful to be able to take a graph of persistent instances "
"and make them persistent in a different datastore, without regenerating "
"identifier values."
msgstr ""
"永続インスタンスのグラフを別のデータストアに永続化する場合に、識別子の値を再"
"生成せずにすむと便利な場合があります。"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>ReplicationMode</literal> determines how <literal>replicate()</"
"literal> will deal with conflicts with existing rows in the database:"
msgstr ""
"レプリケーション先のデータベースに行が既にある場合、 <literal>replicate()</"
"literal> が衝突をどのように扱うかを <literal>ReplicationMode</literal> で指定"
"します。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>ReplicationMode.IGNORE</literal>: ignores the object when there is "
"an existing database row with the same identifier"
msgstr ""
"<literal>ReplicationMode.IGNORE</literal> - 同じ識別子を持つ行がデータベース"
"に存在するなら、そのオブジェクトを無視します。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>ReplicationMode.OVERWRITE</literal>: overwrites any existing "
"database row with the same identifier"
msgstr ""
"<literal>ReplicationMode.OVERWRITE</literal> - 同じ識別子を持つ既存の行をすべ"
"て上書きします。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>ReplicationMode.EXCEPTION</literal>: throws an exception if there "
"is an existing database row with the same identifier"
msgstr ""
"<literal>ReplicationMode.EXCEPTION</literal> - 同じ識別子を持つ行がデータベー"
"スに存在するなら、例外を投げます。"

#. Tag: para
#, no-c-format
msgid ""
"<literal>ReplicationMode.LATEST_VERSION</literal>: overwrites the row if its "
"version number is earlier than the version number of the object, or ignore "
"the object otherwise"
msgstr ""
"<literal>ReplicationMode.LATEST_VERSION</literal> - 行に保存されているバー"
"ジョン番号が、引数のオブジェクトのバージョン番号より古いならば、その行を上書"
"きします。"

#. Tag: para
#, no-c-format
msgid ""
"Usecases for this feature include reconciling data entered into different "
"database instances, upgrading system configuration information during "
"product upgrades, rolling back changes made during non-ACID transactions and "
"more."
msgstr ""
"次のようなケースで、この機能を使用します。異なるデータベースインスタンスに入"
"れられたデータの同期、製品更新時におけるシステム設定情報の更新、非 ACID トラ"
"ンザクションのなかで加えられた変更のロールバックなどです。"

#. Tag: title
#, no-c-format
msgid "Flushing the Session"
msgstr "セッションのフラッシュ"

#. Tag: para
#, no-c-format
msgid ""
"Sometimes the <literal>Session</literal> will execute the SQL statements "
"needed to synchronize the JDBC connection's state with the state of objects "
"held in memory. This process, called <emphasis>flush</emphasis>, occurs by "
"default at the following points:"
msgstr ""
"JDBC コネクションの状態とメモリ上のオブジェクトの状態を同期させるために必要"
"な SQL 文を <literal>Session</literal> が実行することがときどきあります。この"
"処理 <emphasis>flush</emphasis> は、デフォルトでは次のときに起こります。"

#. Tag: para
#, no-c-format
msgid "before some query executions"
msgstr "クエリを実行する前"

#. Tag: para
#, no-c-format
msgid "from <literal>org.hibernate.Transaction.commit()</literal>"
msgstr "<literal>org.hibernate.Transaction.commit()</literal> を実行したとき"

#. Tag: para
#, no-c-format
msgid "from <literal>Session.flush()</literal>"
msgstr "<literal>Session.flush()</literal> を実行したとき"

#. Tag: para
#, no-c-format
msgid "The SQL statements are issued in the following order:"
msgstr "SQL 文は以下の順番で発行されます。"

#. Tag: para
#, no-c-format
msgid ""
"all entity insertions in the same order the corresponding objects were saved "
"using <literal>Session.save()</literal>"
msgstr ""
"すべてのエンティティの挿入。これは、 <literal>Session.save()</literal> を使っ"
"てセーブしたオブジェクトの順に実行していきます。"

#. Tag: para
#, no-c-format
msgid "all entity updates"
msgstr "すべてのエンティティの更新"

#. Tag: para
#, no-c-format
msgid "all collection deletions"
msgstr "すべてのコレクションの削除"

#. Tag: para
#, no-c-format
msgid "all collection element deletions, updates and insertions"
msgstr "すべてのコレクションの要素に対する削除、更新、挿入"

#. Tag: para
#, no-c-format
msgid "all collection insertions"
msgstr "すべてのコレクションの挿入"

#. Tag: para
#, no-c-format
msgid ""
"all entity deletions in the same order the corresponding objects were "
"deleted using <literal>Session.delete()</literal>"
msgstr ""
"すべてのエンティティの削除。これは、 <literal>Session.delete()</literal> を"
"使って削除したオブジェクトの順に実行していきます。"

#. Tag: para
#, no-c-format
msgid ""
"An exception is that objects using <literal>native</literal> ID generation "
"are inserted when they are saved."
msgstr ""
"(１つ例外があります。 <literal>native</literal> ID 生成を使ったオブジェクト"
"は、それらがセーブされたときに挿入されます。）"

#. Tag: para
#, no-c-format
msgid ""
"Except when you explicitly <literal>flush()</literal>, there are absolutely "
"no guarantees about <emphasis>when</emphasis> the <literal>Session</literal> "
"executes the JDBC calls, only the <emphasis>order</emphasis> in which they "
"are executed. However, Hibernate does guarantee that the <literal>Query.list"
"(..)</literal> will never return stale or incorrect data."
msgstr ""
"明示的に <literal>flush()</literal> するときを除いて、 <emphasis>いつ</"
"emphasis> <literal>Session</literal> が JDBC をコールするのかについて絶対的な"
"保証はありません。ただし、それらが実行される <emphasis>順番</emphasis> だけは"
"保証されます。また、 Hibernate は、 <literal>Query.list(..)</literal> が古い"
"データや間違ったデータ返さないことを保証しています。"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is possible to change the default behavior so that flush occurs less "
"frequently. The <literal>FlushMode</literal> class defines three different "
"modes: only flush at commit time when the Hibernate <literal>Transaction</"
"literal> API is used, flush automatically using the explained routine, or "
"never flush unless <literal>flush()</literal> is called explicitly. The last "
"mode is useful for long running units of work, where a <literal>Session</"
"literal> is kept open and disconnected for a long time (see <xref linkend="
"\"transactions-optimistic-longsession\" />)."
msgstr ""
"フラッシュが頻繁に起こらないようにデフォルトの振る舞いを変えることができま"
"す。 <literal>FlushMode</literal> クラスは3つの異なるモードを定義します。それ"
"は、コミット時にだけフラッシュするモード（Hibernate の <literal>Transaction</"
"literal> API が使われる場合だけです）、説明のあった処理順に基づいて自動でフ"
"ラッシュするモード、 <literal>flush()</literal> が明示的に呼ばれない限りフ"
"ラッシュしないモードの３つです。最後のモードは、作業単位が長期間に及ぶ場合に"
"役に立ちます ( <xref linkend=\"transactions-optimistic-longsession\"/> を参照"
"してください)。"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"During flush, an exception might occur (e.g. if a DML operation violates a "
"constraint). Since handling exceptions involves some understanding of "
"Hibernate's transactional behavior, we discuss it in <xref linkend="
"\"transactions\" />."
msgstr ""
"フラッシュのとき、例外が発生するかもしれません（例えば、 DML 操作が制約を違反"
"するような場合です）。例外処理を理解するためには、 Hibernate のトランザクショ"
"ンの振る舞いを理解する必要があるため、 <xref linkend=\"transactions\"/> で説"
"明します。"

#. Tag: title
#, no-c-format
msgid "Transitive persistence"
msgstr "連鎖的な永続化"

#. Tag: para
#, no-c-format
msgid ""
"It is quite cumbersome to save, delete, or reattach individual objects, "
"especially if you deal with a graph of associated objects. A common case is "
"a parent/child relationship. Consider the following example:"
msgstr ""
"個々のオブジェクトをセーブしたり、削除したり、再追加したりすることはかなり面"
"倒です。特に、関連するオブジェクトを扱うような場合には際立ちます。よくあるの"
"は、親子関係を扱うケースです。以下の例を考えてみましょう:"

#. Tag: para
#, no-c-format
msgid ""
"If the children in a parent/child relationship would be value typed (e.g. a "
"collection of addresses or strings), their life cycle would depend on the "
"parent and no further action would be required for convenient \"cascading\" "
"of state changes. When the parent is saved, the value-typed child objects "
"are saved and when the parent is deleted, the children will be deleted, etc. "
"This works for operations such as the removal of a child from the "
"collection. Since value-typed objects cannot have shared references, "
"Hibernate will detect this and delete the child from the database."
msgstr ""
"もし、親子関係の子が値型なら（例えば、住所や文字列のコレクション）、それらの"
"ライフサイクルは親に依存しており、便利な状態変化の「カスケード」を使うため"
"に、追加の作業は必要はありません。親がセーブされたとき、値型の子オブジェクト"
"も同じようにセーブされますし、親が削除されたときは、子も削除されます。その他"
"の操作も同じです。コレクションから1つの子を削除するような操作でもうまくいきま"
"す。すなわち、 Hibernate はこの削除操作を検出すると、値型のオブジェクトは参照"
"を共有できないので、データベースからその子供を削除します。"

#. Tag: para
#, no-c-format
msgid ""
"Now consider the same scenario with parent and child objects being entities, "
"not value-types (e.g. categories and items, or parent and child cats). "
"Entities have their own life cycle and support shared references. Removing "
"an entity from the collection does not mean it can be deleted), and there is "
"by default no cascading of state from one entity to any other associated "
"entities. Hibernate does not implement <emphasis>persistence by "
"reachability</emphasis> by default."
msgstr ""
"ここで、親と子が値型でなくエンティティであるとして同じシナリオを考えてみま"
"しょう。（例えば、カテゴリーと品目の関係や親と子の猫の関係です。）エンティ"
"ティは、それ自身がライフサイクルを持ち、参照の共有をサポートします。（そのた"
"め、コレクションからエンティティを削除することは、エンティティ自身の削除を意"
"味しません。）また、エンティティは、デフォルトでは、関連する他のエンティティ"
"へ状態をカスケードすることはありません。 Hibernate は <emphasis>到達可能性に"
"よる永続化</emphasis> をデフォルトでは実行しません。"

#. Tag: para
#, no-c-format
msgid ""
"For each basic operation of the Hibernate session - including "
"<literal>persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), "
"evict(), replicate()</literal> - there is a corresponding cascade style. "
"Respectively, the cascade styles are named <literal>create, merge, save-"
"update, delete, lock, refresh, evict, replicate</literal>. If you want an "
"operation to be cascaded along an association, you must indicate that in the "
"mapping document. For example:"
msgstr ""
"Hibernate の Session の基本操作（ <literal>persist(), merge(), saveOrUpdate"
"(), delete(), lock(), refresh(), evict(), replicate()</literal> が含まれま"
"す）に対して、それぞれに対応するカスケードスタイルがあります。それぞれのカス"
"ケードスタイルには、 <literal>create, merge, save-update, delete, lock, "
"refresh, evict, replicate</literal> という名前がついています。もし、関連に"
"沿ってカスケードさせたい操作があるなら、マッピングファイルにそう指定しなけれ"
"ばなりません。例えば、以下のようにします:"

#. Tag: para
#, no-c-format
msgid "Cascade styles my be combined:"
msgstr "カスケードスタイルは、組み合わせることができます:"

#. Tag: para
#, no-c-format
msgid ""
"You can even use <literal>cascade=\"all\"</literal> to specify that "
"<emphasis>all</emphasis> operations should be cascaded along the "
"association. The default <literal>cascade=\"none\"</literal> specifies that "
"no operations are to be cascaded."
msgstr ""
"<emphasis>すべての</emphasis> 操作を関連に沿ってカスケードするよう指定すると"
"きは、 <literal>cascade=\"all\"</literal> を使います。デフォルトの "
"<literal>cascade=\"none\"</literal> は、どの操作もカスケードしないことを意味"
"します。"

#. Tag: para
#, no-c-format
msgid ""
"A special cascade style, <literal>delete-orphan</literal>, applies only to "
"one-to-many associations, and indicates that the <literal>delete()</literal> "
"operation should be applied to any child object that is removed from the "
"association."
msgstr ""
"特殊なカスケードスタイル <literal>delete-orphan</literal> は、一対多関連にだ"
"け適用できます。これは、関連から削除された子供のオブジェクトに対して、 "
"<literal>delete()</literal> 操作が適用されることを意味します。"

#. Tag: para
#, no-c-format
msgid "Recommendations:"
msgstr "おすすめ："

#. Tag: para
#, no-c-format
msgid ""
"It does not usually make sense to enable cascade on a <literal>&lt;many-to-"
"one&gt;</literal> or <literal>&lt;many-to-many&gt;</literal> association. "
"Cascade is often useful for <literal>&lt;one-to-one&gt;</literal> and "
"<literal>&lt;one-to-many&gt;</literal> associations."
msgstr ""
"普通、 <literal>&lt;many-to-one&gt;</literal> や <literal>&lt;many-to-"
"many&gt;</literal> 関連に対しては、カスケードを設定する意味はありません。 "
"<literal>&lt;one-to-one&gt;</literal> と <literal>&lt;one-to-many&gt;</"
"literal> 関連に対しては、カスケードが役に立つことがあります。"

#. Tag: para
#, no-c-format
msgid ""
"If the child object's lifespan is bounded by the lifespan of the parent "
"object, make it a <emphasis>life cycle object</emphasis> by specifying "
"<literal>cascade=\"all,delete-orphan\"</literal>."
msgstr ""
"子供オブジェクトの寿命が親オブジェクトの寿命に制限を受けるならば、 "
"<literal>cascade=\"all,delete-orphan\"</literal> を指定し、子供オブジェクト"
"を <emphasis>ライフサイクルオブジェクト</emphasis> にします。"

#. Tag: para
#, no-c-format
msgid ""
"Otherwise, you might not need cascade at all. But if you think that you will "
"often be working with the parent and children together in the same "
"transaction, and you want to save yourself some typing, consider using "
"<literal>cascade=\"persist,merge,save-update\"</literal>."
msgstr ""
"それ以外の場合は、カスケードはほとんど必要ないでしょう。しかし、同じトランザ"
"クションのなかで親と子が一緒に動作することが多いと思い、いくらかのコードを書"
"く手間を省きたいのであれば、 <literal>cascade=\"persist,merge,save-update\"</"
"literal> を使うことを考えましょう。"

#. Tag: para
#, no-c-format
msgid ""
"Mapping an association (either a single valued association, or a collection) "
"with <literal>cascade=\"all\"</literal> marks the association as a "
"<emphasis>parent/child</emphasis> style relationship where save/update/"
"delete of the parent results in save/update/delete of the child or children."
msgstr ""
"<literal>cascade=\"all\"</literal> でマッピングした関連（単値関連やコレクショ"
"ン）は、 <emphasis>親子</emphasis> スタイルの関連とマークされます。それは、親"
"のセーブ/更新/削除が、子のセーブ/更新/削除を引き起こす関係のことです。"

#. Tag: para
#, no-c-format
msgid ""
"Furthermore, a mere reference to a child from a persistent parent will "
"result in save/update of the child. This metaphor is incomplete, however. A "
"child which becomes unreferenced by its parent is <emphasis>not</emphasis> "
"automatically deleted, except in the case of a <literal>&lt;one-to-many&gt;</"
"literal> association mapped with <literal>cascade=\"delete-orphan\"</"
"literal>. The precise semantics of cascading operations for a parent/child "
"relationship are as follows:"
msgstr ""
"さらに、永続化された親が子を単に参照しているだけで、子のセーブ/更新を引き起こ"
"します。しかし、このメタファーは不完全です。親から参照されなくなった子は、自"
"動的に削除 <emphasis>されません</emphasis> 。ただし、 <literal>cascade="
"\"delete-orphan\"</literal> でマッピングされた <literal>&lt;one-to-many&gt;</"
"literal> 関連を除いてです。親子関係のカスケード操作の正確な意味は以下のように"
"なります:"

#. Tag: para
#, no-c-format
msgid ""
"If a parent is passed to <literal>persist()</literal>, all children are "
"passed to <literal>persist()</literal>"
msgstr ""
"親が <literal>persist()</literal> に渡されたならば、すべての子は "
"<literal>persist()</literal> に渡されます。"

#. Tag: para
#, no-c-format
msgid ""
"If a parent is passed to <literal>merge()</literal>, all children are passed "
"to <literal>merge()</literal>"
msgstr ""
"<literal>merge()</literal> に渡されたならば、すべての子は <literal>merge()</"
"literal> に渡されます。"

#. Tag: para
#, no-c-format
msgid ""
"If a parent is passed to <literal>save()</literal>, <literal>update()</"
"literal> or <literal>saveOrUpdate()</literal>, all children are passed to "
"<literal>saveOrUpdate()</literal>"
msgstr ""
"親が <literal>save()</literal> 、 <literal>update()</literal> 、 "
"<literal>saveOrUpdate()</literal> に渡されたならば、すべての子は "
"<literal>saveOrUpdate()</literal> に渡されます。"

#. Tag: para
#, no-c-format
msgid ""
"If a transient or detached child becomes referenced by a persistent parent, "
"it is passed to <literal>saveOrUpdate()</literal>"
msgstr ""
"transient または detached の子が、永続化された親に参照されたならば、 "
"<literal>saveOrUpdate()</literal> に渡されます。"

#. Tag: para
#, no-c-format
msgid ""
"If a parent is deleted, all children are passed to <literal>delete()</"
"literal>"
msgstr ""
"親が削除されたならば、すべての子は、 <literal>delete()</literal> に渡されま"
"す。"

#. Tag: para
#, no-c-format
msgid ""
"If a child is dereferenced by a persistent parent, <emphasis>nothing special "
"happens</emphasis> - the application should explicitly delete the child if "
"necessary - unless <literal>cascade=\"delete-orphan\"</literal>, in which "
"case the \"orphaned\" child is deleted."
msgstr ""
"子が永続化された親から参照されなくなったときは、 <emphasis>特に何も起こりませ"
"ん</emphasis> 。よって、アプリケーションが必要であれば、明示的に削除する必要"
"があります。ただし、 <literal>cascade=\"delete-orphan\"</literal> の場合を除"
"きます。この場合、「親のない」子は削除されます。"

#. Tag: para
#, no-c-format
msgid ""
"Finally, note that cascading of operations can be applied to an object graph "
"at <emphasis>call time</emphasis> or at <emphasis>flush time</emphasis>. All "
"operations, if enabled, are cascaded to associated entities reachable when "
"the operation is executed. However, <literal>save-update</literal> and "
"<literal>delete-orphan</literal> are transitive for all associated entities "
"reachable during flush of the <literal>Session</literal>."
msgstr ""
"最後に、操作のカスケードがオブジェクトグラフに適用されるのは、 <emphasis>コー"
"ルした時</emphasis> あるいは、 <emphasis>flushした時</emphasis> であることに"
"注意してください。すべての操作は、その操作が実行されたときに、到達可能な関連"
"するエンティティに対してカスケードが可能ならカスケードします。しかし、 "
"<literal>save-upate</literal> と <literal>delete-orphan</literal> は、 "
"<literal>Session</literal> が flush している間に、すべての到達可能な関連する"
"エンティティに伝播します。"

#. Tag: title
#, no-c-format
msgid "Using metadata"
msgstr "メタデータの使用"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate requires a rich meta-level model of all entity and value types. "
"This model can be useful to the application itself. For example, the "
"application might use Hibernate's metadata to implement a \"smart\" deep-"
"copy algorithm that understands which objects should be copied (eg. mutable "
"value types) and which objects that should not (e.g. immutable value types "
"and, possibly, associated entities)."
msgstr ""
"Hibernate は、すべてのエンティティと値型の非常にリッチなメタレベルのモデルを"
"必要とします。ときどき、このモデルはアプリケーションにとってとても役に立ちま"
"す。例えば、アプリケーションは、 Hibernate のメタデータを使って、「賢い」"
"ディープコピーアルゴリズムを実装できるかもしません。そのアルゴリズムとは、ど"
"のオブジェクトがコピーされるべきか（例：可変の値型）やどのオブジェクトはコ"
"ピーされないべきか（例：不変な値型や可能なら関連するエンティティ）を判断でき"
"るものです。"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate exposes metadata via the <literal>ClassMetadata</literal> and "
"<literal>CollectionMetadata</literal> interfaces and the <literal>Type</"
"literal> hierarchy. Instances of the metadata interfaces can be obtained "
"from the <literal>SessionFactory</literal>."
msgstr ""
"Hibernate は <literal>ClassMetadata</literal> と "
"<literal>CollectionMetadata</literal> インタフェースと <literal>Type</"
"literal> 階層を通してメタデータを公開します。メタデータインターフェースのイン"
"スタンスは、 <literal>SessionFactory</literal> から得られます。"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[DomesticCat fritz = new DomesticCat();\n"
#~ "fritz.setColor(Color.GINGER);\n"
#~ "fritz.setSex('M');\n"
#~ "fritz.setName(\"Fritz\");\n"
#~ "Long generatedId = (Long) sess.save(fritz);]]>"
#~ msgstr ""
#~ "DomesticCat fritz = new DomesticCat();\n"
#~ "fritz.setColor(Color.GINGER);\n"
#~ "fritz.setSex('M');\n"
#~ "fritz.setName(\"Fritz\");\n"
#~ "Long generatedId = (Long) sess.save(fritz);"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[DomesticCat pk = new DomesticCat();\n"
#~ "pk.setColor(Color.TABBY);\n"
#~ "pk.setSex('F');\n"
#~ "pk.setName(\"PK\");\n"
#~ "pk.setKittens( new HashSet() );\n"
#~ "pk.addKitten(fritz);\n"
#~ "sess.save( pk, new Long(1234) );]]>"
#~ msgstr ""
#~ "DomesticCat pk = new DomesticCat();\n"
#~ "pk.setColor(Color.TABBY);\n"
#~ "pk.setSex('F');\n"
#~ "pk.setName(\"PK\");\n"
#~ "pk.setKittens( new HashSet() );\n"
#~ "pk.addKitten(fritz);\n"
#~ "sess.save( pk, new Long(1234) );"

#, fuzzy
#~ msgid "<![CDATA[Cat fritz = (Cat) sess.load(Cat.class, generatedId);]]>"
#~ msgstr "Cat fritz = (Cat) sess.load(Cat.class, generatedId);"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[// you need to wrap primitive identifiers\n"
#~ "long id = 1234;\n"
#~ "DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long"
#~ "(id) );]]>"
#~ msgstr ""
#~ "// you need to wrap primitive identifiers\n"
#~ "long id = 1234;\n"
#~ "DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long"
#~ "(id) );"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Cat cat = new DomesticCat();\n"
#~ "// load pk's state into cat\n"
#~ "sess.load( cat, new Long(pkId) );\n"
#~ "Set kittens = cat.getKittens();]]>"
#~ msgstr ""
#~ "Cat cat = new DomesticCat();\n"
#~ "// load pk's state into cat\n"
#~ "sess.load( cat, new Long(pkId) );\n"
#~ "Set kittens = cat.getKittens();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Cat cat = (Cat) sess.get(Cat.class, id);\n"
#~ "if (cat==null) {\n"
#~ "    cat = new Cat();\n"
#~ "    sess.save(cat, id);\n"
#~ "}\n"
#~ "return cat;]]>"
#~ msgstr ""
#~ "Cat cat = (Cat) sess.get(Cat.class, id);\n"
#~ "if (cat==null) {\n"
#~ "    cat = new Cat();\n"
#~ "    sess.save(cat, id);\n"
#~ "}\n"
#~ "return cat;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);]]>"
#~ msgstr "Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.save(cat);\n"
#~ "sess.flush(); //force the SQL INSERT\n"
#~ "sess.refresh(cat); //re-read the state (after the trigger executes)]]>"
#~ msgstr ""
#~ "sess.save(cat);\n"
#~ "sess.flush(); //force the SQL INSERT\n"
#~ "sess.refresh(cat); //re-read the state (after the trigger executes)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[List cats = session.createQuery(\n"
#~ "    \"from Cat as cat where cat.birthdate < ?\")\n"
#~ "    .setDate(0, date)\n"
#~ "    .list();\n"
#~ "\n"
#~ "List mothers = session.createQuery(\n"
#~ "    \"select mother from Cat as cat join cat.mother as mother where cat."
#~ "name = ?\")\n"
#~ "    .setString(0, name)\n"
#~ "    .list();\n"
#~ "\n"
#~ "List kittens = session.createQuery(\n"
#~ "    \"from Cat as cat where cat.mother = ?\")\n"
#~ "    .setEntity(0, pk)\n"
#~ "    .list();\n"
#~ "\n"
#~ "Cat mother = (Cat) session.createQuery(\n"
#~ "    \"select cat.mother from Cat as cat where cat = ?\")\n"
#~ "    .setEntity(0, izi)\n"
#~ "    .uniqueResult();]]\n"
#~ "\n"
#~ "Query mothersWithKittens = (Cat) session.createQuery(\n"
#~ "    \"select mother from Cat as mother left join fetch mother.kittens"
#~ "\");\n"
#~ "Set uniqueMothers = new HashSet(mothersWithKittens.list());]]>"
#~ msgstr ""
#~ "List cats = session.createQuery(\n"
#~ "    \"from Cat as cat where cat.birthdate &lt; ?\")\n"
#~ "    .setDate(0, date)\n"
#~ "    .list();\n"
#~ "\n"
#~ "List mothers = session.createQuery(\n"
#~ "    \"select mother from Cat as cat join cat.mother as mother where cat."
#~ "name = ?\")\n"
#~ "    .setString(0, name)\n"
#~ "    .list();\n"
#~ "\n"
#~ "List kittens = session.createQuery(\n"
#~ "    \"from Cat as cat where cat.mother = ?\")\n"
#~ "    .setEntity(0, pk)\n"
#~ "    .list();\n"
#~ "\n"
#~ "Cat mother = (Cat) session.createQuery(\n"
#~ "    \"select cat.mother from Cat as cat where cat = ?\")\n"
#~ "    .setEntity(0, izi)\n"
#~ "    .uniqueResult();]]\n"
#~ "\n"
#~ "Query mothersWithKittens = (Cat) session.createQuery(\n"
#~ "    \"select mother from Cat as mother left join fetch mother.kittens"
#~ "\");\n"
#~ "Set uniqueMothers = new HashSet(mothersWithKittens.list());"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[// fetch ids\n"
#~ "Iterator iter = sess.createQuery(\"from eg.Qux q order by q.likeliness\")."
#~ "iterate();\n"
#~ "while ( iter.hasNext() ) {\n"
#~ "    Qux qux = (Qux) iter.next();  // fetch the object\n"
#~ "    // something we couldnt express in the query\n"
#~ "    if ( qux.calculateComplicatedAlgorithm() ) {\n"
#~ "        // delete the current instance\n"
#~ "        iter.remove();\n"
#~ "        // dont need to process the rest\n"
#~ "        break;\n"
#~ "    }\n"
#~ "}]]>"
#~ msgstr ""
#~ "// fetch ids\n"
#~ "Iterator iter = sess.createQuery(\"from eg.Qux q order by q.likeliness\")."
#~ "iterate();\n"
#~ "while ( iter.hasNext() ) {\n"
#~ "    Qux qux = (Qux) iter.next();  // fetch the object\n"
#~ "    // something we couldnt express in the query\n"
#~ "    if ( qux.calculateComplicatedAlgorithm() ) {\n"
#~ "        // delete the current instance\n"
#~ "        iter.remove();\n"
#~ "        // dont need to process the rest\n"
#~ "        break;\n"
#~ "    }\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Iterator kittensAndMothers = sess.createQuery(\n"
#~ "            \"select kitten, mother from Cat kitten join kitten.mother "
#~ "mother\")\n"
#~ "            .list()\n"
#~ "            .iterator();\n"
#~ "\n"
#~ "while ( kittensAndMothers.hasNext() ) {\n"
#~ "    Object[] tuple = (Object[]) kittensAndMothers.next();\n"
#~ "    Cat kitten = (Cat) tuple[0];\n"
#~ "    Cat mother = (Cat) tuple[1];\n"
#~ "    ....\n"
#~ "}]]>"
#~ msgstr ""
#~ "Iterator kittensAndMothers = sess.createQuery(\n"
#~ "            \"select kitten, mother from Cat kitten join kitten.mother "
#~ "mother\")\n"
#~ "            .list()\n"
#~ "            .iterator();\n"
#~ "\n"
#~ "while ( kittensAndMothers.hasNext() ) {\n"
#~ "    Object[] tuple = (Object[]) kittensAndMothers.next();\n"
#~ "    Cat kitten  = tuple[0];\n"
#~ "    Cat mother  = tuple[1];\n"
#~ "    ....\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Iterator results = sess.createQuery(\n"
#~ "        \"select cat.color, min(cat.birthdate), count(cat) from Cat cat "
#~ "\" +\n"
#~ "        \"group by cat.color\")\n"
#~ "        .list()\n"
#~ "        .iterator();\n"
#~ "\n"
#~ "while ( results.hasNext() ) {\n"
#~ "    Object[] row = (Object[]) results.next();\n"
#~ "    Color type = (Color) row[0];\n"
#~ "    Date oldest = (Date) row[1];\n"
#~ "    Integer count = (Integer) row[2];\n"
#~ "    .....\n"
#~ "}]]>"
#~ msgstr ""
#~ "Iterator results = sess.createQuery(\n"
#~ "        \"select cat.color, min(cat.birthdate), count(cat) from Cat cat "
#~ "\" +\n"
#~ "        \"group by cat.color\")\n"
#~ "        .list()\n"
#~ "        .iterator();\n"
#~ "\n"
#~ "while ( results.hasNext() ) {\n"
#~ "    Object[] row = (Object[]) results.next();\n"
#~ "    Color type = (Color) row[0];\n"
#~ "    Date oldest = (Date) row[1];\n"
#~ "    Integer count = (Integer) row[2];\n"
#~ "    .....\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[//named parameter (preferred)\n"
#~ "Query q = sess.createQuery(\"from DomesticCat cat where cat.name = :name"
#~ "\");\n"
#~ "q.setString(\"name\", \"Fritz\");\n"
#~ "Iterator cats = q.iterate();]]>"
#~ msgstr ""
#~ "//named parameter (preferred)\n"
#~ "Query q = sess.createQuery(\"from DomesticCat cat where cat.name = :name"
#~ "\");\n"
#~ "q.setString(\"name\", \"Fritz\");\n"
#~ "Iterator cats = q.iterate();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[//positional parameter\n"
#~ "Query q = sess.createQuery(\"from DomesticCat cat where cat.name = ?\");\n"
#~ "q.setString(0, \"Izi\");\n"
#~ "Iterator cats = q.iterate();]]>"
#~ msgstr ""
#~ "//positional parameter\n"
#~ "Query q = sess.createQuery(\"from DomesticCat cat where cat.name = ?\");\n"
#~ "q.setString(0, \"Izi\");\n"
#~ "Iterator cats = q.iterate();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[//named parameter list\n"
#~ "List names = new ArrayList();\n"
#~ "names.add(\"Izi\");\n"
#~ "names.add(\"Fritz\");\n"
#~ "Query q = sess.createQuery(\"from DomesticCat cat where cat.name in (:"
#~ "namesList)\");\n"
#~ "q.setParameterList(\"namesList\", names);\n"
#~ "List cats = q.list();]]>"
#~ msgstr ""
#~ "//named parameter list\n"
#~ "List names = new ArrayList();\n"
#~ "names.add(\"Izi\");\n"
#~ "names.add(\"Fritz\");\n"
#~ "Query q = sess.createQuery(\"from DomesticCat cat where cat.name in (:"
#~ "namesList)\");\n"
#~ "q.setParameterList(\"namesList\", names);\n"
#~ "List cats = q.list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Query q = sess.createQuery(\"from DomesticCat cat\");\n"
#~ "q.setFirstResult(20);\n"
#~ "q.setMaxResults(10);\n"
#~ "List cats = q.list();]]>"
#~ msgstr ""
#~ "Query q = sess.createQuery(\"from DomesticCat cat\");\n"
#~ "q.setFirstResult(20);\n"
#~ "q.setMaxResults(10);\n"
#~ "List cats = q.list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Query q = sess.createQuery(\"select cat.name, cat from "
#~ "DomesticCat cat \" +\n"
#~ "                            \"order by cat.name\");\n"
#~ "ScrollableResults cats = q.scroll();\n"
#~ "if ( cats.first() ) {\n"
#~ "\n"
#~ "    // find the first name on each page of an alphabetical list of cats "
#~ "by name\n"
#~ "    firstNamesOfPages = new ArrayList();\n"
#~ "    do {\n"
#~ "        String name = cats.getString(0);\n"
#~ "        firstNamesOfPages.add(name);\n"
#~ "    }\n"
#~ "    while ( cats.scroll(PAGE_SIZE) );\n"
#~ "\n"
#~ "    // Now get the first page of cats\n"
#~ "    pageOfCats = new ArrayList();\n"
#~ "    cats.beforeFirst();\n"
#~ "    int i=0;\n"
#~ "    while( ( PAGE_SIZE > i++ ) && cats.next() ) pageOfCats.add( cats.get"
#~ "(1) );\n"
#~ "\n"
#~ "}\n"
#~ "cats.close()]]>"
#~ msgstr ""
#~ "Query q = sess.createQuery(\"select cat.name, cat from DomesticCat cat \" "
#~ "+\n"
#~ "                            \"order by cat.name\");\n"
#~ "ScrollableResults cats = q.scroll();\n"
#~ "if ( cats.first() ) {\n"
#~ "\n"
#~ "    // find the first name on each page of an alphabetical list of cats "
#~ "by name\n"
#~ "    firstNamesOfPages = new ArrayList();\n"
#~ "    do {\n"
#~ "        String name = cats.getString(0);\n"
#~ "        firstNamesOfPages.add(name);\n"
#~ "    }\n"
#~ "    while ( cats.scroll(PAGE_SIZE) );\n"
#~ "\n"
#~ "    // Now get the first page of cats\n"
#~ "    pageOfCats = new ArrayList();\n"
#~ "    cats.beforeFirst();\n"
#~ "    int i=0;\n"
#~ "    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add"
#~ "( cats.get(1) );\n"
#~ "\n"
#~ "}\n"
#~ "cats.close()"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<query name=\"ByNameAndMaximumWeight\"><![CDATA[\n"
#~ "    from eg.DomesticCat as cat\n"
#~ "        where cat.name = ?\n"
#~ "        and cat.weight > ?\n"
#~ "] ]></query>]]>"
#~ msgstr ""
#~ "&lt;query name=\"ByNameAndMaximumWeight\"&gt;&lt;![CDATA[\n"
#~ "    from eg.DomesticCat as cat\n"
#~ "        where cat.name = ?\n"
#~ "        and cat.weight &gt; ?\n"
#~ "] ]&gt;&lt;/query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Query q = sess.getNamedQuery(\"ByNameAndMaximumWeight\");\n"
#~ "q.setString(0, name);\n"
#~ "q.setInt(1, minWeight);\n"
#~ "List cats = q.list();]]>"
#~ msgstr ""
#~ "Query q = sess.getNamedQuery(\"ByNameAndMaximumWeight\");\n"
#~ "q.setString(0, name);\n"
#~ "q.setInt(1, minWeight);\n"
#~ "List cats = q.list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Collection blackKittens = session.createFilter(\n"
#~ "    pk.getKittens(), \n"
#~ "    \"where this.color = ?\")\n"
#~ "    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )\n"
#~ "    .list()\n"
#~ ");]]>"
#~ msgstr ""
#~ "Collection blackKittens = session.createFilter(\n"
#~ "    pk.getKittens(), \n"
#~ "    \"where this.color = ?\")\n"
#~ "    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )\n"
#~ "    .list()\n"
#~ ");"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Collection blackKittenMates = session.createFilter(\n"
#~ "    pk.getKittens(), \n"
#~ "    \"select this.mate where this.color = eg.Color.BLACK.intValue\")\n"
#~ "    .list();]]>"
#~ msgstr ""
#~ "Collection blackKittenMates = session.createFilter(\n"
#~ "    pk.getKittens(), \n"
#~ "    \"select this.mate where this.color = eg.Color.BLACK.intValue\")\n"
#~ "    .list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Collection tenKittens = session.createFilter(\n"
#~ "    mother.getKittens(), \"\")\n"
#~ "    .setFirstResult(0).setMaxResults(10)\n"
#~ "    .list();]]>"
#~ msgstr ""
#~ "Collection tenKittens = session.createFilter(\n"
#~ "    mother.getKittens(), \"\")\n"
#~ "    .setFirstResult(0).setMaxResults(10)\n"
#~ "    .list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Criteria crit = session.createCriteria(Cat.class);\n"
#~ "crit.add( Restrictions.eq( \"color\", eg.Color.BLACK ) );\n"
#~ "crit.setMaxResults(10);\n"
#~ "List cats = crit.list();]]>"
#~ msgstr ""
#~ "Criteria crit = session.createCriteria(Cat.class);\n"
#~ "crit.add( Expression.eq( \"color\", eg.Color.BLACK ) );\n"
#~ "crit.setMaxResults(10);\n"
#~ "List cats = crit.list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[List cats = session.createSQLQuery(\"SELECT {cat.*} FROM CAT "
#~ "{cat} WHERE ROWNUM<10\")\n"
#~ "    .addEntity(\"cat\", Cat.class)\n"
#~ ".list();]]>"
#~ msgstr ""
#~ "List cats = session.createSQLQuery(\n"
#~ "    \"SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10\",\n"
#~ "    \"cat\",\n"
#~ "    Cat.class\n"
#~ ").list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[List cats = session.createSQLQuery(\n"
#~ "    \"SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, \" +\n"
#~ "           \"{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... "
#~ "\" +\n"
#~ "    \"FROM CAT {cat} WHERE ROWNUM<10\")\n"
#~ "    .addEntity(\"cat\", Cat.class)\n"
#~ ".list()]]>"
#~ msgstr ""
#~ "List cats = session.createSQLQuery(\n"
#~ "    \"SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, \" +\n"
#~ "           \"{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... "
#~ "\" +\n"
#~ "    \"FROM CAT {cat} WHERE ROWNUM&lt;10\",\n"
#~ "    \"cat\",\n"
#~ "    Cat.class\n"
#~ ").list()"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long"
#~ "(69) );\n"
#~ "cat.setName(\"PK\");\n"
#~ "sess.flush();  // changes to cat are automatically detected and "
#~ "persisted]]>"
#~ msgstr ""
#~ "DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );\n"
#~ "cat.setName(\"PK\");\n"
#~ "sess.flush();  // changes to cat are automatically detected and persisted"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[// in the first session\n"
#~ "Cat cat = (Cat) firstSession.load(Cat.class, catId);\n"
#~ "Cat potentialMate = new Cat();\n"
#~ "firstSession.save(potentialMate);\n"
#~ "\n"
#~ "// in a higher layer of the application\n"
#~ "cat.setMate(potentialMate);\n"
#~ "\n"
#~ "// later, in a new session\n"
#~ "secondSession.update(cat);  // update cat\n"
#~ "secondSession.update(mate); // update mate]]>"
#~ msgstr ""
#~ "// in the first session\n"
#~ "Cat cat = (Cat) firstSession.load(Cat.class, catId);\n"
#~ "Cat potentialMate = new Cat();\n"
#~ "firstSession.save(potentialMate);\n"
#~ "\n"
#~ "// in a higher layer of the application\n"
#~ "cat.setMate(potentialMate);\n"
#~ "\n"
#~ "// later, in a new session\n"
#~ "secondSession.update(cat);  // update cat\n"
#~ "secondSession.update(mate); // update mate"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[//just reassociate:\n"
#~ "sess.lock(fritz, LockMode.NONE);\n"
#~ "//do a version check, then reassociate:\n"
#~ "sess.lock(izi, LockMode.READ);\n"
#~ "//do a version check, using SELECT ... FOR UPDATE, then reassociate:\n"
#~ "sess.lock(pk, LockMode.UPGRADE);]]>"
#~ msgstr ""
#~ "//just reassociate:\n"
#~ "sess.lock(fritz, LockMode.NONE);\n"
#~ "//do a version check, then reassociate:\n"
#~ "sess.lock(izi, LockMode.READ);\n"
#~ "//do a version check, using SELECT ... FOR UPDATE, then reassociate:\n"
#~ "sess.lock(pk, LockMode.UPGRADE);"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[// in the first session\n"
#~ "Cat cat = (Cat) firstSession.load(Cat.class, catID);\n"
#~ "\n"
#~ "// in a higher tier of the application\n"
#~ "Cat mate = new Cat();\n"
#~ "cat.setMate(mate);\n"
#~ "\n"
#~ "// later, in a new session\n"
#~ "secondSession.saveOrUpdate(cat);   // update existing state (cat has a "
#~ "non-null id)\n"
#~ "secondSession.saveOrUpdate(mate);  // save the new instance (mate has a "
#~ "null id)]]>"
#~ msgstr ""
#~ "// in the first session\n"
#~ "Cat cat = (Cat) firstSession.load(Cat.class, catID);\n"
#~ "\n"
#~ "// in a higher tier of the application\n"
#~ "Cat mate = new Cat();\n"
#~ "cat.setMate(mate);\n"
#~ "\n"
#~ "// later, in a new session\n"
#~ "secondSession.saveOrUpdate(cat);   // update existing state (cat has a "
#~ "non-null id)\n"
#~ "secondSession.saveOrUpdate(mate);  // save the new instance (mate has a "
#~ "null id)"

#, fuzzy
#~ msgid "<![CDATA[sess.delete(cat);]]>"
#~ msgstr "sess.delete(cat);"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[//retrieve a cat from one database\n"
#~ "Session session1 = factory1.openSession();\n"
#~ "Transaction tx1 = session1.beginTransaction();\n"
#~ "Cat cat = session1.get(Cat.class, catId);\n"
#~ "tx1.commit();\n"
#~ "session1.close();\n"
#~ "\n"
#~ "//reconcile with a second database\n"
#~ "Session session2 = factory2.openSession();\n"
#~ "Transaction tx2 = session2.beginTransaction();\n"
#~ "session2.replicate(cat, ReplicationMode.LATEST_VERSION);\n"
#~ "tx2.commit();\n"
#~ "session2.close();]]>"
#~ msgstr ""
#~ "//retrieve a cat from one database\n"
#~ "Session session1 = factory1.openSession();\n"
#~ "Transaction tx1 = session1.beginTransaction();\n"
#~ "Cat cat = session1.get(Cat.class, catId);\n"
#~ "tx1.commit();\n"
#~ "session1.close();\n"
#~ "\n"
#~ "//reconcile with a second database\n"
#~ "Session session2 = factory2.openSession();\n"
#~ "Transaction tx2 = session2.beginTransaction();\n"
#~ "session2.replicate(cat, ReplicationMode.LATEST_VERSION);\n"
#~ "tx2.commit();\n"
#~ "session2.close();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess = sf.openSession();\n"
#~ "Transaction tx = sess.beginTransaction();\n"
#~ "sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale "
#~ "state\n"
#~ "\n"
#~ "Cat izi = (Cat) sess.load(Cat.class, id);\n"
#~ "izi.setName(iznizi);\n"
#~ "\n"
#~ "// might return stale data\n"
#~ "sess.find(\"from Cat as cat left outer join cat.kittens kitten\");\n"
#~ "\n"
#~ "// change to izi is not flushed!\n"
#~ "...\n"
#~ "tx.commit(); // flush occurs\n"
#~ "sess.close();]]>"
#~ msgstr ""
#~ "sess = sf.openSession();\n"
#~ "Transaction tx = sess.beginTransaction();\n"
#~ "sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale "
#~ "state\n"
#~ "\n"
#~ "Cat izi = (Cat) sess.load(Cat.class, id);\n"
#~ "izi.setName(iznizi);\n"
#~ "\n"
#~ "// might return stale data\n"
#~ "sess.find(\"from Cat as cat left outer join cat.kittens kitten\");\n"
#~ "\n"
#~ "// change to izi is not flushed!\n"
#~ "...\n"
#~ "tx.commit(); // flush occurs\n"
#~ "sess.close();"

#, fuzzy
#~ msgid "<![CDATA[<one-to-one name=\"person\" cascade=\"persist\"/>]]>"
#~ msgstr "&lt;one-to-one name=\"person\" cascade=\"persist\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<one-to-one name=\"person\" cascade=\"persist,delete,lock\"/>]]>"
#~ msgstr "&lt;one-to-one name=\"person\" cascade=\"persist,delete,lock\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Cat fritz = ......;\n"
#~ "ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);\n"
#~ "\n"
#~ "Object[] propertyValues = catMeta.getPropertyValues(fritz);\n"
#~ "String[] propertyNames = catMeta.getPropertyNames();\n"
#~ "Type[] propertyTypes = catMeta.getPropertyTypes();\n"
#~ "\n"
#~ "// get a Map of all properties which are not collections or associations\n"
#~ "Map namedValues = new HashMap();\n"
#~ "for ( int i=0; i<propertyNames.length; i++ ) {\n"
#~ "    if ( !propertyTypes[i].isEntityType() && !propertyTypes[i]."
#~ "isCollectionType() ) {\n"
#~ "        namedValues.put( propertyNames[i], propertyValues[i] );\n"
#~ "    }\n"
#~ "}]]>"
#~ msgstr ""
#~ "Cat fritz = ......;\n"
#~ "ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);\n"
#~ "\n"
#~ "Object[] propertyValues = catMeta.getPropertyValues(fritz);\n"
#~ "String[] propertyNames = catMeta.getPropertyNames();\n"
#~ "Type[] propertyTypes = catMeta.getPropertyTypes();\n"
#~ "\n"
#~ "// get a Map of all properties which are not collections or associations\n"
#~ "Map namedValues = new HashMap();\n"
#~ "for ( int i=0; i&lt;propertyNames.length; i++ ) {\n"
#~ "    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i]."
#~ "isCollectionType() ) {\n"
#~ "        namedValues.put( propertyNames[i], propertyValues[i] );\n"
#~ "    }\n"
#~ "}"
