# translation of Collection_Mapping.po to 
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# Language /mnt/hgfs/base/Hibernate/Reference translations for PACKAGE package.
# Copyright (C) 2006, 2007 Free Software Foundation, Inc.
# Automatically generated, 2006.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
#
msgid ""
msgstr ""
"Project-Id-Version: Collection_Mapping\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:15\n"
"PO-Revision-Date: 2007-02-26 10:27+1000\n"
"Last-Translator: \n"
"Language-Team:  <de@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.9.1\n"

#. Tag: title
#, no-c-format
msgid "HQL: The Hibernate Query Language"
msgstr "HQL: Die \"Hibernate Query Language\""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate uses a powerful query language (HQL) that is similar in appearance "
"to SQL. Compared with SQL, however, HQL is fully object-oriented and "
"understands notions like inheritance, polymorphism and association."
msgstr ""
"Hibernate ist mit einer sehr leistungsfähigen Anfragensprache ausgestattet, "
"die (mit Absicht) große Ähnlichkeit mit SQL besitzt. Aber lassen Sie sich "
"nicht durch die Syntax täuschen; HQL ist rein objektorientiert und versteht "
"Begriffe wie Vererbung, Polymorphismus und Assoziation."

#. Tag: title
#, no-c-format
msgid "Case Sensitivity"
msgstr "Beachtung der Groß- und Kleinschreibung"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"With the exception of names of Java classes and properties, queries are case-"
"insensitive. So <literal>SeLeCT</literal> is the same as <literal>sELEct</"
"literal> is the same as <literal>SELECT</literal>, but <literal>org."
"hibernate.eg.FOO</literal> is not <literal>org.hibernate.eg.Foo</literal>, "
"and <literal>foo.barSet</literal> is not <literal>foo.BARSET</literal>."
msgstr ""
"Bei Anfragen ist die Groß- und Kleinschreibung irrelevant, außer es handelt "
"sich um Namen von Java-Klassen und Properties. Daher ist <literal>SeLeCT</"
"literal> dasselbe wie <literal>sELEct</literal> oder auch <literal>SELECT</"
"literal>, jedoch ist <literal>org.hibernate.eg.FOO</literal> nicht gleich "
"<literal>org.hibernate.eg.Foo</literal> und <literal>foo.barSet</literal> "
"ist nicht <literal>foo.BARSET</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This manual uses lowercase HQL keywords. Some users find queries with "
"uppercase keywords more readable, but this convention is unsuitable for "
"queries embedded in Java code."
msgstr ""
"Dieses Handbuch verwendet Kleinbuchstaben für HQL-Schlüsselbegriffe. Einige "
"Benutzer finden Anfragen, in denen die Schlüsselbegriffe in Großbuchstaben "
"geschrieben sind zwar lesbarer, jedoch finden wir das innerhalb von Java-"
"Code optisch nicht sehr ansprechend."

#. Tag: title
#, no-c-format
msgid "The from clause"
msgstr "Die \"from\"-Klausel"

#. Tag: para
#, no-c-format
msgid "The simplest possible Hibernate query is of the form:"
msgstr "Die einfachste Form der Hibernate-Anfrage lautet:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This returns all instances of the class <literal>eg.Cat</literal>. You do "
"not usually need to qualify the class name, since <literal>auto-import</"
"literal> is the default. For example:"
msgstr ""
"die einfach mit sämtlichen Instanzen der Klasse <literal>eg.Cat</literal> "
"reagiert. In der Regel muss der Klassenname nicht definiert werden, da die "
"Standardeinstellung <literal>auto-import</literal> lautet. Daher schreiben "
"wir in den meisten Fällen nur:"

#. Tag: para
#, no-c-format
msgid ""
"In order to refer to the <literal>Cat</literal> in other parts of the query, "
"you will need to assign an <emphasis>alias</emphasis>. For example:"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This query assigns the alias <literal>cat</literal> to <literal>Cat</"
"literal> instances, so you can use that alias later in the query. The "
"<literal>as</literal> keyword is optional. You could also write:"
msgstr ""
"Diese Anfrage ordnet den Alias <literal>cat</literal> den <literal>Cat</"
"literal>-Instanzen zu, so dass wir diesen Alias später in der Anfrage "
"verwendet können. Der <literal>as</literal>-Schlüsselbegriff ist optional; "
"wir könnten auch schreiben:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Multiple classes can appear, resulting in a cartesian product or \"cross\" "
"join."
msgstr ""
"Mehrere Klassen können erscheinen und zu einem kartesischen Produkt oder "
"Kreuzverbund (sog. \"Cross-Join\") führen."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is good practice to name query aliases using an initial lowercase as this "
"is consistent with Java naming standards for local variables (e.g. "
"<literal>domesticCat</literal>)."
msgstr ""
"Es ist generell ratsam, Anfragen-Aliasse unter Verwendung eines kleinen "
"Anfangsbuchstabens zu beginnen, da dies den Namensgebungsstandards für "
"lokale Variablen bei Java entspricht (z.B. <literal>domesticCat</literal>)."

#. Tag: title
#, no-c-format
msgid "Associations and joins"
msgstr "Assoziationen und Verbünde (\"Joins\")"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can also assign aliases to associated entities or to elements of a "
"collection of values using a <literal>join</literal>. For example:"
msgstr ""
"Man kann auch Aliasse assoziierten Entities oder sogar Elementen einer "
"Collection von Werten mittels <literal>join</literal> zuordnen."

#. Tag: para
#, fuzzy, no-c-format
msgid "The supported join types are borrowed from ANSI SQL:"
msgstr "Die unterstützten Verbundtypen wurden von ANSI SQL geborgt"

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>inner join</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>left outer join</literal>"
msgstr "<literal>full join</literal> (in der Regel nicht sehr nützlich)"

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>right outer join</literal>"
msgstr "right outer join"

#. Tag: para
#, no-c-format
msgid "<literal>full join</literal> (not usually useful)"
msgstr "<literal>full join</literal> (in der Regel nicht sehr nützlich)"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>inner join</literal>, <literal>left outer join</literal> and "
"<literal>right outer join</literal> constructs may be abbreviated."
msgstr ""
"Die <literal>inner join</literal>, <literal>left outer join</literal> und "
"<literal>right outer join</literal>-Konstrukte können abgekürzt werden."

#. Tag: para
#, no-c-format
msgid ""
"You may supply extra join conditions using the HQL <literal>with</literal> "
"keyword."
msgstr ""
"Sie können weitere Verbundbedingungen unter Verwendung des HQL-"
"Schlüsselbegriffs <literal>with</literal> eingeben."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A \"fetch\" join allows associations or collections of values to be "
"initialized along with their parent objects using a single select. This is "
"particularly useful in the case of a collection. It effectively overrides "
"the outer join and lazy declarations of the mapping file for associations "
"and collections. See <xref linkend=\"performance-fetching\" /> for more "
"information."
msgstr ""
"Desweiteren ermöglicht ein \"Abruf\"-Join die Initialisierung von "
"Assoziationen oder Collections von Werten samt deren übergeordneten Objekten "
"unter Verwendung einer einzelnen Auswahl (sog. \"single select\"). Dies ist "
"insbesondere im Zusammenhang mit Collections von Nutzen. Es setzt effektiv "
"den \"Outer-Join\" (Außenverbund) und \"lazy\" Deklarationen der Mapping-"
"Datei für Assoziationen und Collections außer Kraft. Weitere Informationen "
"finden Sie auch unter <xref linkend=\"performance-fetching\"/>."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A fetch join does not usually need to assign an alias, because the "
"associated objects should not be used in the <literal>where</literal> clause "
"(or any other clause). The associated objects are also not returned directly "
"in the query results. Instead, they may be accessed via the parent object. "
"The only reason you might need an alias is if you are recursively join "
"fetching a further collection:"
msgstr ""
"Ein Abruf-Join (sog. \"fetch join\") muss in der Regel keinen Alias "
"zuordnen, weil die zugehörigen Objekte nicht in der <literal>where</literal>-"
"Klausel (oder irgendeiner anderen Klausel) verwendet werden sollten. Die "
"assoziierten Objekte werden außerdem nicht direkt in den Anfragenergebnissen "
"wiedergegeben, sondern es wird via \"Parent\"-Objekt (d.h. dem "
"übergeordneten Objekt) auf diese zugegriffen. Der einzige Grund aus dem wir "
"einen Alias benötigen könnten ist, falls eine weitere Collection rekursiv "
"abgerufen werden soll:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>fetch</literal> construct cannot be used in queries called "
"using <literal>iterate()</literal> (though <literal>scroll()</literal> can "
"be used). <literal>Fetch</literal> should be used together with "
"<literal>setMaxResults()</literal> or <literal>setFirstResult()</literal>, "
"as these operations are based on the result rows which usually contain "
"duplicates for eager collection fetching, hence, the number of rows is not "
"what you would expect. <literal>Fetch</literal> should also not be used "
"together with impromptu <literal>with</literal> condition. It is possible to "
"create a cartesian product by join fetching more than one collection in a "
"query, so take care in this case. Join fetching multiple collection roles "
"can produce unexpected results for bag mappings, so user discretion is "
"advised when formulating queries in this case. Finally, note that "
"<literal>full join fetch</literal> and <literal>right join fetch</literal> "
"are not meaningful."
msgstr ""
"Beachten Sie, dass das <literal>fetch</literal>-Konstrukt nicht in Anfragen "
"verwendet werden kann, bei denen <literal>iterate()</literal> verwendet wird "
"(obwohl <literal>scroll()</literal> verwendet werden kann). Auch sollte "
"<literal>fetch</literal> nicht mit <literal>setMaxResults()</literal> oder "
"<literal>setFirstResult()</literal> benutzt werden, da diese Vorgänge auf "
"Ergebnisreihen basieren, die in der Regel Duplikate für den Collection-Abruf "
"nach \"eager\"-Art (d.h. dem zusammengefassten Laden von Objekt und "
"assoziierten Objekten mit Verbundoperationen) besitzen, und daher eine "
"unerwartete Anzahl von Reihen liefern. Die Verwendung von <literal>fetch</"
"literal> sollte auch in Verbindung mit einer ad hoc <literal>with</literal>-"
"Bedingung vermieden werden. Es ist möglich, ein kartesisches Produkt zu "
"erstellen, indem in einer Anfrage für mehr als eine Collection ein Join-"
"Abruf erfolgt, achten Sie also in diesem Fall darauf. Ein Join-Abruf "
"mehrerer Collection-Rollen führt manchmal zu unerwarteten Ergebnissen bei "
"\"Bag\"-Mappings, achten Sie also darauf, wie Sie Ihre Anfragen in diesem "
"Fall formulieren. <literal>full join fetch</literal> und <literal>right join "
"fetch</literal> sind nicht von Bedeutung."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If you are using property-level lazy fetching (with bytecode "
"instrumentation), it is possible to force Hibernate to fetch the lazy "
"properties in the first query immediately using <literal>fetch all "
"properties</literal>."
msgstr ""
"Falls Sie \"lazy\"-Fetching (d.h. das Nachladen assoziierter Objekte bei "
"Bedarf) auf Property-Ebene verwenden (mit Bytecode Instrumentierung), so "
"kann durchgesetzt werden, dass Hibernate die \"lazy\" Properties sofort (in "
"der ersten Anfrage) mittels <literal>fetch all properties</literal> abruft."

#. Tag: title
#, no-c-format
msgid "Forms of join syntax"
msgstr "Formen der Verbundsyntax"

#. Tag: para
#, no-c-format
msgid ""
"HQL supports two forms of association joining: <literal>implicit</literal> "
"and <literal>explicit</literal>."
msgstr ""
"HQL unterstützt zwei Arten von \"Association-Joining\": <literal>implicit</"
"literal> und <literal>explicit</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The queries shown in the previous section all use the <literal>explicit</"
"literal> form, that is, where the join keyword is explicitly used in the "
"from clause. This is the recommended form."
msgstr ""
"Die im vorherigen Abschnitt gezeigten Beispiele verwenden alle die "
"<literal>explicit</literal>-Form, bei der der \"Join\"-Schlüsselbegriff "
"explizit in der \"from\"-Klausel verwendet wird. Dieses ist die empfohlene "
"Form."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>implicit</literal> form does not use the join keyword. Instead, "
"the associations are \"dereferenced\" using dot-notation. <literal>implicit</"
"literal> joins can appear in any of the HQL clauses. <literal>implicit</"
"literal> join result in inner joins in the resulting SQL statement."
msgstr ""
"Die <literal>implicit</literal>-Form verwendet den \"Join\"-Schlüsselbegriff "
"nicht. Statt dessen sind die Assoziationen unter Verwendung von "
"Punktnotation \"dereferenziert\". <literal>implicit</literal>-Joins können "
"in jedem der HQL-Sätze erscheinen. <literal>implicit</literal>-Join-"
"Ergebnisse resultieren in \"inner Joins\" in der sich ergebenden SQL-"
"Anweisung."

#. Tag: title
#, fuzzy, no-c-format
msgid "Referring to identifier property"
msgstr "Verweise auf die Bezeichner-Property"

#. Tag: para
#, fuzzy, no-c-format
msgid "There are 2 ways to refer to an entity's identifier property:"
msgstr ""
"Es gibt im Wesentlichen 2 Arten, um auf die Bezeichner-Property einer Entity "
"zu verweisen:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The special property (lowercase) <literal>id</literal> may be used to "
"reference the identifier property of an entity <emphasis>provided that the "
"entity does not define a non-identifier property named id</emphasis>."
msgstr ""
"Die spezielle Property (Kleinbuchstaben) <literal>id</literal> kann "
"verwendet werden, um auf die Bezeichner-Property einer Entity zu verweisen "
"<emphasis> vorausgesetzt, dass diese Entity keine nicht-Bezeichner Property "
"mit Namen id definiert </emphasis>."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If the entity defines a named identifier property, you can use that property "
"name."
msgstr ""
"Falls die Entity eine benannte Bezeichner-Property definiert, können Sie "
"diesen Property-Namen verwenden."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"References to composite identifier properties follow the same naming rules. "
"If the entity has a non-identifier property named id, the composite "
"identifier property can only be referenced by its defined named. Otherwise, "
"the special <literal>id</literal> property can be used to reference the "
"identifier property."
msgstr ""
"Verweise auf Properties von zusammengesetzten Bezeichnern folgen denselben "
"Namensgebungsregeln. Falls die Entity eine nicht-Bezeichner Property namens "
"id besitzt, so kann auf die Property des zusammengesetzten Bezeichners nur "
"mittels deren definiertem Namen verwiesen werden; andernfalls kann die "
"spezielle <literal>id</literal>-Property verwendet werden, um auf die "
"Bezeichner-Property zu verweisen."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Please note that, starting in version 3.2.2, this has changed significantly. "
"In previous versions, <literal>id</literal> <emphasis>always</emphasis> "
"referred to the identifier property regardless of its actual name. A "
"ramification of that decision was that non-identifier properties named "
"<literal>id</literal> could never be referenced in Hibernate queries."
msgstr ""
"Hinweis: Dies hat sich seit Version 3.2.2 maßgeblich verändert. In früheren "
"Versionen verwies <literal>id</literal><emphasis>immer</emphasis> auf die "
"Bezeichner-Property, unabhängig vom tatsächlichen Namen. Eine Auswirkung "
"dieser Entscheidung war, dass in Hibernate Anfragen nie auf nicht-Bezeichner "
"Properties mit Namen <literal>id</literal> verwiesen werden konnte."

#. Tag: title
#, no-c-format
msgid "The select clause"
msgstr "Die \"select\"-Klausel"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>select</literal> clause picks which objects and properties to "
"return in the query result set. Consider the following:"
msgstr ""
"Die <literal>select</literal>-Klausel entscheidet, welche Objekte und "
"Properties im Ergebnissatz der Anfrage erscheinen. Beachten Sie:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The query will select <literal>mate</literal>s of other <literal>Cat</"
"literal>s. You can express this query more compactly as:"
msgstr ""
"Die Anfrage wählt <literal>mate</literal>s anderer <literal>Cat</literal>s. "
"Sie können diese Anfrage sogar noch kompakter ausdrücken:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Queries can return properties of any value type including properties of "
"component type:"
msgstr ""
"Anfragen können Properties jeden Wertetyps, einschließlich Properties des "
"Komponententyps, wiedergeben:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Queries can return multiple objects and/or properties as an array of type "
"<literal>Object[]</literal>:"
msgstr ""
"Anfragen können mehrere Objekte und/oder Properties als Array vom Typ "
"<literal>Object[]</literal> wiedergeben,"

#. Tag: para
#, fuzzy, no-c-format
msgid "Or as a <literal>List</literal>:"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Or - assuming that the class <literal>Family</literal> has an appropriate "
"constructor - as an actual typesafe Java object:"
msgstr ""
"in der Annahme, dass die Klasse <literal>Family</literal> einen "
"entsprechenden Konstruktor besitzt."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can assign aliases to selected expressions using <literal>as</literal>:"
msgstr ""
"Unter Verwendung von <literal>as</literal> können Sie Aliasse gewählten "
"Ausdrücken zuordnen:"

#. Tag: para
#, no-c-format
msgid ""
"This is most useful when used together with <literal>select new map</"
"literal>:"
msgstr ""
"Das ist besonders in Verbindung mit <literal>select new map</literal> "
"nützlich:"

#. Tag: para
#, no-c-format
msgid ""
"This query returns a <literal>Map</literal> from aliases to selected values."
msgstr ""
"Diese Anfrage reagiert mit einer <literal>Map</literal> von Aliassen zu "
"gewählten Werten."

#. Tag: title
#, no-c-format
msgid "Aggregate functions"
msgstr "Aggregierte Funktionen"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"HQL queries can even return the results of aggregate functions on properties:"
msgstr ""
"HQL-Anfragen können sogar die Ergebnisse aggregierter Funktionen an "
"Properties zurücksenden:"

#. Tag: para
#, fuzzy, no-c-format
msgid "The supported aggregate functions are:"
msgstr "Die unterstützten aggregierten Funktionen sind "

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>avg(...), sum(...), min(...), max(...)</literal>"
msgstr "avg(...), sum(...), min(...), max(...)"

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>count(*)</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>count(...), count(distinct ...), count(all...)</literal>"
msgstr "count(...), count(distinct ...), count(all...)"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can use arithmetic operators, concatenation, and recognized SQL "
"functions in the select clause:"
msgstr ""
"In der \"select\"-Klausel können Sie Rechenzeichen, Verkettung und "
"anerkannte SQL-Funktionen verwenden:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>distinct</literal> and <literal>all</literal> keywords can be "
"used and have the same semantics as in SQL."
msgstr ""
"Die <literal>distinct</literal> und <literal>all</literal>-Schlüsselbegriffe "
"können verwendet werden und besitzen dieselbe Semantik wie in SQL."

#. Tag: title
#, no-c-format
msgid "Polymorphic queries"
msgstr "Polymorphe Anfragen"

#. Tag: para
#, no-c-format
msgid "A query like:"
msgstr "Eine Anfrage wie:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"returns instances not only of <literal>Cat</literal>, but also of subclasses "
"like <literal>DomesticCat</literal>. Hibernate queries can name "
"<emphasis>any</emphasis> Java class or interface in the <literal>from</"
"literal> clause. The query will return instances of all persistent classes "
"that extend that class or implement the interface. The following query would "
"return all persistent objects:"
msgstr ""
"reagiert nicht nur mit Instanzen von <literal>Cat</literal>, sondern auch "
"Subklassen wie <literal>DomesticCat</literal>. Hibernate Anfragen können "
"eine <emphasis>beliebige</emphasis> Java-Klasse oder Interface in der "
"<literal>from</literal>-Klausel benennen. Die Anfrage reagiert mit Instanzen "
"aller persistenten Klassen, die diese Klasse erweitern oder das Interface "
"implementieren. Die folgende Anfrage würde mit allen persistenten Objekten "
"reagieren:"

#. Tag: para
#, no-c-format
msgid ""
"The interface <literal>Named</literal> might be implemented by various "
"persistent classes:"
msgstr ""
"Das Interface <literal>Named</literal> könnte durch verschiedene persistente "
"Klassen implementiert werden:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"These last two queries will require more than one SQL <literal>SELECT</"
"literal>. This means that the <literal>order by</literal> clause does not "
"correctly order the whole result set. It also means you cannot call these "
"queries using <literal>Query.scroll()</literal>."
msgstr ""
"Bitte beachten Sie, dass für die letzten beiden Anfragen mehr als ein SQL "
"<literal>SELECT</literal> erforderlich ist. Das bedeutet, dass die "
"<literal>order by</literal>-Klausel den gesamten Ergebnissatz nicht korrekt "
"ordnet. (Es bedeutet auch, dass Sie diese Anfragen nicht mittels "
"<literal>Query.scroll()</literal> aufrufen können)."

#. Tag: title
#, no-c-format
msgid "The where clause"
msgstr "Die \"where\"-Klausel"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>where</literal> clause allows you to refine the list of "
"instances returned. If no alias exists, you can refer to properties by name:"
msgstr ""
"Die <literal>where</literal>-Klausel erlaubt es Ihnen, die Liste der "
"erhaltenen Instanzen einzugrenzen. Falls kein Alias existiert, können Sie "
"namentlich auf die Properties verweisen:"

#. Tag: para
#, no-c-format
msgid "If there is an alias, use a qualified property name:"
msgstr ""
"Falls ein Alias existiert, verwenden Sie einen vollständigen Property-Namen:"

#. Tag: para
#, fuzzy, no-c-format
msgid "This returns instances of <literal>Cat</literal> named 'Fritz'."
msgstr "reagiert mit Instanzen von 'Fritz' benannter <literal>Cat</literal>."

#. Tag: para
#, no-c-format
msgid "The following query:"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"returns all instances of <literal>Foo</literal> with an instance of "
"<literal>bar</literal> with a <literal>date</literal> property equal to the "
"<literal>startDate</literal> property of the <literal>Foo</literal>. "
"Compound path expressions make the <literal>where</literal> clause extremely "
"powerful. Consider the following:"
msgstr ""
"sendet sämtliche Instanzen von <literal>Foo</literal> zurück, für die eine "
"Instanz von <literal>bar</literal> mit einer <literal>date</literal>-"
"Property existiert, die gleich der <literal>startDate</literal>-Property von "
"<literal>Foo</literal> ist. Zusammengesetzte Pfadausdrücke machen die "
"<literal>where</literal>-Klausel sehr leistungsfähig. Ziehen Sie folgendes "
"in Betracht:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This query translates to an SQL query with a table (inner) join. For example:"
msgstr ""
"Diese Anfrage wird in eine SQL-Anfrage mit Tabellenverbund (inner join) "
"übersetzt. Falls Sie etwas wie das nachfolgende schreiben würden"

#. Tag: para
#, fuzzy, no-c-format
msgid "would result in a query that would require four table joins in SQL."
msgstr ""
"so würden Sie eine Anfrage erhalten, die vier Tabellenverbünde (sog. \"table "
"joins\") in SQL benötigen würde."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>=</literal> operator can be used to compare not only "
"properties, but also instances:"
msgstr ""
"Mit dem <literal>=</literal>-Operator können nicht nur Properties, sondern "
"auch Instanzen verglichen werden:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The special property (lowercase) <literal>id</literal> can be used to "
"reference the unique identifier of an object. See <xref linkend=\"queryhql-"
"identifier-property\" /> for more information."
msgstr ""
"Die spezielle Property (Kleinbuchstaben) <literal>id</literal> kann "
"verwendet werden, um auf den eindeutigen Bezeichner eines Objekts zu "
"verweisen. Weitere Informationen finden Sie unter <xref linkend=\"queryhql-"
"identifier-property\"/>."

#. Tag: para
#, fuzzy, no-c-format
msgid "The second query is efficient and does not require a table join."
msgstr "Die zweite Anfrage ist effizient. Kein Tabellenverbund wird benötigt!"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Properties of composite identifiers can also be used. Consider the following "
"example where <literal>Person</literal> has composite identifiers consisting "
"of <literal>country</literal> and <literal>medicareNumber</literal>:"
msgstr ""
"Properties zusammengesetzter Bezeichner können ebenfalls verwendet werden. "
"Nehmen wir an <literal>Person</literal> besitzt einen zusammengesetzten "
"Bezeichner, der aus <literal>country</literal> und <literal>medicareNumber</"
"literal> besteht. Auch in diesem Fall finden Sie weitere Informationen zu "
"Verweisen auf Bezeichner-Properties unter <xref linkend=\"queryhql-"
"identifier-property\"/>."

#. Tag: para
#, fuzzy, no-c-format
msgid "Once again, the second query does not require a table join."
msgstr "Erneut benötigt die zweite Anfrage keinen Tabellenverbund."

#. Tag: para
#, no-c-format
msgid ""
"See <xref linkend=\"queryhql-identifier-property\" /> for more information "
"regarding referencing identifier properties)"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The special property <literal>class</literal> accesses the discriminator "
"value of an instance in the case of polymorphic persistence. A Java class "
"name embedded in the where clause will be translated to its discriminator "
"value."
msgstr ""
"Ebenso greift die spezielle Property <literal>class</literal> im Falle "
"polymorpher Persistenz auf den Diskriminatorwert einer Instanz zu. Ein in "
"der \"where\"-Klausel eingebetteter Java-Klassenname wird in seinen "
"Diskriminatorwert übersetzt."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can also use components or composite user types, or properties of said "
"component types. See <xref linkend=\"queryhql-components\" /> for more "
"information."
msgstr ""
"Sie können auch Komponenten oder zusammengesetzte Benutzertypen der besagten "
"Komponententypen verwenden. Weitere Informationen finden Sie unter <xref "
"linkend=\"queryhql-components\"/>."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"An \"any\" type has the special properties <literal>id</literal> and "
"<literal>class</literal> that allows you to express a join in the following "
"way (where <literal>AuditLog.item</literal> is a property mapped with "
"<literal>&lt;any&gt;</literal>):"
msgstr ""
"Ein \"any\"-Typ hat die speziellen Properties <literal>id</literal> und "
"<literal>class</literal>, wodurch ein Verbund auf folgende Weise ausgedrückt "
"werden kann (wo <literal>AuditLog.item</literal> eine mit <literal>&lt;"
"any&gt;</literal> gemappte Property ist)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>log.item.class</literal> and <literal>payment.class</literal> "
"would refer to the values of completely different database columns in the "
"above query."
msgstr ""
"Bitte beachten Sie, dass <literal>log.item.class</literal> und "
"<literal>payment.class</literal> auf Werte völlig unterschiedlicher "
"Datenbankspalten in der obigen Anfrage verweisen würden."

#. Tag: title
#, no-c-format
msgid "Expressions"
msgstr "Ausdrücke"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Expressions used in the <literal>where</literal> clause include the "
"following:"
msgstr ""
"Die in der <literal>where</literal>-Klausel erlaubten Ausdrücke beinhalten "
"die meisten Dinge, die in SQL geschrieben werden können:"

#. Tag: para
#, fuzzy, no-c-format
msgid "mathematical operators: <literal>+, -, *, /</literal>"
msgstr "mathematische Operatoren <literal>+, -, *, /</literal>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"binary comparison operators: <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</"
"literal>"
msgstr ""
"binäre Vergleichsoperatoren <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</"
"literal>"

#. Tag: para
#, no-c-format
msgid "logical operations <literal>and, or, not</literal>"
msgstr "logische Vorgänge <literal>and, or, not</literal>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Parentheses <literal>( )</literal> that indicates grouping"
msgstr "Runde Klammern <literal>( )</literal>, Gruppierung anzeigend"

#. Tag: para
#, no-c-format
msgid ""
"<literal>in</literal>, <literal>not in</literal>, <literal>between</"
"literal>, <literal>is null</literal>, <literal>is not null</literal>, "
"<literal>is empty</literal>, <literal>is not empty</literal>, "
"<literal>member of</literal> and <literal>not member of</literal>"
msgstr ""
"<literal>in</literal>, <literal>not in</literal>, <literal>between</"
"literal>, <literal>is null</literal>, <literal>is not null</literal>, "
"<literal>is empty</literal>, <literal>is not empty</literal>, "
"<literal>member of</literal> and <literal>not member of</literal>"

#. Tag: para
#, no-c-format
msgid ""
"\"Simple\" case, <literal>case ... when ... then ... else ... end</literal>, "
"and \"searched\" case, <literal>case when ... then ... else ... end</literal>"
msgstr ""
"\"Einfacher\" Fall <literal>case ... when ... then ... else ... end</"
"literal>, und \"gesuchter\" Fall <literal>case when ... then ... else ... "
"end</literal>"

#. Tag: para
#, no-c-format
msgid ""
"string concatenation <literal>...||...</literal> or <literal>concat(...,...)"
"</literal>"
msgstr ""
"String-Verkettung <literal>...||...</literal> oder <literal>concat(...,...)</"
"literal>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>current_date()</literal>, <literal>current_time()</literal>, and "
"<literal>current_timestamp()</literal>"
msgstr ""
"<literal>current_date()</literal>, <literal>current_time()</literal>, "
"<literal>current_timestamp()</literal>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour"
"(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, "
"and <literal>year(...)</literal>"
msgstr ""
"<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour"
"(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, "
"<literal>year(...)</literal>,"

#. Tag: para
#, no-c-format
msgid ""
"Any function or operator defined by EJB-QL 3.0: <literal>substring(), trim"
"(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()"
"</literal>"
msgstr ""
"Jede Funktion oder Operator definiert durch EJB-QL 3.0: <literal>substring"
"(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length"
"(), mod()</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>coalesce()</literal> and <literal>nullif()</literal>"
msgstr "<literal>coalesce()</literal> und <literal>nullif()</literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>str()</literal> for converting numeric or temporal values to a "
"readable string"
msgstr ""
"<literal>str()</literal> zur Konvertierung numerischer oder temporärer Werte "
"in einen lesbaren String"

#. Tag: para
#, no-c-format
msgid ""
"<literal>cast(... as ...)</literal>, where the second argument is the name "
"of a Hibernate type, and <literal>extract(... from ...)</literal> if ANSI "
"<literal>cast()</literal> and <literal>extract()</literal> is supported by "
"the underlying database"
msgstr ""
"<literal>cast(... as ...)</literal>, wo ein zweites Argument der Name eines "
"Hibernate-Typs ist und <literal>extract(... from ...)</literal>, wenn ANSI "
"<literal>cast()</literal> und <literal>extract()</literal> von der zu Grunde "
"liegenden Datenbank unterstützt werden"

#. Tag: para
#, no-c-format
msgid ""
"the HQL <literal>index()</literal> function, that applies to aliases of a "
"joined indexed collection"
msgstr ""
"die HQL <literal>index()</literal>-Funktion, die für Aliasse eine "
"verbundenen indizierten Collection gilt "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"HQL functions that take collection-valued path expressions: <literal>size(), "
"minelement(), maxelement(), minindex(), maxindex()</literal>, along with the "
"special <literal>elements()</literal> and <literal>indices</literal> "
"functions that can be quantified using <literal>some, all, exists, any, in</"
"literal>."
msgstr ""
"HQL-Funktionen, die Collection-wertige Pfadausdrücke annehmen: <literal>size"
"(), minelement(), maxelement(), minindex(), maxindex()</literal> sowie die "
"speziellen <literal>elements()</literal> und <literal>indices</literal>-"
"Funktionen, die mittels <literal>some, all, exists, any, in</literal> "
"gemessen werden können."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Any database-supported SQL scalar function like <literal>sign()</literal>, "
"<literal>trunc()</literal>, <literal>rtrim()</literal>, and <literal>sin()</"
"literal>"
msgstr ""
"Jede von der Datenbank unterstützte SQL-Skalarfunktion wie <literal>sign()</"
"literal>, <literal>trunc()</literal>, <literal>rtrim()</literal>, "
"<literal>sin()</literal>"

#. Tag: para
#, no-c-format
msgid "JDBC-style positional parameters <literal>?</literal>"
msgstr "Positionelle Parameter im JDBC-Stil <literal>?</literal>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"named parameters <literal>:name</literal>, <literal>:start_date</literal>, "
"and <literal>:x1</literal>"
msgstr ""
"benannte Parameter <literal>:name</literal>, <literal>:start_date</literal>, "
"<literal>:x1</literal>"

#. Tag: para
#, no-c-format
msgid ""
"SQL literals <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E"
"+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"
msgstr ""
"SQL-Literale <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E"
"+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"

#. Tag: para
#, no-c-format
msgid ""
"Java <literal>public static final</literal> constants <literal>eg.Color."
"TABBY</literal>"
msgstr ""
"Java <literal>public static final</literal>-Konstanten <literal>eg.Color."
"TABBY</literal>"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>in</literal> and <literal>between</literal> can be used as follows:"
msgstr ""
"<literal>in</literal> und <literal>between</literal> können wie folgt "
"verwendet werden:"

#. Tag: para
#, fuzzy, no-c-format
msgid "The negated forms can be written as follows:"
msgstr "und die negierten Formen können geschrieben werden"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Similarly, <literal>is null</literal> and <literal>is not null</literal> can "
"be used to test for null values."
msgstr ""
"Ebenso können <literal>is null</literal> und <literal>is not null</literal> "
"verwendet werden, um auf Nullwerte zu prüfen."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Booleans can be easily used in expressions by declaring HQL query "
"substitutions in Hibernate configuration:"
msgstr ""
"Booleans können ganz einfach in Ausdrücken verwendet werden, indem man in "
"der Hibernate Konfiguration HQL-Anfragesubstitutionen deklariert:"

#. Tag: para
#, no-c-format
msgid ""
"This will replace the keywords <literal>true</literal> and <literal>false</"
"literal> with the literals <literal>1</literal> and <literal>0</literal> in "
"the translated SQL from this HQL:"
msgstr ""
"Das ersetzt die Schlüsselbegriffe <literal>true</literal> und "
"<literal>false</literal> durch die Literale <literal>1</literal> und "
"<literal>0</literal> in der aus dieser HQL übersetzten SQL:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can test the size of a collection with the special property "
"<literal>size</literal> or the special <literal>size()</literal> function."
msgstr ""
"Sie können die Größe einer Collection mit der speziellen Property "
"<literal>size</literal> oder der speziellen <literal>size()</literal>-"
"Funktion überprüfen."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"For indexed collections, you can refer to the minimum and maximum indices "
"using <literal>minindex</literal> and <literal>maxindex</literal> functions. "
"Similarly, you can refer to the minimum and maximum elements of a collection "
"of basic type using the <literal>minelement</literal> and "
"<literal>maxelement</literal> functions. For example:"
msgstr ""
"Für indizierte Collections können Sie auf den minimalen und den maximalen "
"Index verweisen, indem Sie die <literal>minindex</literal> und "
"<literal>maxindex</literal>-Funktionen verwenden. Ähnlich können Sie auch "
"auf die minimalen und maximalen Elemente einer Collection des Grundtyps "
"mittels <literal>minelement</literal> und <literal>maxelement</literal>-"
"Funktionen verweisen."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The SQL functions <literal>any, some, all, exists, in</literal> are "
"supported when passed the element or index set of a collection "
"(<literal>elements</literal> and <literal>indices</literal> functions) or "
"the result of a subquery (see below):"
msgstr ""
"Die SQL-Funktionen <literal>any, some, all, exists, in</literal> werden "
"unterstützt, wenn an den Element- oder Indexsatz einer Collection "
"(<literal>elements</literal> und <literal>indices</literal>-Funktionen) oder "
"das Ergebnis einer Unteranfrage gegeben (siehe unten)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Note that these constructs - <literal>size</literal>, <literal>elements</"
"literal>, <literal>indices</literal>, <literal>minindex</literal>, "
"<literal>maxindex</literal>, <literal>minelement</literal>, "
"<literal>maxelement</literal> - can only be used in the where clause in "
"Hibernate3."
msgstr ""
"Bitte beachten Sie, dass folgende Konstrukte - <literal>size</literal>, "
"<literal>elements</literal>, <literal>indices</literal>, <literal>minindex</"
"literal>, <literal>maxindex</literal>, <literal>minelement</literal>, "
"<literal>maxelement</literal> - in Hibernate3 nur in der \"where\"-Klausel "
"verwendet werden können."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Elements of indexed collections (arrays, lists, and maps) can be referred to "
"by index in a where clause only:"
msgstr ""
"Auf Elemente indizierter Collections (Arrays, Listen, Maps) kann durch den "
"Index verwiesen werden (nur in der \"where\"-Klausel):"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The expression inside <literal>[]</literal> can even be an arithmetic "
"expression:"
msgstr ""
"Der Ausdruck innerhalb von <literal>[]</literal> kann sogar ein "
"arithmetischer Ausdruck sein."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"HQL also provides the built-in <literal>index()</literal> function for "
"elements of a one-to-many association or collection of values."
msgstr ""
"HQL bietet außerdem die eingebaute <literal>index()</literal>-Funktion für "
"Elemente einer \"One-to-Many\"-Assoziation oder einer Collection von Werten."

#. Tag: para
#, fuzzy, no-c-format
msgid "Scalar SQL functions supported by the underlying database can be used:"
msgstr ""
"Skalare SQL-Funktionen, die durch die zu Grunde liegende Datenbank "
"unterstützt werden, können verwendet werden"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Consider how much longer and less readable the following query would be in "
"SQL:"
msgstr ""
"Falls Sie jetzt noch nicht vom Sinn des Ganzen überzeugt sind, überlegen Sie "
"einmal, um wie viel länger und um wie viel weniger lesbar die folgende "
"Anfrage in SQL wäre:"

#. Tag: para
#, no-c-format
msgid "<emphasis>Hint:</emphasis> something like"
msgstr "<emphasis>Tipp:</emphasis> etwas wie"

#. Tag: title
#, no-c-format
msgid "The order by clause"
msgstr "Die Reihenfolge nach Klausel"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The list returned by a query can be ordered by any property of a returned "
"class or components:"
msgstr ""
"Die Liste, mit der eine Anfrage reagiert, kann nach jeder Property der "
"Klasse oder Komponenten geordnet sein:"

#. Tag: para
#, no-c-format
msgid ""
"The optional <literal>asc</literal> or <literal>desc</literal> indicate "
"ascending or descending order respectively."
msgstr ""
"Die optionalen <literal>asc</literal> oder <literal>desc</literal> zeigen "
"die aufsteigende bzw. absteigende Reihenfolge an."

#. Tag: title
#, no-c-format
msgid "The group by clause"
msgstr "Die Gruppe nach Klausel"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A query that returns aggregate values can be grouped by any property of a "
"returned class or components:"
msgstr ""
"Eine Anfrage, die aggregierte Werte zurücksendet kann durch jede Property "
"einer zurückgesendeten Klasse oder Komponenten gruppiert werden:"

#. Tag: para
#, no-c-format
msgid "A <literal>having</literal> clause is also allowed."
msgstr "Eine <literal>having</literal>-Klausel ist ebenfalls gestattet."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"SQL functions and aggregate functions are allowed in the <literal>having</"
"literal> and <literal>order by</literal> clauses if they are supported by "
"the underlying database (i.e., not in MySQL)."
msgstr ""
"SQL-Funktionen und aggregierte Funktionen sind in den <literal>having</"
"literal> und <literal>order by</literal>-Klauseln gestattet , wenn sie von "
"der zu Grunde liegenden Datenbank unterstützt werden (z.B. nicht in MySQL)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Neither the <literal>group by</literal> clause nor the <literal>order by</"
"literal> clause can contain arithmetic expressions. Hibernate also does not "
"currently expand a grouped entity, so you cannot write <literal>group by "
"cat</literal> if all properties of <literal>cat</literal> are non-"
"aggregated. You have to list all non-aggregated properties explicitly."
msgstr ""
"Beachten Sie, dass weder die <literal>group by</literal>-Klausel noch die "
"<literal>order by</literal>-Klausel arithmetische Ausdrücke enthalten "
"dürfen. Beachten Sie auch, dass Hibernate zur Zeit keine gruppierte Entity "
"ausklappt, das heißt, Sie können nicht <literal>group by cat</literal> "
"schreiben, wenn sämtliche Properties von <literal>cat</literal> nicht "
"aggregiert sind. Sie müssen alle nicht aggregierten Properties explizit "
"auflisten."

#. Tag: title
#, no-c-format
msgid "Subqueries"
msgstr "Unteranfragen"

#. Tag: para
#, no-c-format
msgid ""
"For databases that support subselects, Hibernate supports subqueries within "
"queries. A subquery must be surrounded by parentheses (often by an SQL "
"aggregate function call). Even correlated subqueries (subqueries that refer "
"to an alias in the outer query) are allowed."
msgstr ""
"Für Datenbanken, die Unterauswahlen unterstützen, unterstützt Hibernate "
"innerhalb von Anfragen Unteranfragen. Eine Unteranfrage muss eingeklammert "
"sein (oftmals durch einen SQL aggregierten Funktionsaufruf). Selbst "
"korrelierende Unteranfragen (Unteranfragen, die auf einen Alias in der "
"außerhalb liegenden Anfrage verweisen) sind gestattet."

#. Tag: para
#, fuzzy, no-c-format
msgid "Note that HQL subqueries can occur only in the select or where clauses."
msgstr ""
"Beachten Sie, dass HQL-Unteranfragen nur in der Auswahl oder die \"where\"-"
"Klausel auftreten können."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Note that subqueries can also utilize <literal>row value constructor</"
"literal> syntax. See <xref linkend=\"queryhql-tuple\" /> for more "
"information."
msgstr ""
"Beachten Sie, dass Unteranfragen ebenfalls die <literal>row value "
"constructor</literal>-Syntax nutzen können. Weitere Informationen finden Sie "
"unter <xref linkend=\"queryhql-tuple\"/>."

#. Tag: title
#, no-c-format
msgid "HQL examples"
msgstr "HQL-Beispiele"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate queries can be quite powerful and complex. In fact, the power of "
"the query language is one of Hibernate's main strengths. The following "
"example queries are similar to queries that have been used on recent "
"projects. Please note that most queries you will write will be much simpler "
"than the following examples."
msgstr ""
"Anfragen in Hibernate können sehr leistungsfähig und recht komplex sein. "
"Genau genommen ist die Leistungsfähigkeit eine von Hibernates größten "
"Stärken. Nachfolgend sehen Sie einige Beispielanfragen, ähnlich denen, die "
"ich bei einem aktuellen Projekt verwendet habe. Bitte beachten Sie, dass die "
"meisten Anfragen, die Sie werden schreiben müssen, wesentlich einfacher als "
"diese sind!"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The following query returns the order id, number of items, the given minimum "
"total value and the total value of the order for all unpaid orders for a "
"particular customer. The results are ordered by total value. In determining "
"the prices, it uses the current catalog. The resulting SQL query, against "
"the <literal>ORDER</literal>, <literal>ORDER_LINE</literal>, "
"<literal>PRODUCT</literal>, <literal>CATALOG</literal> and <literal>PRICE</"
"literal> tables has four inner joins and an (uncorrelated) subselect."
msgstr ""
"Die folgende Anfrage reagiert mit der ID der Bestellung (sog. \"order id\"), "
"der Anzahl von Posten und dem Gesamtwert der Bestellung für alle unbezahlten "
"Bestellungen für einen bestimmten Kunden und dem gegebenen Mindestwert, "
"wobei die Ergebnisse nach Gesamtwert geordnet wird. Bei der Bestimmung der "
"Preise wird der aktuelle Katalog verwendet. Die sich ergebende SQL-Anfrage "
"an <literal>ORDER</literal>, <literal>ORDER_LINE</literal>, "
"<literal>PRODUCT</literal>, <literal>CATALOG</literal> und <literal>PRICE</"
"literal>-Tabellen besitzt vier innere Verbünde (\"inner joins\") und eine "
"(unkorrelierte) Unterauswahl."

#. Tag: para
#, no-c-format
msgid ""
"What a monster! Actually, in real life, I'm not very keen on subqueries, so "
"my query was really more like this:"
msgstr ""
"Monströs! Im wirklichen Leben bin ich kein großer Freund von Unteranfragen, "
"daher sieht meine Anfrage eher wie folgt aus:"

#. Tag: para
#, no-c-format
msgid ""
"The next query counts the number of payments in each status, excluding all "
"payments in the <literal>AWAITING_APPROVAL</literal> status where the most "
"recent status change was made by the current user. It translates to an SQL "
"query with two inner joins and a correlated subselect against the "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal> and "
"<literal>PAYMENT_STATUS_CHANGE</literal> tables."
msgstr ""
"Die nächste Anfrage zählt die Anzahl von Zahlungen in jedem Status, wobei "
"Zahlungen mit <literal>AWAITING_APPROVAL</literal>-Status, bei denen die "
"aktuellste Statusänderung durch den Benutzer vorgenommen wurde, ausgenommen "
"sind. Sie wird in eine SQL-Anfrage mit zwei inneren Verbünden und eine "
"korrelierte Unterauswahl an die <literal>PAYMENT</literal>, "
"<literal>PAYMENT_STATUS</literal> und <literal>PAYMENT_STATUS_CHANGE</"
"literal>-Tabellen übersetzt."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"If the <literal>statusChanges</literal> collection was mapped as a list, "
"instead of a set, the query would have been much simpler to write."
msgstr ""
"Wäre die <literal>statusChanges</literal>-Collection als Liste statt als "
"Satz (sog. \"set\") gemappt, so hätte sich die Anfrage einfacher schreiben "
"lassen."

#. Tag: para
#, no-c-format
msgid ""
"The next query uses the MS SQL Server <literal>isNull()</literal> function "
"to return all the accounts and unpaid payments for the organization to which "
"the current user belongs. It translates to an SQL query with three inner "
"joins, an outer join and a subselect against the <literal>ACCOUNT</literal>, "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal>, "
"<literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> and "
"<literal>ORG_USER</literal> tables."
msgstr ""
"Die nächste Anfrage verwendet die MS SQL Server <literal>isNull()</literal>-"
"Funktion, um alle Konten und unbezahlten Zahlungen für the Organisation, zu "
"der der aktuelle Benutzer gehört, wiederzugeben. Sie wird in eine SQL-"
"Anfrage mit drei inneren Verbünden (\"inner Joins\"), einen äußeren Verbund "
"(\"outer Join\") und eine Unterauswahl gegen die <literal>ACCOUNT</literal>, "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal>, "
"<literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> und "
"<literal>ORG_USER</literal>-Tabellen übersetzt."

#. Tag: para
#, no-c-format
msgid ""
"For some databases, we would need to do away with the (correlated) subselect."
msgstr ""
"Bei einigen Datenbanken würden wir die (korrelierende) Unterauswahl "
"abschaffen müssen."

#. Tag: title
#, no-c-format
msgid "Bulk update and delete"
msgstr "\"Bulk\"-Aktualisierung und Löschen"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"HQL now supports <literal>update</literal>, <literal>delete</literal> and "
"<literal>insert ... select ...</literal> statements. See <xref linkend="
"\"batch-direct\" /> for more information."
msgstr ""
"HQL unterstützt nun <literal>update</literal>, <literal>delete</literal> und "
"<literal>insert ... select ...</literal>-Anweisungen. Weitere Einzelheiten "
"hierzu finden Sie unter <xref linkend=\"batch-direct\"/>."

#. Tag: title
#, no-c-format
msgid "Tips &amp; Tricks"
msgstr "Tipps &amp; Tricks"

#. Tag: para
#, fuzzy, no-c-format
msgid "You can count the number of query results without returning them:"
msgstr ""
"Sie können die Anzahl der Anfragenergebnisse zählen, ohne diese tatsächlich "
"wiederzugeben:"

#. Tag: para
#, no-c-format
msgid "To order a result by the size of a collection, use the following query:"
msgstr ""
"Um ein Ergebnis nach der Größe einer Collection zu ordnen, verwenden Sie die "
"folgende Anfrage:"

#. Tag: para
#, no-c-format
msgid ""
"If your database supports subselects, you can place a condition upon "
"selection size in the where clause of your query:"
msgstr ""
"Falls Ihre Datenbank Unterauswahlen unterstützt, können Sie eine Bedingung "
"bezüglich der Auswahlgröße in der \"where\"-Klausel Ihrer Anfrage stellen:"

#. Tag: para
#, fuzzy, no-c-format
msgid "If your database does not support subselects, use the following query:"
msgstr ""
"Falls Ihre Datenbank keine Unterauswahl unterstützt, verwenden Sie folgende "
"Anfrage:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"As this solution cannot return a <literal>User</literal> with zero messages "
"because of the inner join, the following form is also useful:"
msgstr ""
"Da dabei wegen des inneren Verbunds nicht mit einem <literal>User</literal> "
"mit \"Null\" Nachrichten reagiert werden kann, ist die folgende Form "
"ebenfalls hilfreich:"

#. Tag: para
#, no-c-format
msgid "Properties of a JavaBean can be bound to named query parameters:"
msgstr ""
"Properties eines JavaBean können an benannte Anfragenparameter gebunden "
"werden:"

#. Tag: para
#, no-c-format
msgid ""
"Collections are pageable by using the <literal>Query</literal> interface "
"with a filter:"
msgstr ""
"Collections sind unter Verwendung des <literal>Query</literal>-Interface mit "
"einem Filter seitenwechselbar:"

#. Tag: para
#, fuzzy, no-c-format
msgid "Collection elements can be ordered or grouped using a query filter:"
msgstr ""
"Collection-Elemente können mittels eines Anfragenfilters geordnet oder "
"gruppiert werden:"

#. Tag: para
#, no-c-format
msgid "You can find the size of a collection without initializing it:"
msgstr ""
"Sie können die Größe einer Collection finden, ohne diese zu initialisieren:"

#. Tag: title
#, no-c-format
msgid "Components"
msgstr "Komponenten"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Components can be used similarly to the simple value types that are used in "
"HQL queries. They can appear in the <literal>select</literal> clause as "
"follows:"
msgstr ""
"Komponenten können auf nahezu alle Arten verwendet werden, wie Wertetypen in "
"HQL-Anfragen. Sie können in der <literal>select</literal>-Klausel auftreten:"

#. Tag: para
#, no-c-format
msgid ""
"where the Person's name property is a component. Components can also be used "
"in the <literal>where</literal> clause:"
msgstr ""
"wo die Namen-Property der Person eine Komponente ist. Komponenten können "
"auch in der <literal>where</literal>-Klausel verwendet werden:"

#. Tag: para
#, no-c-format
msgid "Components can also be used in the <literal>order by</literal> clause:"
msgstr ""
"Komponenten können auch in der <literal>order by</literal>-Klausel verwendet "
"werden:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Another common use of components is in <link linkend=\"queryhql-tuple\">row "
"value constructors</link>."
msgstr ""
"Ein weiterer gängiger Anwendungsbereich von Komponenten ist in <xref linkend="
"\"queryhql-tuple\"/> \"Row-Value-Constructors\"."

#. Tag: title
#, no-c-format
msgid "Row value constructor syntax"
msgstr "Die Syntax des \"Row-Value-Constructors\""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"HQL supports the use of ANSI SQL <literal>row value constructor</literal> "
"syntax, sometimes referred to AS <literal>tuple</literal> syntax, even "
"though the underlying database may not support that notion. Here, we are "
"generally referring to multi-valued comparisons, typically associated with "
"components. Consider an entity Person which defines a name component:"
msgstr ""
"HQL unterstützt die Verwendung der ANSI SQL <literal>row value constructor</"
"literal>-Syntax (auch als <literal>tuple</literal>-Syntax bekannt), obwohl "
"die zu Grunde liegende Datenbank diesen Begriff möglicherweise nicht "
"unterstützt. Wir beziehen uns hier im Wesentlichen auf mehrwertige "
"Vergleiche, in der Regel mit Komponenten assoziiert. Ziehen Sie eine Entity "
"Person in Betracht, die eine Namenskomponente definiert:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"That is valid syntax although it is a little verbose. You can make this more "
"concise by using <literal>row value constructor</literal> syntax:"
msgstr ""
"Das ist eine gültige Syntax, wenngleich etwas wortreich. Präziser lässt sich "
"dies mittels der <literal>row value constructor</literal>-Syntax ausdrücken:"

#. Tag: para
#, no-c-format
msgid ""
"It can also be useful to specify this in the <literal>select</literal> "
"clause:"
msgstr ""
"Es kann sich als nützlich erweisen, dies in der <literal>select</literal>-"
"Klausel zu spezifizieren:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Using <literal>row value constructor</literal> syntax can also be beneficial "
"when using subqueries that need to compare against multiple values:"
msgstr ""
"Die Verwendung der <literal>row value constructor</literal>-Syntax kann "
"außerdem bei der Verwendung von Unteranfragen hilfreich sein, die mit "
"mehreren Werten verglichen werden müssen:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"One thing to consider when deciding if you want to use this syntax, is that "
"the query will be dependent upon the ordering of the component sub-"
"properties in the metadata."
msgstr ""
"Bei der Entscheidung, ob Sie diese Syntax verwenden möchten, sollten Sie "
"berücksichtigen, dass die Anfrage von der Anordnung der Komponenten Sub-"
"Properties in Metadata abhängig sein wird."

#, fuzzy
#~ msgid "<![CDATA[from eg.Cat]]>"
#~ msgstr "from eg.Cat"

#, fuzzy
#~ msgid "<![CDATA[from Cat]]>"
#~ msgstr "from eg.Cat"

#, fuzzy
#~ msgid "<![CDATA[from Cat as cat]]>"
#~ msgstr "from Cat as cat"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat]]>"
#~ msgstr "from Cat cat"

#, fuzzy
#~ msgid "<![CDATA[from Formula, Parameter]]>"
#~ msgstr "from Formula, Parameter"

#, fuzzy
#~ msgid "<![CDATA[from Formula as form, Parameter as param]]>"
#~ msgstr "from Formula as form, Parameter as param"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "    inner join cat.mate as mate\n"
#~ "    left outer join cat.kittens as kitten]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "    inner join cat.mate as mate\n"
#~ "    left outer join cat.kittens as kitten"

#, fuzzy
#~ msgid "<![CDATA[from Cat as cat left join cat.mate.kittens as kittens]]>"
#~ msgstr "from Cat as cat left join cat.mate.kittens as kittens"

#, fuzzy
#~ msgid "<![CDATA[from Formula form full join form.parameter param]]>"
#~ msgstr "from Formula form full join form.parameter param"

#~ msgid "inner join"
#~ msgstr "inner join"

#~ msgid "left outer join"
#~ msgstr "left outer join"

#, fuzzy
#~ msgid "right outer join"
#~ msgstr "left outer join"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "    join cat.mate as mate\n"
#~ "    left join cat.kittens as kitten]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "    join cat.mate as mate\n"
#~ "    left join cat.kittens as kitten"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "    left join cat.kittens as kitten\n"
#~ "        with kitten.bodyWeight > 10.0]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "    left join cat.kittens as kitten\n"
#~ "        with kitten.bodyWeight &gt; 10.0"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "    inner join fetch cat.mate\n"
#~ "    left join fetch cat.kittens]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "    inner join fetch cat.mate\n"
#~ "    left join fetch cat.kittens"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "    inner join fetch cat.mate\n"
#~ "    left join fetch cat.kittens child\n"
#~ "    left join fetch child.kittens]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "    inner join fetch cat.mate\n"
#~ "    left join fetch cat.kittens child\n"
#~ "    left join fetch child.kittens"

#, fuzzy
#~ msgid "<![CDATA[from Document fetch all properties order by name]]>"
#~ msgstr "from Document fetch all properties order by name"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Document doc fetch all properties where lower(doc.name) "
#~ "like '%cats%']]>"
#~ msgstr ""
#~ "from Document doc fetch all properties where lower(doc.name) like '&#37;"
#~ "cats&#37;'"

#, fuzzy
#~ msgid "<![CDATA[from Cat as cat where cat.mate.name like '%s%']]>"
#~ msgstr "from Cat as cat where cat.mate.name like '&#37;s&#37;'"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select mate\n"
#~ "from Cat as cat\n"
#~ "    inner join cat.mate as mate]]>"
#~ msgstr ""
#~ "select mate\n"
#~ "from Cat as cat\n"
#~ "    inner join cat.mate as mate"

#, fuzzy
#~ msgid "<![CDATA[select cat.mate from Cat cat]]>"
#~ msgstr "select cat.mate from Cat cat"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat.name from DomesticCat cat\n"
#~ "where cat.name like 'fri%']]>"
#~ msgstr ""
#~ "select cat.name from DomesticCat cat\n"
#~ "where cat.name like 'fri&#37;'"

#, fuzzy
#~ msgid "<![CDATA[select cust.name.firstName from Customer as cust]]>"
#~ msgstr "select cust.name.firstName from Customer as cust"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select mother, offspr, mate.name\n"
#~ "from DomesticCat as mother\n"
#~ "    inner join mother.mate as mate\n"
#~ "    left outer join mother.kittens as offspr]]>"
#~ msgstr ""
#~ "select mother, offspr, mate.name\n"
#~ "from DomesticCat as mother\n"
#~ "    inner join mother.mate as mate\n"
#~ "    left outer join mother.kittens as offspr"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select new list(mother, offspr, mate.name)\n"
#~ "from DomesticCat as mother\n"
#~ "    inner join mother.mate as mate\n"
#~ "    left outer join mother.kittens as offspr]]>"
#~ msgstr ""
#~ "select new list(mother, offspr, mate.name)\n"
#~ "from DomesticCat as mother\n"
#~ "    inner join mother.mate as mate\n"
#~ "    left outer join mother.kittens as offspr"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select new Family(mother, mate, offspr)\n"
#~ "from DomesticCat as mother\n"
#~ "    join mother.mate as mate\n"
#~ "    left join mother.kittens as offspr]]>"
#~ msgstr ""
#~ "select new Family(mother, mate, offspr)\n"
#~ "from DomesticCat as mother\n"
#~ "    join mother.mate as mate\n"
#~ "    left join mother.kittens as offspr"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select max(bodyWeight) as max, min(bodyWeight) as min, count(*) "
#~ "as n\n"
#~ "from Cat cat]]>"
#~ msgstr ""
#~ "select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n\n"
#~ "from Cat cat"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select new map( max(bodyWeight) as max, min(bodyWeight) as min, "
#~ "count(*) as n )\n"
#~ "from Cat cat]]>"
#~ msgstr ""
#~ "select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) "
#~ "as n )\n"
#~ "from Cat cat"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select avg(cat.weight), sum(cat.weight), max(cat.weight), count"
#~ "(cat)\n"
#~ "from Cat cat]]>"
#~ msgstr ""
#~ "select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)\n"
#~ "from Cat cat"

#~ msgid "count(*)"
#~ msgstr "count(*)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat.weight + sum(kitten.weight)\n"
#~ "from Cat cat\n"
#~ "    join cat.kittens kitten\n"
#~ "group by cat.id, cat.weight]]>"
#~ msgstr ""
#~ "select cat.weight + sum(kitten.weight)\n"
#~ "from Cat cat\n"
#~ "    join cat.kittens kitten\n"
#~ "group by cat.id, cat.weight"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select firstName||' '||initial||' '||upper(lastName) from "
#~ "Person]]>"
#~ msgstr "select firstName||' '||initial||' '||upper(lastName) from Person"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select distinct cat.name from Cat cat\n"
#~ "\n"
#~ "select count(distinct cat.name), count(cat) from Cat cat]]>"
#~ msgstr ""
#~ "select distinct cat.name from Cat cat\n"
#~ "\n"
#~ "select count(distinct cat.name), count(cat) from Cat cat"

#, fuzzy
#~ msgid "<![CDATA[from java.lang.Object o]]>"
#~ msgstr "from java.lang.Object o"

#, fuzzy
#~ msgid "<![CDATA[from Named n, Named m where n.name = m.name]]>"
#~ msgstr "from Named n, Named m where n.name = m.name"

#, fuzzy
#~ msgid "<![CDATA[from Cat where name='Fritz']]>"
#~ msgstr "from Cat where name='Fritz'"

#, fuzzy
#~ msgid "<![CDATA[from Cat as cat where cat.name='Fritz']]>"
#~ msgstr "from Cat as cat where cat.name='Fritz'"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select foo\n"
#~ "from Foo foo, Bar bar\n"
#~ "where foo.startDate = bar.date]]>"
#~ msgstr ""
#~ "select foo\n"
#~ "from Foo foo, Bar bar\n"
#~ "where foo.startDate = bar.date"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat where cat.mate.name is not null]]>"
#~ msgstr "from Cat cat where cat.mate.name is not null"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Foo foo\n"
#~ "where foo.bar.baz.customer.address.city is not null]]>"
#~ msgstr ""
#~ "from Foo foo\n"
#~ "where foo.bar.baz.customer.address.city is not null"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat, Cat rival where cat.mate = rival.mate]]>"
#~ msgstr "from Cat cat, Cat rival where cat.mate = rival.mate"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat, mate\n"
#~ "from Cat cat, Cat mate\n"
#~ "where cat.mate = mate]]>"
#~ msgstr ""
#~ "select cat, mate\n"
#~ "from Cat cat, Cat mate\n"
#~ "where cat.mate = mate"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat where cat.id = 123\n"
#~ "\n"
#~ "from Cat as cat where cat.mate.id = 69]]>"
#~ msgstr ""
#~ "from Cat as cat where cat.id = 123\n"
#~ "\n"
#~ "from Cat as cat where cat.mate.id = 69"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from bank.Person person\n"
#~ "where person.id.country = 'AU'\n"
#~ "    and person.id.medicareNumber = 123456]]>"
#~ msgstr ""
#~ "from bank.Person person\n"
#~ "where person.id.country = 'AU'\n"
#~ "    and person.id.medicareNumber = 123456"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from bank.Account account\n"
#~ "where account.owner.id.country = 'AU'\n"
#~ "    and account.owner.id.medicareNumber = 123456]]>"
#~ msgstr ""
#~ "from bank.Account account\n"
#~ "where account.owner.id.country = 'AU'\n"
#~ "    and account.owner.id.medicareNumber = 123456"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat where cat.class = DomesticCat]]>"
#~ msgstr "from Cat cat where cat.class = DomesticCat"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from AuditLog log, Payment payment\n"
#~ "where log.item.class = 'Payment' and log.item.id = payment.id]]>"
#~ msgstr ""
#~ "from AuditLog log, Payment payment\n"
#~ "where log.item.class = 'Payment' and log.item.id = payment.id"

#, fuzzy
#~ msgid "<![CDATA[from DomesticCat cat where cat.name between 'A' and 'B']]>"
#~ msgstr "from DomesticCat cat where cat.name between 'A' and 'B'"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )]]>"
#~ msgstr "from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from DomesticCat cat where cat.name not between 'A' and 'B']]>"
#~ msgstr "from DomesticCat cat where cat.name not between 'A' and 'B'"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', "
#~ "'Baz' )]]>"
#~ msgstr "from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<property name=\"hibernate.query.substitutions\">true 1, false "
#~ "0</property>]]>"
#~ msgstr ""
#~ "&lt;property name=\"hibernate.query.substitutions\"&gt;true 1, false "
#~ "0&lt;/property&gt;"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat where cat.alive = true]]>"
#~ msgstr "from Cat cat where cat.alive = true"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat where cat.kittens.size > 0]]>"
#~ msgstr "from Cat cat where cat.kittens.size &gt; 0"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat where size(cat.kittens) > 0]]>"
#~ msgstr "from Cat cat where size(cat.kittens) &gt; 0"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Calendar cal where maxelement(cal.holidays) > current_date]]"
#~ ">"
#~ msgstr "from Calendar cal where maxelement(cal.holidays) &gt; current_date"

#, fuzzy
#~ msgid "<![CDATA[from Order order where maxindex(order.items) > 100]]>"
#~ msgstr "from Order order where maxindex(order.items) &gt; 100"

#, fuzzy
#~ msgid "<![CDATA[from Order order where minelement(order.items) > 10000]]>"
#~ msgstr "from Order order where minelement(order.items) &gt; 10000"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select mother from Cat as mother, Cat as kit\n"
#~ "where kit in elements(foo.kittens)]]>"
#~ msgstr ""
#~ "select mother from Cat as mother, Cat as kit\n"
#~ "where kit in elements(foo.kittens)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select p from NameList list, Person p\n"
#~ "where p.name = some elements(list.names)]]>"
#~ msgstr ""
#~ "select p from NameList list, Person p\n"
#~ "where p.name = some elements(list.names)"

#, fuzzy
#~ msgid "<![CDATA[from Cat cat where exists elements(cat.kittens)]]>"
#~ msgstr "from Cat cat where exists elements(cat.kittens)"

#, fuzzy
#~ msgid "<![CDATA[from Player p where 3 > all elements(p.scores)]]>"
#~ msgstr "from Player p where 3 &gt; all elements(p.scores)"

#, fuzzy
#~ msgid "<![CDATA[from Show show where 'fizard' in indices(show.acts)]]>"
#~ msgstr "from Show show where 'fizard' in indices(show.acts)"

#, fuzzy
#~ msgid "<![CDATA[from Order order where order.items[0].id = 1234]]>"
#~ msgstr "from Order order where order.items[0].id = 1234"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select person from Person person, Calendar calendar\n"
#~ "where calendar.holidays['national day'] = person.birthDay\n"
#~ "    and person.nationality.calendar = calendar]]>"
#~ msgstr ""
#~ "select person from Person person, Calendar calendar\n"
#~ "where calendar.holidays['national day'] = person.birthDay\n"
#~ "    and person.nationality.calendar = calendar"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select item from Item item, Order order\n"
#~ "where order.items[ order.deliveredItemIndices[0] ] = item and order.id = "
#~ "11]]>"
#~ msgstr ""
#~ "select item from Item item, Order order\n"
#~ "where order.items[ order.deliveredItemIndices[0] ] = item and order.id = "
#~ "11"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select item from Item item, Order order\n"
#~ "where order.items[ maxindex(order.items) ] = item and order.id = 11]]>"
#~ msgstr ""
#~ "select item from Item item, Order order\n"
#~ "where order.items[ maxindex(order.items) ] = item and order.id = 11"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select item from Item item, Order order\n"
#~ "where order.items[ size(order.items) - 1 ] = item]]>"
#~ msgstr ""
#~ "select item from Item item, Order order\n"
#~ "where order.items[ size(order.items) - 1 ] = item"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select item, index(item) from Order order\n"
#~ "    join order.items item\n"
#~ "where index(item) < 5]]>"
#~ msgstr ""
#~ "select item, index(item) from Order order\n"
#~ "    join order.items item\n"
#~ "where index(item) &lt; 5"

#, fuzzy
#~ msgid "<![CDATA[from DomesticCat cat where upper(cat.name) like 'FRI%']]>"
#~ msgstr "from DomesticCat cat where upper(cat.name) like 'FRI&#37;'"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cust\n"
#~ "from Product prod,\n"
#~ "    Store store\n"
#~ "    inner join store.customers cust\n"
#~ "where prod.name = 'widget'\n"
#~ "    and store.location.name in ( 'Melbourne', 'Sydney' )\n"
#~ "    and prod = all elements(cust.currentOrder.lineItems)]]>"
#~ msgstr ""
#~ "select cust\n"
#~ "from Product prod,\n"
#~ "    Store store\n"
#~ "    inner join store.customers cust\n"
#~ "where prod.name = 'widget'\n"
#~ "    and store.location.name in ( 'Melbourne', 'Sydney' )\n"
#~ "    and prod = all elements(cust.currentOrder.lineItems)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[SELECT cust.name, cust.address, cust.phone, cust.id, cust."
#~ "current_order\n"
#~ "FROM customers cust,\n"
#~ "    stores store,\n"
#~ "    locations loc,\n"
#~ "    store_customers sc,\n"
#~ "    product prod\n"
#~ "WHERE prod.name = 'widget'\n"
#~ "    AND store.loc_id = loc.id\n"
#~ "    AND loc.name IN ( 'Melbourne', 'Sydney' )\n"
#~ "    AND sc.store_id = store.id\n"
#~ "    AND sc.cust_id = cust.id\n"
#~ "    AND prod.id = ALL(\n"
#~ "        SELECT item.prod_id\n"
#~ "        FROM line_items item, orders o\n"
#~ "        WHERE item.order_id = o.id\n"
#~ "            AND cust.current_order = o.id\n"
#~ "    )]]>"
#~ msgstr ""
#~ "SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order\n"
#~ "FROM customers cust,\n"
#~ "    stores store,\n"
#~ "    locations loc,\n"
#~ "    store_customers sc,\n"
#~ "    product prod\n"
#~ "WHERE prod.name = 'widget'\n"
#~ "    AND store.loc_id = loc.id\n"
#~ "    AND loc.name IN ( 'Melbourne', 'Sydney' )\n"
#~ "    AND sc.store_id = store.id\n"
#~ "    AND sc.cust_id = cust.id\n"
#~ "    AND prod.id = ALL(\n"
#~ "        SELECT item.prod_id\n"
#~ "        FROM line_items item, orders o\n"
#~ "        WHERE item.order_id = o.id\n"
#~ "            AND cust.current_order = o.id\n"
#~ "    )"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from DomesticCat cat\n"
#~ "order by cat.name asc, cat.weight desc, cat.birthdate]]>"
#~ msgstr ""
#~ "from DomesticCat cat\n"
#~ "order by cat.name asc, cat.weight desc, cat.birthdate"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat.color, sum(cat.weight), count(cat)\n"
#~ "from Cat cat\n"
#~ "group by cat.color]]>"
#~ msgstr ""
#~ "select cat.color, sum(cat.weight), count(cat)\n"
#~ "from Cat cat\n"
#~ "group by cat.color"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select foo.id, avg(name), max(name)\n"
#~ "from Foo foo join foo.names name\n"
#~ "group by foo.id]]>"
#~ msgstr ""
#~ "select foo.id, avg(name), max(name)\n"
#~ "from Foo foo join foo.names name\n"
#~ "group by foo.id"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat.color, sum(cat.weight), count(cat)\n"
#~ "from Cat cat\n"
#~ "group by cat.color\n"
#~ "having cat.color in (eg.Color.TABBY, eg.Color.BLACK)]]>"
#~ msgstr ""
#~ "select cat.color, sum(cat.weight), count(cat)\n"
#~ "from Cat cat\n"
#~ "group by cat.color\n"
#~ "having cat.color in (eg.Color.TABBY, eg.Color.BLACK)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat\n"
#~ "from Cat cat\n"
#~ "    join cat.kittens kitten\n"
#~ "group by cat.id, cat.name, cat.other, cat.properties\n"
#~ "having avg(kitten.weight) > 100\n"
#~ "order by count(kitten) asc, sum(kitten.weight) desc]]>"
#~ msgstr ""
#~ "select cat\n"
#~ "from Cat cat\n"
#~ "    join cat.kittens kitten\n"
#~ "group by cat.id, cat.name, cat.other, cat.properties\n"
#~ "having avg(kitten.weight) &gt; 100\n"
#~ "order by count(kitten) asc, sum(kitten.weight) desc"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as fatcat\n"
#~ "where fatcat.weight > (\n"
#~ "    select avg(cat.weight) from DomesticCat cat\n"
#~ ")]]>"
#~ msgstr ""
#~ "from Cat as fatcat\n"
#~ "where fatcat.weight &gt; (\n"
#~ "    select avg(cat.weight) from DomesticCat cat\n"
#~ ")"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from DomesticCat as cat\n"
#~ "where cat.name = some (\n"
#~ "    select name.nickName from Name as name\n"
#~ ")]]>"
#~ msgstr ""
#~ "from DomesticCat as cat\n"
#~ "where cat.name = some (\n"
#~ "    select name.nickName from Name as name\n"
#~ ")"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "where not exists (\n"
#~ "    from Cat as mate where mate.mate = cat\n"
#~ ")]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "where not exists (\n"
#~ "    from Cat as mate where mate.mate = cat\n"
#~ ")"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from DomesticCat as cat\n"
#~ "where cat.name not in (\n"
#~ "    select name.nickName from Name as name\n"
#~ ")]]>"
#~ msgstr ""
#~ "from DomesticCat as cat\n"
#~ "where cat.name not in (\n"
#~ "    select name.nickName from Name as name\n"
#~ ")"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select cat.id, (select max(kit.weight) from cat.kitten kit)\n"
#~ "from Cat as cat]]>"
#~ msgstr ""
#~ "select cat.id, (select max(kit.weight) from cat.kitten kit)\n"
#~ "from Cat as cat"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select order.id, sum(price.amount), count(item)\n"
#~ "from Order as order\n"
#~ "    join order.lineItems as item\n"
#~ "    join item.product as product,\n"
#~ "    Catalog as catalog\n"
#~ "    join catalog.prices as price\n"
#~ "where order.paid = false\n"
#~ "    and order.customer = :customer\n"
#~ "    and price.product = product\n"
#~ "    and catalog.effectiveDate < sysdate\n"
#~ "    and catalog.effectiveDate >= all (\n"
#~ "        select cat.effectiveDate\n"
#~ "        from Catalog as cat\n"
#~ "        where cat.effectiveDate < sysdate\n"
#~ "    )\n"
#~ "group by order\n"
#~ "having sum(price.amount) > :minAmount\n"
#~ "order by sum(price.amount) desc]]>"
#~ msgstr ""
#~ "select order.id, sum(price.amount), count(item)\n"
#~ "from Order as order\n"
#~ "    join order.lineItems as item\n"
#~ "    join item.product as product,\n"
#~ "    Catalog as catalog\n"
#~ "    join catalog.prices as price\n"
#~ "where order.paid = false\n"
#~ "    and order.customer = :customer\n"
#~ "    and price.product = product\n"
#~ "    and catalog.effectiveDate &lt; sysdate\n"
#~ "    and catalog.effectiveDate &gt;= all (\n"
#~ "        select cat.effectiveDate\n"
#~ "        from Catalog as cat\n"
#~ "        where cat.effectiveDate &lt; sysdate\n"
#~ "    )\n"
#~ "group by order\n"
#~ "having sum(price.amount) &gt; :minAmount\n"
#~ "order by sum(price.amount) desc"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select order.id, sum(price.amount), count(item)\n"
#~ "from Order as order\n"
#~ "    join order.lineItems as item\n"
#~ "    join item.product as product,\n"
#~ "    Catalog as catalog\n"
#~ "    join catalog.prices as price\n"
#~ "where order.paid = false\n"
#~ "    and order.customer = :customer\n"
#~ "    and price.product = product\n"
#~ "    and catalog = :currentCatalog\n"
#~ "group by order\n"
#~ "having sum(price.amount) > :minAmount\n"
#~ "order by sum(price.amount) desc]]>"
#~ msgstr ""
#~ "select order.id, sum(price.amount), count(item)\n"
#~ "from Order as order\n"
#~ "    join order.lineItems as item\n"
#~ "    join item.product as product,\n"
#~ "    Catalog as catalog\n"
#~ "    join catalog.prices as price\n"
#~ "where order.paid = false\n"
#~ "    and order.customer = :customer\n"
#~ "    and price.product = product\n"
#~ "    and catalog = :currentCatalog\n"
#~ "group by order\n"
#~ "having sum(price.amount) &gt; :minAmount\n"
#~ "order by sum(price.amount) desc"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select count(payment), status.name\n"
#~ "from Payment as payment\n"
#~ "    join payment.currentStatus as status\n"
#~ "    join payment.statusChanges as statusChange\n"
#~ "where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"
#~ "    or (\n"
#~ "        statusChange.timeStamp = (\n"
#~ "            select max(change.timeStamp)\n"
#~ "            from PaymentStatusChange change\n"
#~ "            where change.payment = payment\n"
#~ "        )\n"
#~ "        and statusChange.user <> :currentUser\n"
#~ "    )\n"
#~ "group by status.name, status.sortOrder\n"
#~ "order by status.sortOrder]]>"
#~ msgstr ""
#~ "select count(payment), status.name\n"
#~ "from Payment as payment\n"
#~ "    join payment.currentStatus as status\n"
#~ "    join payment.statusChanges as statusChange\n"
#~ "where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL\n"
#~ "    or (\n"
#~ "        statusChange.timeStamp = (\n"
#~ "            select max(change.timeStamp)\n"
#~ "            from PaymentStatusChange change\n"
#~ "            where change.payment = payment\n"
#~ "        )\n"
#~ "        and statusChange.user &lt;&gt; :currentUser\n"
#~ "    )\n"
#~ "group by status.name, status.sortOrder\n"
#~ "order by status.sortOrder"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select count(payment), status.name\n"
#~ "from Payment as payment\n"
#~ "    join payment.currentStatus as status\n"
#~ "where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"
#~ "    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user <> :"
#~ "currentUser\n"
#~ "group by status.name, status.sortOrder\n"
#~ "order by status.sortOrder]]>"
#~ msgstr ""
#~ "select count(payment), status.name\n"
#~ "from Payment as payment\n"
#~ "    join payment.currentStatus as status\n"
#~ "where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL\n"
#~ "    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;"
#~ "&gt; :currentUser\n"
#~ "group by status.name, status.sortOrder\n"
#~ "order by status.sortOrder"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select account, payment\n"
#~ "from Account as account\n"
#~ "    left outer join account.payments as payment\n"
#~ "where :currentUser in elements(account.holder.users)\n"
#~ "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, "
#~ "PaymentStatus.UNPAID)\n"
#~ "order by account.type.sortOrder, account.accountNumber, payment.dueDate]]>"
#~ msgstr ""
#~ "select account, payment\n"
#~ "from Account as account\n"
#~ "    left outer join account.payments as payment\n"
#~ "where :currentUser in elements(account.holder.users)\n"
#~ "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, "
#~ "PaymentStatus.UNPAID)\n"
#~ "order by account.type.sortOrder, account.accountNumber, payment.dueDate"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select account, payment\n"
#~ "from Account as account\n"
#~ "    join account.holder.users as user\n"
#~ "    left outer join account.payments as payment\n"
#~ "where :currentUser = user\n"
#~ "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, "
#~ "PaymentStatus.UNPAID)\n"
#~ "order by account.type.sortOrder, account.accountNumber, payment.dueDate]]>"
#~ msgstr ""
#~ "select account, payment\n"
#~ "from Account as account\n"
#~ "    join account.holder.users as user\n"
#~ "    left outer join account.payments as payment\n"
#~ "where :currentUser = user\n"
#~ "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, "
#~ "PaymentStatus.UNPAID)\n"
#~ "order by account.type.sortOrder, account.accountNumber, payment.dueDate"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[( (Integer) session.createQuery(\"select count(*) from ....\")."
#~ "iterate().next() ).intValue()]]>"
#~ msgstr ""
#~ "( (Integer) session.iterate(\"select count(*) from ....\").next() )."
#~ "intValue()"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select usr.id, usr.name\n"
#~ "from User as usr\n"
#~ "    left join usr.messages as msg\n"
#~ "group by usr.id, usr.name\n"
#~ "order by count(msg)]]>"
#~ msgstr ""
#~ "select usr.id, usr.name\n"
#~ "from User as usr\n"
#~ "    left join usr.messages as msg\n"
#~ "group by usr.id, usr.name\n"
#~ "order by count(msg)"

#, fuzzy
#~ msgid "<![CDATA[from User usr where size(usr.messages) >= 1]]>"
#~ msgstr "from User usr where size(usr.messages) &gt;= 1"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select usr.id, usr.name\n"
#~ "from User usr.name\n"
#~ "    join usr.messages msg\n"
#~ "group by usr.id, usr.name\n"
#~ "having count(msg) >= 1]]>"
#~ msgstr ""
#~ "select usr.id, usr.name\n"
#~ "from User usr.name\n"
#~ "    join usr.messages msg\n"
#~ "group by usr.id, usr.name\n"
#~ "having count(msg) &gt;= 1"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[select usr.id, usr.name\n"
#~ "from User as usr\n"
#~ "    left join usr.messages as msg\n"
#~ "group by usr.id, usr.name\n"
#~ "having count(msg) = 0]]>"
#~ msgstr ""
#~ "select usr.id, usr.name\n"
#~ "from User as usr\n"
#~ "    left join usr.messages as msg\n"
#~ "group by usr.id, usr.name\n"
#~ "having count(msg) = 0"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Query q = s.createQuery(\"from foo Foo as foo where foo.name=:"
#~ "name and foo.size=:size\");\n"
#~ "q.setProperties(fooBean); // fooBean has getName() and getSize()\n"
#~ "List foos = q.list();]]>"
#~ msgstr ""
#~ "Query q = s.createQuery(\"from foo Foo as foo where foo.name=:name and "
#~ "foo.size=:size\");\n"
#~ "q.setProperties(fooBean); // fooBean has getName() and getSize()\n"
#~ "List foos = q.list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Query q = s.createFilter( collection, \"\" ); // the trivial "
#~ "filter\n"
#~ "q.setMaxResults(PAGE_SIZE);\n"
#~ "q.setFirstResult(PAGE_SIZE * pageNumber);\n"
#~ "List page = q.list();]]>"
#~ msgstr ""
#~ "Query q = s.createFilter( collection, \"\" ); // the trivial filter\n"
#~ "q.setMaxResults(PAGE_SIZE);\n"
#~ "q.setFirstResult(PAGE_SIZE * pageNumber);\n"
#~ "List page = q.list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Collection orderedCollection = s.filter( collection, \"order by "
#~ "this.amount\" );\n"
#~ "Collection counts = s.filter( collection, \"select this.type, count(this) "
#~ "group by this.type\" );]]>"
#~ msgstr ""
#~ "Collection orderedCollection = s.filter( collection, \"order by this."
#~ "amount\" );\n"
#~ "Collection counts = s.filter( collection, \"select this.type, count(this) "
#~ "group by this.type\" );"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[( (Integer) session.createQuery(\"select count(*) from ....\")."
#~ "iterate().next() ).intValue();]]>"
#~ msgstr ""
#~ "( (Integer) session.iterate(\"select count(*) from ....\").next() )."
#~ "intValue();"

#, fuzzy
#~ msgid "<![CDATA[select p.name from Person p]]>"
#~ msgstr "select p.name from from Person p"

#, fuzzy
#~ msgid "<![CDATA[select p.name.first from Person p]]>"
#~ msgstr "select p.name.first from from Person p"

#, fuzzy
#~ msgid "<![CDATA[from Person p where p.name = :name]]>"
#~ msgstr "from from Person p where p.name = :name"

#, fuzzy
#~ msgid "<![CDATA[from Person p where p.name.first = :firstName]]>"
#~ msgstr "from from Person p where p.name.first = :firstName"

#, fuzzy
#~ msgid "<![CDATA[from Person p order by p.name]]>"
#~ msgstr "from from Person p order by p.name"

#, fuzzy
#~ msgid "<![CDATA[from Person p order by p.name.first]]>"
#~ msgstr "from from Person p order by p.name.first"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Person p where p.name.first='John' and p.name."
#~ "last='Jingleheimer-Schmidt']]>"
#~ msgstr ""
#~ "from Person p where p.name.first='John' and p.name.last='Jingleheimer-"
#~ "Schmidt'"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Person p where p.name=('John', 'Jingleheimer-Schmidt')]]>"
#~ msgstr "from Person p where p.name=('John', 'Jingleheimer-Schmidt')"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[from Cat as cat\n"
#~ "where not ( cat.name, cat.color ) in (\n"
#~ "    select cat.name, cat.color from DomesticCat cat\n"
#~ ")]]>"
#~ msgstr ""
#~ "from Cat as cat\n"
#~ "where not ( cat.name, cat.color ) in (\n"
#~ "    select cat.name, cat.color from DomesticCat cat\n"
#~ ")"
