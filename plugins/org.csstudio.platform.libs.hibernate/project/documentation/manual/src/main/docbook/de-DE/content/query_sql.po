# translation of Collection_Mapping.po to 
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# Language /mnt/hgfs/base/Hibernate/Reference translations for PACKAGE package.
# Copyright (C) 2006, 2007 Free Software Foundation, Inc.
# Automatically generated, 2006.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
# , 2007.
#
msgid ""
msgstr ""
"Project-Id-Version: Collection_Mapping\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:15\n"
"PO-Revision-Date: 2007-02-26 10:27+1000\n"
"Last-Translator: \n"
"Language-Team:  <de@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.9.1\n"

#. Tag: title
#, no-c-format
msgid "Native SQL"
msgstr "Native SQL"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can also express queries in the native SQL dialect of your database. "
"This is useful if you want to utilize database-specific features such as "
"query hints or the <literal>CONNECT</literal> keyword in Oracle. It also "
"provides a clean migration path from a direct SQL/JDBC based application to "
"Hibernate."
msgstr ""
"Sie können Anfragen im nativen SQL-Dialekt Ihrer Datenbank ausdrücken. Das "
"ist insbesondere dann von Nutzen, wenn Sie Datenbank-spezifische Features "
"wie Anfragetipps oder den <literal>CONNECT</literal>-Schlüsselbegriff in "
"Oracle verwenden wollen. Außerdem steht dadurch ein Migrationspfad von einer "
"direkten, auf SQL/JDBC basierenden Anwendung zu Hibernate zur Verfügung."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate3 allows you to specify handwritten SQL, including stored "
"procedures, for all create, update, delete, and load operations."
msgstr ""
"Mit Hibernate3 können Sie per Hand geschriebene SQL (einschließlich "
"gespeicherter Prozeduren) für alle create, update, delete, und load Vorgänge "
"festlegen."

#. Tag: title
#, fuzzy, no-c-format
msgid "Using a <literal>SQLQuery</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Execution of native SQL queries is controlled via the <literal>SQLQuery</"
"literal> interface, which is obtained by calling <literal>Session."
"createSQLQuery()</literal>. The following sections describe how to use this "
"API for querying."
msgstr ""
"Die Ausführung nativer SQL-Anfragen wird mittels <literal>SQLQuery</literal>-"
"Interface gesteuert, das man durch Aufruf von <literal>Session.createSQLQuery"
"()</literal> erhält. Nachfolgend erläutern wir die Verwendung dieser API für "
"Anfragen."

#. Tag: title
#, no-c-format
msgid "Scalar queries"
msgstr "Skalare Anfragen"

#. Tag: para
#, no-c-format
msgid "The most basic SQL query is to get a list of scalars (values)."
msgstr ""
"Die grundlegendste SQL-Anfrage erfolgt durch eine Liste von Skalaren "
"(Werten)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"These will return a List of Object arrays (Object[]) with scalar values for "
"each column in the CATS table. Hibernate will use ResultSetMetadata to "
"deduce the actual order and types of the returned scalar values."
msgstr ""
"Beides reagiert mit einer Liste von Objekt-Datenelementen (Object[]) mit "
"skalaren Werten für jede Spalte der CATS-Tabelle. Hibernate wird unter "
"Verwendung von ResultSetMetadata die tatsächliche Anordnung und Typen der "
"erhaltenen Skalarwerte ableiten."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"To avoid the overhead of using <literal>ResultSetMetadata</literal>, or "
"simply to be more explicit in what is returned, one can use "
"<literal>addScalar()</literal>:"
msgstr ""
"Um den Zusatz der Verwendung von <literal>ResultSetMetadata</literal> zu "
"vermeiden oder einfach expliziter zu sein, können Sie <literal>addScalar()</"
"literal> verwenden."

#. Tag: para
#, no-c-format
msgid "This query specified:"
msgstr "Diese Anfrage spezifiziert:"

#. Tag: para
#, no-c-format
msgid "the SQL query string"
msgstr "den SQL-Anfragen-String"

#. Tag: para
#, no-c-format
msgid "the columns and types to return"
msgstr "die wiederzugebenden Spalten und Typen"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This will return Object arrays, but now it will not use "
"<literal>ResultSetMetadata</literal> but will instead explicitly get the ID, "
"NAME and BIRTHDATE column as respectively a Long, String and a Short from "
"the underlying resultset. This also means that only these three columns will "
"be returned, even though the query is using <literal>*</literal> and could "
"return more than the three listed columns."
msgstr ""
"Dadurch werden Objektreihen wiedergegeben, jedoch werden keine "
"<literal>ResultSetMetdata</literal> verwendet, sondern es wird explizit die "
"ID, NAME und BIRTHDATE Spalte als ein Long, String und ein Short vom zu "
"Grunde liegenden Ergebnissatz (\"result set\") geholt. Das bedeutet auch, "
"dass nur diese drei Spalten wiedergegeben werden, selbst wenn die Anfrage "
"<literal>*</literal> verwendet und mehr als die drei gelisteten Spalten "
"wiedergeben könnte."

#. Tag: para
#, no-c-format
msgid ""
"It is possible to leave out the type information for all or some of the "
"scalars."
msgstr ""
"Es ist möglich, die Typeninformationen für alle oder einige der Skalare "
"auszulassen."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This is essentially the same query as before, but now "
"<literal>ResultSetMetaData</literal> is used to determine the type of NAME "
"and BIRTHDATE, where as the type of ID is explicitly specified."
msgstr ""
"Es handelt sich im Wesentlichen um diesselbe Anfrage wie zuvor, außer dass "
"jetzt <literal>ResultSetMetaData</literal> verwendet wurde, um den Typ von "
"NAME und BIRTHDATE zu bestimmen, während der ID-Typ explizit spezifiziert "
"wird."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"How the java.sql.Types returned from ResultSetMetaData is mapped to "
"Hibernate types is controlled by the Dialect. If a specific type is not "
"mapped, or does not result in the expected type, it is possible to customize "
"it via calls to <literal>registerHibernateType</literal> in the Dialect."
msgstr ""
"Der Dialekt steuert, wie die java.sql.Typen, die von ResultSetMetaData "
"erhalten werden, zu Hibernate Typen gemappt werden. Falls ein bestimmter Typ "
"nicht gemappt ist oder nicht den erwarteten Typ hervorbringt, so ist es "
"möglich, dies durch Anpassung an <literal>registerHibernateType</literal> im "
"Dialekt anzupassen."

#. Tag: title
#, no-c-format
msgid "Entity queries"
msgstr "Entity-Anfragen"

#. Tag: para
#, no-c-format
msgid ""
"The above queries were all about returning scalar values, basically "
"returning the \"raw\" values from the resultset. The following shows how to "
"get entity objects from a native sql query via <literal>addEntity()</"
"literal>."
msgstr ""
"Die Anfragen oben behandeln die erhaltenen Skalarwerte, wobei es sich dabei "
"um die \"unbearbeiteten\" Werte von resultset handelt. Nachfolgend sehen "
"Sie, wie Sie Entity-Objekte von einer nativen SQL-Anfrage mittels "
"<literal>addEntity()</literal> erhalten."

#. Tag: para
#, no-c-format
msgid "the entity returned by the query"
msgstr "die von der Anfrage wiedergegebene Entity"

#. Tag: para
#, no-c-format
msgid ""
"Assuming that Cat is mapped as a class with the columns ID, NAME and "
"BIRTHDATE the above queries will both return a List where each element is a "
"Cat entity."
msgstr ""
"Geht man davon aus, dass Cat als Klasse mit den Spalten ID, NAME und "
"BIRTHDATE gemappt ist, werden die Anfragen oben beide mit einer Liste "
"antworten, in der jedes Element eine Entity von Cat ist."

#. Tag: para
#, no-c-format
msgid ""
"If the entity is mapped with a <literal>many-to-one</literal> to another "
"entity it is required to also return this when performing the native query, "
"otherwise a database specific \"column not found\" error will occur. The "
"additional columns will automatically be returned when using the * notation, "
"but we prefer to be explicit as in the following example for a <literal>many-"
"to-one</literal> to a <literal>Dog</literal>:"
msgstr ""
"Falls die Entity mit <literal>many-to-one</literal> zu einer anderen Entity "
"gemappt ist, so ist dies ebenfalls erforderlich wenn die native Anfrage "
"durchgeführt wird, da sonst eine Datenbank-spezifische \"Spalte nicht "
"gefunden\"-Fehlermeldung (\"column not found\") erscheint. Die zusätzlichen "
"Spalten werden bei Verwendung der * Notation automatisch wiedergegeben, aber "
"wie im folgenden Beispiel für eine <literal>many-to-one</literal> zu "
"<literal>Dog</literal> wollen wir lieber explizit sein:"

#. Tag: para
#, no-c-format
msgid "This will allow cat.getDog() to function properly."
msgstr "Dies ermöglicht die ordnungsgemäße Funktion von cat.getDog()."

#. Tag: title
#, no-c-format
msgid "Handling associations and collections"
msgstr "Umgang mit Assoziationen und Collections"

#. Tag: para
#, no-c-format
msgid ""
"It is possible to eagerly join in the <literal>Dog</literal> to avoid the "
"possible extra roundtrip for initializing the proxy. This is done via the "
"<literal>addJoin()</literal> method, which allows you to join in an "
"association or collection."
msgstr ""
"Es ist möglich \"eager Join\" in <literal>Dog</literal> anzuwenden, um den "
"Extra-Weg zur Datenbank zur Initialisierung des Proxy zu vermeiden. Dies "
"geschieht mittels der <literal>addJoin()</literal>-Methode, die es Ihnen "
"ermöglicht, eine Assoziation oder Collection zu verbinden."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"In this example, the returned <literal>Cat</literal>'s will have their "
"<literal>dog</literal> property fully initialized without any extra "
"roundtrip to the database. Notice that you added an alias name (\"cat\") to "
"be able to specify the target property path of the join. It is possible to "
"do the same eager joining for collections, e.g. if the <literal>Cat</"
"literal> had a one-to-many to <literal>Dog</literal> instead."
msgstr ""
"In diesem Beispiel ist die <literal>dog</literal>-Property der "
"wiedergegebenen <literal>Cat</literal>'s voll initialisiert, ohne dass ein "
"Extra-Weg zur Datenbank nötig ist. Beachten Sie, dass wir einen Alias-Namen "
"(\"cat\") hinzugefügt haben, um den Pfad der Ziel-Property der Verbindung "
"spezifizieren zu können. Es ist möglich, dasselbe für das \"eager Joining\" "
"von Collections zu tun, z.B. wenn  <literal>Cat</literal> satt dessen eine "
"\"One-to-many\" zu <literal>Dog</literal> hätte."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"At this stage you are reaching the limits of what is possible with native "
"queries, without starting to enhance the sql queries to make them usable in "
"Hibernate. Problems can arise when returning multiple entities of the same "
"type or when the default alias/column names are not enough."
msgstr ""
"Wir erreichen nun den Punkt, an dem wir an die Grenzen dessen stoßen, was "
"mit nativen Anfragen möglich ist, ohne die sql-Anfragen weiterzuentwickeln, "
"um sie in Hibernate verwendbar zu machen. Das Problem zeigt sich erstmals, "
"wenn mehrere Entities desselben Typs auftauchen oder wenn die Standard "
"Alias-/Spaltennamen nicht ausreichen."

#. Tag: title
#, no-c-format
msgid "Returning multiple entities"
msgstr "Wiedergabe mehrerer Entities"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Until now, the result set column names are assumed to be the same as the "
"column names specified in the mapping document. This can be problematic for "
"SQL queries that join multiple tables, since the same column names can "
"appear in more than one table."
msgstr ""
"Bis jetzt wird angenommen, dass die Spaltennamen des Ergebnissatzes "
"dieselben wie die im Mapping-Dokument spezifizierten Spaltennamen sind. Dies "
"kann problematisch für SQL-Anfragen sein, die mehrere Tabellen verbinden, da "
"dieselben Spaltennamen stets in mehr als einer Tabelle vorkommen."

#. Tag: para
#, no-c-format
msgid ""
"Column alias injection is needed in the following query (which most likely "
"will fail):"
msgstr ""
"Spalten Alias-Einspeisung wird bei der folgenden Anfrage benötigt (die aller "
"Wahrscheinlichkeit nach fehlschlagen wird):"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The query was intended to return two Cat instances per row: a cat and its "
"mother. The query will, however, fail because there is a conflict of names; "
"the instances are mapped to the same column names. Also, on some databases "
"the returned column aliases will most likely be on the form \"c.ID\", \"c."
"NAME\", etc. which are not equal to the columns specified in the mappings "
"(\"ID\" and \"NAME\")."
msgstr ""
"Die Absicht dieser Anfrage ist es, das diese zwei Cat-Instanzen pro Reihe "
"wiedergibt, einer \"Cat\" und deren \"Mother\". Dies wird fehlschlagen, da "
"ein Namenskonflikt existiert, weil diese zu denselben Spaltennamen gemappt "
"sind; in manchen Datenbanken haben die wiedergegebenen Spalten-Aliasse aller "
"Wahrscheinlichkeit nach die Form \"c.ID\", \"c.NAME\", usw. die nicht "
"dieselbe wie die in den Mappings (\"ID\" und \"NAME\") spezifizierten "
"Spalten besitzt."

#. Tag: para
#, no-c-format
msgid "The following form is not vulnerable to column name duplication:"
msgstr ""
"Die folgende Form ist nicht anfällig für die Duplizierung von Spaltennamen:"

#. Tag: para
#, no-c-format
msgid ""
"the SQL query string, with placeholders for Hibernate to inject column "
"aliases"
msgstr ""
"der SQL Anfragen-String mit Platzhaltern für die durch Hibernate "
"eingespeisten Aliasse"

#. Tag: para
#, no-c-format
msgid "the entities returned by the query"
msgstr "die von der Anfrage erhaltenen Entities"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The {cat.*} and {mother.*} notation used above is a shorthand for \"all "
"properties\". Alternatively, you can list the columns explicitly, but even "
"in this case Hibernate injects the SQL column aliases for each property. The "
"placeholder for a column alias is just the property name qualified by the "
"table alias. In the following example, you retrieve Cats and their mothers "
"from a different table (cat_log) to the one declared in the mapping "
"metadata. You can even use the property aliases in the where clause."
msgstr ""
"Die oben verwendete {cat.*} und {mother.*} Notation ist eine Kurzschrift für "
"\"alle Properties\". Alternativ können Sie die Spalten direkt auflisten, "
"wobei wir aber selbst in diesem Fall Hibernate die SQL Spalten-Aliasse für "
"jede Property einspeisen lassen. Der Platzhalter für einen Spalten-Alias ist "
"einfach der durch den Tabellen-Alias definierte Property-Name. Im folgenden "
"Beispiel erhalten wir \"Cats\" und deren \"Mothers\" von einer anderen "
"Tabelle (cat_log) als der in den Mapping-Metadata deklarierten. Beachten "
"Sie, dass wir sogar die Property-Aliasse in der \"where\"-Klausel verwenden "
"können, wenn wir das möchten."

#. Tag: title
#, no-c-format
msgid "Alias and property references"
msgstr "Alias- und Property-Referenzen"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"In most cases the above alias injection is needed. For queries relating to "
"more complex mappings, like composite properties, inheritance "
"discriminators, collections etc., you can use specific aliases that allow "
"Hibernate to inject the proper aliases."
msgstr ""
"In den meisten Fällen wird die obige Alias-Einspeisung benötigt, jedoch "
"müssen für komplexere Mappings betreffende Anfragen wie zusammengesetzte "
"Properties, Vererbungsdiskriminatoren, Collections usw. spezielle Aliasse "
"verwendet werden, die es Hibernate erlauben, die korrekten Aliasse "
"einzuspeisen."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The following table shows the different ways you can use the alias "
"injection. Please note that the alias names in the result are simply "
"examples; each alias will have a unique and probably different name when "
"used."
msgstr ""
"Die folgende Tabelle zeigt die verschiedenen Möglichkeiten wie die Alias-"
"Einspeisung verwendet werden kann. Hinweis: Die Alias-Namen im Ergebnis sind "
"Beispiele, jeder Alias wird bei seiner Anwendung einen eindeutigen und "
"wahrscheinlich unterschiedlichen Namen besitzen."

#. Tag: title
#, no-c-format
msgid "Alias injection names"
msgstr "Alias-Einspeisungsnamen"

#. Tag: entry
#, no-c-format
msgid "Description"
msgstr "Beschreibung"

#. Tag: entry
#, no-c-format
msgid "Syntax"
msgstr "Syntax"

#. Tag: entry
#, no-c-format
msgid "Example"
msgstr "Beispiel"

#. Tag: entry
#, no-c-format
msgid "A simple property"
msgstr "Eine einfache Property"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>{[aliasname].[propertyname]</literal>"
msgstr "{[aliasname].[propertyname]"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>A_NAME as {item.name}</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: entry
#, no-c-format
msgid "A composite property"
msgstr "Eine zusammengesetzte Property"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>{[aliasname].[componentname].[propertyname]}</literal>"
msgstr "{[aliasname].[componentname].[propertyname]}"

#. Tag: entry
#, fuzzy, no-c-format
msgid ""
"<literal>CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}</"
"literal>"
msgstr "CURRENCY als {item.amount.currency}, VALUE als {item.amount.value}"

#. Tag: entry
#, no-c-format
msgid "Discriminator of an entity"
msgstr "Diskriminator einer Entity"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>{[aliasname].class}</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>DISC as {item.class}</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: entry
#, no-c-format
msgid "All properties of an entity"
msgstr "Alle Properties einer Entity"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>{[aliasname].*}</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>{item.*}</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: entry
#, no-c-format
msgid "A collection key"
msgstr "Ein Collection-Schlüssel"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>{[aliasname].key}</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>ORGID as {coll.key}</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: entry
#, no-c-format
msgid "The id of an collection"
msgstr "Die id einer Collection"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>{[aliasname].id}</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>EMPID as {coll.id}</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: entry
#, no-c-format
msgid "The element of an collection"
msgstr "Das Element einer Collection"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>{[aliasname].element}</literal>"
msgstr "{coll.element.*}"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>XID as {coll.element}</literal>"
msgstr "{coll.element.*}"

#. Tag: entry
#, fuzzy, no-c-format
msgid "property of the element in the collection"
msgstr "Property des Elements in der Collection"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>{[aliasname].element.[propertyname]}</literal>"
msgstr "{[aliasname].element.[propertyname]}"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>NAME as {coll.element.name}</literal>"
msgstr "{coll.element.*}"

#. Tag: entry
#, no-c-format
msgid "All properties of the element in the collection"
msgstr "Alle Properties des Elements in der Collection"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>{[aliasname].element.*}</literal>"
msgstr "{coll.element.*}"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>{coll.element.*}</literal>"
msgstr "{coll.element.*}"

#. Tag: entry
#, fuzzy, no-c-format
msgid "All properties of the the collection"
msgstr "Alle Properties der Collection"

#. Tag: entry
#, fuzzy, no-c-format
msgid "<literal>{coll.*}</literal>"
msgstr "oder als eine <literal>List</literal>,"

#. Tag: title
#, no-c-format
msgid "Returning non-managed entities"
msgstr "Wiedergabe nicht gemanagter Entities"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It is possible to apply a ResultTransformer to native SQL queries, allowing "
"it to return non-managed entities."
msgstr ""
"Es ist möglich, einen ResultTransformer (Ergebnistransformer) an nativen SQL-"
"Anfragen anzuwenden, der die Wiedergabe nicht gemanagter Entities ermöglicht."

#. Tag: para
#, no-c-format
msgid "a result transformer"
msgstr "ein Ergebnistransformer"

#. Tag: para
#, no-c-format
msgid ""
"The above query will return a list of <literal>CatDTO</literal> which has "
"been instantiated and injected the values of NAME and BIRTHNAME into its "
"corresponding properties or fields."
msgstr ""
"Die Anfrage oben wird eine Liste von <literal>CatDTO</literal> wiedergeben, "
"die instantiiert wurde und die Werte für NAME und BIRTHNAME in die "
"entsprechenden Properties oder Felder eingespeist hat."

#. Tag: title
#, no-c-format
msgid "Handling inheritance"
msgstr "Umgang mit Vererbung"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Native SQL queries which query for entities that are mapped as part of an "
"inheritance must include all properties for the baseclass and all its "
"subclasses."
msgstr ""
"Native SQL-Anfragen für Entities, die als Teil einer Vererbung gemappt sind, "
"müssen sämtliche Properties für die Stammklasse und alle Subklassen "
"enthalten."

#. Tag: title
#, no-c-format
msgid "Parameters"
msgstr "Parameter"

#. Tag: para
#, fuzzy, no-c-format
msgid "Native SQL queries support positional as well as named parameters:"
msgstr ""
"Native SQL-Anfragen unterstützen sowohl positionelle als auch benannte "
"Parameter:"

#. Tag: title
#, no-c-format
msgid "Named SQL queries"
msgstr "Benannte SQL-Anfragen"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Named SQL queries can be defined in the mapping document and called in "
"exactly the same way as a named HQL query. In this case, you do "
"<emphasis>not</emphasis> need to call <literal>addEntity()</literal>."
msgstr ""
"Benannte SQL-Anfragen können im Mapping-Dokument definiert und auf dieselbe "
"Weise wie eine benannte HQL-Anfrage benannt werden. In diesem Fall muss "
"<emphasis>nicht</emphasis> der Aufruf <literal>addEntity()</literal> "
"erfolgen."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;return-join&gt;</literal> element is use to join "
"associations and the <literal>&lt;load-collection&gt;</literal> element is "
"used to define queries which initialize collections,"
msgstr ""
"Die <literal>&lt;return-join&gt;</literal> und <literal>&lt;load-"
"collection&gt;</literal>-Elemente werden verwendet, um Assoziationen zu "
"verbinden bzw. Anfragen, die Collections definieren, zu initialisieren."

#. Tag: para
#, no-c-format
msgid ""
"A named SQL query may return a scalar value. You must declare the column "
"alias and Hibernate type using the <literal>&lt;return-scalar&gt;</literal> "
"element:"
msgstr ""
"Eine benannte SQL-Anfrage kann einen Skalarwert wiedergeben. Sie müssen "
"unter Verwendung des <literal>&lt;return-scalar&gt;</literal>-Elements den "
"Spalten-Alias und den Hibernate-Typ deklarieren:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can externalize the resultset mapping information in a <literal>&lt;"
"resultset&gt;</literal> element which will allow you to either reuse them "
"across several named queries or through the <literal>setResultSetMapping()</"
"literal> API."
msgstr ""
"Sie können die Mapping-Informationen des Ergebnissatzes (\"resultset\") in "
"einem <literal>&lt;resultset&gt;</literal>-Element externalisieren, um diese "
"entweder über mehrere benannte Anfragen hinweg oder durch die "
"<literal>setResultSetMapping()</literal>-API wiederzuverwenden."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can, alternatively, use the resultset mapping information in your hbm "
"files directly in java code."
msgstr ""
"Alternativ können Sie Mapping-Informationen des Ergebnissatzes in Ihren hbm-"
"Dateien direkt in Java Code verwenden."

#. Tag: title
#, no-c-format
msgid "Using return-property to explicitly specify column/alias names"
msgstr ""
"Die Verwendung der Return-Property zur expliziten Spezifizierung von "
"Spalten-/Aliasnamen"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can explicitly tell Hibernate what column aliases to use with "
"<literal>&lt;return-property&gt;</literal>, instead of using the <literal>{}"
"</literal>-syntax to let Hibernate inject its own aliases.For example:"
msgstr ""
"Mit <literal>&lt;return-property&gt;</literal> können Sie Hibernate explizit "
"anweisen, welche Aliasse es verwenden soll, statt die <literal>{}</literal>-"
"Syntax zu verwenden, bei der Hibernate seine eigenen Aliasse einspeist."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"<literal>&lt;return-property&gt;</literal> also works with multiple columns. "
"This solves a limitation with the <literal>{}</literal>-syntax which cannot "
"allow fine grained control of multi-column properties."
msgstr ""
"<literal>&lt;return-property&gt;</literal> funktioniert auch mit mehreren "
"Spalten. Dies löst die Einschränkungen der <literal>{}</literal>-Syntax, die "
"keine feinstufige Steuerung mehrspaltiger Properties erlaubt."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"In this example <literal>&lt;return-property&gt;</literal> was used in "
"combination with the <literal>{}</literal>-syntax for injection. This allows "
"users to choose how they want to refer column and properties."
msgstr ""
"Bitte beachten Sie, dass wir in diesem Beispiel <literal>&lt;return-"
"property&gt;</literal> in Verbindung mit der <literal>{}</literal>-Syntax "
"für die Einspeisung verwendet haben. Dadurch ist es Benutzern möglich zu "
"entscheiden, wie auf Spalten und Properties verwiesen werden soll."

#. Tag: para
#, no-c-format
msgid ""
"If your mapping has a discriminator you must use <literal>&lt;return-"
"discriminator&gt;</literal> to specify the discriminator column."
msgstr ""
"Falls Ihr Mapping über einen Diskriminator verfügt, so müssen Sie "
"<literal>&lt;return-discriminator&gt;</literal> verwenden, um die "
"Diskriminator-Spalte festzulegen."

#. Tag: title
#, no-c-format
msgid "Using stored procedures for querying"
msgstr "Die Verwendung gespeicherter Prozeduren für Anfragen"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Hibernate3 provides support for queries via stored procedures and functions. "
"Most of the following documentation is equivalent for both. The stored "
"procedure/function must return a resultset as the first out-parameter to be "
"able to work with Hibernate. An example of such a stored function in Oracle "
"9 and higher is as follows:"
msgstr ""
"Hibernate 3 bietet Support für Anfragen via gespeicherter Prozeduren und "
"Funktionen. Die meisten Teile der nachfolgenden Dokumentation sind für beide "
"gleich. Die gespeicherte Prozedur/Funktion muss einen Ergebnissatz als "
"ersten \"out-Parameter\" wiedergeben, um mit Hibernate arbeiten zu können. "
"Ein Beispiel für eine solche gespeicherte Funktion in Oracle 9 und späteren "
"Versionen lautet wie folgt:"

#. Tag: para
#, no-c-format
msgid "To use this query in Hibernate you need to map it via a named query."
msgstr ""
"Um diese Anfrage in Hibernate zu verwenden, müssen Sie sie durch eine "
"benannte Anfrage mappen."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Stored procedures currently only return scalars and entities. <literal>&lt;"
"return-join&gt;</literal> and <literal>&lt;load-collection&gt;</literal> are "
"not supported."
msgstr ""
"Bitte beachten Sie, dass gespeicherte Prozeduren gegenwärtig nur Skalare und "
"Entities wiedergeben. <literal>&lt;return-join&gt;</literal> und "
"<literal>&lt;load-collection&gt;</literal> werden nicht unterstützt."

#. Tag: title
#, no-c-format
msgid "Rules/limitations for using stored procedures"
msgstr "Regeln/Einschränkungen bei der Verwendung gespeicherter Prozeduren"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You cannot use stored procedures with Hibernate unless you follow some "
"procedure/function rules. If they do not follow those rules they are not "
"usable with Hibernate. If you still want to use these procedures you have to "
"execute them via <literal>session.connection()</literal>. The rules are "
"different for each database, since database vendors have different stored "
"procedure semantics/syntax."
msgstr ""
"Um gespeicherte Prozeduren mit Hibernate zu verwenden, müssen die Prozeduren/"
"Funktionen einigen Regeln folgen. Falls sie diese nicht berücksichtigen, "
"können sie nicht mit Hibernate verwendet werden. Falls Sie diese Prozeduren "
"dennoch benutzen wollen, so müssen Sie sie mittels <literal>session."
"connection()</literal> ausführen. Die Regeln sind für jede Datenbank anders, "
"da Datenbankanbieter jeweils über verschiedene gespeicherte Semantik/Syntax "
"für Prozeduren verfügen."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Stored procedure queries cannot be paged with <literal>setFirstResult()/"
"setMaxResults()</literal>."
msgstr ""
"Gespeicherte Prozeduren können nicht mit <literal>setFirstResult()/"
"setMaxResults()</literal> seitenweise umgespeichert werden."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The recommended call form is standard SQL92: <literal>{ ? = call functionName"
"(&lt;parameters&gt;) }</literal> or <literal>{ ? = call procedureName(&lt;"
"parameters&gt;}</literal>. Native call syntax is not supported."
msgstr ""
"Die empfohlen Form für den Aufruf ist Standard SQL92: <literal>{ ? = call "
"functionName (&lt;parameters&gt;) }</literal> oder <literal>{ ? = call "
"procedureName(&lt;parameters&gt;}</literal>. Native Aufrufsyntax wird nicht "
"unterstützt."

#. Tag: para
#, no-c-format
msgid "For Oracle the following rules apply:"
msgstr "Für Oracle gelten die folgenden Regeln:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"A function must return a result set. The first parameter of a procedure must "
"be an <literal>OUT</literal> that returns a result set. This is done by "
"using a <literal>SYS_REFCURSOR</literal> type in Oracle 9 or 10. In Oracle "
"you need to define a <literal>REF CURSOR</literal> type. See Oracle "
"literature for further information."
msgstr ""
"Eine Funktion muss mit einem Ergebnissatz (\"result set\") reagieren. Der "
"erste Parameter einer Prozedur muss ein <literal>OUT</literal> sein, das "
"einen Satz von Ergenissen liefert. Dies geschieht unter Verwendung eines "
"<literal>SYS_REFCURSOR</literal>-Typs in Oracle 9 oder 10. In Oracle müssen "
"Sie einen <literal>REF CURSOR</literal>-Typ definieren, siehe auch in "
"Literatur zu Oracle."

#. Tag: para
#, no-c-format
msgid "For Sybase or MS SQL server the following rules apply:"
msgstr "Für Sybase oder MS SQL Server gelten die folgenden Regeln:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The procedure must return a result set. Note that since these servers can "
"return multiple result sets and update counts, Hibernate will iterate the "
"results and take the first result that is a result set as its return value. "
"Everything else will be discarded."
msgstr ""
"Eine Prozedur muss mit einem Ergebnissatz (\"result set\") reagieren. Bitte "
"beachten Sie, dass - da diese Server mit mehreren Ergebnissätzen reagieren "
"können/werden und Zählungen aktualisieren - Hibernate die Ergebnisse "
"wiederholt und das erste Ergebnis als Wiedergabewert nimmt, das einen "
"Ergebnissatz darstellt. Alles andere wird verworfen."

#. Tag: para
#, no-c-format
msgid ""
"If you can enable <literal>SET NOCOUNT ON</literal> in your procedure it "
"will probably be more efficient, but this is not a requirement."
msgstr ""
"Falls Sie <literal>SET NOCOUNT ON</literal> in Ihrer Prozedur aktivieren "
"können, so würde sie wahrscheinlich effizienter. Dies ist jedoch keine "
"Voraussetzung."

#. Tag: title
#, no-c-format
msgid "Custom SQL for create, update and delete"
msgstr ""
"Anwenderspezifische SQL für \"create\" (erstellen), \"update"
"\" (aktualisieren) und \"delete\" (löschen)"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate3 can use custom SQL for create, update, and delete operations. The "
"SQL can be overridden at the statement level or inidividual column level. "
"This section describes statement overrides. For columns, see <xref linkend="
"\"mapping-column-read-and-write\" />."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The class and collection persisters in Hibernate already contain a set of "
"configuration time generated strings (insertsql, deletesql, updatesql etc.). "
"The mapping tags <literal>&lt;sql-insert&gt;</literal>, <literal>&lt;sql-"
"delete&gt;</literal>, and <literal>&lt;sql-update&gt;</literal> override "
"these strings:"
msgstr ""
"Hibernate3 kann angepasste SQL-Anweisungen für \"create\", \"update\", und "
"\"delete\" Vorgänge verwenden. Die Klassen- und Collection-Persister in "
"Hibernate enthalten bereits einen Satz von zur Konfigurationszeit "
"generierten Strings (insertsql, deletesql, updatesql usw.). Die Mapping-Tags "
"<literal>&lt;sql-insert&gt;</literal>, <literal>&lt;sql-delete&gt;</literal> "
"und <literal>&lt;sql-update&gt;</literal> setzen diese Strings außer Kraft:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The SQL is directly executed in your database, so you can use any dialect "
"you like. This will reduce the portability of your mapping if you use "
"database specific SQL."
msgstr ""
"Die SQL wird direkt in Ihrer Datenbank ausgeführt, Sie können daher jeden "
"beliebigen Dialekt verwenden. Dies wird natürlich die Übertragbarkeit Ihres "
"Mappings reduzieren, wenn Sie Datenbank-spezifische SQL benutzen."

#. Tag: para
#, no-c-format
msgid ""
"Stored procedures are supported if the <literal>callable</literal> attribute "
"is set:"
msgstr ""
"Gespeicherte Prozeduren werden unterstützt, wenn das <literal>callable</"
"literal>-Attribut wie folgt eingestellt ist:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The order of the positional parameters is vital, as they must be in the same "
"sequence as Hibernate expects them."
msgstr ""
"Die Reihenfolge der positionellen Parameter ist gegenwärtig entscheidend, da "
"sie dieselbe Sequenz besitzen müssen, wie Hibernate sie erwartet."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can view the expected order by enabling debug logging for the "
"<literal>org.hibernate.persister.entity</literal> level. With this level "
"enabled, Hibernate will print out the static SQL that is used to create, "
"update, delete etc. entities. To view the expected sequence, do not include "
"your custom SQL in the mapping files, as this will override the Hibernate "
"generated static SQL."
msgstr ""
"Sie können die erwartete Reihenfolge sehen, indem Sie Debug-Protokollierung "
"für die<literal>org.hibernate.persister.entity</literal>-Ebene aktivieren. "
"Wenn diese Ebene aktiviert ist, druckt Hibernate die statische SQL aus, die "
"zur Erstellung, Aktualisierung, Löschung usw. von Entities verwendet wird. "
"(Um die erwartete Sequenz zu sehen, denken Sie daran, Ihre angepasste SQL "
"nicht in die Mapping-Dateien einzuschließen, da diese die durch Hibernate "
"generierte statische sql außer Kraft setzt)."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The stored procedures are in most cases required to return the number of "
"rows inserted, updated and deleted, as Hibernate has some runtime checks for "
"the success of the statement. Hibernate always registers the first statement "
"parameter as a numeric output parameter for the CUD operations:"
msgstr ""
"Die gespeicherten Prozeduren sind in den meisten Fällen (bzw. fast immer) "
"für die Wiedergabe der Anzahl von eingefügten/aktualisierten/gelöschten "
"Reihen erforderlich, da Hibernate einige Runtime-Überprüfungen hinsichtlich "
"des Erfolgs der Anweisung durchführt. Hibernate registriert immer den ersten "
"Anweisungsparameter als numerischen Ausgabeparameter für die CUD-Vorgänge:"

#. Tag: title
#, no-c-format
msgid "Custom SQL for loading"
msgstr "Angepasste SQL für das Laden"

#. Tag: para
#, no-c-format
msgid ""
"You can also declare your own SQL (or HQL) queries for entity loading. As "
"with inserts, updates, and deletes, this can be done at the individual "
"column level as described in <xref linkend=\"mapping-column-read-and-write"
"\" /> or at the statement level. Here is an example of a statement level "
"override:"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"This is just a named query declaration, as discussed earlier. You can "
"reference this named query in a class mapping:"
msgstr ""
"Hier handelt es sich lediglich um eine Anfragendeklaration, wie zuvor "
"erläutert. Sie können auf diese benannte Anfrage in einem Klassen-Mapping "
"verweisen:"

#. Tag: para
#, no-c-format
msgid "This even works with stored procedures."
msgstr "Das funktioniert sogar mit gespeicherten Prozeduren."

#. Tag: para
#, fuzzy, no-c-format
msgid "You can even define a query for collection loading:"
msgstr ""
"Sie können sogar eine Anfrage für das Laden von Collections definieren:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"You can also define an entity loader that loads a collection by join "
"fetching:"
msgstr ""
"Sie könnten sogar einen Entity-Loader definieren, der eine Collection "
"mittels \"Join-Fetching\" lädt:"

#, fuzzy
#~ msgid ""
#~ "You can also declare your own SQL (or HQL) queries for entity loading:"
#~ msgstr ""
#~ "Sie können auch Ihre eigenen SQL (oder HQL)-Anfragen für das Laden von "
#~ "Entities deklarieren:"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").list();\n"
#~ "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").list();\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT * FROM CATS\").list();\n"
#~ "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
#~ " .addScalar(\"ID\", Hibernate.LONG)\n"
#~ " .addScalar(\"NAME\", Hibernate.STRING)\n"
#~ " .addScalar(\"BIRTHDATE\", Hibernate.DATE)\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
#~ " .addScalar(\"ID\", Hibernate.LONG)\n"
#~ " .addScalar(\"NAME\", Hibernate.STRING)\n"
#~ " .addScalar(\"BIRTHDATE\", Hibernate.DATE)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
#~ " .addScalar(\"ID\", Hibernate.LONG)\n"
#~ " .addScalar(\"NAME\")\n"
#~ " .addScalar(\"BIRTHDATE\")\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
#~ " .addScalar(\"ID\", Hibernate.LONG)\n"
#~ " .addScalar(\"NAME\")\n"
#~ " .addScalar(\"BIRTHDATE\")"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").addEntity(Cat."
#~ "class);\n"
#~ "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").addEntity"
#~ "(Cat.class);\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT * FROM CATS\").addEntity(Cat.class);\n"
#~ "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").addEntity"
#~ "(Cat.class);"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, DOG_ID FROM "
#~ "CATS\").addEntity(Cat.class);\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS\")."
#~ "addEntity(Cat.class);"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT c.ID, NAME, BIRTHDATE, DOG_ID, "
#~ "D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addJoin(\"cat.dog\");\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME "
#~ "FROM CATS c, DOGS d \n"
#~ "    WHERE c.DOG_ID = d.D_ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addJoin(\"cat.dog\");"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, "
#~ "CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addJoin(\"cat.dogs\");\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID "
#~ "FROM CATS c, DOGS d\n"
#~ "    WHERE c.ID = d.CAT_ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addJoin(\"cat.dogs\");"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT c.*, m.*  FROM CATS c, CATS m WHERE "
#~ "c.MOTHER_ID = c.ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addEntity(\"mother\", Cat.class)\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT c.*, m.*  FROM CATS c, CATS m WHERE c."
#~ "MOTHER_ID = c.ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addEntity(\"mother\", Cat.class)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT {cat.*}, {mother.*}  FROM CATS c, "
#~ "CATS m WHERE c.MOTHER_ID = c.ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addEntity(\"mother\", Cat.class)\n"
#~ "]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m "
#~ "WHERE c.MOTHER_ID = c.ID\")\n"
#~ " .addEntity(\"cat\", Cat.class)\n"
#~ " .addEntity(\"mother\", Cat.class)"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[String sql = \"SELECT ID as {c.id}, NAME as {c.name}, \" + \n"
#~ "         \"BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother."
#~ "*} \" +\n"
#~ "         \"FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID\";\n"
#~ "\n"
#~ "List loggedCats = sess.createSQLQuery(sql)\n"
#~ "        .addEntity(\"cat\", Cat.class)\n"
#~ "        .addEntity(\"mother\", Cat.class).list()\n"
#~ "]]>"
#~ msgstr ""
#~ "String sql = \"SELECT ID as {c.id}, NAME as {c.name}, \" + \n"
#~ "         \"BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother."
#~ "*} \" +\n"
#~ "         \"FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID\";\n"
#~ "\n"
#~ "List loggedCats = sess.createSQLQuery(sql)\n"
#~ "        .addEntity(\"cat\", Cat.class)\n"
#~ "        .addEntity(\"mother\", Cat.class).list()"

#, fuzzy
#~ msgid "A_NAME as {item.name}"
#~ msgstr "A_NAME as {item.name}"

#, fuzzy
#~ msgid "{[aliasname].class}"
#~ msgstr "{[aliasname].class}"

#, fuzzy
#~ msgid "DISC as {item.class}"
#~ msgstr "DISC as {item.class}"

#, fuzzy
#~ msgid "{[aliasname].*}"
#~ msgstr "{[aliasname].*}"

#~ msgid "{item.*}"
#~ msgstr "{item.*}"

#, fuzzy
#~ msgid "{[aliasname].key}"
#~ msgstr "{[aliasname].key}"

#, fuzzy
#~ msgid "ORGID as {coll.key}"
#~ msgstr "ORGID als {coll.key}"

#, fuzzy
#~ msgid "{[aliasname].id}"
#~ msgstr "{[aliasname].id}"

#, fuzzy
#~ msgid "EMPID as {coll.id}"
#~ msgstr "EMPID als {coll.id}"

#, fuzzy
#~ msgid "{[aliasname].element}"
#~ msgstr "{[aliasname].element}"

#, fuzzy
#~ msgid "XID as {coll.element}"
#~ msgstr "XID als {coll.element}"

#, fuzzy
#~ msgid "NAME as {coll.element.name}"
#~ msgstr "NAME als {coll.element.name}"

#, fuzzy
#~ msgid "{[aliasname].element.*}"
#~ msgstr "{[aliasname].element.*}"

#, fuzzy
#~ msgid "{coll.element.*}"
#~ msgstr "{coll.*}"

#~ msgid "{coll.*}"
#~ msgstr "{coll.*}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[sess.createSQLQuery(\"SELECT NAME, BIRTHDATE FROM CATS\")\n"
#~ "        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))]]>"
#~ msgstr ""
#~ "sess.createSQLQuery(\"SELECT NAME, BIRTHDATE FROM CATS\")\n"
#~ "        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[Query query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE "
#~ "NAME like ?\").addEntity(Cat.class);\n"
#~ "List pusList = query.setString(0, \"Pus%\").list();\n"
#~ "     \n"
#~ "query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like :name\")."
#~ "addEntity(Cat.class);\n"
#~ "List pusList = query.setString(\"name\", \"Pus%\").list();          ]]>"
#~ msgstr ""
#~ "Query query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like ?"
#~ "\").addEntity(Cat.class);\n"
#~ "List pusList = query.setString(0, \"Pus&#37;\").list();\n"
#~ "     \n"
#~ "query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like :name\")."
#~ "addEntity(Cat.class);\n"
#~ "List pusList = query.setString(\"name\", \"Pus&#37;\").list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"persons\">\n"
#~ "    <return alias=\"person\" class=\"eg.Person\"/>\n"
#~ "    SELECT person.NAME AS {person.name},\n"
#~ "           person.AGE AS {person.age},\n"
#~ "           person.SEX AS {person.sex}\n"
#~ "    FROM PERSON person\n"
#~ "    WHERE person.NAME LIKE :namePattern\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"persons\"&gt;\n"
#~ "    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
#~ "    SELECT person.NAME AS {person.name},\n"
#~ "           person.AGE AS {person.age},\n"
#~ "           person.SEX AS {person.sex}\n"
#~ "    FROM PERSON person\n"
#~ "    WHERE person.NAME LIKE :namePattern\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[List people = sess.getNamedQuery(\"persons\")\n"
#~ "    .setString(\"namePattern\", namePattern)\n"
#~ "    .setMaxResults(50)\n"
#~ "    .list();]]>"
#~ msgstr ""
#~ "List people = sess.getNamedQuery(\"persons\")\n"
#~ "    .setString(\"namePattern\", namePattern)\n"
#~ "    .setMaxResults(50)\n"
#~ "    .list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"personsWith\">\n"
#~ "    <return alias=\"person\" class=\"eg.Person\"/>\n"
#~ "    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
#~ "    SELECT person.NAME AS {person.name},\n"
#~ "           person.AGE AS {person.age},\n"
#~ "           person.SEX AS {person.sex},\n"
#~ "           address.STREET AS {address.street},\n"
#~ "           address.CITY AS {address.city},\n"
#~ "           address.STATE AS {address.state},\n"
#~ "           address.ZIP AS {address.zip}\n"
#~ "    FROM PERSON person\n"
#~ "    JOIN ADDRESS address\n"
#~ "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
#~ "    WHERE person.NAME LIKE :namePattern\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"personsWith\"&gt;\n"
#~ "    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
#~ "    &lt;return-join alias=\"address\" property=\"person.mailingAddress\"/"
#~ "&gt;\n"
#~ "    SELECT person.NAME AS {person.name},\n"
#~ "           person.AGE AS {person.age},\n"
#~ "           person.SEX AS {person.sex},\n"
#~ "           adddress.STREET AS {address.street},\n"
#~ "           adddress.CITY AS {address.city},\n"
#~ "           adddress.STATE AS {address.state},\n"
#~ "           adddress.ZIP AS {address.zip}\n"
#~ "    FROM PERSON person\n"
#~ "    JOIN ADDRESS adddress\n"
#~ "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
#~ "    WHERE person.NAME LIKE :namePattern\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"mySqlQuery\">\n"
#~ "    <return-scalar column=\"name\" type=\"string\"/>\n"
#~ "    <return-scalar column=\"age\" type=\"long\"/>\n"
#~ "    SELECT p.NAME AS name,\n"
#~ "           p.AGE AS age,\n"
#~ "    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"mySqlQuery\"&gt;\n"
#~ "    &lt;return-scalar column=\"name\" type=\"string\"/&gt;\n"
#~ "    &lt;return-scalar column=\"age\" type=\"long\"/&gt;\n"
#~ "    SELECT p.NAME AS name,\n"
#~ "           p.AGE AS age,\n"
#~ "    FROM PERSON p WHERE p.NAME LIKE 'Hiber&#37;'\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<resultset name=\"personAddress\">\n"
#~ "    <return alias=\"person\" class=\"eg.Person\"/>\n"
#~ "    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
#~ "</resultset>\n"
#~ "\n"
#~ "<sql-query name=\"personsWith\" resultset-ref=\"personAddress\">\n"
#~ "    SELECT person.NAME AS {person.name},\n"
#~ "           person.AGE AS {person.age},\n"
#~ "           person.SEX AS {person.sex},\n"
#~ "           address.STREET AS {address.street},\n"
#~ "           address.CITY AS {address.city},\n"
#~ "           address.STATE AS {address.state},\n"
#~ "           address.ZIP AS {address.zip}\n"
#~ "    FROM PERSON person\n"
#~ "    JOIN ADDRESS address\n"
#~ "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
#~ "    WHERE person.NAME LIKE :namePattern\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;resultset name=\"personAddress\"&gt;\n"
#~ "    &lt;return alias=\"person\" class=\"eg.Person\"/&gt;\n"
#~ "    &lt;return-join alias=\"address\" property=\"person.mailingAddress\"/"
#~ "&gt;\n"
#~ "&lt;/resultset&gt;\n"
#~ "\n"
#~ "&lt;sql-query name=\"personsWith\" resultset-ref=\"personAddress\"&gt;\n"
#~ "    SELECT person.NAME AS {person.name},\n"
#~ "           person.AGE AS {person.age},\n"
#~ "           person.SEX AS {person.sex},\n"
#~ "           adddress.STREET AS {address.street},\n"
#~ "           adddress.CITY AS {address.city},\n"
#~ "           adddress.STATE AS {address.state},\n"
#~ "           adddress.ZIP AS {address.zip}\n"
#~ "    FROM PERSON person\n"
#~ "    JOIN ADDRESS adddress\n"
#~ "        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
#~ "    WHERE person.NAME LIKE :namePattern\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[List cats = sess.createSQLQuery(\n"
#~ "        \"select {cat.*}, {kitten.*} from cats cat, cats kitten where "
#~ "kitten.mother = cat.id\"\n"
#~ "    )\n"
#~ "    .setResultSetMapping(\"catAndKitten\")\n"
#~ "    .list();]]>"
#~ msgstr ""
#~ "List cats = sess.createSQLQuery(\n"
#~ "        \"select {cat.*}, {kitten.*} from cats cat, cats kitten where "
#~ "kitten.mother = cat.id\"\n"
#~ "    )\n"
#~ "    .setResultSetMapping(\"catAndKitten\")\n"
#~ "    .list();"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"mySqlQuery\">\n"
#~ "    <return alias=\"person\" class=\"eg.Person\">\n"
#~ "        <return-property name=\"name\" column=\"myName\"/>\n"
#~ "        <return-property name=\"age\" column=\"myAge\"/>\n"
#~ "        <return-property name=\"sex\" column=\"mySex\"/>\n"
#~ "    </return>\n"
#~ "    SELECT person.NAME AS myName,\n"
#~ "           person.AGE AS myAge,\n"
#~ "           person.SEX AS mySex,\n"
#~ "    FROM PERSON person WHERE person.NAME LIKE :name\n"
#~ "</sql-query>\n"
#~ "]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"mySqlQuery\"&gt;\n"
#~ "    &lt;return alias=\"person\" class=\"eg.Person\"&gt;\n"
#~ "        &lt;return-property name=\"name\" column=\"myName\"/&gt;\n"
#~ "        &lt;return-property name=\"age\" column=\"myAge\"/&gt;\n"
#~ "        &lt;return-property name=\"sex\" column=\"mySex\"/&gt;\n"
#~ "    &lt;/return&gt;\n"
#~ "    SELECT person.NAME AS myName,\n"
#~ "           person.AGE AS myAge,\n"
#~ "           person.SEX AS mySex,\n"
#~ "    FROM PERSON person WHERE person.NAME LIKE :name\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"organizationCurrentEmployments\">\n"
#~ "    <return alias=\"emp\" class=\"Employment\">\n"
#~ "        <return-property name=\"salary\">\n"
#~ "            <return-column name=\"VALUE\"/>\n"
#~ "            <return-column name=\"CURRENCY\"/>\n"
#~ "        </return-property>\n"
#~ "        <return-property name=\"endDate\" column=\"myEndDate\"/>\n"
#~ "    </return>\n"
#~ "        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},\n"
#~ "        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},\n"
#~ "        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY\n"
#~ "        FROM EMPLOYMENT\n"
#~ "        WHERE EMPLOYER = :id AND ENDDATE IS NULL\n"
#~ "        ORDER BY STARTDATE ASC\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"organizationCurrentEmployments\"&gt;\n"
#~ "    &lt;return alias=\"emp\" class=\"Employment\"&gt;\n"
#~ "        &lt;return-property name=\"salary\"&gt;\n"
#~ "            &lt;return-column name=\"VALUE\"/&gt;\n"
#~ "            &lt;return-column name=\"CURRENCY\"/&gt;\n"
#~ "        &lt;/return-property&gt;\n"
#~ "        &lt;return-property name=\"endDate\" column=\"myEndDate\"/&gt;\n"
#~ "    &lt;/return&gt;\n"
#~ "        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},\n"
#~ "        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},\n"
#~ "        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY\n"
#~ "        FROM EMPLOYMENT\n"
#~ "        WHERE EMPLOYER = :id AND ENDDATE IS NULL\n"
#~ "        ORDER BY STARTDATE ASC\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[CREATE OR REPLACE FUNCTION selectAllEmployments\n"
#~ "    RETURN SYS_REFCURSOR\n"
#~ "AS\n"
#~ "    st_cursor SYS_REFCURSOR;\n"
#~ "BEGIN\n"
#~ "    OPEN st_cursor FOR\n"
#~ " SELECT EMPLOYEE, EMPLOYER,\n"
#~ " STARTDATE, ENDDATE,\n"
#~ " REGIONCODE, EID, VALUE, CURRENCY\n"
#~ " FROM EMPLOYMENT;\n"
#~ "      RETURN  st_cursor;\n"
#~ " END;]]>"
#~ msgstr ""
#~ "CREATE OR REPLACE FUNCTION selectAllEmployments\n"
#~ "    RETURN SYS_REFCURSOR\n"
#~ "AS\n"
#~ "    st_cursor SYS_REFCURSOR;\n"
#~ "BEGIN\n"
#~ "    OPEN st_cursor FOR\n"
#~ " SELECT EMPLOYEE, EMPLOYER,\n"
#~ " STARTDATE, ENDDATE,\n"
#~ " REGIONCODE, EID, VALUE, CURRENCY\n"
#~ " FROM EMPLOYMENT;\n"
#~ "      RETURN  st_cursor;\n"
#~ " END;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"selectAllEmployees_SP\" callable=\"true\">\n"
#~ "    <return alias=\"emp\" class=\"Employment\">\n"
#~ "        <return-property name=\"employee\" column=\"EMPLOYEE\"/>\n"
#~ "        <return-property name=\"employer\" column=\"EMPLOYER\"/>\n"
#~ "        <return-property name=\"startDate\" column=\"STARTDATE\"/>\n"
#~ "        <return-property name=\"endDate\" column=\"ENDDATE\"/>\n"
#~ "        <return-property name=\"regionCode\" column=\"REGIONCODE\"/>\n"
#~ "        <return-property name=\"id\" column=\"EID\"/>\n"
#~ "        <return-property name=\"salary\">\n"
#~ "            <return-column name=\"VALUE\"/>\n"
#~ "            <return-column name=\"CURRENCY\"/>\n"
#~ "        </return-property>\n"
#~ "    </return>\n"
#~ "    { ? = call selectAllEmployments() }\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"selectAllEmployees_SP\" callable=\"true\"&gt;\n"
#~ "    &lt;return alias=\"emp\" class=\"Employment\"&gt;\n"
#~ "        &lt;return-property name=\"employee\" column=\"EMPLOYEE\"/&gt;\n"
#~ "        &lt;return-property name=\"employer\" column=\"EMPLOYER\"/&gt;\n"
#~ "        &lt;return-property name=\"startDate\" column=\"STARTDATE\"/&gt;\n"
#~ "        &lt;return-property name=\"endDate\" column=\"ENDDATE\"/&gt;\n"
#~ "        &lt;return-property name=\"regionCode\" column=\"REGIONCODE\"/"
#~ "&gt;\n"
#~ "        &lt;return-property name=\"id\" column=\"EID\"/&gt;\n"
#~ "        &lt;return-property name=\"salary\"&gt;\n"
#~ "            &lt;return-column name=\"VALUE\"/&gt;\n"
#~ "            &lt;return-column name=\"CURRENCY\"/&gt;\n"
#~ "        &lt;/return-property&gt;\n"
#~ "    &lt;/return&gt;\n"
#~ "    { ? = call selectAllEmployments() }\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Person\">\n"
#~ "    <id name=\"id\">\n"
#~ "        <generator class=\"increment\"/>\n"
#~ "    </id>\n"
#~ "    <property name=\"name\" not-null=\"true\"/>\n"
#~ "    <sql-insert>INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )</sql-"
#~ "insert>\n"
#~ "    <sql-update>UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?</sql-update>\n"
#~ "    <sql-delete>DELETE FROM PERSON WHERE ID=?</sql-delete>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"Person\"&gt;\n"
#~ "    &lt;id name=\"id\"&gt;\n"
#~ "        &lt;generator class=\"increment\"/&gt;\n"
#~ "    &lt;/id&gt;\n"
#~ "    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
#~ "    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )"
#~ "&lt;/sql-insert&gt;\n"
#~ "    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-"
#~ "update&gt;\n"
#~ "    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Person\">\n"
#~ "    <id name=\"id\">\n"
#~ "        <generator class=\"increment\"/>\n"
#~ "    </id>\n"
#~ "    <property name=\"name\" not-null=\"true\"/>\n"
#~ "    <sql-insert callable=\"true\">{call createPerson (?, ?)}</sql-"
#~ "insert>\n"
#~ "    <sql-delete callable=\"true\">{? = call deletePerson (?)}</sql-"
#~ "delete>\n"
#~ "    <sql-update callable=\"true\">{? = call updatePerson (?, ?)}</sql-"
#~ "update>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"Person\"&gt;\n"
#~ "    &lt;id name=\"id\"&gt;\n"
#~ "        &lt;generator class=\"increment\"/&gt;\n"
#~ "    &lt;/id&gt;\n"
#~ "    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
#~ "    &lt;sql-insert callable=\"true\"&gt;{call createPerson (?, ?)}&lt;/"
#~ "sql-insert&gt;\n"
#~ "    &lt;sql-delete callable=\"true\"&gt;{? = call deletePerson (?)}&lt;/"
#~ "sql-delete&gt;\n"
#~ "    &lt;sql-update callable=\"true\"&gt;{? = call updatePerson (?, ?)}"
#~ "&lt;/sql-update&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN "
#~ "VARCHAR2)\n"
#~ "    RETURN NUMBER IS\n"
#~ "BEGIN\n"
#~ "\n"
#~ "    update PERSON\n"
#~ "    set\n"
#~ "        NAME = uname,\n"
#~ "    where\n"
#~ "        ID = uid;\n"
#~ "\n"
#~ "    return SQL%ROWCOUNT;\n"
#~ "\n"
#~ "END updatePerson;]]>"
#~ msgstr ""
#~ "CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN "
#~ "VARCHAR2)\n"
#~ "    RETURN NUMBER IS\n"
#~ "BEGIN\n"
#~ "\n"
#~ "    update PERSON\n"
#~ "    set\n"
#~ "        NAME = uname,\n"
#~ "    where\n"
#~ "        ID = uid;\n"
#~ "\n"
#~ "    return SQL&#37;ROWCOUNT;\n"
#~ "\n"
#~ "END updatePerson;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"person\">\n"
#~ "    <return alias=\"pers\" class=\"Person\" lock-mode=\"upgrade\"/>\n"
#~ "    SELECT NAME AS {pers.name}, ID AS {pers.id}\n"
#~ "    FROM PERSON\n"
#~ "    WHERE ID=?\n"
#~ "    FOR UPDATE\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"person\"&gt;\n"
#~ "    &lt;return alias=\"pers\" class=\"Person\" lock-mode=\"upgrade\"/"
#~ "&gt;\n"
#~ "    SELECT NAME AS {pers.name}, ID AS {pers.id}\n"
#~ "    FROM PERSON\n"
#~ "    WHERE ID=?\n"
#~ "    FOR UPDATE\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<class name=\"Person\">\n"
#~ "    <id name=\"id\">\n"
#~ "        <generator class=\"increment\"/>\n"
#~ "    </id>\n"
#~ "    <property name=\"name\" not-null=\"true\"/>\n"
#~ "    <loader query-ref=\"person\"/>\n"
#~ "</class>]]>"
#~ msgstr ""
#~ "&lt;class name=\"Person\"&gt;\n"
#~ "    &lt;id name=\"id\"&gt;\n"
#~ "        &lt;generator class=\"increment\"/&gt;\n"
#~ "    &lt;/id&gt;\n"
#~ "    &lt;property name=\"name\" not-null=\"true\"/&gt;\n"
#~ "    &lt;loader query-ref=\"person\"/&gt;\n"
#~ "&lt;/class&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<set name=\"employments\" inverse=\"true\">\n"
#~ "    <key/>\n"
#~ "    <one-to-many class=\"Employment\"/>\n"
#~ "    <loader query-ref=\"employments\"/>\n"
#~ "</set>]]>"
#~ msgstr ""
#~ "&lt;set name=\"employments\" inverse=\"true\"&gt;\n"
#~ "    &lt;key/&gt;\n"
#~ "    &lt;one-to-many class=\"Employment\"/&gt;\n"
#~ "    &lt;loader query-ref=\"employments\"/&gt;\n"
#~ "&lt;/set&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"employments\">\n"
#~ "    <load-collection alias=\"emp\" role=\"Person.employments\"/>\n"
#~ "    SELECT {emp.*}\n"
#~ "    FROM EMPLOYMENT emp\n"
#~ "    WHERE EMPLOYER = :id\n"
#~ "    ORDER BY STARTDATE ASC, EMPLOYEE ASC\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"employments\"&gt;\n"
#~ "    &lt;load-collection alias=\"emp\" role=\"Person.employments\"/&gt;\n"
#~ "    SELECT {emp.*}\n"
#~ "    FROM EMPLOYMENT emp\n"
#~ "    WHERE EMPLOYER = :id\n"
#~ "    ORDER BY STARTDATE ASC, EMPLOYEE ASC\n"
#~ "&lt;/sql-query&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<sql-query name=\"person\">\n"
#~ "    <return alias=\"pers\" class=\"Person\"/>\n"
#~ "    <return-join alias=\"emp\" property=\"pers.employments\"/>\n"
#~ "    SELECT NAME AS {pers.*}, {emp.*}\n"
#~ "    FROM PERSON pers\n"
#~ "    LEFT OUTER JOIN EMPLOYMENT emp\n"
#~ "        ON pers.ID = emp.PERSON_ID\n"
#~ "    WHERE ID=?\n"
#~ "</sql-query>]]>"
#~ msgstr ""
#~ "&lt;sql-query name=\"person\"&gt;\n"
#~ "    &lt;return alias=\"pers\" class=\"Person\"/&gt;\n"
#~ "    &lt;return-join alias=\"emp\" property=\"pers.employments\"/&gt;\n"
#~ "    SELECT NAME AS {pers.*}, {emp.*}\n"
#~ "    FROM PERSON pers\n"
#~ "    LEFT OUTER JOIN EMPLOYMENT emp\n"
#~ "        ON pers.ID = emp.PERSON_ID\n"
#~ "    WHERE ID=?\n"
#~ "&lt;/sql-query&gt;"
