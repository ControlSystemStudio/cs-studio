# translation of query_hql.po to
# Michael H. Smith <mhideo@redhat.com>, 2007.
# Angela Garcia <agarcia@redhat.com>, 2009, 2010.
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
# translation of Collection_Mapping.po to
msgid ""
msgstr ""
"Project-Id-Version: query_hql\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-02-11T05:38:15\n"
"PO-Revision-Date: 2010-03-15 14:46+1000\n"
"Last-Translator: Angela Garcia <agarcia@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "HQL: The Hibernate Query Language"
msgstr "HQL: El lenguaje de consulta de Hibernate"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate uses a powerful query language (HQL) that is similar in appearance "
"to SQL. Compared with SQL, however, HQL is fully object-oriented and "
"understands notions like inheritance, polymorphism and association."
msgstr ""
"Hibernate utiliza un lenguaje de consulta potente (HQL) que se parece a SQL. "
"Sin embargo, comparado con SQL, HQL es completamente orientado a objetos y "
"comprende nociones como herencia, polimorfismo y asociación."

#. Tag: title
#, no-c-format
msgid "Case Sensitivity"
msgstr "Sensibilidad a mayúsculas"

#. Tag: para
#, no-c-format
msgid ""
"With the exception of names of Java classes and properties, queries are case-"
"insensitive. So <literal>SeLeCT</literal> is the same as <literal>sELEct</"
"literal> is the same as <literal>SELECT</literal>, but <literal>org."
"hibernate.eg.FOO</literal> is not <literal>org.hibernate.eg.Foo</literal>, "
"and <literal>foo.barSet</literal> is not <literal>foo.BARSET</literal>."
msgstr ""
"Las consultas no son sensibles a mayúsculas, a excepción de los nombres de "
"las clases y propiedades Java. De modo que <literal>SeLeCT</literal> es lo "
"mismo que <literal>sELEct</literal> e igual a <literal>SELECT</literal>, "
"pero <literal>org.hibernate.eg.FOO</literal> no es lo mismo que <literal>org."
"hibernate.eg.Foo</literal> y <literal>foo.barSet</literal> no es igual a "
"<literal>foo.BARSET</literal>."

#. Tag: para
#, no-c-format
msgid ""
"This manual uses lowercase HQL keywords. Some users find queries with "
"uppercase keywords more readable, but this convention is unsuitable for "
"queries embedded in Java code."
msgstr ""
"Este manual utiliza palabras clave HQL en minúsculas. Algunos usuarios "
"encuentran que las consultas con palabras clave en mayúsculas son más "
"fáciles de leer, pero esta convención no es apropiada para las peticiones "
"incluidas en código Java."

#. Tag: title
#, no-c-format
msgid "The from clause"
msgstr "La cláusula from"

#. Tag: para
#, no-c-format
msgid "The simplest possible Hibernate query is of the form:"
msgstr "La consulta posible más simple de Hibernate es de esta manera:"

#. Tag: para
#, no-c-format
msgid ""
"This returns all instances of the class <literal>eg.Cat</literal>. You do "
"not usually need to qualify the class name, since <literal>auto-import</"
"literal> is the default. For example:"
msgstr ""
"Esto retorna todas las instancias de la clase <literal>eg.Cat</literal>. "
"Usualmente no es necesario calificar el nombre de la clase ya que "
"<literal>auto-import</literal> es el valor predeterminado. Por ejemplo:"

#. Tag: para
#, no-c-format
msgid ""
"In order to refer to the <literal>Cat</literal> in other parts of the query, "
"you will need to assign an <emphasis>alias</emphasis>. For example:"
msgstr ""
"Con el fin de referirse al <literal>Cat</literal> en otras partes de la "
"petición, necesitará asignar un <emphasis>alias</emphasis>. Por ejemplo:"

#. Tag: para
#, no-c-format
msgid ""
"This query assigns the alias <literal>cat</literal> to <literal>Cat</"
"literal> instances, so you can use that alias later in the query. The "
"<literal>as</literal> keyword is optional. You could also write:"
msgstr ""
"Esta consulta asigna el alias <literal>cat</literal> a las instancias "
"<literal>Cat</literal>, de modo que puede utilizar ese alias luego en la "
"consulta. La palabra clave <literal>as</literal> es opcional. También podría "
"escribir:"

#. Tag: para
#, no-c-format
msgid ""
"Multiple classes can appear, resulting in a cartesian product or \"cross\" "
"join."
msgstr ""
"Pueden aparecer múltiples clases, lo que causa un producto cartesiano o una "
"unión \"cruzada\" (cross join)."

#. Tag: para
#, no-c-format
msgid ""
"It is good practice to name query aliases using an initial lowercase as this "
"is consistent with Java naming standards for local variables (e.g. "
"<literal>domesticCat</literal>)."
msgstr ""
"Se considera como una buena práctica el nombrar los alias de consulta "
"utilizando una inicial en minúsculas, consistente con los estándares de "
"nombrado de Java para las variables locales (por ejemplo, "
"<literal>domesticCat</literal>). "

#. Tag: title
#, no-c-format
msgid "Associations and joins"
msgstr "Asociaciones y uniones (joins)"

#. Tag: para
#, no-c-format
msgid ""
"You can also assign aliases to associated entities or to elements of a "
"collection of values using a <literal>join</literal>. For example:"
msgstr ""
"También puede asignar alias a entidades asociadas o a elementos de una "
"colección de valores utilizando una <literal>join</literal>. Por ejemplo:"

#. Tag: para
#, no-c-format
msgid "The supported join types are borrowed from ANSI SQL:"
msgstr "Los tipos de uniones soportadas se tomaron prestados de ANSI SQL"

#. Tag: para
#, no-c-format
msgid "<literal>inner join</literal>"
msgstr "<literal>inner join</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>left outer join</literal>"
msgstr "<literal>left outer join</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>right outer join</literal>"
msgstr "<literal>right outer join</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>full join</literal> (not usually useful)"
msgstr "<literal>full join</literal> (no es útil usualmente)"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>inner join</literal>, <literal>left outer join</literal> and "
"<literal>right outer join</literal> constructs may be abbreviated."
msgstr ""
"Las construcciones <literal>inner join</literal>, <literal>left outer join</"
"literal> y <literal>right outer join</literal> se pueden abreviar."

#. Tag: para
#, no-c-format
msgid ""
"You may supply extra join conditions using the HQL <literal>with</literal> "
"keyword."
msgstr ""
"Puede proveer condiciones extras de unión utilizando la palabra clave "
"<literal>with</literal> de HQL."

#. Tag: para
#, no-c-format
msgid ""
"A \"fetch\" join allows associations or collections of values to be "
"initialized along with their parent objects using a single select. This is "
"particularly useful in the case of a collection. It effectively overrides "
"the outer join and lazy declarations of the mapping file for associations "
"and collections. See <xref linkend=\"performance-fetching\" /> for more "
"information."
msgstr ""
"Una unión de \"recuperación\" le permite a las asociaciones o colecciones de "
"valores que se inicialicen junto a sus objetos padres, usando un sólo "
"select. Esto es útil particularmente en el caso de una colección. "
"Efectivamente sobrescribe la unión externa y las declaraciones perezosas del "
"archivo de mapeo para asociaciones y colecciones. Consulte <xref linkend=\"performance-fetching\" /> para obtener más información."

#. Tag: para
#, no-c-format
msgid ""
"A fetch join does not usually need to assign an alias, because the "
"associated objects should not be used in the <literal>where</literal> clause "
"(or any other clause). The associated objects are also not returned directly "
"in the query results. Instead, they may be accessed via the parent object. "
"The only reason you might need an alias is if you are recursively join "
"fetching a further collection:"
msgstr ""
"Usualmente no se necesita asignársele un alias a una unión de recuperación "
"ya que los objetos asociados no se deben utilizar en la cláusula "
"<literal>where</literal> (ni en cualquier otra cláusula). Los objetos "
"asociados no se retornan directamente en los resultados de la consulta. En "
"cambio, se pueden acceder por medio del objeto padre. La única razón por la "
"que necesitaríamos un alias es si estamos uniendo recursivamente otra "
"colección:"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>fetch</literal> construct cannot be used in queries called "
"using <literal>iterate()</literal> (though <literal>scroll()</literal> can "
"be used). <literal>Fetch</literal> should be used together with "
"<literal>setMaxResults()</literal> or <literal>setFirstResult()</literal>, "
"as these operations are based on the result rows which usually contain "
"duplicates for eager collection fetching, hence, the number of rows is not "
"what you would expect. <literal>Fetch</literal> should also not be used "
"together with impromptu <literal>with</literal> condition. It is possible to "
"create a cartesian product by join fetching more than one collection in a "
"query, so take care in this case. Join fetching multiple collection roles "
"can produce unexpected results for bag mappings, so user discretion is "
"advised when formulating queries in this case. Finally, note that "
"<literal>full join fetch</literal> and <literal>right join fetch</literal> "
"are not meaningful."
msgstr ""
"La construcción <literal>fetch</literal> no puede utilizarse en consultas "
"llamadas que usen <literal>iterate()</literal> (aunque se puede utilizar "
"<literal>scroll()</literal>). <literal>Fetch</literal> se debe usar junto "
"con <literal>setMaxResults()</literal> o <literal>setFirstResult()</literal> "
"ya que estas operaciones se basan en las filas de resultados, las cuales "
"usualmente contienen duplicados para la recuperación de colección temprana, "
"por lo tanto, el número de filas no es lo que se esperaría. <literal>Fetch</"
"literal> no se debe usar junto con una condición <literal>with</literal> "
"improvisadas. Es posible crear un producto cartesiano por medio de una "
"recuperación por union más de una colección en una consulta, así que tenga "
"cuidado en este caso. La recuperación por unión de múltiples roles de "
"colección también da resultados a veces inesperados para mapeos de bag, así "
"que tenga cuidado de cómo formular sus consultas en este caso. Finalmente, "
"observe que <literal>full join fetch</literal> y <literal>right join fetch</"
"literal> no son significativos."

#. Tag: para
#, no-c-format
msgid ""
"If you are using property-level lazy fetching (with bytecode "
"instrumentation), it is possible to force Hibernate to fetch the lazy "
"properties in the first query immediately using <literal>fetch all "
"properties</literal>."
msgstr ""
"Si está utilizando una recuperación perezosa a nivel de propiedad (con "
"instrumentación de código byte), es posible forzar a Hibernate a traer las "
"propiedades perezosas inmediatamente utilizando <literal>fetch all "
"properties</literal>."

#. Tag: title
#, no-c-format
msgid "Forms of join syntax"
msgstr "Formas de sintaxis unida"

#. Tag: para
#, no-c-format
msgid ""
"HQL supports two forms of association joining: <literal>implicit</literal> "
"and <literal>explicit</literal>."
msgstr ""
"HQL soporta dos formas de unión de asociación: <literal>implicit</literal> y "
"<literal>explicit</literal>."

#. Tag: para
#, no-c-format
msgid ""
"The queries shown in the previous section all use the <literal>explicit</"
"literal> form, that is, where the join keyword is explicitly used in the "
"from clause. This is the recommended form."
msgstr ""
"Las consultas que se mostraron en la sección anterior todas utilizan la "
"forma <literal>explicit</literal>, en donde la palabra clave join se utiliza "
"explícitamente en la claúsula from. Esta es la forma recomendada."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>implicit</literal> form does not use the join keyword. Instead, "
"the associations are \"dereferenced\" using dot-notation. <literal>implicit</"
"literal> joins can appear in any of the HQL clauses. <literal>implicit</"
"literal> join result in inner joins in the resulting SQL statement."
msgstr ""
"La forma <literal>implicit</literal> no utiliza la palabra clave join. Las "
"asociaciones se \"desreferencian\" utilizando la notación punto. Uniones "
"<literal>implicit</literal> pueden aparecer en cualquiera de las cláusulas "
"HQL. La unión <literal>implicit</literal> causa uniones internas (inner "
"joins) en la declaración SQL que resulta."

#. Tag: title
#, no-c-format
msgid "Referring to identifier property"
msgstr "Referencia a la propiedad identificadora "

#. Tag: para
#, no-c-format
msgid "There are 2 ways to refer to an entity's identifier property:"
msgstr "Hay dos maneras de referirse a la propiedad identificadora de una entidad:"

#. Tag: para
#, no-c-format
msgid ""
"The special property (lowercase) <literal>id</literal> may be used to "
"reference the identifier property of an entity <emphasis>provided that the "
"entity does not define a non-identifier property named id</emphasis>."
msgstr ""
"La propiedad especial (en minúsculas) <literal>id</literal> se puede "
"utilizar para referenciar la propiedad identificadora de una entidad "
"<emphasis> dado que la entidad no defina un id del nombre de la propiedad no-"
"identificadora</emphasis>."

#. Tag: para
#, no-c-format
msgid ""
"If the entity defines a named identifier property, you can use that property "
"name."
msgstr ""
"Si la entidad define una propiedad identificadora nombrada, puede utilizar "
"ese nombre de propiedad."

#. Tag: para
#, no-c-format
msgid ""
"References to composite identifier properties follow the same naming rules. "
"If the entity has a non-identifier property named id, the composite "
"identifier property can only be referenced by its defined named. Otherwise, "
"the special <literal>id</literal> property can be used to reference the "
"identifier property."
msgstr ""
"Las referencias a propiedades identificadoras compuestas siguen las mismas "
"reglas de nombramiento. Si la entidad no tiene un id del nombre de la "
"propiedad no-identificadora, la propiedad identificadora compuesta sólamente "
"puede ser referenciada por su nombre definido. De otra manera se puede "
"utilizar la propiedad <literal>id</literal> especial para referenciar la "
"propiedad identificadora."

#. Tag: para
#, no-c-format
msgid ""
"Please note that, starting in version 3.2.2, this has changed significantly. "
"In previous versions, <literal>id</literal> <emphasis>always</emphasis> "
"referred to the identifier property regardless of its actual name. A "
"ramification of that decision was that non-identifier properties named "
"<literal>id</literal> could never be referenced in Hibernate queries."
msgstr ""
"Observe que esto ha cambiado bastante desde la version 3.2.2. En versiones "
"previas, <literal>id</literal><emphasis>siempre</emphasis> se refería a la "
"propiedad identificadora sin importar su nombre real. Una ramificación de "
"esa decisión fue que las propiedades no-identificadoras nombradas "
"<literal>id</literal> nunca podrían ser referenciadas en consultas de "
"Hibernate. "

#. Tag: title
#, no-c-format
msgid "The select clause"
msgstr "La cláusula select"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>select</literal> clause picks which objects and properties to "
"return in the query result set. Consider the following:"
msgstr ""
"La cláusula <literal>select</literal> escoge qué objetos y propiedades "
"devolver en el conjunto de resultados de la consulta. Considere lo siguiente:"

#. Tag: para
#, no-c-format
msgid ""
"The query will select <literal>mate</literal>s of other <literal>Cat</"
"literal>s. You can express this query more compactly as:"
msgstr ""
"La consulta seleccionará <literal>mate</literal>s de otros <literal>Cat</"
"literal>s. Puede expresar esta consulta de una manera más compacta así:"

#. Tag: para
#, no-c-format
msgid ""
"Queries can return properties of any value type including properties of "
"component type:"
msgstr ""
"Las consultas pueden retornar propiedades de cualquier tipo de valor "
"incluyendo propiedades del tipo componente:"

#. Tag: para
#, no-c-format
msgid ""
"Queries can return multiple objects and/or properties as an array of type "
"<literal>Object[]</literal>:"
msgstr ""
"Las consultas pueden retornar múltiples objetos y/o propiedades como un "
"array de tipo <literal>Object[]</literal>,"

#. Tag: para
#, no-c-format
msgid "Or as a <literal>List</literal>:"
msgstr "O como una <literal>List</literal>:"

#. Tag: para
#, no-c-format
msgid ""
"Or - assuming that the class <literal>Family</literal> has an appropriate "
"constructor - as an actual typesafe Java object:"
msgstr ""
"O asumiendo que la clase <literal>Family</literal> tiene un constructor "
"apropiado - como un objeto Java de tipo seguro:"

#. Tag: para
#, no-c-format
msgid "You can assign aliases to selected expressions using <literal>as</literal>:"
msgstr ""
"Puede asignar alias para expresiones seleccionadas utilizando <literal>as</"
"literal>:"

#. Tag: para
#, no-c-format
msgid ""
"This is most useful when used together with <literal>select new map</"
"literal>:"
msgstr ""
"Esto es lo más útil cuando se usa junto con <literal>select new map</"
"literal>:"

#. Tag: para
#, no-c-format
msgid "This query returns a <literal>Map</literal> from aliases to selected values."
msgstr ""
"Esta consulta devuelve un <literal>Map</literal> de alias a valores "
"seleccionados."

#. Tag: title
#, no-c-format
msgid "Aggregate functions"
msgstr "Funciones de agregación"

#. Tag: para
#, no-c-format
msgid "HQL queries can even return the results of aggregate functions on properties:"
msgstr ""
"Las consultas HQL pueden incluso retornar resultados de funciones de "
"agregación sobre propiedades:"

#. Tag: para
#, no-c-format
msgid "The supported aggregate functions are:"
msgstr "Las funciones de agregación soportadas son:"

#. Tag: para
#, no-c-format
msgid "<literal>avg(...), sum(...), min(...), max(...)</literal>"
msgstr "<literal>avg(...), sum(...), min(...), max(...)</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>count(*)</literal>"
msgstr "<literal>count(*)</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>count(...), count(distinct ...), count(all...)</literal>"
msgstr "<literal>count(...), count(distinct ...), count(all...)</literal>"

#. Tag: para
#, no-c-format
msgid ""
"You can use arithmetic operators, concatenation, and recognized SQL "
"functions in the select clause:"
msgstr ""
"Puede utilizar operadores aritméticos, concatenación y funciones SQL "
"reconocidas en la cláusula select:"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>distinct</literal> and <literal>all</literal> keywords can be "
"used and have the same semantics as in SQL."
msgstr ""
"Las palabras clave <literal>distinct</literal> y <literal>all</literal> se "
"pueden utilizar y tienen las misma semántica que en SQL."

#. Tag: title
#, no-c-format
msgid "Polymorphic queries"
msgstr "Consultas polimórficas"

#. Tag: para
#, no-c-format
msgid "A query like:"
msgstr "Una consulta como:"

#. Tag: para
#, no-c-format
msgid ""
"returns instances not only of <literal>Cat</literal>, but also of subclasses "
"like <literal>DomesticCat</literal>. Hibernate queries can name "
"<emphasis>any</emphasis> Java class or interface in the <literal>from</"
"literal> clause. The query will return instances of all persistent classes "
"that extend that class or implement the interface. The following query would "
"return all persistent objects:"
msgstr ""
"devuelve instancias no sólamente de <literal>Cat</literal>, sino también de "
"subclases como <literal>DomesticCat</literal>. Las consultas de Hibernate "
"pueden nombrar <emphasis>cualquier</emphasis> clase o interfaz Java en la "
"cláusula <literal>from</literal>. La consulta retornará instancias de todas "
"las clases persistentes que extiendan esa clase o implementen la interfaz. "
"La siguiente consulta retornaría todos los objetos persistentes."

#. Tag: para
#, no-c-format
msgid ""
"The interface <literal>Named</literal> might be implemented by various "
"persistent classes:"
msgstr ""
"La interfaz <literal>Named</literal> se podría implementar por varias clases "
"persistentes:"

#. Tag: para
#, no-c-format
msgid ""
"These last two queries will require more than one SQL <literal>SELECT</"
"literal>. This means that the <literal>order by</literal> clause does not "
"correctly order the whole result set. It also means you cannot call these "
"queries using <literal>Query.scroll()</literal>."
msgstr ""
"Las dos últimas consultas requerirán más de un <literal>SELECT</literal> "
"SQL. Esto significa que la cláusula <literal>order by</literal> no ordenará "
"correctamente todo el conjunto que resulte. También significa que no puede "
"llamar estas consulta usando <literal>Query.scroll()</literal>."

#. Tag: title
#, no-c-format
msgid "The where clause"
msgstr "La cláusula where"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>where</literal> clause allows you to refine the list of "
"instances returned. If no alias exists, you can refer to properties by name:"
msgstr ""
"La cláusula <literal>where</literal> le permite refinar la lista de "
"instancias retornadas. Si no existe ningún alias, puede referirse a las "
"propiedades por nombre:"

#. Tag: para
#, no-c-format
msgid "If there is an alias, use a qualified property name:"
msgstr "Si existe un alias, use un nombre de propiedad calificado:"

#. Tag: para
#, no-c-format
msgid "This returns instances of <literal>Cat</literal> named 'Fritz'."
msgstr "Esto retorna instancias de <literal>Cat</literal> llamadas 'Fritz'."

#. Tag: para
#, no-c-format
msgid "The following query:"
msgstr "La siguiente petición:"

#. Tag: para
#, no-c-format
msgid ""
"returns all instances of <literal>Foo</literal> with an instance of "
"<literal>bar</literal> with a <literal>date</literal> property equal to the "
"<literal>startDate</literal> property of the <literal>Foo</literal>. "
"Compound path expressions make the <literal>where</literal> clause extremely "
"powerful. Consider the following:"
msgstr ""
"retornará todas las instancias de <literal>Foo</literal> con una instancia "
"de <literal>bar</literal> con una propiedad <literal>date</literal> igual a "
"la propiedad <literal>startDate</literal> del <literal>Foo</literal>. Las "
"expresiones de ruta compuestas hacen la cláusula <literal>where</literal> "
"extremadamente potente. Tome en consideración lo siguiente:"

#. Tag: para
#, no-c-format
msgid "This query translates to an SQL query with a table (inner) join. For example:"
msgstr ""
"Esta consulta se traduce a una consulta SQL con una unión de tabla "
"(interna). Por ejemplo:"

#. Tag: para
#, no-c-format
msgid "would result in a query that would require four table joins in SQL."
msgstr "terminaría con una consulta que requeriría cuatro uniones de tablas en SQL. "

#. Tag: para
#, no-c-format
msgid ""
"The <literal>=</literal> operator can be used to compare not only "
"properties, but also instances:"
msgstr ""
"El operador <literal>=</literal> se puede utilizar para comparar no "
"sólamente propiedades sino también instancias:"

#. Tag: para
#, no-c-format
msgid ""
"The special property (lowercase) <literal>id</literal> can be used to "
"reference the unique identifier of an object. See <xref linkend=\"queryhql-"
"identifier-property\" /> for more information."
msgstr ""
"La propiedad especial <literal>id</literal> (en minúsculas) se puede "
"utilizar para referenciar el identificador único de un objeto. Consulte "
"<xref linkend=\"queryhql-"
"identifier-property\" /> para obtener más "
"información."

#. Tag: para
#, no-c-format
msgid "The second query is efficient and does not require a table join."
msgstr "La segunda consulta es eficiente y no se necesita una unión de tablas."

#. Tag: para
#, no-c-format
msgid ""
"Properties of composite identifiers can also be used. Consider the following "
"example where <literal>Person</literal> has composite identifiers consisting "
"of <literal>country</literal> and <literal>medicareNumber</literal>:"
msgstr ""
"También se pueden utilizar las propiedades de identificadores compuestos. "
"Considere el siguiente ejemplo en donde <literal>Person</literal> tiene "
"identificadores compuestos que consisten de <literal>country</literal> y "
"<literal>medicareNumber</literal>:"

#. Tag: para
#, no-c-format
msgid "Once again, the second query does not require a table join."
msgstr "Una vez más, la segunda consulta no requiere una unión de tablas."

#. Tag: para
#, no-c-format
msgid ""
"See <xref linkend=\"queryhql-identifier-property\" /> for more information "
"regarding referencing identifier properties)"
msgstr ""
"Consulte <xref linkend=\"queryhql-identifier-property\" /> para obtener "
"mayor información con relación a la referencia de propiedades del "
"identificador."

#. Tag: para
#, no-c-format
msgid ""
"The special property <literal>class</literal> accesses the discriminator "
"value of an instance in the case of polymorphic persistence. A Java class "
"name embedded in the where clause will be translated to its discriminator "
"value."
msgstr ""
"La propiedad especial <literal>class</literal> acccede al valor "
"discriminador de una instancia en el caso de persistencia polimórfica. Un "
"nombre de clase Java incluído en la cláusula where será traducido a su valor "
"discriminador."

#. Tag: para
#, no-c-format
msgid ""
"You can also use components or composite user types, or properties of said "
"component types. See <xref linkend=\"queryhql-components\" /> for more "
"information."
msgstr ""
"También puede utilizar componentes o tipos de usuario compuestos o "
"propiedades de dichos tipos de componentes. Consulte <xref linkend="
"\"queryhql-components\" /> para obtener más detalles."

#. Tag: para
#, no-c-format
msgid ""
"An \"any\" type has the special properties <literal>id</literal> and "
"<literal>class</literal> that allows you to express a join in the following "
"way (where <literal>AuditLog.item</literal> is a property mapped with "
"<literal>&lt;any&gt;</literal>):"
msgstr ""
"Un tipo \"any\" tiene las propiedades especiales <literal>id</literal> y "
"<literal>class</literal>, permiténdole expresar una unión de la siguiente "
"forma (en donde <literal>AuditLog.item</literal> es una propiedad mapeada "
"con <literal>&lt;any&gt;</literal>)."

#. Tag: para
#, no-c-format
msgid ""
"The <literal>log.item.class</literal> and <literal>payment.class</literal> "
"would refer to the values of completely different database columns in the "
"above query."
msgstr ""
"La <literal>log.item.class</literal> y <literal>payment.class</literal> "
"harían referencia a los valores de columnas de la base de datos "
"completamente diferentes en la consulta anterior."

#. Tag: title
#, no-c-format
msgid "Expressions"
msgstr "Expresiones"

#. Tag: para
#, no-c-format
msgid ""
"Expressions used in the <literal>where</literal> clause include the "
"following:"
msgstr ""
"Las expresiones utilizadas en la cláusula <literal>where</literal> incluyen "
"lo siguiente:"

#. Tag: para
#, no-c-format
msgid "mathematical operators: <literal>+, -, *, /</literal>"
msgstr "operadores matemáticos: <literal>+, -, *, /</literal>"

#. Tag: para
#, no-c-format
msgid ""
"binary comparison operators: <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</"
"literal>"
msgstr ""
"operadores de comparación binarios: <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, "
"like</literal>"

#. Tag: para
#, no-c-format
msgid "logical operations <literal>and, or, not</literal>"
msgstr "operadores lógicos <literal>and, or, not</literal>"

#. Tag: para
#, no-c-format
msgid "Parentheses <literal>( )</literal> that indicates grouping"
msgstr "Paréntesis <literal>( )</literal> que indican agrupación"

#. Tag: para
#, no-c-format
msgid ""
"<literal>in</literal>, <literal>not in</literal>, <literal>between</"
"literal>, <literal>is null</literal>, <literal>is not null</literal>, "
"<literal>is empty</literal>, <literal>is not empty</literal>, "
"<literal>member of</literal> and <literal>not member of</literal>"
msgstr ""
"<literal>in</literal>, <literal>not in</literal>, <literal>between</"
"literal>, <literal>is null</literal>, <literal>is not null</literal>, "
"<literal>is empty</literal>, <literal>is not empty</literal>, "
"<literal>member of</literal> y <literal>not member of</literal>"

#. Tag: para
#, no-c-format
msgid ""
"\"Simple\" case, <literal>case ... when ... then ... else ... end</literal>, "
"and \"searched\" case, <literal>case when ... then ... else ... end</literal>"
msgstr ""
"Caso \"simple\", <literal>case ... when ... then ... else ... end</literal>, "
"y caso \"buscado\", <literal>case when ... then ... else ... end</literal>"

#. Tag: para
#, no-c-format
msgid ""
"string concatenation <literal>...||...</literal> or <literal>concat(...,...)"
"</literal>"
msgstr ""
"concatenación de cadenas <literal>...||...</literal> o <literal>concat"
"(...,...)</literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>current_date()</literal>, <literal>current_time()</literal>, and "
"<literal>current_timestamp()</literal>"
msgstr ""
"<literal>current_date()</literal>, <literal>current_time()</literal> y "
"<literal>current_timestamp()</literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour"
"(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, "
"and <literal>year(...)</literal>"
msgstr ""
"<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour"
"(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, "
"and <literal>year(...)</literal>"

#. Tag: para
#, no-c-format
msgid ""
"Any function or operator defined by EJB-QL 3.0: <literal>substring(), trim"
"(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()"
"</literal>"
msgstr ""
"Cualquier función u operador definido por EJB-QL 3.0: <literal>substring(), "
"trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), "
"mod()</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>coalesce()</literal> and <literal>nullif()</literal>"
msgstr "<literal>coalesce()</literal> y <literal>nullif()</literal>"

#. Tag: para
#, no-c-format
msgid ""
"<literal>str()</literal> for converting numeric or temporal values to a "
"readable string"
msgstr ""
"<literal>str()</literal> para convertir valores numéricos o temporales a una "
"cadena legible."

#. Tag: para
#, no-c-format
msgid ""
"<literal>cast(... as ...)</literal>, where the second argument is the name "
"of a Hibernate type, and <literal>extract(... from ...)</literal> if ANSI "
"<literal>cast()</literal> and <literal>extract()</literal> is supported by "
"the underlying database"
msgstr ""
"<literal>cast(... as ...)</literal>, donde el segundo argumento es el nombre "
"de un tipo de Hibernate , y <literal>extract(... from ...)</literal> si "
"<literal>cast()</literal> y <literal>extract()</literal> es soportado por la "
"base de datos subyacente."

#. Tag: para
#, no-c-format
msgid ""
"the HQL <literal>index()</literal> function, that applies to aliases of a "
"joined indexed collection"
msgstr ""
"la función <literal>index()</literal> de HQL, que se aplica a alias de una "
"colección indexada unida."

#. Tag: para
#, no-c-format
msgid ""
"HQL functions that take collection-valued path expressions: <literal>size(), "
"minelement(), maxelement(), minindex(), maxindex()</literal>, along with the "
"special <literal>elements()</literal> and <literal>indices</literal> "
"functions that can be quantified using <literal>some, all, exists, any, in</"
"literal>."
msgstr ""
"Las funciones de HQL que tomen expresiones de ruta valuadas en colecciones: "
"<literal>size(), minelement(), maxelement(), minindex(), maxindex()</"
"literal>, junto con las funciones especiales <literal>elements()</literal> e "
"<literal>indices</literal>, las cuales se pueden cuantificar utilizando "
"<literal>some, all, exists, any, in</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Any database-supported SQL scalar function like <literal>sign()</literal>, "
"<literal>trunc()</literal>, <literal>rtrim()</literal>, and <literal>sin()</"
"literal>"
msgstr ""
"Cualquier función escalar SQL soportada por la base de datos como "
"<literal>sign()</literal>, <literal>trunc()</literal>, <literal>rtrim()</"
"literal> y <literal>sin()</literal>"

#. Tag: para
#, no-c-format
msgid "JDBC-style positional parameters <literal>?</literal>"
msgstr "parámetros posicionales JDBC <literal>?</literal>"

#. Tag: para
#, no-c-format
msgid ""
"named parameters <literal>:name</literal>, <literal>:start_date</literal>, "
"and <literal>:x1</literal>"
msgstr ""
"parámetros con nombre <literal>:name</literal>, <literal>:start_date</"
"literal> y <literal>:x1</literal>"

#. Tag: para
#, no-c-format
msgid ""
"SQL literals <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E"
"+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"
msgstr ""
"literales SQL <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E"
"+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"

#. Tag: para
#, no-c-format
msgid ""
"Java <literal>public static final</literal> constants <literal>eg.Color."
"TABBY</literal>"
msgstr ""
"constantes Java <literal>public static final</literal><literal>eg.Color."
"TABBY</literal>"

#. Tag: para
#, no-c-format
msgid "<literal>in</literal> and <literal>between</literal> can be used as follows:"
msgstr "<literal>in</literal> y <literal>between</literal> pueden utilizarse así:"

#. Tag: para
#, no-c-format
msgid "The negated forms can be written as follows:"
msgstr "Las formas negadas se pueden escribir así:"

#. Tag: para
#, no-c-format
msgid ""
"Similarly, <literal>is null</literal> and <literal>is not null</literal> can "
"be used to test for null values."
msgstr ""
"De manera similar, <literal>is null</literal> y <literal>is not null</"
"literal> se pueden utilizar para probar valores nulos."

#. Tag: para
#, no-c-format
msgid ""
"Booleans can be easily used in expressions by declaring HQL query "
"substitutions in Hibernate configuration:"
msgstr ""
"Los valores booleanos se pueden utilizar fácilmente en expresiones "
"declarando substituciones de consulta HQL en la configuración de Hibernate:"

#. Tag: para
#, no-c-format
msgid ""
"This will replace the keywords <literal>true</literal> and <literal>false</"
"literal> with the literals <literal>1</literal> and <literal>0</literal> in "
"the translated SQL from this HQL:"
msgstr ""
"Esto remplazará las palabras clave <literal>true</literal> y <literal>false</"
"literal> con los literales <literal>1</literal> y <literal>0</literal> en el "
"SQL traducido de este HQL:"

#. Tag: para
#, no-c-format
msgid ""
"You can test the size of a collection with the special property "
"<literal>size</literal> or the special <literal>size()</literal> function."
msgstr ""
"Puede comprobar el tamaño de una colección con la propiedad especial "
"<literal>size</literal> o la función especial <literal>size()</literal>."

#. Tag: para
#, no-c-format
msgid ""
"For indexed collections, you can refer to the minimum and maximum indices "
"using <literal>minindex</literal> and <literal>maxindex</literal> functions. "
"Similarly, you can refer to the minimum and maximum elements of a collection "
"of basic type using the <literal>minelement</literal> and "
"<literal>maxelement</literal> functions. For example:"
msgstr ""
"Para las colecciones indexadas, puede referirse a los índices máximo y "
"mínimo utilizando las funciones <literal>minindex</literal> y "
"<literal>maxindex</literal>. De manera similar, se puede referir a los "
"elementos máximo y mínimo de una colección de tipo básico utilizando las "
"funciones <literal>minelement</literal> y <literal>maxelement</literal>. Por "
"ejemplo: "

#. Tag: para
#, no-c-format
msgid ""
"The SQL functions <literal>any, some, all, exists, in</literal> are "
"supported when passed the element or index set of a collection "
"(<literal>elements</literal> and <literal>indices</literal> functions) or "
"the result of a subquery (see below):"
msgstr ""
"Las funciones SQL <literal>any, some, all, exists, in</literal> están "
"soportadas cuando se les pasa el conjunto de elementos o índices de una "
"colección (las funciones <literal>elements</literal> e <literal>indices</"
"literal>) o el resultado de una subconsulta (vea a continuación):"

#. Tag: para
#, no-c-format
msgid ""
"Note that these constructs - <literal>size</literal>, <literal>elements</"
"literal>, <literal>indices</literal>, <literal>minindex</literal>, "
"<literal>maxindex</literal>, <literal>minelement</literal>, "
"<literal>maxelement</literal> - can only be used in the where clause in "
"Hibernate3."
msgstr ""
"Note que estas construcciones - <literal>size</literal>, <literal>elements</"
"literal>, <literal>indices</literal>, <literal>minindex</literal>, "
"<literal>maxindex</literal>, <literal>minelement</literal>, "
"<literal>maxelement</literal> - solo se pueden utilizar en la cláusula where "
"en Hibernate3."

#. Tag: para
#, no-c-format
msgid ""
"Elements of indexed collections (arrays, lists, and maps) can be referred to "
"by index in a where clause only:"
msgstr ""
"Los elementos de colecciones indexadas (arrays, listas, mapas) se pueden "
"referir por índice sólamente en una cláusula where:"

#. Tag: para
#, no-c-format
msgid ""
"The expression inside <literal>[]</literal> can even be an arithmetic "
"expression:"
msgstr ""
"La expresión dentro de <literal>[]</literal> puede incluso ser una expresión "
"aritmética:"

#. Tag: para
#, no-c-format
msgid ""
"HQL also provides the built-in <literal>index()</literal> function for "
"elements of a one-to-many association or collection of values."
msgstr ""
"HQL también proporciona la función incorporada <literal>index()</literal>, "
"para los elementos de una asociación uno-a-muchos o una colección de valores."

#. Tag: para
#, no-c-format
msgid "Scalar SQL functions supported by the underlying database can be used:"
msgstr ""
"Se pueden utilizar las funciones SQL escalares soportadas por la base de "
"datos subyacente:"

#. Tag: para
#, no-c-format
msgid ""
"Consider how much longer and less readable the following query would be in "
"SQL:"
msgstr "Considere qué tan larga y menos leíble sería la siguiente consulta en SQL:"

#. Tag: para
#, no-c-format
msgid "<emphasis>Hint:</emphasis> something like"
msgstr "<emphasis>Ayuda:</emphasis> algo como"

#. Tag: title
#, no-c-format
msgid "The order by clause"
msgstr "La cláusula order by"

#. Tag: para
#, no-c-format
msgid ""
"The list returned by a query can be ordered by any property of a returned "
"class or components:"
msgstr ""
"La lista retornada por una consulta se puede ordenar por cualquier propiedad "
"de una clase retornada o componentes:"

#. Tag: para
#, no-c-format
msgid ""
"The optional <literal>asc</literal> or <literal>desc</literal> indicate "
"ascending or descending order respectively."
msgstr ""
"Los <literal>asc</literal> o <literal>desc</literal> opcionales indican "
"ordenamiento ascendente o descendente respectivamente."

#. Tag: title
#, no-c-format
msgid "The group by clause"
msgstr "La cláusula group by"

#. Tag: para
#, no-c-format
msgid ""
"A query that returns aggregate values can be grouped by any property of a "
"returned class or components:"
msgstr ""
"Una consulta que retorna valores agregados  se puede agrupar por cualquier "
"propiedad de una clase retornada o componentes:"

#. Tag: para
#, no-c-format
msgid "A <literal>having</literal> clause is also allowed."
msgstr "Se permite también una cláusula <literal>having</literal>."

#. Tag: para
#, no-c-format
msgid ""
"SQL functions and aggregate functions are allowed in the <literal>having</"
"literal> and <literal>order by</literal> clauses if they are supported by "
"the underlying database (i.e., not in MySQL)."
msgstr ""
"Las funciones SQL y las funciones de agregación SQL están permitidas en las "
"cláusulas <literal>having</literal> y <literal>order by</literal>, si están "
"soportadas por la base de datos subyacente (por ejemplo, no lo están en "
"MySQL). "

#. Tag: para
#, no-c-format
msgid ""
"Neither the <literal>group by</literal> clause nor the <literal>order by</"
"literal> clause can contain arithmetic expressions. Hibernate also does not "
"currently expand a grouped entity, so you cannot write <literal>group by "
"cat</literal> if all properties of <literal>cat</literal> are non-"
"aggregated. You have to list all non-aggregated properties explicitly."
msgstr ""
"La cláusula <literal>group by</literal> ni la cláusula <literal>order by</"
"literal> pueden contener expresiones aritméticas. Hibernate tampocoo expande "
"una entidad agrupada así que no puede escribir <literal>group by cat</"
"literal> si todas las propiedades de <literal>cat</literal> son no-"
"agregadas. Tiene que enumerar todas la propiedades no-agregadas "
"explícitamente."

#. Tag: title
#, no-c-format
msgid "Subqueries"
msgstr "Subconsultas"

#. Tag: para
#, no-c-format
msgid ""
"For databases that support subselects, Hibernate supports subqueries within "
"queries. A subquery must be surrounded by parentheses (often by an SQL "
"aggregate function call). Even correlated subqueries (subqueries that refer "
"to an alias in the outer query) are allowed."
msgstr ""
"Para bases de datos que soportan subconsultas, Hibernate soporta "
"subconsultas dentro de consultas. Una subconsulta se debe encerrar entre "
"paréntesis (frecuentemente por una llamada a una función de agregación SQL). "
"Incluso se permiten subconsultas correlacionadas (subconsultas que se "
"refieren a un alias en la consulta exterior)."

#. Tag: para
#, no-c-format
msgid "Note that HQL subqueries can occur only in the select or where clauses."
msgstr ""
"Note que las subconsultas HQL pueden ocurrir sólamente en las cláusulas "
"select o where."

#. Tag: para
#, no-c-format
msgid ""
"Note that subqueries can also utilize <literal>row value constructor</"
"literal> syntax. See <xref linkend=\"queryhql-tuple\" /> for more "
"information."
msgstr ""
"Note que las subconsultas también pueden utilizar la sintaxis <literal>row "
"value constructor</literal>. Consulte la <xref linkend=\"queryhql-tuple\" /> para obtener más información."

#. Tag: title
#, no-c-format
msgid "HQL examples"
msgstr "Ejemplos de HQL"

#. Tag: para
#, no-c-format
msgid ""
"Hibernate queries can be quite powerful and complex. In fact, the power of "
"the query language is one of Hibernate's main strengths. The following "
"example queries are similar to queries that have been used on recent "
"projects. Please note that most queries you will write will be much simpler "
"than the following examples."
msgstr ""
"Las consultas de Hibernate pueden ser bastante potentes y complejas. De "
"hecho, el poder del lenguaje de consulta es uno de las fortalezas "
"principales de Hibernate. He aquí algunos ejemplos de consultas muy "
"similares a las consultas de proyectos recientes. Note que la mayoría de las "
"consultas que escribirá son mucho más simples que los siguientes ejemplos."

#. Tag: para
#, no-c-format
msgid ""
"The following query returns the order id, number of items, the given minimum "
"total value and the total value of the order for all unpaid orders for a "
"particular customer. The results are ordered by total value. In determining "
"the prices, it uses the current catalog. The resulting SQL query, against "
"the <literal>ORDER</literal>, <literal>ORDER_LINE</literal>, "
"<literal>PRODUCT</literal>, <literal>CATALOG</literal> and <literal>PRICE</"
"literal> tables has four inner joins and an (uncorrelated) subselect."
msgstr ""
"La siguiente consulta retorna el order id, número de items y valor total "
"mínimo dado y el valor de la orden para todas las órdenes no pagadas de un "
"cliente en particular. Los resultados se ordenan de acuerdo al valor total. "
"Al determinar los precios, usa el catálogo actual. La consulta SQL "
"resultante, contra las tablas <literal>ORDER</literal>, <literal>ORDER_LINE</"
"literal>, <literal>PRODUCT</literal>, <literal>CATALOG</literal> y "
"<literal>PRICE</literal> tiene cuatro uniones interiores y una subselección "
"(no correlacionada)."

#. Tag: para
#, no-c-format
msgid ""
"What a monster! Actually, in real life, I'm not very keen on subqueries, so "
"my query was really more like this:"
msgstr ""
"¡Qué monstruo! Realmente, en la vida real, no me gustan mucho las "
"subconsultas, de modo que mi consulta fue realmente algo como esto:"

#. Tag: para
#, no-c-format
msgid ""
"The next query counts the number of payments in each status, excluding all "
"payments in the <literal>AWAITING_APPROVAL</literal> status where the most "
"recent status change was made by the current user. It translates to an SQL "
"query with two inner joins and a correlated subselect against the "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal> and "
"<literal>PAYMENT_STATUS_CHANGE</literal> tables."
msgstr ""
"La próxima consulta cuenta el número de pagos en cada estado, excluyendo "
"todos los pagos en el estado <literal>AWAITING_APPROVAL</literal> donde el "
"cambio más reciente al estado lo hizo el usuario actual. Se traduce en una "
"consulta SQL con dos uniones interiores y una subselección correlacionada "
"contra las tablas <literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</"
"literal> y <literal>PAYMENT_STATUS_CHANGE</literal>."

#. Tag: para
#, no-c-format
msgid ""
"If the <literal>statusChanges</literal> collection was mapped as a list, "
"instead of a set, the query would have been much simpler to write."
msgstr ""
"Si la colección <literal>statusChanges</literal> se mapeara como una lista, "
"en vez de un conjunto, la consulta habría sido mucho más simple de escribir."

#. Tag: para
#, no-c-format
msgid ""
"The next query uses the MS SQL Server <literal>isNull()</literal> function "
"to return all the accounts and unpaid payments for the organization to which "
"the current user belongs. It translates to an SQL query with three inner "
"joins, an outer join and a subselect against the <literal>ACCOUNT</literal>, "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal>, "
"<literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> and "
"<literal>ORG_USER</literal> tables."
msgstr ""
"La próxima consulta utiliza la función <literal>isNull()</literal> de MS SQL "
"Server para devolver todas las cuentas y pagos aún no cancelados de la "
"organización a la que pertenece el usuario actual. Se traduce como una "
"consulta SQL con tres uniones interiores, una unión exterior y una "
"subselección contra las tablas <literal>ACCOUNT</literal>, <literal>PAYMENT</"
"literal>, <literal>PAYMENT_STATUS</literal>, <literal>ACCOUNT_TYPE</"
"literal>, <literal>ORGANIZATION</literal> y <literal>ORG_USER</literal>."

#. Tag: para
#, no-c-format
msgid "For some databases, we would need to do away with the (correlated) subselect."
msgstr ""
"Para algunas bases de datos, necesitaríamos eliminar la subselección "
"(correlacionada)."

#. Tag: title
#, no-c-format
msgid "Bulk update and delete"
msgstr "Declaraciones UPDATE y DELETE masivas"

#. Tag: para
#, no-c-format
msgid ""
"HQL now supports <literal>update</literal>, <literal>delete</literal> and "
"<literal>insert ... select ...</literal> statements. See <xref linkend="
"\"batch-direct\" /> for more information."
msgstr ""
"HQL ahora soporta declaraciones <literal>update</literal>, <literal>delete</"
"literal> e <literal>insert ... select ...</literal>. Consulte la <xref linkend="
"\"batch-direct\" /> para obtener mayor información. "

#. Tag: title
#, no-c-format
msgid "Tips &amp; Tricks"
msgstr "Consejos y Trucos"

#. Tag: para
#, no-c-format
msgid "You can count the number of query results without returning them:"
msgstr "Puede contar el número de resultados de una consulta sin retornarlos:"

#. Tag: para
#, no-c-format
msgid "To order a result by the size of a collection, use the following query:"
msgstr ""
"Para ordenar un resultado por el tamaño de una colección, utilice la "
"siguiente consulta:"

#. Tag: para
#, no-c-format
msgid ""
"If your database supports subselects, you can place a condition upon "
"selection size in the where clause of your query:"
msgstr ""
"Si su base de datos soporta subselecciones, puede colocar una condición "
"sobre el tamaño de selección en la cláusula where de su consulta:"

#. Tag: para
#, no-c-format
msgid "If your database does not support subselects, use the following query:"
msgstr ""
"Si su base de datos no soporta subselecciones, utilice la siguiente "
"consulta: "

#. Tag: para
#, no-c-format
msgid ""
"As this solution cannot return a <literal>User</literal> with zero messages "
"because of the inner join, the following form is also useful:"
msgstr ""
"Como esta solución no puede retornar un <literal>User</literal> con cero "
"mensajes debido a la unión interior, la siguiente forma también es útil:"

#. Tag: para
#, no-c-format
msgid "Properties of a JavaBean can be bound to named query parameters:"
msgstr ""
"Las propiedades de un JavaBean pueden ser ligadas a los parámetros de "
"consulta con nombre:"

#. Tag: para
#, no-c-format
msgid ""
"Collections are pageable by using the <literal>Query</literal> interface "
"with a filter:"
msgstr ""
"Las colecciones son paginables usando la interfaz <literal>Query</literal> "
"con un filtro:"

#. Tag: para
#, no-c-format
msgid "Collection elements can be ordered or grouped using a query filter:"
msgstr ""
"Los elementos de colección se pueden ordenar o agrupar usando un filtro de "
"consulta:"

#. Tag: para
#, no-c-format
msgid "You can find the size of a collection without initializing it:"
msgstr "Puede hallar el tamaño de una colección sin inicializarla:"

#. Tag: title
#, no-c-format
msgid "Components"
msgstr "Componentes"

#. Tag: para
#, no-c-format
msgid ""
"Components can be used similarly to the simple value types that are used in "
"HQL queries. They can appear in the <literal>select</literal> clause as "
"follows:"
msgstr ""
"Los componentes se pueden utilizar de la misma manera en que se pueden "
"utilizar los tipos de valores simples en consultas HQL. Pueden aparecer en "
"la cláusula <literal>select</literal> así:"

#. Tag: para
#, no-c-format
msgid ""
"where the Person's name property is a component. Components can also be used "
"in the <literal>where</literal> clause:"
msgstr ""
"en donde el nombre de la Persona es un componente. Los componentes también "
"se pueden utilizar en la cláusula <literal>where</literal>:"

#. Tag: para
#, no-c-format
msgid "Components can also be used in the <literal>order by</literal> clause:"
msgstr ""
"Los componentes también se pueden utilizar en la cláusula <literal>where</"
"literal>:"

#. Tag: para
#, no-c-format
msgid ""
"Another common use of components is in <link linkend=\"queryhql-tuple\">row "
"value constructors</link>."
msgstr ""
"Otro uso común de los componentes se encuentra en <link linkend=\"queryhql-tuple\">row "
"value constructors</link>."

#. Tag: title
#, no-c-format
msgid "Row value constructor syntax"
msgstr "Sintaxis del constructor de valores por fila"

#. Tag: para
#, no-c-format
msgid ""
"HQL supports the use of ANSI SQL <literal>row value constructor</literal> "
"syntax, sometimes referred to AS <literal>tuple</literal> syntax, even "
"though the underlying database may not support that notion. Here, we are "
"generally referring to multi-valued comparisons, typically associated with "
"components. Consider an entity Person which defines a name component:"
msgstr ""
"HQL soporta la utilización de la sintaxis <literal>row value constructor</"
"literal> de SQL ANSI que a veces se denomina sintaxis <literal>tuple</"
"literal>, aunque puede que la base de datos subyacentes no soporte esa "
"noción. Aquí estamos refiriéndonos generalmente a las comparaciones "
"multivaluadas que se asocian típicamente con los componentes. Considere una "
"entidad Persona, la cual define un componente de nombre:"

#. Tag: para
#, no-c-format
msgid ""
"That is valid syntax although it is a little verbose. You can make this more "
"concise by using <literal>row value constructor</literal> syntax:"
msgstr ""
"Esa es una sintaxis válida aunque un poco verbosa. Puede hacerlo un poco más "
"conciso utilizando la sintaxis <literal>row value constructor</literal>:"

#. Tag: para
#, no-c-format
msgid ""
"It can also be useful to specify this in the <literal>select</literal> "
"clause:"
msgstr ""
"También puede ser útil especificar esto en la cláusula <literal>select</"
"literal>:"

#. Tag: para
#, no-c-format
msgid ""
"Using <literal>row value constructor</literal> syntax can also be beneficial "
"when using subqueries that need to compare against multiple values:"
msgstr ""
"También puede ser beneficioso el utilizar la sintaxis <literal>row value "
"constructor</literal> cuando se utilizan subconsultas que necesitan "
"compararse con valores múltiples:"

#. Tag: para
#, no-c-format
msgid ""
"One thing to consider when deciding if you want to use this syntax, is that "
"the query will be dependent upon the ordering of the component sub-"
"properties in the metadata."
msgstr ""
"Algo que se debe tomar en consideración al decidir si quiere usar esta "
"sintaxis es que la consulta dependerá del orden de las sub-propiedades "
"componentes en los metadatos."

