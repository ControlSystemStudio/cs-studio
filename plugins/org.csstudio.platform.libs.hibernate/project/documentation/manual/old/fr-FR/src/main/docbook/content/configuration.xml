<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="session-configuration" revision="1">

    <title>Configuration</title>
    
    <para>
        Parce qu'Hibernate est conçu pour fonctionner dans différents environnements,
        il existe beaucoup de paramètres de configuration. Heureusement, la plupart
        ont des valeurs par défaut appropriées et la distribution d'Hibernate contient
        un exemple de fichier <literal>hibernate.properties</literal> dans le répertoire
        <literal>etc/</literal> qui montre les différentes options. Vous n'avez qu'à 
        placer ce fichier dans votre classpath et à l'adapter.
    </para>

    <sect1 id="configuration-programmatic" revision="1">
        <title>Configuration par programmation</title>

        <para>
            Une instance de <literal>org.hibernate.cfg.Configuration</literal>
            représente un ensemble de mappings des classes Java d'une application vers
            la base de données SQL. La <literal>Configuration</literal> est utilisée
            pour construire un objet (immuable) <literal>SessionFactory</literal>.
            Les mappings sont constitués d'un ensemble de fichiers de mapping XML.
        </para>

        <para>
            Vous pouvez obtenir une instance de <literal>Configuration</literal>
            en l'instanciant directement et en spécifiant la liste des documents 
            XML de mapping. Si les fichiers de mapping sont dans le classpath, vous
            pouvez le faire à l'aide de la méthode <literal>addResource()</literal> :
        </para>

        <programlisting><![CDATA[Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");]]></programlisting>

        <para>
            Une alternative (parfois meilleure)  est de spécifier les classes mappées
            et de laisser Hibernate trouver les documents de mapping pour vous :
        </para>

        <programlisting><![CDATA[Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);]]></programlisting>

        <para>
            Hibernate va rechercher les fichiers de mappings 
            <literal>/org/hibernate/auction/Item.hbm.xml</literal> et
            <literal>/org/hibernate/auction/Bid.hbm.xml</literal> dans le classpath.
            Cette approche élimine les noms de fichiers en dur.
        </para>
        
        <para>
            Une <literal>Configuration</literal> vous permet également de préciser des
            propriétés de configuration :
        </para>

        <programlisting><![CDATA[Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");]]></programlisting>

        <para>
            Ce n'est pas le seul moyen de passer des propriétés de configuration à Hibernate.
            Les différentes options sont :
        </para>

        <orderedlist spacing="compact">
            <listitem>
                <para>
                    Passer une instance de <literal>java.util.Properties</literal>
                    à <literal>Configuration.setProperties()</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Placer <literal>hibernate.properties</literal> dans un répertoire racine
                    du classpath
                </para>
            </listitem>
            <listitem>
                <para>
                    Positionner les propriétés <literal>System</literal> en utilisant
                    <literal>java -Dproperty=value</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Inclure des éléments <literal>&lt;property&gt;</literal> dans le
                    fichier <literal>hibernate.cfg.xml</literal> (voir plus loin).
                </para>
            </listitem>
        </orderedlist>

        <para>
            L'utilisation d'<literal>hibernate.properties</literal> est l'approche la plus
            simple si vous voulez démarrer rapidement
        </para>
        <para>
            La <literal>Configuration</literal> est un objet de démarrage qui sera supprimé
            une fois qu'une <literal>SessionFactory</literal> aura été créée.
        </para>

    </sect1>
    
    <sect1 id="configuration-sessionfactory">
        <title>Obtenir une SessionFactory</title>

        <para>
            Une fois que tous les mappings ont été parsés par la <literal>Configuration</literal>, 
            l'application doit obtenir une fabrique d'instances de <literal>Session</literal>. 
            Cette fabrique sera partagée entre tous les threads de l'application :
        </para>

        <programlisting><![CDATA[SessionFactory sessions = cfg.buildSessionFactory();]]></programlisting>

        <para>
            Hibernate permet à votre application d'instancier plus d'une <literal>SessionFactory</literal>.
            Cela est pratique lorsque vous utilisez plus d'une base de données.
        </para>

    </sect1>

    <sect1 id="configuration-hibernatejdbc" revision="1">
        <title>Connexions JDBC</title>

        <para>
            Habituellement, vous voulez que la <literal>SessionFactory</literal> crée les connexions JDBC et
            les mette dans un pool pour vous. Si vous suivez cette approche, ouvrir une <literal>Session</literal> 
            est aussi simple que :
        </para>

        <programlisting><![CDATA[Session session = sessions.openSession(); // open a new Session]]></programlisting>
        
        <para>
            Dès que vous ferez quelquechose qui requiert un accès à la base de données, une connexion
            JDBC sera récupérée dans le pool.
        </para>

        <para>
            Pour faire cela, il faut passer les propriétés de la connexion JDBC à Hibernate.
            Tous les noms des propriétés Hibernate et leur signification sont définies dans
            la classe <literal>org.hibernate.cfg.Environment</literal>. Nous allons maintenant
            décrire les paramètres de configuration des connexions JDBC les plus importants.
        </para>

         <para>
            Hibernate obtiendra des connexions (et les mettra dans un pool) en utilisant 
            <literal>java.sql.DriverManager</literal> si vous positionnez les paramètres de la manière
            suivante :
        </para>

        <table frame="topbot">
            <title>Propriétés JDBC d'Hibernate</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nom de la propriété</entry>
                        <entry>Fonction</entry>
                    </row>
                </thead>
            <tbody>
            <row>
                <entry>
                    <literal>hibernate.connection.driver_class</literal>
                </entry>
                <entry>
                    <emphasis>Classe du driver jdbc</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.url</literal>
                </entry>
                <entry>
                    <emphasis>URL jdbc</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.username</literal>
                </entry>
                <entry>
                    <emphasis>utilisateur de la base de données</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.password</literal>
                </entry>
                <entry>
                    <emphasis>mot de passe de la base de données</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.pool_size</literal>
                </entry>
                <entry>
                    <emphasis>nombre maximum de connexions dans le pool</emphasis>
                </entry>
            </row>
            </tbody>
            </tgroup>
        </table>

        <para>
            L'algorithme natif de pool de connexions d'Hibernate est plutôt rudimentaire. Il a été fait 
            dans le but de vous aider à démarrer et <emphasis>n'est pas prévu pour un système en production</emphasis>
            ou même pour un test de peformance. Utilisez plutôt un pool tiers pour de meilleures performances et une
            meilleure stabilité : pour cela, remplacez la propriété <literal>hibernate.connection.pool_size</literal> avec les propriétés
            spécifique au pool de connexions que vous avez choisi. Cela désactivera le pool de connexions interne
            d'Hibernate. Vous pouvez par exemple utiliser C3P0.
        </para>

        <para>
            C3P0 est un pool de connexions JDBC open source distribué avec Hibernate dans le répertoire
            <literal>lib</literal>. Hibernate utilisera son provider <literal>C3P0ConnectionProvider</literal>
            pour le pool de connexions si vous positionnez les propriétés <literal>hibernate.c3p0.*</literal>.
            Si vous voulez utiliser Proxool, référez vous au groupe de propriétés d'<literal>hibernate.properties</literal>
            correspondant et regardez sur le site web d'Hibernate pour plus d'informations.
        </para>

        <para>
            Voici un exemple de fichier <literal>hibernate.properties</literal> pour C3P0:
        </para>

        <programlisting id="c3p0-configuration" revision="1"><![CDATA[hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statement=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]></programlisting>

        <para>
            Dans le cadre de l'utilisation au sein d'un serveur d'applications,
            vous devriez quasiment toujours configurer Hibernate pour qu'il obtienne
            ses connexions de la <literal>DataSource</literal> du serveur d'application
            enregistrée dans le JNDI. Pour cela vous devrez définir au moins une des
            propriétés suivantes :
        </para>

        <table frame="topbot">
            <title>Propriété d'une Datasource Hibernate</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nom d'une propriété</entry>
                        <entry>fonction</entry>
                    </row>
                </thead>
            <tbody>
            <row>
                <entry>
                    <literal>hibernate.connection.datasource</literal>
                </entry>
                <entry>
                    <emphasis>Nom JNDI de la datasource</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.jndi.url</literal>
                </entry>
                <entry>
                    <emphasis>URL du fournisseur JNDI</emphasis> (optionnelle)
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.jndi.class</literal>
                </entry>
                <entry>
                    <emphasis>Classe de l'<literal>InitialContextFactory</literal> du JNDI</emphasis> (optionnelle)
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.username</literal>
                </entry>
                <entry>
                    <emphasis>utilisateur de la base de données</emphasis> (optionnelle)
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.password</literal>
                </entry>
                <entry>
                    <emphasis>mot de passe de la base de données</emphasis> (optionnelle)
                </entry>
            </row>
            </tbody>
            </tgroup>
        </table>

        <para>
            Voici un exemple de fichier <literal>hibernate.properties</literal>
            pour l'utilisation d'une datasource JNDI fournie par un serveur d'applications :
        </para>

        <programlisting><![CDATA[hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]></programlisting>

        <para>
            Les connexions JDBC obtenues à partir d'une datasource JNDI participeront automatiquement
            aux transactions gérées par le conteneur du serveur d'applications.
        </para>

        <para>
            Des propriétés supplémentaires de connexion peuvent être passées en préfixant
            le nom de la propriété par "<literal>hibernate.connnection</literal>". Par exemple,
            vous pouvez spécifier un jeu de caractères en utilisant 
            <literal>hibernate.connection.charSet</literal>.
        </para>

        <para>
            Vous pouvez fournir votre propre stratégie d'obtention des connexions JDBC en implémentant l'interface
            <literal>org.hibernate.connection.ConnectionProvider</literal>. Vous pouvez sélectionner
            une implémentation spécifique en positionnant <literal>hibernate.connection.provider_class</literal>.
        </para>

    </sect1>

    <sect1 id="configuration-optional" revision="1">
        <title>Propriétés de configuration optionnelles</title>
        
        <para>
            Il y a un certain nombre d'autres propriétés qui contrôlent le fonctionnement 
            d'Hibernate à l'exécution. Toutes sont optionnelles et ont comme valeurs par défaut
            des valeurs "raisonnables" pour un fonctionnement nominal.
        </para>

        <para>
            <emphasis>Attention : Certaines de ces propriétés sont uniquement de niveau System.</emphasis>
            Les propriétés de niveau System ne peuvent être positionnées que via la ligne de commande
            (<literal>java -Dproperty=value</literal>) ou être définies dans <literal>hibernate.properties</literal>.
            Elle <emphasis>ne peuvent pas</emphasis> l'être via une des autres techniques décrites ci-dessus.
        </para>

        <table frame="topbot" id="configuration-optional-properties" revision="8">
            <title>Propriétés de configuration d'Hibernate</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nom de la propriété</entry>
                        <entry>Fonction</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.dialect</literal>
                        </entry>
                        <entry>
                            Le nom de la classe du <literal>Dialect</literal> Hibernate.
                            qui permet à Hibernate de générer du SQL optimisé pour une
                            base de données relationnelle particulière.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>nom.complet.de.ma.classe.de.Dialect</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.show_sql</literal>
                        </entry>
                        <entry>
                            Ecrit toutes les requêtes SQL sur la console. Il s'agit d'une
                            alternative au positionnement de la catégorie de log
                            <literal>org.hibernate.SQL</literal> au niveau <literal>debug</literal>.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.format_sql</literal>
                        </entry>
                        <entry>
                            Formate et indente le sql dans la console et dans le log
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_schema</literal>
                        </entry>
                        <entry>
                            Positionne dans le SQL généré un schéma/tablespace par défaut pour les noms de
                            table ne l'ayant pas surchargé.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>MON_SCHEMA</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_catalog</literal>
                        </entry>
                        <entry>
                            Qualifie les noms de tables non qualifiées avec ce catalogue
                            dans le SQL généré.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>CATALOG_NAME</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.session_factory_name</literal>
                        </entry>
                        <entry>
                            La <literal>SessionFactory</literal> sera automatiquement
                            liée à ce nom dans le JNDI après sa création.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>jndi/nom/hierarchique</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.max_fetch_depth</literal>
                        </entry>
                        <entry>
                            Définit la profondeur maximale d'un arbre de chargement par
                            jointures ouvertes pour les associations à cardinalité unitaire
                            (un-à-un, plusieurs-à-un).
                            Un <literal>0</literal> désactive le chargement par jointure
                            ouverte.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                valeurs recommandées entre <literal>0</literal> et <literal>3</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_batch_fetch_size</literal>
                        </entry>
                        <entry>
                            Définit une taille par défaut pour le chargement par lot des associations
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                Valeurs recommandées : <literal>4</literal>, <literal>8</literal>, 
                                <literal>16</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_entity_mode</literal>
                        </entry>
                        <entry>
                            Définit un mode de représentation par défaut des entités pour
                            toutes les sessions ouvertes depuis cette <literal>SessionFactory</literal>
                            <para>
                                <literal>dynamic-map</literal>, <literal>dom4j</literal>,
                                <literal>pojo</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.order_updates</literal>
                        </entry>
                        <entry>
                            Force Hibernate à trier les updates SQL par la valeur de la clé
                            primaire des éléments qui sont mis à jour. Cela permet de limiter
                            les deadlocks de transaction dans les systèmes hautement concurents.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.generate_statistics</literal>
                        </entry>
                        <entry>
                            Si activé, Hibernate va collecter des statistiques utiles
                            pour le réglage des performances.
                            <para>
                                <emphasis role="strong">ex.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.use_identifer_rollback</literal>
                        </entry>
                        <entry>
                            Si activé, les propriétés correspondant à l'identifiant
                            des objets vont être remises aux valeurs par défaut lorsque
                            les objets seront supprimés.
                            <para>
                                <emphasis role="strong">ex.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.use_sql_comments</literal>
                        </entry>
                        <entry>
                            Si activé, Hibernate va générer des commentaires à l'intérieur
                            des requêtes SQL pour faciliter le debogage., par défaut à <literal>false</literal>.
                            <para>
                                <emphasis role="strong">ex.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

         <table frame="topbot" id="configuration-jdbc-properties" revision="8">
            <title>Propriétés Hibernate liées à JDBC et aux connexions</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nom de la propriété</entry>
                        <entry>Fonction</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.fetch_size</literal>
                        </entry>
                        <entry>
                            Une valeur non nulle détermine la taille de chargement
                            des statements JDBC (appelle 
                            <literal>Statement.setFetchSize()</literal>).
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.batch_size</literal>
                        </entry>
                        <entry>
                            Une valeur non nulle active l'utilisation par Hibernate des mises 
                            à jour par batch de JDBC2.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                les valeurs recommandées entre <literal>5</literal> et <literal>30</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.batch_versioned_data</literal>
                        </entry>
                        <entry>
                            Paramétrez cette propriété à <literal>true</literal> si votre pilote JDBC
                            retourne des row counts corrects depuis <literal>executeBatch()</literal> (il est 
                            souvent approprié d'activer cette option). Hibernate utilisera alors le "batched DML" pour
                            versionner automatiquement les données. Par défaut = <literal>false</literal>.
                            <para>
                                <emphasis role="strong">eg.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.factory_class</literal>
                        </entry>
                        <entry>
                           Sélectionne un <literal>Batcher</literal> personnalisé. La
                           plupart des applications n'auront pas besoin de cette propriété
                           de configuration
                            <para>
                                <emphasis role="strong">ex.</emphasis>
                                <literal>classname.of.BatcherFactory</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.use_scrollable_resultset</literal>
                        </entry>
                        <entry>
                            Active l'utilisation par Hibernate des resultsets scrollables 
                            de JDBC2. Cette propriété est seulement nécessaire lorsque l'on
                            utilise une connexion JDBC fournie par l'utilisateur. Autrement,
                            Hibernate utilise les métadonnées de la connexion.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.use_streams_for_binary</literal>
                        </entry>
                        <entry>
                            Utilise des flux lorsque l'on écrit/lit des types
                            <literal>binary</literal> ou <literal>serializable</literal>
                            vers et à partir de JDBC (propriété de niveau système).
                            <para>
                                <emphasis role="strong">ex.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.use_get_generated_keys</literal>
                        </entry>
                        <entry>
                            Active l'utilisation de <literal>PreparedStatement.getGeneratedKeys()</literal> de JDBC3
                            pour récupérer nativement les clés générées après insertion. Nécessite un pilote
                            JDBC3+, le mettre à false si votre pilote a des problèmes avec les générateurs
                            d'identifiant Hibernate. Par défaut, essaie de déterminer les possibilités du
                            pilote en utilisant les meta données de connexion.
                            <para>
                                <emphasis role="strong">eg.</emphasis>
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>                    
                    <row>
                        <entry>
                            <literal>hibernate.connection.provider_class</literal>
                        </entry>
                        <entry>
                            Le nom de la classe d'un <literal>ConnectionProvider</literal> personnalisé
                            qui fournit des connexions JDBC à Hibernate
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>classname.of.ConnectionProvider</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                    <entry>
                        <literal>hibernate.connection.isolation</literal>
                    </entry>
                    <entry>
                        Définit le niveau d'isolation des transactions JDBC. Regardez
                        <literal>java.sql.Connection</literal> pour connaître le
                        sens des différentes valeurs mais notez également que la plupart
                        des bases de données ne supportent pas tous les niveaux d'isolation.
                        <para>
                            <emphasis role="strong">ex.</emphasis> 
                            <literal>1, 2, 4, 8</literal>
                        </para>
                    </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.connection.autocommit</literal>
                        </entry>
                        <entry>
                            Active le mode de commit automatique (autocommit) pour les connexions
                            JDBC du pool (non recommandé).
                            <para>
                                <emphasis role="strong">ex.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.connection.release_mode</literal>
                        </entry>
                        <entry>
                            Spécifie à quel moment Hibernate doit relacher les connexion JDBC.
                            Par défaut une connexion JDBC est conservée jusqu'à ce que la session
                            soit explicitement fermée ou déconnectée. Pour une source de données
                            JTA d'un serveur d'application, vous devriez utiliser <literal>after_statement</literal>
                            pour libérer les connexions de manière plus agressive après chaque appel
                            JDBC. Pour une connexion non JTA, il est souvent préférable de libérer
                            la connexion à la fin de chaque transaction en utilisant <literal>after_transaction</literal>.
                            <literal>auto</literal> choisira <literal>after_statement</literal> pour
                            des transactions JTA et CMT et <literal>after_transaction</literal> pour
                            des transactions JDBC.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>on_close</literal> (default) | <literal>after_transaction</literal> |
                                <literal>after_statement</literal> | <literal>auto</literal>
			</para>                            <para>
				Note that this setting only affects <literal>Session</literal>s returned from
				<literal>SessionFactory.openSession</literal>.  For <literal>Session</literal>s
				obtained through <literal>SessionFactory.getCurrentSession</literal>, the
				<literal>CurrentSessionContext</literal> implementation configured for use
				controls the connection release mode for those <literal>Session</literal>s.
				See <xref linkend="architecture-current-session"/>
                            </para>
                        </entry>
                    </row>
                    <row>
                    <entry>
			    <literal>hibernate.connection.</literal><emphasis>&lt;propertyName&gt;</emphasis>
                    </entry>
                    <entry>
			    Passe la propriété JDBC <emphasis>&lt;propertyName&gt;</emphasis>
                        à <literal>DriverManager.getConnection()</literal>.
                    </entry>
                    </row>
                    <row>
                        <entry>
				<literal>hibernate.jndi.</literal><emphasis>&lt;propertyName&gt;</emphasis>
                        </entry>
                        <entry>
                           Passe la propriété <literal>propertyName</literal> à l'<literal>InitialContextFactory</literal>
                           de JNDI.
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-cache-properties" revision="7">
            <title>Propriétés du Cache d'Hibernate</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nom de la propriété</entry>
                        <entry>Fonction</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.cache.provider_class</literal>
                        </entry>
                        <entry>
                            Le nom de classe d'un <literal>CacheProvider</literal> 
                            spécifique.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>nom.de.classe.du.CacheProvider</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_minimal_puts</literal>
                        </entry>
                        <entry>
                            Optimise le cache de second niveau en minimisant les écritures,
                            au prix de plus de lectures. Ce paramètre est surtout utile pour
                            les caches en cluster et est activé par défaut dans hibernate3
                            pour les implémentations de cache en cluster.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_query_cache</literal>
                        </entry>
                        <entry>
                            Activer le cache de requête, les requêtes individuelles doivent tout
                            de même être déclarées comme pouvant être mise en cache.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_second_level_cache</literal>
                        </entry>
                        <entry>
                            Peut être utilisé pour désactiver complètement le cache de second niveau
                            qui est activé par défaut pour les classes qui spécifient un élément
                            <literal>&lt;cache&gt;</literal> dans leur mapping.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.query_cache_factory</literal>
                        </entry>
                        <entry>
                            Le nom de classe d'une interface <literal>QueryCacheFactory</literal> ,
                            par défaut = built-in <literal>StandardQueryCacheFactory</literal>.
                            <para>
                                <emphasis role="strong">ex.</emphasis>
                                <literal>nom.de.la.classe.de.QueryCacheFactory</literal>
                            </para>
                        </entry>
                    </row>

                    <row>
                        <entry>
                            <literal>hibernate.cache.region_prefix</literal>
                        </entry>
                        <entry>
                            Un préfixe à utiliser pour le nom des régions du 
                            cache de second niveau.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>prefix</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_structured_entries</literal>
                        </entry>
                        <entry>
                            Force Hibernate à stocker les données dans le cache de
                            second niveau dans un format plus adapté à la visualisation
                            par un humain.
                            <para>
                                <emphasis role="strong">ex.</emphasis>
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-transaction-properties" revision="9">
            <title>Propriétés des transactions Hibernate</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nom de la propriété</entry>
                        <entry>Fonction</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.factory_class</literal>
                        </entry>
                        <entry>
                            Le nom de classe d'une <literal>TransactionFactory</literal>
                            qui sera utilisée par l'API <literal>Transaction</literal>
                            d'Hibernate (la valeur par défaut est 
                            <literal>JDBCTransactionFactory</literal>).
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>nom.de.classe.d.une.TransactionFactory</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>jta.UserTransaction</literal>
                        </entry>
                        <entry>
                            Le nom JNDI utilisé par la <literal>JTATransactionFactory</literal>
                            pour obtenir la <literal>UserTransaction</literal> JTA du serveur 
                            d'applications.
                            <para>
                                <emphasis role="strong">eg.</emphasis> 
                                <literal>jndi/nom/compose</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.manager_lookup_class</literal>
                        </entry>
                        <entry>
                            Le nom de la classe du <literal>TransactionManagerLookup</literal>
                            - requis lorsque le cache de niveau JVM est activé ou lorsque l'on
                            utilise un générateur hilo dans un environnement JTA.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>nom.de.classe.du.TransactionManagerLookup</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.flush_before_completion</literal>
                        </entry>
                        <entry>
                            Si activé, la session sera automatiquement vidée durant la phase
                            qui précède la fin de la transaction (before completion). 
                            La gestion automatique de contexte fourni par Hibernate est
                            recommandée, voir
                            <xref linkend="architecture-current-session"/>.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.auto_close_session</literal>
                        </entry>
                        <entry>
                            Si activé, la session sera automatiquement fermé pendant la phase 
                            qui suit la fin de la transaction (after completion). 
                            La gestion automatique de contexte fourni par Hibernate est
                            recommandée, voir
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-misc-properties" revision="9">
            <title>Propriétés diverses</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nom de la propriété</entry>
                        <entry>Fonction</entry>
                    </row>
                </thead>
                <tbody>
                     <row>
                        <entry>
                            <literal>hibernate.current_session_context_class</literal>
                        </entry>
                        <entry>
                            Fournit une stratégie particulière pour contextualiser
                            la <literal>Session</literal> courante. Voir
                            <xref linkend="architecture-current-session"/> pour plus
                            d'informations sur les stratégies fournies.
                            <para>
                                <emphasis role="strong">eg.</emphasis>
                                <literal>jta</literal> | <literal>thread</literal> |
                                <literal>custom.Class</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.query.factory_class</literal>
                        </entry>
                        <entry>
                            Choisi l'implémentation du parseur de requête
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>org.hibernate.hql.ast.ASTQueryTranslatorFactory</literal> ou
                                <literal>org.hibernate.hql.classic.ClassicQueryTranslatorFactory</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.query.substitutions</literal>
                        </entry>
                        <entry>
                            Lien entre les tokens de requêtes Hibernate et les 
                            tokens SQL (les tokens peuvent être des fonctions ou des
                            noms littéraux par exemple).
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.hbm2ddl.auto</literal>
                        </entry>
                        <entry>
                            Valide ou exporte  automatiquement le schéma DDL vers la base de données
                            lorsque la <literal>SessionFactory</literal> est créée.
                            La valeur <literal>create-drop</literal> permet de supprimer 
                            le schéma de base de données lorsque la <literal>SessionFactory</literal>
                            est fermée explicitement.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>validate</literal> | <literal>update</literal> | 
                                <literal>create</literal> | <literal>create-drop</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cglib.use_reflection_optimizer</literal>
                        </entry>
                        <entry>
                            Active l'utilisation de CGLIB à la place de la réflexion à l'exécution
                            (Propriété de niveau système). La réflexion peut parfois être utile pour
                            résoudre des problèmes. Notez qu'Hibernate a tout de même toujours besoin
                            de CGLIB même si l'optimiseur est désactivé. Cette optimisation ne peut être
                            définie que dans le fichier <literal>hibernate.cfg.xml</literal>.
                            <para>
                                <emphasis role="strong">ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <sect2 id="configuration-optional-dialects" revision="1">
            <title>Dialectes SQL</title>

            <para>
                Vous devriez toujours positionner la propriété <literal>hibernate.dialect</literal> à
                la sous-classe de <literal>org.hibernate.dialect.Dialect</literal> appropriée à 
                votre base de données. Si vous spécifiez un dialecte,
                Hibernate utilisera des valeurs adaptées pour certaines autres
                propriétés listées ci-dessus, vous évitant l'effort de le faire à la main.
            </para>

            <table frame="topbot" id="sql-dialects" revision="2">
                <title>Dialectes SQL d'Hibernate (<literal>hibernate.dialect</literal>)</title>
                <tgroup cols="2">
                    <colspec colwidth="1*"/>
                    <colspec colwidth="2.5*"/>
                    <thead>
                        <row>
                            <entry>SGBD</entry>
                            <entry>Dialecte</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>DB2</entry> <entry><literal>org.hibernate.dialect.DB2Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>DB2 AS/400</entry> <entry><literal>org.hibernate.dialect.DB2400Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>DB2 OS390</entry> <entry><literal>org.hibernate.dialect.DB2390Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>PostgreSQL</entry> <entry><literal>org.hibernate.dialect.PostgreSQLDialect</literal></entry>
                        </row>
                        <row>
                            <entry>MySQL</entry> <entry><literal>org.hibernate.dialect.MySQLDialect</literal></entry>
                        </row>
                        <row>
                            <entry>MySQL with InnoDB</entry> <entry><literal>org.hibernate.dialect.MySQLInnoDBDialect</literal></entry>
                        </row>
                        <row>
                            <entry>MySQL with MyISAM</entry> <entry><literal>org.hibernate.dialect.MySQLMyISAMDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Oracle (any version)</entry> <entry><literal>org.hibernate.dialect.OracleDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Oracle 9i/10g</entry> <entry><literal>org.hibernate.dialect.Oracle9Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>Sybase</entry> <entry><literal>org.hibernate.dialect.SybaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Sybase Anywhere</entry> <entry><literal>org.hibernate.dialect.SybaseAnywhereDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Microsoft SQL Server</entry> <entry><literal>org.hibernate.dialect.SQLServerDialect</literal></entry>
                        </row>
                        <row>
                            <entry>SAP DB</entry> <entry><literal>org.hibernate.dialect.SAPDBDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Informix</entry> <entry><literal>org.hibernate.dialect.InformixDialect</literal></entry>
                        </row>
                        <row>
                            <entry>HypersonicSQL</entry> <entry><literal>org.hibernate.dialect.HSQLDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Ingres</entry> <entry><literal>org.hibernate.dialect.IngresDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Progress</entry> <entry><literal>org.hibernate.dialect.ProgressDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Mckoi SQL</entry> <entry><literal>org.hibernate.dialect.MckoiDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Interbase</entry> <entry><literal>org.hibernate.dialect.InterbaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Pointbase</entry> <entry><literal>org.hibernate.dialect.PointbaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>FrontBase</entry> <entry><literal>org.hibernate.dialect.FrontbaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Firebird</entry> <entry><literal>org.hibernate.dialect.FirebirdDialect</literal></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

        </sect2>

        <sect2 id="configuration-optional-outerjoin" revision="4">
            <title>Chargement par Jointure Ouverte</title>

            <para>
                Si votre base de données supporte les outer joins de type ANSI, Oracle ou Sybase, 
                <emphasis>le chargement par jointure ouverte</emphasis> devrait améliorer les 
                performances en limitant le nombre d'aller-retour avec la base de données (la
                base de données effectuant donc potentiellement plus de travail). Le chargement par
                jointure ouverte permet à un graphe entier d'objets connectés par une relation plusieurs-à-un,
                un-à-plusieurs ou un-à-un d'être chargé en un seul <literal>SELECT</literal> SQL.
            </para>

            <para>
                Le chargement par jointure ouverte peut être désactiver <emphasis>globalement</emphasis>
                en mettant la propriété <literal>hibernate.max_fetch_depth</literal> à <literal>0</literal>.
                Une valeur de <literal>1</literal> ou plus active le chargement par jointure ouverte
                pour les associatiosn un-à-un et plusieurs-à-un qui ont été mappée avec
                <literal>fetch="join"</literal>.
            </para>

            <para>
                Reportez vous à <xref linkend="performance-fetching"/> pour plus d'information.
            </para>

        </sect2>

        <sect2 id="configuration-optional-binarystreams" revision="1">
            <title>Flux binaires</title>

            <para>
                Oracle limite la taille d'un tableau de <literal>byte</literal> qui peuvent être
                passées à et vers son pilote JDBC. Si vous souhaitez utiliser des instances larges
                de type <literal>binary</literal> ou <literal>serializable</literal>, vous devez activer
                la propriété <literal>hibernate.jdbc.use_streams_for_binary</literal>. <emphasis>C'est une 
                fonctionalité de niveau système uniquement.</emphasis>
            </para>

        </sect2>

        <sect2 id="configuration-optional-cacheprovider" revision="2">
            <title>Cache de second niveau et cache de requêtes</title>

            <para>
                Les propriétés préfixées par <literal>hibernate.cache</literal>
                vous permettent d'utiliser un système de cache de second niveau. Ce cache
                peut avoir une portée dans le processus ou même être utilisable dans un
                système distribué. Référez vous au chapitre <xref linkend="performance-cache"/> 
                pour plus de détails.
            </para>

        </sect2>
        
        <sect2 id="configuration-optional-querysubstitution">
            <title>Substitution dans le langage de requêtage</title>

            <para>
                Vous pouvez définir de nouveaux tokens dans les requêtes Hibernate en utilisant la propriété
                <literal>hibernate.query.substitutions</literal>. Par exemple :
            </para>

            <programlisting>hibernate.query.substitutions vrai=1, faux=0</programlisting>

            <para>
                remplacerait les tokens <literal>vrai</literal> et <literal>faux</literal> par
                des entiers dans le SQL généré.
            </para>

            <programlisting>hibernate.query.substitutions toLowercase=LOWER</programlisting>

            <para>
                permettrait de renommer la fonction SQL <literal>LOWER</literal> en <literal>toLowercase</literal>
            </para>

        </sect2>

        <sect2 id="configuration-optional-statistics" revision="2">
            <title>Statistiques Hibernate</title>

            <para>
                Si vous activez <literal>hibernate.generate_statistics</literal>, Hibernate va
                fournir un certains nombre de métriques utiles pour régler les performances
                d'une application qui tourne via <literal>SessionFactory.getStatistics()</literal>.
                Hibernate peut aussi être configuré pour exposer ces statistiques via JMX.
                Lisez les Javadoc des interfaces dans le package
                <literal>org.hibernate.stats</literal> pour plus d'informations.
            </para>

        </sect2>
    </sect1>

    <sect1 id="configuration-logging">
        <title>Tracer</title>

        <para>
            Hibernate trace divers évènements en utilisant Apache commons-logging.
        </para>

        <para>
            Le service commons-logging délèguera directement à Apache Log4j
            (si vous incluez <literal>log4j.jar</literal> dans votre classpath)
            ou le système de trace du JDK 1.4 (si vous tournez sous le JDK 1.4
            et supérieur). Vous pouvez télécharger Log4j à partir de
            <literal>http://jakarta.apache.org</literal>. Pour utiliser Log4j,
            vous devrez placer dans votre classpath un fichier 
            <literal>log4j.properties</literal>. Un exemple de fichier est distribué
            avec Hibernate dans le répertoire <literal>src/</literal>.
        </para>
        
        <para>
            Nous vous recommandons fortement de vous familiariser avec les messages des traces 
            d'Hibernate. Beaucoup de soins a été apporté pour donner le plus de détails
            possible sans les rendre illisibles. C'est un outil essentiel en cas de soucis.
            Les catégories de trace les plus intéressantes sont les suivantes :
        </para>
        
            <table frame="topbot" id="log-categories" revision="2">
                <title>Catégories de trace d'Hibernate</title>
                <tgroup cols="2">
                    <colspec colwidth="1*"/>
                    <colspec colwidth="2.5*"/>
                    <thead>
                        <row>
                            <entry>Catégorie</entry>
                            <entry>Fonction</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>org.hibernate.SQL</literal></entry>
                            <entry>Trace toutes les requêts SQL de type DML (gestion des données) qui sont exécutées</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.type</literal></entry>
                            <entry>Trace tous les paramètres JDBC</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.tool.hbm2ddl</literal></entry>
                            <entry>Trace toutes les requêts SQL de type DDL (gestion de la structure de la base) qui sont exécutées</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.pretty</literal></entry>
                            <entry>
                                Trace l'état de toutes les entités (20 entités maximum) qui
                                sont associées avec la session hibernate au moment du flush
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.cache</literal></entry>
                            <entry>Trace toute l'activité du cache de second niveau</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction</literal></entry>
                            <entry>Trace toute l'activité relative aux transactions</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.jdbc</literal></entry>
                            <entry>Trace toute acquisition de ressource JDBC</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.hql.ast.AST</literal></entry>
                            <entry>
                                Trace l'arbre syntaxique des requêtes HQL et SQL durant l'analyse syntaxique des requêtes
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.secure</literal></entry>
                            <entry>Trace toutes les demandes d'autorisation JAAS</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate</literal></entry>
                            <entry>
                                Trace tout (beaucoupe d'informations, mais très utile pour résoudre les problèmes).
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            
        <para>
            Lorsque vous développez des applications avec Hibernate, vous devriez quasiment toujours
            travailler avec le niveau <literal>debug</literal> activé pour la catégorie
            <literal>org.hibernate.SQL</literal>, ou sinon avec la propriété 
            <literal>hibernate.show_sql</literal> activée.
        </para>
                       
        
    </sect1>

    <sect1 id="configuration-namingstrategy">
        <title>Implémenter une <literal>NamingStrategy</literal></title>

        <para>
            L'interface <literal>org.hibernate.cfg.NamingStrategy</literal> vous permet de
            spécifier une "stratégie de nommage" des objets et éléments de la base de données.
        </para>

        <para>
            Vous pouvez fournir des règles pour automatiquement générer les identifiants
            de base de données à partir des identifiants Java, ou transformer une colonne
            ou table "logique" donnée dans le fichier de mapping en une colonne ou table
            "physique". Cette fonctionnalité aide à réduire la verbosité de documents
            de mapping, en éliminant le bruit répétitif (les préfixes <literal>TBL_</literal>
            par exemple). La stratégie par défaut utilisée par Hibernate est minimale.
        </para>

        <para>
            Vous pouvez définir une stratégie différente en appelant
            <literal>Configuration.setNamingStrategy()</literal> avant d'ajouter des
            mappings :
        </para>

        <programlisting><![CDATA[SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();]]></programlisting>
    
        <para>
            <literal>net.sf.hibernate.cfg.ImprovedNamingStrategy</literal> est une 
            stratégie fournie qui peut être utile comme point de départ de quelques
            applications.
        </para>

    </sect1>

    <sect1 id="configuration-xmlconfig" revision="2">
        <title>Fichier de configuration XML</title>

        <para>
            Une approche alternative est de spécifier toute la configuration dans un
            fichier nommé <literal>hibernate.cfg.xml</literal>. Ce fichier peut être 
            utilisé à la place du fichier <literal>hibernate.properties</literal>, voire
            même peut servir à surcharger les propriétés si les deux fichiers sont présents.
        </para>

        <para>
            Le fichier de configuration XML doit par défaut se placer à la racine
            du <literal>CLASSPATH</literal>. En voici un exemple :
        </para>

        <programlisting><![CDATA[<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>

    <!-- a SessionFactory instance listed as /jndi/name -->
    <session-factory
        name="java:hibernate/SessionFactory">

        <!-- properties -->
        <property name="connection.datasource">java:/comp/env/jdbc/MyDB</property>
        <property name="dialect">org.hibernate.dialect.MySQLDialect</property>
        <property name="show_sql">false</property>
        <property name="transaction.factory_class">
            org.hibernate.transaction.JTATransactionFactory
        </property>
        <property name="jta.UserTransaction">java:comp/UserTransaction</property>

        <!-- mapping files -->
        <mapping resource="org/hibernate/auction/Item.hbm.xml"/>
        <mapping resource="org/hibernate/auction/Bid.hbm.xml"/>

        <!-- cache settings -->
        <class-cache class="org.hibernate.auction.Item" usage="read-write"/>
        <class-cache class="org.hibernate.auction.Bid" usage="read-only"/>
        <collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/>

    </session-factory>

</hibernate-configuration>]]></programlisting>

       <para>
          Commme vous pouvez le voir, l'avantage de cette approche est l'externalisation
          des noms des fichiers de mapping de la configuration. Le fichier <literal>hibernate.cfg.xml</literal>
          est également plus pratique quand on commence à régler le cache d'Hibernate. Notez
          que vous pouvez choisir entre utiliser <literal>hibernate.properties</literal> ou
          <literal>hibernate.cfg.xml</literal>, les deux sont équivalents, sauf en ce qui
          concerne les bénéfices de l'utilisation de la syntaxe XML mentionnés ci-dessus.
       </para>
 
       <para>
           Avec la configuration XML, démarrer Hibernate devient donc aussi simple que ceci :
       </para>

       <programlisting><![CDATA[SessionFactory sf = new Configuration().configure().buildSessionFactory();]]></programlisting>

       <para>
	       You can pick a different XML configuration file using
       </para>
       
       <programlisting><![CDATA[SessionFactory sf = new Configuration()
					       .configure("catdb.cfg.xml")
    .buildSessionFactory();]]></programlisting>

    </sect1>

    <sect1 id="configuration-j2ee" revision="1">
        <title>Intégration à un serveur d'application J2EE</title>

        <para>
            Hibernate possède les points suivants d'intégration à l'infrastructure J2EE :
        </para>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>Source de données gérée par le conteneur</emphasis> : Hibernate peut
                utiliser des connexions JDBC gérées par le conteneur et fournie par l'intermédiaire
                de JNDI. Souvent, un <literal>TransactionManager</literal> compatible JTA
                et un <literal>ResourceManager</literal> s'occupent de la gestion des transactions (CMT).
                Ils sont particulièrement prévus pour pouvoir gérer des transactions distribuées
                sur plusieurs sources de données. Vous pouvez bien sûr également définir vos
                limites de transaction dans votre programme (BMT) ou vous pouvez sinon aussi
                utiliser l'API optionnelle <literal>Transaction</literal> d'Hibernate qui vous garantira
                la portabilité de votre code entre plusieurs serveurs d'application.
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>Association JNDI automatique</emphasis>: Hibernate peut associer sa
                <literal>SessionFactory</literal> à JNDI après le démarrage.
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>Association de la Session à JTA:</emphasis> La <literal>Session</literal> Hibernate
                peut être associée automatiquement à une transaction JTA si vous utilisez les EJBs.
                Vous avez juste à récupérer la <literal>SessionFactory</literal> depuis JNDI et
                à récupérer la <literal>Session</literal> courante. Hibernate s'occupe de vider et
                fermer la <literal>Session</literal> lorsque le transaction JTA se termine. La
                démarcation des transactions se fait de manière déclarative dans les descripteurs de déploiement.
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>Déploiement JMX :</emphasis>Si vous avez un serveur d'application compatible JMX
                (JBoss AS par exemple), vous pouvez choisir de déployer Hibernate en temps que MBean géré par
                le serveur. Cela vous évite de coder la ligne de démarrage qui permet de construire
                la <literal>SessionFactory</literal> depuis la <literal>Configuration</literal>.
                Le conteneur va démarrer votre <literal>HibernateService</literal>, et va idéalement
                s'occuper des dépendances entre les services (la source de données doit être disponible
                avant qu'Hibernate ne démarre, etc).
                </para>
            </listitem>
        </itemizedlist>

        <para>
            En fonction de votre environnement, vous devrez peut être mettre l'option de 
            configuration <literal>hibernate.connection.aggressive_release</literal> à vrai si
            le serveur d'application affiche des exceptions de type "connection containment".
        </para>

        <sect2 id="configuration-optional-transactionstrategy" revision="3">
            <title>Configuration de la stratégie transactionnelle</title>

            <para>
                L'API de la <literal>Session</literal> Hibernate est indépendante de tout système
                de démarcation des transactions qui peut être présent dans votre architecture. Si
                vous laissez Hibernate utiliser l'API JDBC directement via un pool de connexion, vous
                devrez commencer et terminer vos transactions en utilisant l'API JDBC. Si votre
                application tourne à l'intérieur d'un serveur d'application J2EE, vous voudrez peut être
                utiliser les transactions gérées par les beans (BMT) et appeller l'API JTA et 
                <literal>UserTransaction</literal> lorsque cela est nécessaire.
            </para>
            <para>
                Pour conserver votre code portable entre ces deux environnements (et d'autres éventuels)
                nous vous recommandons d'utiliser l'API optionnelle <literal>Transaction</literal> d'Hibernate,
                qui va encapsuler et masquer le système de transaction sous-jacent.
                Pour cela, vous devez préciser une classe de fabrique d'instances de <literal>Transaction</literal>
                en positionnant la propriété
                <literal>hibernate.transaction.factory_class</literal>.
            </para>

            <para>
                Il existe trois choix standards (fournis) :
            </para>

            <variablelist spacing="compact">
                <varlistentry>
                    <term><literal>net.sf.hibernate.transaction.JDBCTransactionFactory</literal></term>
                    <listitem>
                        <para>délègue aux transactions de la base de données (JDBC). Valeur par défaut.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>org.hibernate.transaction.JTATransactionFactory</literal></term>
                    <listitem>
                        <para>
                            délègue à CMT si une transaction existante est sous ce contexte (ex: méthode
                            d'un EJB session), sinon une nouvelle transaction est entamée et
                            une transaction gérée par le bean est utilisée.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>org.hibernate.transaction.CMTTransactionFactory</literal></term>
                    <listitem>
                        <para>délègue à aux transactions JTA gérées par le conteneur</para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                Vous pouvez également définir votre propre stratégie transactionnelle
                (pour un service de transaction CORBA par exemple).
            </para>

            <para>
                Certaines fonctionnalités d'Hibernate (i.e. le cache de second niveau, l'association
                automatique des Session à JTA, etc.) nécessitent l'accès au <literal>TransactionManager</literal>
                JTA dans un environnement "managé". Dans un serveur d'application, vous devez indiquer
                comment Hibernate peut obtenir une référence vers le <literal>TransactionManager</literal>,
                car J2EE ne fournit pas un seul mécanisme standard.
            </para>

            <table frame="topbot" id="jtamanagerlookup" revision="1">
                <title>TransactionManagers JTA</title>
                <tgroup cols="2">
                    <colspec colwidth="2.5*"/>
                    <colspec colwidth="1*"/>
                    <thead>
                        <row>
                            <entry>Fabrique de Transaction</entry>
                            <entry align="center">Serveur d'application</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>org.hibernate.transaction.JBossTransactionManagerLookup</literal></entry>
                            <entry align="center">JBoss</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.WeblogicTransactionManagerLookup</literal></entry>
                            <entry align="center">Weblogic</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.WebSphereTransactionManagerLookup</literal></entry>
                            <entry align="center">WebSphere</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</literal></entry>
                            <entry align="center">WebSphere 6</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.OrionTransactionManagerLookup</literal></entry>
                            <entry align="center">Orion</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.ResinTransactionManagerLookup</literal></entry>
                            <entry align="center">Resin</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.JOTMTransactionManagerLookup</literal></entry>
                            <entry align="center">JOTM</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.JOnASTransactionManagerLookup</literal></entry>
                            <entry align="center">JOnAS</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.JRun4TransactionManagerLookup</literal></entry>
                            <entry align="center">JRun4</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.BESTransactionManagerLookup</literal></entry>
                            <entry align="center">Borland ES</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

        </sect2>

        <sect2 id="configuration-optional-jndi" revision="3">
            <title><literal>SessionFactory</literal> associée au JNDI</title>

            <para>
                Une <literal>SessionFactory</literal> Hibernate associée au JNDI peut 
                simplifier l'accès à la fabrique et donc la création de nouvelles
                <literal>Session</literal>s. Notez que cela n'est pas lié avec les <literal>Datasource</literal>
                associées au JNDI, elles utilisent juste le même registre.
            </para>

            <para>
                Si vous désirez associer la <literal>SessionFactory</literal> à un nom JNDI,
                spécifiez un nom (ex. <literal>java:hibernate/SessionFactory</literal>) en
                utilisant la propriété <literal>hibernate.session_factory_name</literal>.
                Si cette propriété est omise, la <literal>SessionFactory</literal> ne sera pas
                associée au JNDI (c'est particulièrement pratique dans les environnements ayant une
                implémentation de JNDI en lecture seule, comme c'est le cas pour Tomcat).
            </para>

            <para>
                Lorsqu'il associe la <literal>SessionFactory</literal> au JNDI, Hibernate utilisera 
                les valeurs de <literal>hibernate.jndi.url</literal>, <literal>hibernate.jndi.class</literal>
                pour instancier un contexte d'initialisation. S'ils ne sont pas spécifiés, 
                l'<literal>InitialContext</literal> par défaut sera utilisé.
            </para>
            
            <para>
                Hibernate va automatiquement placer la <literal>SessionFactory</literal> dans JNDI
                après avoir appelé <literal>cfg.buildSessionFactory()</literal>. Cela signifie que vous
                devez avoir cet appel dans un code de démarrage (ou dans une classe utilitaire) dans
                votre application sauf si vous utilisez le déploiement JMX avec le service
                <literal>HibernateService</literal> présenté plus tard dans ce document.
            </para>
            <para>           
                Si vous utilisez <literal>SessionFactory</literal> JNDI, un EJB ou n'importe quelle autre classe
                peut obtenir la <literal>SessionFactory</literal> en utilisant un lookup JNDI.
            </para>

            <para>
                Nous recommandons que vous liiez la <literal>SessionFactory</literal> à JNDI dans les
                environnements managés et que vous utilisiez un singleton <literal>static</literal> si ce n'est pas le cas.
                Pour isoler votre application de ces détails, nous vous recommandons aussi de masquer
                le code de lookup actuel pour une <literal>SessionFactory</literal> dans une classe helper,
                comme <literal>HibernateUtil.getSessionFactory()</literal>. Notez qu'une telle classe
                est aussi un moyen efficace de démarrer Hibernate&mdash;voir chapitre 1.
            </para>
        </sect2>

        <sect2 id="configuration-j2ee-currentsession" revision="4">
            <title>Association automatique de la Session à JTA</title>

            <para>
                Le moyen le plus simple de gérer les <literal>Session</literal>s et transactions est
                la gestion automatique de session "courante" offerte par Hibernate.
                Voir détail à <xref linkend="architecture-current-session">current sessions</xref>.
                En utilisant le contexte de session <literal>"jta"</literal> session context, s'il n'y a pas
                de <literal>Session</literal> associée à la transaction JTA courante, une session sera
                démarrée et associée à la transaction JTA courante la première fois que vous appelez
                <literal>sessionFactory.getCurrentSession()</literal>. Les <literal>Session</literal>s
                obtenue via <literal>getCurrentSession()</literal> dans une contexte <literal>"jta"</literal> 
                seront automatiquement flushées avant la validation de la transaction, fermées une fois
                la transaction complétée, et libéreront les connexions JDBC de manière aggressive
                après chaque statement. Ceci permet aux <literal>Session</literal>s d'être
                gérées par le cycle de vie de la transaction JTA à la quelle est sont associées, 
                laissant le code de l'utilisateur propre de ce type de gestion. Votre code peut
                soit utiliser JTA de manière programmatique via <literal>UserTransaction</literal>, ou (ce qui est recommandé
                pour la portabilité du code) utiliser l'API <literal>Transaction</literal> API pour marquer
                les limites. Si vous exécutez sous un conteneur EJB, la démarcation déclarative des transactions
                avec CMT est recommandée.
            </para>

        </sect2>

        <sect2 id="configuration-j2ee-jmx" revision="1">
            <title>Déploiement JMX</title>

            <para>
                La ligne <literal>cfg.buildSessionFactory()</literal>  doit toujours être exécutée
                quelque part pour avoir une <literal>SessionFactory</literal> dans JNDI. Vous pouvez
                faire cela dans un bloc d'initialisation <literal>static</literal> (comme
                celui qui se trouve dans la classe <literal>HibernateUtil</literal>) ou vous pouvez
                déployer Hibernate en temps que <emphasis>service managé</emphasis>.
            </para>

            <para>
                Hibernate est distribué avec <literal>org.hibernate.jmx.HibernateService</literal>
                pour le déploiement sur un serveur d'application avec le support de JMX comme JBoss AS.
                Le déploiement et la configuration sont spécifiques à chaque vendeur. Voici un fichier
                <literal>jboss-service.xml</literal> d'exemple pour JBoss 4.0.x:
            </para>

            <programlisting><![CDATA[<?xml version="1.0"?>
<server>

<mbean code="org.hibernate.jmx.HibernateService"
    name="jboss.jca:service=HibernateFactory,name=HibernateFactory">

    <!-- Required services -->
    <depends>jboss.jca:service=RARDeployer</depends>
    <depends>jboss.jca:service=LocalTxCM,name=HsqlDS</depends>

    <!-- Bind the Hibernate service to JNDI -->
    <attribute name="JndiName">java:/hibernate/SessionFactory</attribute>

    <!-- Datasource settings -->
    <attribute name="Datasource">java:HsqlDS</attribute>
    <attribute name="Dialect">org.hibernate.dialect.HSQLDialect</attribute>

    <!-- Transaction integration -->
    <attribute name="TransactionStrategy">
        org.hibernate.transaction.JTATransactionFactory</attribute>
    <attribute name="TransactionManagerLookupStrategy">
        org.hibernate.transaction.JBossTransactionManagerLookup</attribute>
    <attribute name="FlushBeforeCompletionEnabled">true</attribute>
    <attribute name="AutoCloseSessionEnabled">true</attribute>

    <!-- Fetching options -->
    <attribute name="MaximumFetchDepth">5</attribute>

    <!-- Second-level caching -->
    <attribute name="SecondLevelCacheEnabled">true</attribute>
    <attribute name="CacheProviderClass">org.hibernate.cache.EhCacheProvider</attribute>
    <attribute name="QueryCacheEnabled">true</attribute>

    <!-- Logging -->
    <attribute name="ShowSqlEnabled">true</attribute>

    <!-- Mapping files -->
    <attribute name="MapResources">auction/Item.hbm.xml,auction/Category.hbm.xml</attribute>

</mbean>

</server>]]></programlisting>

            <para>
                Ce fichier est déployé dans un répertoire <literal>META-INF</literal> et est packagé
                dans un fichier JAR avec l'extension <literal>.sar</literal> (service archive).
                Vous devez également packager Hibernate, les librairies tierces requises, vos classes
                persistantes compilées et vos fichiers de mapping dans la même archive. Vos beans
                entreprise (souvent des EJBs session) peuvent rester dans leur propre fichier JAR mais
                vous pouvez inclure ce fichier JAR dans le jar principal du service pour avoir une seule unité
                déployable à chaud. Vous pouvez consulter la documentation de JBoss AS pour plus d'information
                sur les services JMX et le déploiement des EJBs.
            </para>

        </sect2>


    </sect1>




</chapter>
