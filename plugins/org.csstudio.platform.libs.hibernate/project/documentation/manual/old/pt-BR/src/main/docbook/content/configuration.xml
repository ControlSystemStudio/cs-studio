<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="session-configuration" revision="1">

    <title>Configuração</title>
    
    <para>
        Devido ao fato de o Hibernate ser projetado para operar em vários ambientes diferentes, 
        há um grande número de parâmetros de configuração. Felizmente, a maioria tem valores default 
        lógicos e o Hibernate é distribuído com um arquivo <literal>hibernate.properties</literal> 
        de exemplo no <literal>etc/</literal> que mostra várias opções. Apenas coloque o arquivo 
        de exemplo no seu classpath e personalize-o.
    </para>

    <sect1 id="configuration-programmatic" revision="1">
        <title>1.11 Configuração programática</title>

        <para>
            Uma instância de <literal>org.hibernate.cfg.Configuration</literal>
            representa um conjunto inteiro de mapeamentos de tipos Java da aplicação para 
            um banco de dados SQL. O <literal>Configuration</literal> é usado para construir 
            uma <literal>SessionFactory</literal> (imutável). Os mapeamentos são compilados 
            a partir de arquivos de mapeamento XML.

        </para>

        <para>
            Você pode obter uma instância <literal>Configuration</literal> intanciando-
            o diretamente e especificando documentos de mapeamento XML. Se o arquivo 
            de mapeamento estão no classpath, use use <literal>addResource()</literal>:
        </para>

        <programlisting><![CDATA[Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");]]></programlisting>

        <para>
            Uma alternativa (às vezes melhor) é especificar a classe mapeada, 
            e permitir que o Hibernate encontre o documento de mapeamento para você: 
        </para>

        <programlisting><![CDATA[Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);]]></programlisting>

        <para>
            Então o Hibernate procurará pelos arquivos de mapeamento chamados 
            <literal>/org/hibernate/auction/Item.hbm.xml</literal> e
            <literal>/org/hibernate/auction/Bid.hbm.xml</literal> no classpath.
            Esta abordagem elimina qualquer nome de arquivo de difícil compreensão.
        </para>
        
        <para>
            Uma <literal>Configuration</literal> também permite você especificar 
            propriedades de configuração:
        </para>

        <programlisting><![CDATA[Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");]]></programlisting>
    
        <para>
            Este não é o único caminho para passar as propriedades de configuração 
            para o Hibernate. As várias opções incluem:
        </para>

        <orderedlist spacing="compact">
            <listitem>
                <para>
                    Passar uma instância de <literal>java.util.Properties</literal> 
                    para <literal>Configuration.setProperties()</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Colocar <literal>hibernate.properties</literal> no diretório 
                    raiz do classpath.
                </para>
            </listitem>
            <listitem>
                <para>
                    Determinar as propriedades do <literal>System</literal> 
                    usando <literal>java -Dproperty=value</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Include <literal>&lt;property&gt;</literal> elements in
                    <literal>hibernate.cfg.xml</literal> (discussed later).
                    Incluir elementos <literal>&lt;property&gt;</literal> no 
                    <literal>hibernate.cfg.xml</literal> (discutido mais tarde).
                </para>
            </listitem>
        </orderedlist>

        <para>
            <literal>hibernate.properties</literal>  é o caminho mais facil 
            se você quer começar mais rápido.
        </para>

        <para>
            O <literal>Configuration</literal> é entendido como um objeto startup-time, 
            é descartado uma vez que a <literal>SessionFactory</literal> é criada.
        </para>

    </sect1>
    
    <sect1 id="configuration-sessionfactory">
        <title>Obtendo uma SessionFactory</title>

        <para>
            Quando todos os mapeamentos têm sido analisados pelo <literal>Configuration</literal>, 
            a aplicação deve obter uma factory para as instâncias da <literal>Session</literal>. 
            O objetivo desta factory é ser compartilhado por todas as threads da aplicação:
        </para>

        <programlisting><![CDATA[SessionFactory sessions = cfg.buildSessionFactory();]]></programlisting>

        <para>
            Hibernate permite sua aplicação instanciar mais do que uma 
            <literal>SessionFactory</literal>. Isto é útil se você está usando mais 
            do que um banco de dados.
        </para>

    </sect1>

    <sect1 id="configuration-hibernatejdbc" revision="1">
        <title>Conexões JDBC</title>

        <para>
            Normalmente, você quer mandar criar a  <literal>SessionFactory</literal>  criar um
            pool de conexões JDBC para você. Se você seguir essa abordagem, a abertura de uma 
            <literal>Session</literal> é tão simples quanto:

        </para>

        <programlisting><![CDATA[Session session = sessions.openSession(); // open a new Session]]></programlisting>
        
        <para>
            Assim que você fizer algo que requer o acesso ao banco de dados, uma 
            conexão JDBC será obtida do pool.
        </para>

        <para>
            Para esse trabalho, nós necessitamos passar algumas propriedades da conexão JDBC 
            para o Hibernate. Todos os nomes de propriedades Hibernate e semânticas são definidas 
            <literal>org.hibernate.cfg.Environment</literal>. Nós iremos descrever agora 
            o mais importantes configurações de conexão JDBC.
        </para>

        <para>
            O Hibernate obterá conexões( e pool) usando <literal>java.sql.DriverManager</literal>
            se você determinar as seguintes propriedades:
        </para>

        <table frame="topbot">
            <title>Propriedades JDBC Hibernate</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nome da Propriedade</entry>
                        <entry>Propósito</entry>
                    </row>
                </thead>
            <tbody>
            <row>
                <entry>
                    <literal>hibernate.connection.driver_class</literal>
                </entry>
                <entry>
                    <emphasis>Classe driver jdbc</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.url</literal>
                </entry>
                <entry>
                    <emphasis>URL jdbc</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.username</literal>
                </entry>
                <entry>
                    <emphasis>Usuário do banco de dados</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.password</literal>
                </entry>
                <entry>
                    <emphasis>Senha do usuário do banco de dados</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.pool_size</literal>
                </entry>
                <entry>
                    <emphasis>Número máximo de connecxões no pool</emphasis>
                </entry>
            </row>
            </tbody>
            </tgroup>
        </table>

        <para>
            O algoritmo de pool de conexões do próprio Hibernate entretanto é completamente 
            rudimentar. A intenção dele e ajudar a iniciar e <emphasis>não para usar em um 
            sistema de produção</emphasis> ou até para testar desempenho. Você deveria usar 
            uma ferramente de pool de terceiros para conseguir melhor desempenho e estabilidade. 
            Apenas especifique a propriedade <literal>hibernate.connection.pool_size</literal> 
            com a definição do pool de conexões. Isto irá desligar o pool interno do Hibernate. 
            Por exemplo, você pode gostar de usar C3P0.
        </para>

        <para>
            O C3P0 é um pool conexão JDBC de código aberto distribuído junto com 
            Hibernate       no diretório <literal>lib</literal>. O Hibernate usará o 
            <literal>C3P0ConnectionProvider</literal> para o pool de conexão se 
            você configurar a propriedade <literal>hibernate.c3p0.*</literal>. Se você 
            gostar de usar Proxool consulte ao pacote <literal>hibernate.properties</literal> 
            e o web site do Hibernate para mais informações.
        </para>

        <para>
            Aqui é um exemplo de arquivo <literal>hibernate.properties</literal> para C3P0:
        </para>

        <programlisting id="c3p0-configuration" revision="1"><![CDATA[hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]></programlisting>

        <para>
            Para usar dentro de um servidor de aplicação, você deve configurar 
            o Hibernate para obter conexões de um application server  
            <literal>Datasource</literal> registrado no JNDI. Você necessitará 
            determinar pelo menos uma das seguintes propriedades:
        </para>

        <table frame="topbot">
            <title>Propriedades do Datasource do Hibernate</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nome da Propriedade</entry>
                        <entry>Propósito</entry>
                    </row>
                </thead>
            <tbody>
            <row>
                <entry>
                    <literal>hibernate.connection.datasource</literal>
                </entry>
                <entry>
                    <emphasis>Nome datasource JNDI</emphasis>
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.jndi.url</literal>
                </entry>
                <entry>
                    <emphasis>URL do fornecedor JNDI</emphasis> (opcional)
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.jndi.class</literal>
                </entry>
                <entry>
                    <emphasis>Classe do JNDI <literal>InitialContextFactory</literal></emphasis> (opcional)
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.username</literal>
                </entry>
                <entry>
                    <emphasis>Usuário do banco de dados</emphasis> (opcional)
                </entry>
            </row>
            <row>
                <entry>
                    <literal>hibernate.connection.password</literal>
                </entry>
                <entry>
                    <emphasis>Senha do usuário do banco de dados</emphasis> (opcional)
                </entry>
            </row>
            </tbody>
            </tgroup>
        </table>

        <para>
            Eis um exemplo de arquivo <literal>hibernate.properties</literal> para 
            um servidor de aplicação fornecedor de datasources JNDI:
        </para>

        <programlisting><![CDATA[hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect]]></programlisting>

        <para>
            Conexões JDBC obtidas de um datasource JNDI irão automaticamente irão participar 
            das transações gerenciadas pelo container no servidor de aplicação.
        </para>

        <para>
            Arbitrariamente as propriedades de conexão podem ser acrescentandas ao 
            "<literal>hibernate.connnection</literal>" ao nome da propriedade. Por exemplo, 
            você deve especificar o <literal>charSet</literal> usando <literal>hibernate.connection.charSet</literal>.t.
        </para>

        <para>
            Você pode definir sua própria estratégia de plugin para obter conexões JDBC implementando 
            a interface <literal>org.hibernate.connection.ConnectionProvider</literal>. Você pode 
            escolher uma implementação customizada setando <literal>hibernate.connection.provider_class</literal>.
        </para>

    </sect1>

    <sect1 id="configuration-optional" revision="1">
        <title>Propriedades opcionais de configuração</title>
        
        <para>
            Há um grande número de outras propriedades que controlam o comportamento do Hibernate 
            em tempo de execução. Todos são opcionais e tem valores default lógicos.
        </para>

        <para>
            <emphasis>Aviso: algumas destas propriedades são somente a "nível de sistema".</emphasis>
            Propriedades nível de sistema podem ser determinados somente via <literal>java -Dproperty=value</literal>
            ou <literal>hibernate.properties</literal>. Elas <emphasis>não</emphasis>podem ser 
            configuradas por outras técnicas descritas abaixo.
        </para>

        <table frame="topbot" id="configuration-optional-properties" revision="8">
            <title>Hibernate Configuration Properties</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nome da Propriedade</entry>
                        <entry>Propósito</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.dialect</literal>
                        </entry>
                        <entry>
                            O nome da classe de um <literal>Dialeto</literal> 
                            que permite o Hibernate gerar SQL otimizado para um banco de 
                            dados relacional em particular.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>full.classname.of.Dialect</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.show_sql</literal>
                        </entry>
                        <entry>
                            Escreve todas as instruções SQL no console. Esta é uma alternativa 
                            a configurar a categoria de log <literal>org.hibernate.SQL</literal>
                            para <literal>debug</literal>.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.format_sql</literal>
                        </entry>
                        <entry>
                            Imprime o SQL formatado no log e console.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_schema</literal>
                        </entry>
                        <entry>
                            Qualifica no sql gerado, os nome das tabelas sem qualificar 
                            com schena/tablespace dado
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>SCHEMA_NAME</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_catalog</literal>
                        </entry>
                        <entry>
                            Qualifica no sql gerado, os nome das tabelas sem qualificar 
                            com catálogo dado
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>CATALOG_NAME</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.session_factory_name</literal>
                        </entry>
                        <entry>
                            O <literal>SessionFactory</literal> irá automaticamente 
                            se ligar a este nome no JNDI depois de ter sido criado.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>jndi/composite/name</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.max_fetch_depth</literal>
                        </entry>
                        <entry>
                            Estabelece a "profundidade" máxima para árvore outer join fetch 
                            para associações finais únicas(one-to-one,many-to-one). 
                            Um <literal>0</literal> desativa por default a busca outer join.
                            <para>
                                <emphasis role="strong">eg.</emphasis> 
                                Valores recomendados entre<literal>0</literal> e <literal>3</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_batch_fetch_size</literal>
                        </entry>
                        <entry>
                            Determina um tamanho default para busca de associações em lotes do Hibernate 
                            <para>
                                <emphasis role="strong">eg.</emphasis> 
                                Valores recomendados <literal>4</literal>, <literal>8</literal>, 
                                <literal>16</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.default_entity_mode</literal>
                        </entry>
                        <entry>
                            Determina um modo default para representação de entidades 
                            para todas as sessões abertas desta <literal>SessionFactory</literal>
                            <para>
                                <literal>dynamic-map</literal>, <literal>dom4j</literal>,
                                <literal>pojo</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.order_updates</literal>
                        </entry>
                        <entry>
                            Força o Hibernate a ordenar os updates SQL pelo valor da chave 
                            primária dos itens a serem atualizados. Isto resultará em menos 
                            deadlocks nas transações em sistemas altamente concorrente.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.generate_statistics</literal>
                        </entry>
                        <entry>
                            If enabled, Hibernate will collect statistics useful for
                            performance tuning.
                            Se habilitado, o Hibernate coletará estatísticas úties 
                            para performance tuning dos bancos.
                            <para>
                                <emphasis role="strong">Ex.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.use_identifer_rollback</literal>
                        </entry>
                        <entry>
                            Se habilitado, propriedades identificadoras geradas 
                            serão zeradas para os valores default quando os 
                            objetos forem apagados.
                            <para>
                                <emphasis role="strong">Ex.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.use_sql_comments</literal>
                        </entry>
                        <entry>
                            Se ligado, o Hibernate irá gerar comentários dentro do SQL, 
                            para facilitar o debugging, o valor default é <literal>false</literal>.
                            <para>
                                <emphasis role="strong">eg.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-jdbc-properties" revision="8">
            <title>JDBC Hibernate e Propriedades de Conexão</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nome da Propriedade</entry>
                        <entry>Propósito</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.fetch_size</literal>
                        </entry>
                        <entry>
                            Um valor maior que zero determina o tamanho do fetch 
                            do JDBC( chamadas <literal>Statement.setFetchSize()</literal>).
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.batch_size</literal>
                        </entry>
                        <entry>
                            Um valor maior que zero habilita uso de batch updates JDBC2 pelo Hibernate.
                            <para>
                                <emphasis role="strong">Ex.</emphasis>
                                valores recomentados entre <literal>5</literal> e <literal>30</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.batch_versioned_data</literal>
                        </entry>
                        <entry>
                            Sete esta propriedade como <literal>true</literal> se seu driver JDBC retorna 
                            o número correto de linhas no <literal>executeBatch()</literal> ( É usualmente 
                            seguro tornar esta opção ligada). O Hibernate então irá usar betched DML 
                            para automaticamente versionar dados.  <literal>false</literal> por default.
                            <para>
                                <emphasis role="strong">Ex.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.factory_class</literal>
                        </entry>
                        <entry>
                            Escolher um <literal>Batcher</literal> customizado. Muitas 
                            aplicações não irão necessitar desta propriedade de configuração
                            <para>
                                <emphasis role="strong">Ex.</emphasis>
                                <literal>classname.of.BatcherFactory</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.use_scrollable_resultset</literal>
                        </entry>
                        <entry>
                            Habilita o uso de JDBC2 scrollable resultsets pelo Hibernate.
                            Essa propriedade somente é necessaria quando se usa Conexeções
                            JDBC providas pelo usuário, caso contrário o Hibernate os os 
                            metadados da conexão.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.use_streams_for_binary</literal>
                        </entry>
                        <entry>
                            Use streams para escrever/ler tipos <literal>binary</literal>
                            ou <literal>serializable</literal> para/a o JDBC( propriedade a nível de sistema).
                            <para>
                                <emphasis role="strong">Ex.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jdbc.use_get_generated_keys</literal>
                        </entry>
                        <entry>
                            Possibilita o uso <literal>PreparedStatement.getGeneratedKeys()</literal> 
                            do JDBC3 para recuperar chaves geradas nativamente depois da inserçãp. 
                            Requer driver JDBC3+ e JRE1.4+, determine para false se seu driver tem 
                            problemas com gerador de indentificadores Hibernate. Por default, tente 
                            determinar o driver capaz de usar metadados da conexão.
                            <para>
                                <emphasis role="strong">Ex.</emphasis>
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.connection.provider_class</literal>
                        </entry>
                        <entry>
                            O nome da classe de um <literal>ConnectionProvider</literal> personalizado
                            o qual proverá conexões JDBC para o Hibernate.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>classname.of.ConnectionProvider</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                    <entry>
                        <literal>hibernate.connection.isolation</literal>
                    </entry>
                    <entry>
                        Determina o nível de isolamento de uma transação JDBC. 
                        Verifique <literal>java.sql.Connection</literal> para valores 
                        siginificativos mas note que a maior parte dos bancos de dados 
                        não suportam todos os níveis de isolamento.
                        <para>
                            <emphasis role="strong">Ex.</emphasis> 
                            <literal>1, 2, 4, 8</literal>
                        </para>
                    </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.connection.autocommit</literal>
                        </entry>
                        <entry>
                            Habilita autocommit para conexões no pool JDBC( não recomendado).
                            <para>
                                <emphasis role="strong">Ex.</emphasis>
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.connection.release_mode</literal>
                        </entry>
                        <entry>
                            Especifica quando o Hibernate deve liberar conexões JDBC. Por default, 
                            uma conexão JDBC é retida até a sessão está explicitamente fechada 
                            ou desconectada. Para um datasource JTA do servidor de aplicação, você deve 
                            usar <literal>after_statement</literal> para forçar s liberação da conexões 
                            depois de todas as chamadas JDBC. Para uma conexão não-JTA, freqüentemente 
                            faz sentido liberar a conexão ao fim de cada transação, usando
                            <literal>after_transaction</literal>. <literal>auto</literal> escolheremos
                            <literal>after_statement</literal>  para as estratégias de transaçãoes JTA e CMT 
                            e <literal>after_transaction</literal> para as estratégias de transação JDBC
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>auto</literal> (default) | <literal>on_close</literal> |
                                <literal>after_transaction</literal> | <literal>after_statement</literal>
                            </para>
                            <para>
                                Note that this setting only affects <literal>Session</literal>s returned from
                                <literal>SessionFactory.openSession</literal>.  For <literal>Session</literal>s
                                obtained through <literal>SessionFactory.getCurrentSession</literal>, the
                                <literal>CurrentSessionContext</literal> implementation configured for use
                                controls the connection release mode for those <literal>Session</literal>s.
                                See <xref linkend="architecture-current-session"/>
                            </para>
                        </entry>
                    </row>
                    <row>
                    <entry>
                        <literal>hibernate.connection.<emphasis>&lt;propertyName&gt;</emphasis></literal>
                    </entry>
                    <entry>
                        Passa a propriedade JDBC <literal>propertyName</literal> 
                        para <literal>DriverManager.getConnection()</literal>.
                    </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.jndi.<emphasis>&lt;propertyName&gt;</emphasis></literal>
                        </entry>
                        <entry>
                            Passar a propriedade <literal>propertyName</literal> para 
                            o <literal>InitialContextFactory</literal> JNDI.
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-cache-properties" revision="7">
            <title>Propriedades de Cachê do Hibernate</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nome da Propriedade</entry>
                        <entry>Propósito</entry>
                    </row>
                </thead>
                <tbody>
                     <row>
                        <entry>
                            <literal>hibernate.cache.provider_class</literal>
                        </entry>
                        <entry>
                            O nome da classe de um <literal>CacheProvider</literal> customizado.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>classname.of.CacheProvider</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_minimal_puts</literal>
                        </entry>
                        <entry>
                            Otimizar operação de cachê de segundo nível para minimizar escritas, 
                            ao custo de leituras mais frequantes. Esta configuração é mais útil 
                            para cachês clusterizados e, no Hibernate3, é habilitado por default 
                            para implementações de cachê clusterizar.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_query_cache</literal>
                        </entry>
                        <entry>
                            Habilita a cache de consultas, Mesmo assim, consultas individuais ainda tem que ser 
                            habilitadas para o cache.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_second_level_cache</literal>
                        </entry>
                        <entry>
                            Pode ser usada para desabilitar completamente ocache de segundo nível, 
                            o qual está habilitado por default para classes que especificam 
                            um mapeamento <literal>&lt;cache&gt;</literal>.

                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.query_cache_factory</literal>
                        </entry>
                        <entry>
                            O nome de uma classe que implementa a interface 
                            <literal>QueryCache</literal> personalizada, por 
                            default, um <literal>StandardQueryCache</literal>
                            criado automaticamente.
                            <para>
                                <emphasis role="strong">Ex.</emphasis>
                                <literal>classname.of.QueryCache</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.region_prefix</literal>
                        </entry>
                        <entry>
                            Um prefixo para usar nos nomes da área especial 
                            do cachê de segundo nível.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>prefix</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cache.use_structured_entries</literal>
                        </entry>
                        <entry>
                            Forces Hibernate to store data in the second-level cache
                            in a more human-friendly format.
                            Força o Hibernate armazenar dados no cachê se segundo 
                            nível em um formato mais legivel.
                            <para>
                                <emphasis role="strong">Ex.</emphasis>
                                <literal>true|false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-transaction-properties" revision="9">
            <title>Propriedades de Transação do Hibernate</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nome da Propriedade</entry>
                        <entry>Propósito</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.factory_class</literal>
                        </entry>
                        <entry>
                            O nome da clase de um a <literal>TransactionFactory</literal>
                            para usar com API <literal>Transaction</literal>
			    ( por default <literal>JDBCTransactionFactory</literal>).
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>classname.of.TransactionFactory</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>jta.UserTransaction</literal>
                        </entry>
                        <entry>
                            Um nome JNDI usado pelo <literal>JTATransactionFactory</literal> 
                            para obter uma <literal>UserTransaction</literal> JTA a partir 
                            do servidor de aplicação.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>jndi/composite/name</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.manager_lookup_class</literal>
                        </entry>
                        <entry>
                            O nome da classe de um <literal>TransactionManagerLookup</literal>
                            – requerido quando caching a nível JVM esta habilitado ou quando 
                            estivermos usando um generator hilo em um ambiente JTA.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>classname.of.TransactionManagerLookup</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.flush_before_completion</literal>
                        </entry>
                        <entry>
                            Se habilitado, a sessão será automaticamente limpa antes da fase de 
                            conclusão da transação. É preferivel a gerência interna e 
                            automática do contexto da sessão, veja
                            <xref linkend="architecture-current-session"/>
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.transaction.auto_close_session</literal>
                        </entry>
                        <entry>
                            Se habilitado, a sessão será automaticamente fechada após a fase de
                             conclusão da transação. É preferivel a gerência interna e 
                            automática do contexto da sessão, veja
                            <xref linkend="architecture-current-session"/>
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <table frame="topbot" id="configuration-misc-properties" revision="10">
            <title>Propriedades Variadas</title>
            <tgroup cols="2">
                <colspec colname="c1" colwidth="1*"/>
                <colspec colname="c2" colwidth="1*"/>
                <thead>
                    <row>
                        <entry>Nome da Propriedade</entry>
                        <entry>Propósito</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <literal>hibernate.current_session_context_class</literal>
                        </entry>
                        <entry>
                            Forneçe uma estratégia (personalizada) para extensão 
                            da <literal>Session</literal> "corrente". Veja 
                             <xref linkend="architecture-current-session"/> para 
                             mais informação sobre estratégias internas.
                            <para>
                                <emphasis role="strong">Ex.</emphasis>
                                <literal>jta</literal> | <literal>thread</literal> |
                                <literal>managed</literal> | <literal>custom.Class</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.query.factory_class</literal>
                        </entry>
                        <entry>
                            Escolha a implementação de análise HQL.
                            <para>
                                <emphasis role="strong">eg.</emphasis> 
                                <literal>org.hibernate.hql.ast.ASTQueryTranslatorFactory</literal> or
                                <literal>org.hibernate.hql.classic.ClassicQueryTranslatorFactory</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.query.substitutions</literal>
                        </entry>
                        <entry>
                            Mapeamento a partir de símbolos em consultas HQL para 
                            símbolos SQL( símbolos devem ser funções ou nome literais
                            , por exemplo).
                            <para>
                                <emphasis role="strong">eg.</emphasis> 
                                <literal>hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.hbm2ddl.auto</literal>
                        </entry>
                        <entry>
                            Automaticamente valida ou exporta schema DDL para o banco de 
                            dados quando o <literal>SessionFactory</literal>  é criads.
                            Com <literal>create-drop</literal>, o schema do banco de dados 
                            será excluido quando a <literal>create-drop</literal> for
                            fechada esplicitamente.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>validate</literal> | <literal>update</literal> | 
                                <literal>create</literal> | <literal>create-drop</literal>
                            </para>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <literal>hibernate.cglib.use_reflection_optimizer</literal>
                        </entry>
                        <entry>
                            Habilita o uso de CGLIB em vez de reflexão em tempo de execução
                            ( propriedade a nível de sistema). Reflexão pode algumas vezes ser ú
                            til quando controlar erros, note que o Hibernate sempre irá requerer a CGLIB 
                            mesmo se você desligar o otimizador. Você não pode determinar esta 
			    propriedade no <literal>hibernate.cfg.xml</literal>.
                            <para>
                                <emphasis role="strong">Ex.</emphasis> 
                                <literal>true</literal> | <literal>false</literal>
                            </para>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <sect2 id="configuration-optional-dialects" revision="1">
            <title>Dialetos SQL</title>

            <para>
                Você deve sempre determinar a propriedade <literal>hibernate.dialect</literal> 
                para a subclasse de <literal>org.hibernate.dialect.Dialect</literal>  correta de seu 
                banco de dados. Se você especificar um dialeto, Hibernate usará defaults lógicos 
                para qualquer um das outras propriedades listadas abaixo, reduzindo o esforço de 
                especificá-los manualmente. 
            </para>

            <table frame="topbot" id="sql-dialects" revision="2">
                <title>Hibernate SQL Dialects (<literal>hibernate.dialect</literal>)</title>
                <tgroup cols="2">
                    <colspec colwidth="1*"/>
                    <colspec colwidth="2.5*"/>
                    <thead>
                        <row>
                            <entry>RDBMS</entry>
                            <entry>Dialect</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>DB2</entry> <entry><literal>org.hibernate.dialect.DB2Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>DB2 AS/400</entry> <entry><literal>org.hibernate.dialect.DB2400Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>DB2 OS390</entry> <entry><literal>org.hibernate.dialect.DB2390Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>PostgreSQL</entry> <entry><literal>org.hibernate.dialect.PostgreSQLDialect</literal></entry>
                        </row>
                        <row>
                            <entry>MySQL</entry> <entry><literal>org.hibernate.dialect.MySQLDialect</literal></entry>
                        </row>
                        <row>
                            <entry>MySQL with InnoDB</entry> <entry><literal>org.hibernate.dialect.MySQLInnoDBDialect</literal></entry>
                        </row>
                        <row>
                            <entry>MySQL with MyISAM</entry> <entry><literal>org.hibernate.dialect.MySQLMyISAMDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Oracle (any version)</entry> <entry><literal>org.hibernate.dialect.OracleDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Oracle 9i/10g</entry> <entry><literal>org.hibernate.dialect.Oracle9Dialect</literal></entry>
                        </row>
                        <row>
                            <entry>Sybase</entry> <entry><literal>org.hibernate.dialect.SybaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Sybase Anywhere</entry> <entry><literal>org.hibernate.dialect.SybaseAnywhereDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Microsoft SQL Server</entry> <entry><literal>org.hibernate.dialect.SQLServerDialect</literal></entry>
                        </row>
                        <row>
                            <entry>SAP DB</entry> <entry><literal>org.hibernate.dialect.SAPDBDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Informix</entry> <entry><literal>org.hibernate.dialect.InformixDialect</literal></entry>
                        </row>
                        <row>
                            <entry>HypersonicSQL</entry> <entry><literal>org.hibernate.dialect.HSQLDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Ingres</entry> <entry><literal>org.hibernate.dialect.IngresDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Progress</entry> <entry><literal>org.hibernate.dialect.ProgressDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Mckoi SQL</entry> <entry><literal>org.hibernate.dialect.MckoiDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Interbase</entry> <entry><literal>org.hibernate.dialect.InterbaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Pointbase</entry> <entry><literal>org.hibernate.dialect.PointbaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>FrontBase</entry> <entry><literal>org.hibernate.dialect.FrontbaseDialect</literal></entry>
                        </row>
                        <row>
                            <entry>Firebird</entry> <entry><literal>org.hibernate.dialect.FirebirdDialect</literal></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

        </sect2>

        <sect2 id="configuration-optional-outerjoin" revision="4">
            <title>Recuperação por união externa (Outer Join Fetching)</title>

            <para>
                Se seu banco de dados suporta Recuperação por união externa (Outer Join Fetching) no estilo ANSI, 
                Oracle ou Sybase, A recuperação por união externa (Outer Join Fetching) frequentemente aumentará
                o desempenho limitando o número de chamadas (round trips) ao banco de dados( ao custo de 
                possivelmente mais trabalho desempenhado pelo próprio banco de dados). A recuperação por 
                união externa (Outer Join Fetching)permite um gráfico completo de objetos conectados 
                por muitos-para-um, um-para-muitos, muitos-para-muitos e associações um-para-um para ser 
                recuperadas em um simples instrução SQL SELECT .

            </para>

            <para>
                A recuperação por união externa (Outer Join Fetching) pode ser desabilitado 
                <emphasis>globalmente</emphasis> setando a propriedade 
                <literal>hibernate.max_fetch_depth</literal> para <literal>0</literal>. 
                Uma valor 1 ou maior habilita o outer join fetching para associações um-para-um 
                e muitos-para-umos cujos quais tem sido mapeado com <literal>fetch="join"</literal>.
            </para>

            <para>
                Veja <xref linkend="performance-fetching"/> para mais informações.
            </para>

        </sect2>

        <sect2 id="configuration-optional-binarystreams" revision="1">
            <title>Fluxos Binários (Binary Streams)</title>

            <para>
                O Oracle limita o tamanho de arrays de <literal>byte</literal> que pode ser 
                passado para/de o driver JDBC. Se você desejar usar grandes instâncias de 
                tipos  <literal>binary</literal> ou <literal>serializable</literal>, você 
                deve habilitar <literal>hibernate.jdbc.use_streams_for_binary</literal>.
                <emphasis>Essa é uma configuração que só pode ser feita a nível de sistema.</emphasis>
            </para>

        </sect2>

        <sect2 id="configuration-optional-cacheprovider" revision="2">
            <title>Cachê de segundo nível e query</title>

            <para>
                As propriedades prefixadas pelo <literal>hibernate.cache</literal> 
                permite você usar um sistema de cachê de segundo nível 
                em um processo executado em clustercom Hibernate. 
                Veja <xref linkend="performance-cache"/> para mais detalhes.
            </para>

        </sect2>

        <sect2 id="configuration-optional-querysubstitution">
            <title>Substituições na Linguagem de Consulta</title>

            <para>
                Você pode definir novos símbolos de consulta Hibernate usando 
                <literal>hibernate.query.substitutions</literal>. 
                Por exemplo:
            </para>

            <programlisting>hibernate.query.substitutions true=1, false=0</programlisting>

            <para>
                Faria com que os símbolos <literal>true</literal> e <literal>false</literal> 
                passasem a ser traduzidos para literais inteiro no SQL gerado.
            </para>

            <programlisting>hibernate.query.substitutions toLowercase=LOWER</programlisting>

            <para>
                permitirá você renomear a função <literal>LOWER</literal> no SQL.
            </para>

        </sect2>

        <sect2 id="configuration-optional-statistics" revision="2">
            <title>Estatísticas do Hibernate</title>

            <para>
                If you enable <literal>hibernate.generate_statistics</literal>, Hibernate will 
                expose a number of metrics that are useful when tuning a running system via
                <literal>SessionFactory.getStatistics()</literal>. Hibernate can even be configured
                to expose these statistics via JMX. Read the Javadoc of the interfaces in
                <literal>org.hibernate.stats</literal> for more information.
                
                Se você habilitar <literal>hibernate.generate_statistics</literal>, o Hibernate 
                exibirá um número de métricas bastante útil ao ajustar um sistema via
                <literal>SessionFactory.getStatistics()</literal>. O Hibernate pode até ser 
                configurado para exibir essas estatísticas via JMX. Leia o Javadoc da interface
                <literal>org.hibernate.stats</literal> para mais informações.
            </para>

        </sect2>
    </sect1>

    <sect1 id="configuration-logging">
        <title>Logging</title>

        <para>
            Hibernate registra vários eventos usando Apache commons-logging.
        </para>

        <para>
            O serviço commons-logging direcionará a saída para o Apache Log4j
            ( se você incluir <literal>log4j.jar</literal>r no seu classpath) ou 
            JDK1.4 logging( se estiver em uso JDK1.4 ou maior). Você pode fazer o 
            download do Log4j a partir de  <literal>http://jakarta.apache.org</literal>.
            Para usar Log4j você necessitará colocar um arquivo 
            <literal>log4j.properties</literal> no seu classpath, um exemplo de arquivo
            de propriedades é distribuído com o Hibernate no diretório 
            <literal>src/</literal>.

        </para>
        
        <para>
            We strongly recommend that you familiarize yourself with Hibernate's log
            messages. A lot of work has been put into making the Hibernate log as
            detailed as possible, without making it unreadable. It is an essential
            troubleshooting device. The most interesting log categories are the
            following:
            
            Nós recomendamos enfaticamente que você se familiarize-se com mensagens de 
            log do Hibernate. Uma parte do trabalho tem sido posto em fazer o log 
            Hibernate tão detalhado quanto possível, sem fazê-lo ilegível. 
            É um essencial dispositivos de controle de erros. As categorias de log 
            mais interessantes são as seguintes:
        </para>
        
            <table frame="topbot" id="log-categories" revision="2">
                <title>Categorias de Log do Hibernate</title>
                <tgroup cols="2">
                    <colspec colwidth="1*"/>
                    <colspec colwidth="2.5*"/>
                    <thead>
                        <row>
                            <entry>Categoria</entry>
                            <entry>Função</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>org.hibernate.SQL</literal></entry>
                            <entry>Registra todas as instruções SQL DML a medida que elas são executadas</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.type</literal></entry>
                            <entry>Registra todos os parâmetros JDBC</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.tool.hbm2ddl</literal></entry>
                            <entry>Registra todas as instruções SQL DDL a medida que elas são executadas</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.pretty</literal></entry>
                            <entry>
                                Log the state of all entities (max 20 entities) associated
                                with the session at flush time
                                Registra o estado de todas as entidades (máximo 20 entidades) 
                                associadas a session no momento da limpeza (flush).
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.cache</literal></entry>
                            <entry>Registra todas as atividades de cachê de segundo nível</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction</literal></entry>
                            <entry>Registra atividades relacionada a transação</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.jdbc</literal></entry>
                            <entry>Registra todas as requisições de recursos JDBC</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.hql.ast.AST</literal></entry>
                            <entry>
                                Registra instruções SQL e HQL durante a análise da consultas
                            </entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.secure</literal></entry>
                            <entry>Registra todas as requisições de autorização JAAS</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate</literal></entry>
                            <entry>
                                Registra tudo ( uma parte das informações, mas muito 
                                útil para controle de erros )
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            
        <para>
            Quando desenvolver aplicações com Hibernate, você deve quase sempre trabalhar com 
            debug <literal>debug</literal>  para a categoria <literal>org.hibernate.SQL</literal>, 
            ou, alternativamente, a com a propriedade <literal>hibernate.show_sql</literal> habilitada.
        </para>
                       
        
    </sect1>

    <sect1 id="configuration-namingstrategy">
        <title>Implementado uma <literal>NamingStrategy</literal></title>

        <para>
            A interface <literal>org.hibernate.cfg.NamingStrategy</literal> permite você 
            especificar um "padrão de nomeação" para objetos do banco de dados e elementos schema.
        </para>

        <para>
            Você deve criar regras para a geração automaticamente de identificadores 
            do banco de dados a partir de identificadores Java ou para processar  
            colunas "computadas" e nomes de tabelas dado o arquivo de mapeamento 
            para nomes "físicos" de tabelas e colunas. Esta característica ajuda a 
            reduzir a verbosidade do documento de mapeamento, eliminando interferências 
            repetitivas( <literal>TBL_</literal>prefixos, por exemplo). A estratégia 
            default usada pelo Hibernate é completamente mínima.
        </para>

        <para>
            Você pode especificar uma estratégia diferente ao chamar 
            <literal>Configuration.setNamingStrategy()</literal> antes de adicionar 
            os mapeamentos:
        </para>

        <programlisting><![CDATA[SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();]]></programlisting>
    
        <para>
            <literal>org.hibernate.cfg.ImprovedNamingStrategy</literal> é uma estratégia 
            interna que pode ser um ponto de começo útil para algumas aplicações.
        </para>

    </sect1>

    <sect1 id="configuration-xmlconfig" revision="2">
        <title>Arquivo de configuração XML</title>

        <para>
            Uma maneira alternativa de configuração é especificar uma configuração completa 
            em um arquivo chamado <literal>hibernate.cfg.xml</literal>. Este arquivo pode 
            ser usado como um substituto para o arquivo <literal>hibernate.properties</literal> 
            ou, se ambos estão presentes, sobrescrever propriedades.
        </para>

        <para>
            The XML configuration file is by default expected to be in the root o
            your <literal>CLASSPATH</literal>. Here is an example:
            O arquivo XML de configuração é por default esperado para estar na 
            raiz do seu <literal>CLASSPATH</literal>. Veja um exemplo:
        </para>

        <programlisting><![CDATA[<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>

    <!-- a SessionFactory instance listed as /jndi/name -->
    <session-factory
        name="java:hibernate/SessionFactory">

        <!-- properties -->
        <property name="connection.datasource">java:/comp/env/jdbc/MyDB</property>
        <property name="dialect">org.hibernate.dialect.MySQLDialect</property>
        <property name="show_sql">false</property>
        <property name="transaction.factory_class">
            org.hibernate.transaction.JTATransactionFactory
        </property>
        <property name="jta.UserTransaction">java:comp/UserTransaction</property>

        <!-- mapping files -->
        <mapping resource="org/hibernate/auction/Item.hbm.xml"/>
        <mapping resource="org/hibernate/auction/Bid.hbm.xml"/>

        <!-- cache settings -->
        <class-cache class="org.hibernate.auction.Item" usage="read-write"/>
        <class-cache class="org.hibernate.auction.Bid" usage="read-only"/>
        <collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/>

    </session-factory>

</hibernate-configuration>]]></programlisting>

        <para>
            Como você pode ver, a vantagem deste enfoque é a externalização dos nomes dos 
            arquivos de mapeamento para configuração. O  <literal>hibernate.cfg.xml</literal> 
            também é mais conveniente caso você tenha que ajustar o cache do Hibernate. 
            Note que a escolha é sua  em usar  <literal>hibernate.properties</literal> ou
            <literal>hibernate.cfg.xml</literal>, ambos são equivalente, à exceção dos benefícios 
            acima mencionados de usar a sintaxe de XML.
        </para>

       <para>
           Com a configuração do XML, iniciar o Hibernate é então tão simples como
       </para>

       <programlisting><![CDATA[SessionFactory sf = new Configuration().configure().buildSessionFactory();]]></programlisting>

       <para>
           You can pick a different XML configuration file using
       </para>

       <programlisting><![CDATA[SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();]]></programlisting>

    </sect1>

    <sect1 id="configuration-j2ee" revision="1">
        <title>Integração com servidores de aplicação J2EE</title>

        <para>
            O Hibernate tem os seguintes pontos da integração para o infraestrutura de J2EE:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>DataSources gerenciados pelo container</emphasis>: O Hibernate pode 
                usar conexões JDBC gerenciadas pelo Container e fornecidas pela JNDI. Geralmente, 
                um <literal>TransactionManager</literal> compatível com JTA e um 
                <literal>ResourceManager</literal> cuidam do gerenciamento da transação ( CMT ), 
                especialmente em transações distribuídas manipuladas através de vários DataSources. 
                Naturalmente, você também pode demarcar os limites das transações programaticamente (BMT) 
                ou você poderia querer usar a API opcional do Hibernate  <literal>Transaction</literal>
                para esta manter seu código portável.
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>Ligação (binding) automática a JNDI</emphasis>: O Hibernate pode 
                associar sua <literal>SessionFactory</literal> a JNDI depois de iniciado.
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>Ligação (binding) Session na JTA:</emphasis> 
                A <literal>Session</literal> do Hibernate pode automaticamente ser ligada 
                ao escopo da transações JTA. Simplesmente localizando a <literal>SessionFactory</literal> 
                da JNDI e obtendo a<literal>Session</literal> corrente. Deixe o Hibernate cuidar 
                da limpeza e encerramento da <literal>Session</literal> quando as transações JTA 
                terminarem. A Demarcação de transação pode ser declarativa (CMT) ou 
                programática(BMT/Transação do usuário).
                </para>
            </listitem>
        </itemizedlist>

        <itemizedlist>
            <listitem>
                <para>
                <emphasis>JMX deployment:</emphasis> Se você usa um JMX servidor de 
                aplicações capaz (ex. Jboss AS), você pode fazer a instação do Hibernate 
                como um Mbean controlado. Isto evita ter que iniciar uma linha de 
                código para construir sua <literal>SessionFactory</literal> de uma 
                <literal>Configuration</literal>. O container iniciará seu 
                <literal>HibernateService</literal>, e idealmente também cuidará 
                das dependências de serviços (DataSources, têm que estar disponíveis 
                antes do Hibernate iniciar, etc.).
                </para>
            </listitem>
        </itemizedlist>

        <para>
             Dependendo em seu ambiente, você poderia ter que ajustar a opção de configuração 
            <literal>hibernate.connection.aggressive_release</literal> para verdadeiro ( true ), 
            se seu servidor de aplicações lançar exeções "retenção de conecção".
        </para>

        <sect2 id="configuration-optional-transactionstrategy" revision="3">
            <title>Configuração de estratégia de transação</title>

            <para>
                A API Hibernate <literal>Session</literal> é independente de qualquer sistema de 
                demarcação de transação em sua arquitetura. Se você deixar o Hibernate usar 
                a JDBC diretamente, através de um pool de conexões, você pode inicializar e 
                encerrar  suas transações chamando a API JDBC. Se você rodar em um servidor de 
                aplicações J2EE, você poderá usar transações controladas por beans e chamar 
                a API JTA e <literal>UserTransaction</literal> quando necessário.

            </para>

            <para>
                Para manter seu código portável entre estes dois ( e outros ) ambientes, recomendamos 
                a API Hibernate <literal>Transaction</literal>, que envolve e esconde o sistema subjacente. 
                Você tem que especificar um classe construtora para <literal>Transaction</literal> instanciar 
                ajustando a propriedade de configuração do <literal>hibernate.transaction.factory_class</literal>.

            </para>

            <para>
                Existem três escolhas (internas) padrões:
            </para>

            <variablelist spacing="compact">
                <varlistentry>
                    <term><literal>org.hibernate.transaction.JDBCTransactionFactory</literal></term>
                    <listitem>
                        <para>delegada as transações (JDBC)a bases de dados  (Padrão)</para>
                              
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>org.hibernate.transaction.JTATransactionFactory</literal></term>
                    <listitem>
                        <para>
                            delegada a transação a um container gerenciador se a transação 
                            existente estiver de acordo neste contexto (ex: método bean sessão EJB), 
                            se não uma nova transação é iniciada e uma transação controlado por 
                            um bean é usada.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>org.hibernate.transaction.CMTTransactionFactory</literal></term>
                    <listitem>
                        <para>delega para um container gerenciador de transações JTA</para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                Você também pode definir suas próprias estratégias de transação ( para um serviço de 
                transação CORBA por exemplo).
            </para>

            <para>
                Algumas características no Hibernate (ex., o cache de segundo nível, sessões contextuais 
                com JTA, etc.) requerem acesso a JTA <literal>TransactionManager</literal> em um ambiente 
                controlado. Em um servidor de aplicação você tem que especificar como o Hibernate pode 
                obter uma referência para a <literal>TransactionManager</literal>, pois o J2EE não 
                padronize um mecanismo simples :
            </para>

            <table frame="topbot" id="jtamanagerlookup" revision="1">
                <title>Gerenciadores de transações JTA</title>
                <tgroup cols="2">
                    <colspec colwidth="2.5*"/>
                    <colspec colwidth="1*"/>
                    <thead>
                        <row>
                            <entry>Transaction Factory</entry>
                            <entry align="center">Application Server</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>org.hibernate.transaction.JBossTransactionManagerLookup</literal></entry>
                            <entry align="center">JBoss</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.WeblogicTransactionManagerLookup</literal></entry>
                            <entry align="center">Weblogic</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.WebSphereTransactionManagerLookup</literal></entry>
                            <entry align="center">WebSphere</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</literal></entry>
                            <entry align="center">WebSphere 6</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.OrionTransactionManagerLookup</literal></entry>
                            <entry align="center">Orion</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.ResinTransactionManagerLookup</literal></entry>
                            <entry align="center">Resin</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.JOTMTransactionManagerLookup</literal></entry>
                            <entry align="center">JOTM</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.JOnASTransactionManagerLookup</literal></entry>
                            <entry align="center">JOnAS</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.JRun4TransactionManagerLookup</literal></entry>
                            <entry align="center">JRun4</entry>
                        </row>
                        <row>
                            <entry><literal>org.hibernate.transaction.BESTransactionManagerLookup</literal></entry>
                            <entry align="center">Borland ES</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

        </sect2>

        <sect2 id="configuration-optional-jndi" revision="3">
            <title><literal>SessionFactory</literal> ligada a JNDI</title>

            <para>
                Uma <literal>SessionFactory</literal> de Hibernate ligada a JNDI pode simplificar
                a localização da fabrica e a criação de novas <literal>Session</literal>s.
                Observe que isto não relacionado a um <literal>Datasource</literal> ligado 
                a JNDI, simplemente ambos usam o mesmo registro!
            </para>

            <para>
                If you wish to have the <literal>SessionFactory</literal> bound to a JNDI namespace, specify
                a name (eg. <literal>java:hibernate/SessionFactory</literal>) using the property
                <literal>hibernate.session_factory_name</literal>. If this property is omitted, the
                <literal>SessionFactory</literal> will not be bound to JNDI. (This is especially useful in
                environments with a read-only JNDI default implementation, e.g. Tomcat.)
            </para>

            <para>
                When binding the <literal>SessionFactory</literal> to JNDI, Hibernate will use the values of
                <literal>hibernate.jndi.url</literal>, <literal>hibernate.jndi.class</literal> to instantiate
                an initial context. If they are not specified, the default <literal>InitialContext</literal>
                will be used.
            </para>

            <para>
                Hibernate will automatically place the <literal>SessionFactory</literal> in JNDI after
                you call <literal>cfg.buildSessionFactory()</literal>. This means you will at least have
                this call in some startup code (or utility class) in your application, unless you use
                JMX deployment with the <literal>HibernateService</literal> (discussed later).
            </para>

            <para>
                If you use a JNDI <literal>SessionFactory</literal>, an EJB or any other class may
                obtain the  <literal>SessionFactory</literal> using a JNDI lookup.
            </para>

            <para>
                We recommend that you bind the <literal>SessionFactory</literal> to JNDI in
                a managend environment and use a <literal>static</literal> singleton otherwise.
                To shield your application code from these details, we also recommend to hide the
                actual lookup code for a <literal>SessionFactory</literal> in a helper class,
                such as <literal>HibernateUtil.getSessionFactory()</literal>. Note that such a
                class is also a convenient way to startup Hibernate&mdash;see chapter 1.
            </para>

        </sect2>

        <sect2 id="configuration-j2ee-currentsession" revision="4">
            <title>Current Session context management with JTA</title>

            <para>
                The easiest way to handle <literal>Session</literal>s and transactions is
                Hibernates automatic "current" <literal>Session</literal> management.
                See the discussion of <xref linkend="architecture-current-session">current sessions</xref>.
                Using the <literal>"jta"</literal> session context, if there is no Hibernate
                <literal>Session</literal> associated with the current JTA transaction, one will
	            be started and associated with that JTA transaction the first time you call
	            <literal>sessionFactory.getCurrentSession()</literal>. The <literal>Session</literal>s
	            retrieved via <literal>getCurrentSession()</literal> in <literal>"jta"</literal> context
	            will be set to automatically flush before the transaction completes, close
	            after the transaction completes, and aggressively release JDBC connections
	            after each statement.  This allows the <literal>Session</literal>s to
	            be managed by the life cycle of the JTA transaction to which it is associated,
	            keeping user code clean of such management concerns. Your code can either use
	            JTA programmatically through <literal>UserTransaction</literal>, or (recommended
	            for portable code) use the Hibernate <literal>Transaction</literal> API to set
	            transaction boundaries. If you run in an EJB container, declarative transaction
	            demarcation with CMT is preferred.
            </para>

        </sect2>

        <sect2 id="configuration-j2ee-jmx" revision="1">
            <title>JMX deployment</title>

            <para>
                The line <literal>cfg.buildSessionFactory()</literal> still has to be executed
                somewhere to get a <literal>SessionFactory</literal> into JNDI. You can do this
                either in a <literal>static</literal> initializer block (like the one in
                <literal>HibernateUtil</literal>) or you deploy Hibernate as a <emphasis>managed
                service</emphasis>.
            </para>

            <para>
                Hibernate is distributed with <literal>org.hibernate.jmx.HibernateService</literal>
                for deployment on an application server with JMX capabilities, such as JBoss AS.
                The actual deployment and configuration is vendor specific. Here is an example
                <literal>jboss-service.xml</literal> for JBoss 4.0.x:
            </para>

            <programlisting><![CDATA[<?xml version="1.0"?>
<server>

<mbean code="org.hibernate.jmx.HibernateService"
    name="jboss.jca:service=HibernateFactory,name=HibernateFactory">

    <!-- Required services -->
    <depends>jboss.jca:service=RARDeployer</depends>
    <depends>jboss.jca:service=LocalTxCM,name=HsqlDS</depends>

    <!-- Bind the Hibernate service to JNDI -->
    <attribute name="JndiName">java:/hibernate/SessionFactory</attribute>

    <!-- Datasource settings -->
    <attribute name="Datasource">java:HsqlDS</attribute>
    <attribute name="Dialect">org.hibernate.dialect.HSQLDialect</attribute>

    <!-- Transaction integration -->
    <attribute name="TransactionStrategy">
        org.hibernate.transaction.JTATransactionFactory</attribute>
    <attribute name="TransactionManagerLookupStrategy">
        org.hibernate.transaction.JBossTransactionManagerLookup</attribute>
    <attribute name="FlushBeforeCompletionEnabled">true</attribute>
    <attribute name="AutoCloseSessionEnabled">true</attribute>

    <!-- Fetching options -->
    <attribute name="MaximumFetchDepth">5</attribute>

    <!-- Second-level caching -->
    <attribute name="SecondLevelCacheEnabled">true</attribute>
    <attribute name="CacheProviderClass">org.hibernate.cache.EhCacheProvider</attribute>
    <attribute name="QueryCacheEnabled">true</attribute>

    <!-- Logging -->
    <attribute name="ShowSqlEnabled">true</attribute>

    <!-- Mapping files -->
    <attribute name="MapResources">auction/Item.hbm.xml,auction/Category.hbm.xml</attribute>

</mbean>

</server>]]></programlisting>

            <para>
                This file is deployed in a directory called <literal>META-INF</literal> and packaged
                in a JAR file with the extension <literal>.sar</literal> (service archive). You also need
                to package Hibernate, its required third-party libraries, your compiled persistent classes,
                as well as your mapping files in the same archive. Your enterprise beans (usually session
                beans) may be kept in their own JAR file, but you may include this EJB JAR file in the
                main service archive to get a single (hot-)deployable unit. Consult the JBoss AS
                documentation for more information about JMX service and EJB deployment.
            </para>

        </sect2>

    </sect1>

</chapter>

