/*
 * Copyright 2010 Brookhaven National Laboratory
 * All rights reserved. Use is subject to license terms.
 */

package org.epics.pvmanager.sim;

import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.epics.pvmanager.Collector;
import org.epics.pvmanager.DataSource;
import org.epics.pvmanager.ExceptionHandler;
import org.epics.pvmanager.util.TimeDuration;
import org.epics.pvmanager.util.TimeInterval;
import org.epics.pvmanager.util.TimeStamp;
import org.epics.pvmanager.ValueCache;

/**
 * Base class for all simulated signals. It provides the common mechanism for
 * registering the update on a timer and a few other utilities.
 *
 * @author carcassi
 */
abstract class Simulation<T> {

    private static final Logger log = Logger.getLogger(Simulation.class.getName());

    private final long intervalBetweenExecution;
    private final Class<T> classToken;
    volatile TimeStamp lastTime;

    /**
     * Creates a new simulation.
     *
     * @param secondsBeetwenSamples seconds between each samples
     */
    Simulation(TimeDuration scanRate, Class<T> classToken) {
        if (scanRate.getNanoSec() < 1000000) {
            throw new IllegalArgumentException("Scans must be at least every ms (was " + scanRate + ")");
        }
        this.intervalBetweenExecution = Math.max(scanRate.getNanoSec() / 1000000, 1);
        this.classToken = classToken;
    }

    /**
     * Computes all the new values in the given time slice.
     *
     * @param interval the interval where the data should be generated
     * @return the new values
     */
    abstract List<T> createValues(TimeInterval interval);

    private TimerTask task;

    /**
     * Initialize timer task. Must be called before start.
     *
     * @param collector collector notified of updates
     * @param cache cache to put the new value in
     */
    void initialize(final Collector collector, final ValueCache<T> cache, final ExceptionHandler exceptionHandler) {
        // Determines whether objects generated by the SimFunction
        // can actually be put in the cache.
        if (!cache.getType().isAssignableFrom(classToken)) {
            throw new IllegalArgumentException("Function is of type " + classToken.getSimpleName() + " (requested " + cache.getType().getSimpleName() + ")");
        }

        if (task != null)
            task.cancel();
        task = new TimerTask() {
            DataSource.ValueProcessor<T, T> processor = new SimulationDataSource.ValueProcessor<T, T>(collector, cache, exceptionHandler) {

                @Override
                public void close() {
                    log.log(Level.FINE, "Closing {0}", this);
                    cancel();
                }

                @Override
                public boolean updateCache(T payload, ValueCache<T> cache) {
                    cache.setValue(payload);
                    return true;
                }
            };


            @Override
            public void run() {
                // Protect the timer thread for possible problems.
                try {
                    if (lastTime == null)
                        lastTime = TimeStamp.now();
                    List<T> newValues = createValues(TimeInterval.between(lastTime, TimeStamp.now()));

                    for (T newValue : newValues) {
                        processor.processValue(newValue);
                    }
                } catch (Exception ex) {
                    log.log(Level.WARNING, "Data simulation problem", ex);
                }
            }
        };
    }

    /**
     * Starts notification by dispatching the prepared task on the timer.
     *
     * @param timer timer on which to execute the updates
     */
    void start(Timer timer) {
        if (task == null)
            throw new IllegalStateException("Must call initialize first");

        timer.schedule(task, 0, intervalBetweenExecution);
        log.log(Level.FINE, "Synch starting {0} every " + intervalBetweenExecution + " ms", task);
    }

    /**
     * Stops the variable from further notifications.
     */
    void stop() {
        if (task != null) {
            task.cancel();
            log.log(Level.FINE, "Synch closing {0}", task);
        }
        task = null;
    }

    /**
     * Changes the time at which the data will be generated.
     *
     * @param lastTime new timestamp
     */
    void setLastTime(TimeStamp lastTime) {
        this.lastTime = lastTime;
    }

}
