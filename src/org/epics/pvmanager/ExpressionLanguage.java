/*
 * Copyright 2010 Brookhaven National Laboratory
 * All rights reserved. Use is subject to license terms.
 */

package org.epics.pvmanager;

import org.epics.pvmanager.util.TimeDuration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Operators to constructs expression of PVs that the {@link PVManager} will
 * be able to monitor.
 *
 * @author carcassi
 */
public class ExpressionLanguage {
    
    static {
        // Install support for basic java types
        BasicTypeSupport.install();
    }
    
    private ExpressionLanguage() {}

    /**
     * A channel with the given name of any type.
     *
     * @param name the channel name; can't be null
     * @return an expression representing the channel
     */
    public static SourceRateExpression<Object> channel(String name) {
        return new SourceRateExpression<Object>(name, Object.class);
    }

    /**
     * Returns all the new values generated by the expression source rate.
     *
     * @param <T> type read
     * @param expression source rate expression
     * @return a new expression
     */
    public static <T> DesiredRateExpression<List<T>>
            newValuesOf(SourceRateExpression<T> expression) {
        return new DesiredRateExpression<List<T>>(expression,
                new QueueCollector<T>(expression.getFunction()),
                expression.getDefaultName());
    }

    /**
     * Returns up to maxValues new values generated by the expression source rate.
     *
     * @param <T> type read
     * @param expression source rate expression
     * @param maxValues maximum number of values to send with each notification
     * @return a new expression
     */
    public static <T> DesiredRateExpression<List<T>>
            newValuesOf(SourceRateExpression<T> expression, int maxValues) {
        return new DesiredRateExpression<List<T>>(expression,
                new QueueCollector<T>(expression.getFunction(), maxValues),
                expression.getDefaultName());
    }

    public static <T> DesiredRateExpression<List<T>>
            timedCacheOf(SourceRateExpression<T> expression, TimeDuration maxIntervalBetweenSamples) {
        return new DesiredRateExpression<List<T>>(expression,
                new TimedCacheCollector<T>(expression.getFunction(), maxIntervalBetweenSamples),
                expression.getDefaultName());
    }

    /**
     * Expression that returns (only) at the desired rate the latest value computed
     * from a {@code SourceRateExpression}.
     *
     * @param <T> result type
     * @param expression expression read at the source rate
     * @return a new expression
     */
    public static <T> DesiredRateExpression<T> latestValueOf(SourceRateExpression<T> expression) {
        // TODO This should use a cache of size one
        DesiredRateExpression<List<T>> queue = newValuesOf(expression, 1);
        return new DesiredRateExpression<T>(queue,
                new LastValueAggregator<T>((Collector<T>) queue.getFunction()),
                expression.getDefaultName());
    }

    /**
     * A user provided single argument function.
     *
     * @param <R> result type
     * @param <A> argument type
     */
    public static interface OneArgFunction<R, A> {
        /**
         * Calculates the new value.
         *
         * @param arg argument
         * @return result
         */
        R calculate(A arg);
    }

    /**
     * A user provided double argument function.
     *
     * @param <R> result type
     * @param <A1> first argument type
     * @param <A2> second argument type
     */
    public static interface TwoArgFunction<R, A1, A2> {
        /**
         * Calculates the new value.
         *
         * @param arg1 first argument
         * @param arg2 second argument
         * @return result
         */
        R calculate(A1 arg1, A2 arg2);
    }

    /**
     * An expression that represents the result of a user provided function.
     *
     * @param <R> result type
     * @param <A> argument type
     * @param function the user provided function
     * @param argExpression expression for the function argument
     * @return a new expression
     */
    public static <R, A> DesiredRateExpression<R> resultOf(final OneArgFunction<R, A> function,
            DesiredRateExpression<A> argExpression) {
        String name = function.getClass().getSimpleName() + "(" + argExpression.getDefaultName() + ")";
        final Function<A> arg = argExpression.getFunction();
        return new DesiredRateExpression<R>(argExpression, new Function<R>() {
            @Override
            public R getValue() {
                return function.calculate(arg.getValue());
            }
        }, name);
    }

    /**
     * An expression that represents the result of a user provided function.
     *
     * @param <R> result type
     * @param <A1> first argument type
     * @param <A2> second argument type
     * @param function the user provided function
     * @param arg1Expression expression for the first argument
     * @param arg2Expression expression for the second argument
     * @return a new expression
     */
    public static <R, A1, A2> DesiredRateExpression<R> resultOf(final TwoArgFunction<R, A1, A2> function,
            DesiredRateExpression<A1> arg1Expression, DesiredRateExpression<A2> arg2Expression) {
        String name = function.getClass().getSimpleName() + "(" + arg1Expression.getDefaultName() +
                ", " + arg2Expression.getDefaultName() + ")";
        final Function<A1> arg1 = arg1Expression.getFunction();
        final Function<A2> arg2 = arg2Expression.getFunction();
        @SuppressWarnings("unchecked")
        final List<DesiredRateExpression<? extends Object>> argExpressions =
                Arrays.asList(arg1Expression, arg2Expression);
        return new DesiredRateExpression<R>(argExpressions,
                new Function<R>() {
                    @Override
                    public R getValue() {
                        return function.calculate(arg1.getValue(), arg2.getValue());
                    }
                }, name);
    }

    /**
     * Filters a data stream, removing updates that match the given function.
     * Looks for objects of a specific type,
     * and filters based on previous and current value.
     * 
     * @param <T> the type to cast to before the filtering
     */
    public static abstract class Filter<T> {

        private final Class<T> clazz;
        private final boolean filterUnmatched;

        Filter() {
            clazz = null;
            filterUnmatched = false;
        }

        /**
         * Creates a filter which looks for and cases data objects of the
         * given class.
         *
         * @param clazz the argument type of the filter
         */
        public Filter(Class<T> clazz) {
            this(clazz, false);
        }

        /**
         * Creates a filter which looks for and cases data objects of the
         * given class. If objects do not match, returns filterUnmatched.
         *
         * @param clazz the argument type of the filter
         * @param filterUnmatched whether objects that don't match the class
         * should be filtered or not
         */
        public Filter(Class<T> clazz, boolean filterUnmatched) {
            this.clazz = clazz;
            this.filterUnmatched = filterUnmatched;
        }

        // This is what the framework should actually call: it does the
        // type checking and casting
        boolean innerFilter(Object previousValue, Object currentValue) {
            if ((previousValue == null || clazz.isInstance(previousValue)) &&
                    (currentValue == null || clazz.isInstance(currentValue))) {
                return filter(clazz.cast(previousValue), clazz.cast(currentValue));
            }
            return filterUnmatched;
        }

        /**
         * Determines whether the new value should be filtered or not. The
         * filtering is done based on the previousValue, which is always a
         * value that passed the filtering. The first value ever to be
         * passed to the filter will have null for previousValue.
         *
         * @param previousValue the previous data update
         * @param currentValue the current data update
         * @return true if the current data update should be dropped
         */
        public abstract boolean filter(T previousValue, T currentValue);

        /**
         * Returns a new filter that is the logical AND of this and the given
         * one.
         *
         * @param filter another filter
         * @return a new filter that is the AND of the two
         */
        public Filter<?> and(final Filter<?> filter) {
            return new Filter<Object>() {

                @Override
                public boolean innerFilter(Object previousValue, Object currentValue) {
                    return super.innerFilter(previousValue, currentValue) &&
                            filter.innerFilter(previousValue, currentValue);
                }

                @Override
                public boolean filter(Object previousValue, Object currentValue) {
                    throw new UnsupportedOperationException("Not used.");
                }

            };
        }

        /**
         * Returns a new filter that is the logical OR of this and the given
         * one.
         *
         * @param filter another filter
         * @return a new filter that is the OR of the two
         */
        public Filter<?> or(final Filter<?> filter) {
            return new Filter<Object>() {

                @Override
                public boolean innerFilter(Object previousValue, Object currentValue) {
                    return super.innerFilter(previousValue, currentValue) ||
                            filter.innerFilter(previousValue, currentValue);
                }

                @Override
                public boolean filter(Object previousValue, Object currentValue) {
                    throw new UnsupportedOperationException("Not used.");
                }

            };
        }
    }

    /**
     * Filters a stream of updates with the given filter.
     *
     * @param <T> the type of data streaming in and out
     * @param filter the filtering function
     * @param expression the argument expression
     * @return a new expression for the filtering result
     */
    public static <T> DesiredRateExpression<List<T>> filterBy(final Filter<?> filter,
            DesiredRateExpression<List<T>> expression) {
        String name = expression.getDefaultName();
        final Function<List<T>> arg = expression.getFunction();
        return new DesiredRateExpression<List<T>>(expression,
                new Function<List<T>>() {

                    private T previousValue;

                    @Override
                    public List<T> getValue() {
                        List<T> list = arg.getValue();
                        List<T> newList = new ArrayList<T>();
                        for (T element : list) {
                            if (!filter.innerFilter(previousValue, element)) {
                                newList.add(element);
                                previousValue = element;
                            }
                        }
                        return newList;
                    }
                }, name);
    }
}
